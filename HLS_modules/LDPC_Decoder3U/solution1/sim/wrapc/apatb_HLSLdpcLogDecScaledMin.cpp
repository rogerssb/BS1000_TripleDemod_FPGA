// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2016.4
// Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
// ==============================================================

#include <systemc>
#include <iostream>
#include <cstdlib>
#include <cstddef>
#include <stdint.h>
#include "SysCFileHandler.h"
#include "ap_int.h"
#include "ap_fixed.h"
#include <complex>
#include <stdbool.h>
#include "autopilot_cbe.h"
#include "ap_stream.h"
#include "hls_stream.h"
#include "hls_half.h"
#include "hls_signal_handler.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


// [dump_struct_tree [build_nameSpaceTree] dumpedStructList] ---------->


// [dump_enumeration [get_enumeration_list]] ---------->


// wrapc file define: "pR"
#define AUTOTB_TVIN_pR  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR.dat"
// wrapc file define: "pR1"
#define AUTOTB_TVIN_pR1  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR1.dat"
// wrapc file define: "pR2"
#define AUTOTB_TVIN_pR2  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR2.dat"
// wrapc file define: "pR3"
#define AUTOTB_TVIN_pR3  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR3.dat"
// wrapc file define: "pR4"
#define AUTOTB_TVIN_pR4  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR4.dat"
// wrapc file define: "pR5"
#define AUTOTB_TVIN_pR5  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR5.dat"
// wrapc file define: "pR6"
#define AUTOTB_TVIN_pR6  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR6.dat"
// wrapc file define: "pR7"
#define AUTOTB_TVIN_pR7  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR7.dat"
// wrapc file define: "pR8"
#define AUTOTB_TVIN_pR8  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR8.dat"
// wrapc file define: "pR9"
#define AUTOTB_TVIN_pR9  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pR9.dat"
// wrapc file define: "pbhat0"
#define AUTOTB_TVOUT_pbhat0  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat0.dat"
#define AUTOTB_TVIN_pbhat0  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat0.dat"
// wrapc file define: "pbhat1"
#define AUTOTB_TVOUT_pbhat1  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat1.dat"
#define AUTOTB_TVIN_pbhat1  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat1.dat"
// wrapc file define: "pbhat2"
#define AUTOTB_TVOUT_pbhat2  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat2.dat"
#define AUTOTB_TVIN_pbhat2  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat2.dat"
// wrapc file define: "pbhat3"
#define AUTOTB_TVOUT_pbhat3  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat3.dat"
#define AUTOTB_TVIN_pbhat3  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat3.dat"
// wrapc file define: "pbhat4"
#define AUTOTB_TVOUT_pbhat4  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat4.dat"
#define AUTOTB_TVIN_pbhat4  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat4.dat"
// wrapc file define: "pbhat5"
#define AUTOTB_TVOUT_pbhat5  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat5.dat"
#define AUTOTB_TVIN_pbhat5  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat5.dat"
// wrapc file define: "pbhat6"
#define AUTOTB_TVOUT_pbhat6  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat6.dat"
#define AUTOTB_TVIN_pbhat6  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat6.dat"
// wrapc file define: "pbhat7"
#define AUTOTB_TVOUT_pbhat7  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_pbhat7.dat"
#define AUTOTB_TVIN_pbhat7  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pbhat7.dat"
// wrapc file define: "cnt"
#define AUTOTB_TVOUT_cnt  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_cnt.dat"
// wrapc file define: "pMaxIterations"
#define AUTOTB_TVIN_pMaxIterations  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_pMaxIterations.dat"
// wrapc file define: "itt_num"
#define AUTOTB_TVOUT_itt_num  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvout_itt_num.dat"
// wrapc file define: "numbits"
#define AUTOTB_TVIN_numbits  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_numbits.dat"
// wrapc file define: "mux"
#define AUTOTB_TVIN_mux  "../tv/cdatafile/c.HLSLdpcLogDecScaledMin.autotvin_mux.dat"

#define INTER_TCL  "../tv/cdatafile/ref.tcl"

// tvout file define: "pbhat0"
#define AUTOTB_TVOUT_PC_pbhat0  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat0.dat"
// tvout file define: "pbhat1"
#define AUTOTB_TVOUT_PC_pbhat1  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat1.dat"
// tvout file define: "pbhat2"
#define AUTOTB_TVOUT_PC_pbhat2  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat2.dat"
// tvout file define: "pbhat3"
#define AUTOTB_TVOUT_PC_pbhat3  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat3.dat"
// tvout file define: "pbhat4"
#define AUTOTB_TVOUT_PC_pbhat4  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat4.dat"
// tvout file define: "pbhat5"
#define AUTOTB_TVOUT_PC_pbhat5  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat5.dat"
// tvout file define: "pbhat6"
#define AUTOTB_TVOUT_PC_pbhat6  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat6.dat"
// tvout file define: "pbhat7"
#define AUTOTB_TVOUT_PC_pbhat7  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_pbhat7.dat"
// tvout file define: "cnt"
#define AUTOTB_TVOUT_PC_cnt  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_cnt.dat"
// tvout file define: "itt_num"
#define AUTOTB_TVOUT_PC_itt_num  "../tv/rtldatafile/rtl.HLSLdpcLogDecScaledMin.autotvout_itt_num.dat"

class INTER_TCL_FILE {
	public:
		INTER_TCL_FILE(const char* name) {
			mName = name;
			pR_depth = 0;
			pR1_depth = 0;
			pR2_depth = 0;
			pR3_depth = 0;
			pR4_depth = 0;
			pR5_depth = 0;
			pR6_depth = 0;
			pR7_depth = 0;
			pR8_depth = 0;
			pR9_depth = 0;
			pbhat0_depth = 0;
			pbhat1_depth = 0;
			pbhat2_depth = 0;
			pbhat3_depth = 0;
			pbhat4_depth = 0;
			pbhat5_depth = 0;
			pbhat6_depth = 0;
			pbhat7_depth = 0;
			cnt_depth = 0;
			pMaxIterations_depth = 0;
			itt_num_depth = 0;
			numbits_depth = 0;
			mux_depth = 0;
			trans_num =0;
		}

		~INTER_TCL_FILE() {
			mFile.open(mName);
			if (!mFile.good()) {
				cout << "Failed to open file ref.tcl" << endl;
				exit (1);
			}
			string total_list = get_depth_list();
			mFile << "set depth_list {\n";
			mFile << total_list;
			mFile << "}\n";
			mFile << "set trans_num "<<trans_num<<endl;
			mFile.close();
		}

		string get_depth_list () {
			stringstream total_list;
			total_list << "{pR " << pR_depth << "}\n";
			total_list << "{pR1 " << pR1_depth << "}\n";
			total_list << "{pR2 " << pR2_depth << "}\n";
			total_list << "{pR3 " << pR3_depth << "}\n";
			total_list << "{pR4 " << pR4_depth << "}\n";
			total_list << "{pR5 " << pR5_depth << "}\n";
			total_list << "{pR6 " << pR6_depth << "}\n";
			total_list << "{pR7 " << pR7_depth << "}\n";
			total_list << "{pR8 " << pR8_depth << "}\n";
			total_list << "{pR9 " << pR9_depth << "}\n";
			total_list << "{pbhat0 " << pbhat0_depth << "}\n";
			total_list << "{pbhat1 " << pbhat1_depth << "}\n";
			total_list << "{pbhat2 " << pbhat2_depth << "}\n";
			total_list << "{pbhat3 " << pbhat3_depth << "}\n";
			total_list << "{pbhat4 " << pbhat4_depth << "}\n";
			total_list << "{pbhat5 " << pbhat5_depth << "}\n";
			total_list << "{pbhat6 " << pbhat6_depth << "}\n";
			total_list << "{pbhat7 " << pbhat7_depth << "}\n";
			total_list << "{cnt " << cnt_depth << "}\n";
			total_list << "{pMaxIterations " << pMaxIterations_depth << "}\n";
			total_list << "{itt_num " << itt_num_depth << "}\n";
			total_list << "{numbits " << numbits_depth << "}\n";
			total_list << "{mux " << mux_depth << "}\n";
			return total_list.str();
		}

		void set_num (int num , int* class_num) {
			(*class_num) = (*class_num) > num ? (*class_num) : num;
		}
	public:
		int pR_depth;
		int pR1_depth;
		int pR2_depth;
		int pR3_depth;
		int pR4_depth;
		int pR5_depth;
		int pR6_depth;
		int pR7_depth;
		int pR8_depth;
		int pR9_depth;
		int pbhat0_depth;
		int pbhat1_depth;
		int pbhat2_depth;
		int pbhat3_depth;
		int pbhat4_depth;
		int pbhat5_depth;
		int pbhat6_depth;
		int pbhat7_depth;
		int cnt_depth;
		int pMaxIterations_depth;
		int itt_num_depth;
		int numbits_depth;
		int mux_depth;
		int trans_num;

	private:
		ofstream mFile;
		const char* mName;
};

extern void HLSLdpcLogDecScaledMin (
signed char pR[2048],
signed char pR1[2048],
signed char pR2[2048],
signed char pR3[2048],
signed char pR4[1024],
signed char pR5[1024],
signed char pR6[1024],
signed char pR7[1024],
signed char pR8[1024],
signed char pR9[1024],
signed char pR10[1024],
bool pbhat0[2048],
bool pbhat1[2048],
bool pbhat2[1024],
bool pbhat3[1024],
bool pbhat4[1024],
bool pbhat5[1024],
bool pbhat6[1024],
bool pbhat7[1024],
int* cnt,
unsigned short nR_M,
unsigned short etaIndexM_M,
unsigned short pCodeM,
unsigned short pMaxIterations,
signed char* itt_num,
unsigned short numbits,
volatile bool* mux);

void AESL_WRAP_HLSLdpcLogDecScaledMin (
signed char pR[2048],
signed char pR1[2048],
signed char pR2[2048],
signed char pR3[2048],
signed char pR4[1024],
signed char pR5[1024],
signed char pR6[1024],
signed char pR7[1024],
signed char pR8[1024],
signed char pR9[1024],
signed char pR10[1024],
bool pbhat0[2048],
bool pbhat1[2048],
bool pbhat2[1024],
bool pbhat3[1024],
bool pbhat4[1024],
bool pbhat5[1024],
bool pbhat6[1024],
bool pbhat7[1024],
int* cnt,
unsigned short nR_M,
unsigned short etaIndexM_M,
unsigned short pCodeM,
unsigned short pMaxIterations,
signed char* itt_num,
unsigned short numbits,
volatile bool* mux)
{
	refine_signal_handler();
	fstream wrapc_switch_file_token;
	wrapc_switch_file_token.open(".hls_cosim_wrapc_switch.log");
	int AESL_i;
	if (wrapc_switch_file_token.good())
	{
		CodeState = ENTER_WRAPC_PC;
		static unsigned AESL_transaction_pc = 0;
		string AESL_token;
		string AESL_num;
		static AESL_FILE_HANDLER aesl_fh;


		// output port post check: "pbhat0"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat0, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat0, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat0, AESL_token); // data

			sc_bv<1> *pbhat0_pc_buffer = new sc_bv<1>[2048];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat0_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat0, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat0))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat0
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat0(0, 0)
						// {
							sc_lv<1>* pbhat0_lv0_0_2047_1 = new sc_lv<1>[2048];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat0(0, 0)
						{
							// carray: (0) => (2047) @ (1)
							for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
							{
								if (&(pbhat0[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat0_lv0_0_2047_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat0_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat0(0, 0)
						{
							// carray: (0) => (2047) @ (1)
							for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat0[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat0[0]
								// output_left_conversion : pbhat0[i_0]
								// output_type_conversion : (pbhat0_lv0_0_2047_1[hls_map_index++]).to_uint64()
								if (&(pbhat0[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat0[i_0] = (pbhat0_lv0_0_2047_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat0_pc_buffer;
		}

		// output port post check: "pbhat1"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat1, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat1, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat1, AESL_token); // data

			sc_bv<1> *pbhat1_pc_buffer = new sc_bv<1>[2048];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat1_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat1, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat1))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat1
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat1(0, 0)
						// {
							sc_lv<1>* pbhat1_lv0_0_2047_1 = new sc_lv<1>[2048];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat1(0, 0)
						{
							// carray: (0) => (2047) @ (1)
							for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
							{
								if (&(pbhat1[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat1_lv0_0_2047_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat1_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat1(0, 0)
						{
							// carray: (0) => (2047) @ (1)
							for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat1[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat1[0]
								// output_left_conversion : pbhat1[i_0]
								// output_type_conversion : (pbhat1_lv0_0_2047_1[hls_map_index++]).to_uint64()
								if (&(pbhat1[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat1[i_0] = (pbhat1_lv0_0_2047_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat1_pc_buffer;
		}

		// output port post check: "pbhat2"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat2, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat2, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat2, AESL_token); // data

			sc_bv<1> *pbhat2_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat2_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat2, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat2))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat2
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat2(0, 0)
						// {
							sc_lv<1>* pbhat2_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat2(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat2[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat2_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat2_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat2(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat2[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat2[0]
								// output_left_conversion : pbhat2[i_0]
								// output_type_conversion : (pbhat2_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat2[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat2[i_0] = (pbhat2_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat2_pc_buffer;
		}

		// output port post check: "pbhat3"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat3, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat3, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat3, AESL_token); // data

			sc_bv<1> *pbhat3_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat3_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat3, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat3))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat3
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat3(0, 0)
						// {
							sc_lv<1>* pbhat3_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat3(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat3[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat3_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat3_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat3(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat3[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat3[0]
								// output_left_conversion : pbhat3[i_0]
								// output_type_conversion : (pbhat3_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat3[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat3[i_0] = (pbhat3_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat3_pc_buffer;
		}

		// output port post check: "pbhat4"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat4, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat4, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat4, AESL_token); // data

			sc_bv<1> *pbhat4_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat4_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat4, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat4))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat4
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat4(0, 0)
						// {
							sc_lv<1>* pbhat4_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat4(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat4[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat4_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat4_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat4(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat4[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat4[0]
								// output_left_conversion : pbhat4[i_0]
								// output_type_conversion : (pbhat4_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat4[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat4[i_0] = (pbhat4_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat4_pc_buffer;
		}

		// output port post check: "pbhat5"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat5, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat5, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat5, AESL_token); // data

			sc_bv<1> *pbhat5_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat5_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat5, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat5))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat5
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat5(0, 0)
						// {
							sc_lv<1>* pbhat5_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat5(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat5[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat5_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat5_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat5(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat5[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat5[0]
								// output_left_conversion : pbhat5[i_0]
								// output_type_conversion : (pbhat5_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat5[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat5[i_0] = (pbhat5_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat5_pc_buffer;
		}

		// output port post check: "pbhat6"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat6, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat6, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat6, AESL_token); // data

			sc_bv<1> *pbhat6_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat6_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat6, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat6))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat6
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat6(0, 0)
						// {
							sc_lv<1>* pbhat6_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat6(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat6[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat6_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat6_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat6(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat6[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat6[0]
								// output_left_conversion : pbhat6[i_0]
								// output_type_conversion : (pbhat6_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat6[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat6[i_0] = (pbhat6_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat6_pc_buffer;
		}

		// output port post check: "pbhat7"
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat7, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_pbhat7, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_pbhat7, AESL_token); // data

			sc_bv<1> *pbhat7_pc_buffer = new sc_bv<1>[1024];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'pbhat7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					pbhat7_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_pbhat7, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_pbhat7))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: pbhat7
				{
					// bitslice(0, 0)
					// {
						// celement: pbhat7(0, 0)
						// {
							sc_lv<1>* pbhat7_lv0_0_1023_1 = new sc_lv<1>[1024];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat7(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								if (&(pbhat7[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat7_lv0_0_1023_1[hls_map_index++].range(0, 0) = sc_bv<1>(pbhat7_pc_buffer[hls_map_index].range(0, 0));
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: pbhat7(0, 0)
						{
							// carray: (0) => (1023) @ (1)
							for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : pbhat7[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : pbhat7[0]
								// output_left_conversion : pbhat7[i_0]
								// output_type_conversion : (pbhat7_lv0_0_1023_1[hls_map_index++]).to_uint64()
								if (&(pbhat7[0]) != NULL) // check the null address if the c port is array or others
								{
									pbhat7[i_0] = (pbhat7_lv0_0_1023_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] pbhat7_pc_buffer;
		}

		// output port post check: "cnt"
		aesl_fh.read(AUTOTB_TVOUT_PC_cnt, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_cnt, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_cnt, AESL_token); // data

			sc_bv<32> *cnt_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'cnt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'cnt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					cnt_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_cnt, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_cnt))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: cnt
				{
					// bitslice(31, 0)
					// {
						// celement: cnt(31, 0)
						// {
							sc_lv<32>* cnt_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: cnt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(cnt[0]) != NULL) // check the null address if the c port is array or others
								{
									cnt_lv0_0_0_1[hls_map_index++].range(31, 0) = sc_bv<32>(cnt_pc_buffer[hls_map_index].range(31, 0));
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: cnt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : cnt[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : cnt[0]
								// output_left_conversion : cnt[i_0]
								// output_type_conversion : (cnt_lv0_0_0_1[hls_map_index++]).to_uint64()
								if (&(cnt[0]) != NULL) // check the null address if the c port is array or others
								{
									cnt[i_0] = (cnt_lv0_0_0_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] cnt_pc_buffer;
		}

		// output port post check: "itt_num"
		aesl_fh.read(AUTOTB_TVOUT_PC_itt_num, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_itt_num, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_itt_num, AESL_token); // data

			sc_bv<8> *itt_num_pc_buffer = new sc_bv<8>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'itt_num', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'itt_num', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					itt_num_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_itt_num, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_itt_num))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: itt_num
				{
					// bitslice(7, 0)
					// {
						// celement: itt_num(7, 0)
						// {
							sc_lv<8>* itt_num_lv0_0_0_1 = new sc_lv<8>[1];
						// }
					// }

					// bitslice(7, 0)
					{
						int hls_map_index = 0;
						// celement: itt_num(7, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(itt_num[0]) != NULL) // check the null address if the c port is array or others
								{
									itt_num_lv0_0_0_1[hls_map_index++].range(7, 0) = sc_bv<8>(itt_num_pc_buffer[hls_map_index].range(7, 0));
								}
							}
						}
					}

					// bitslice(7, 0)
					{
						int hls_map_index = 0;
						// celement: itt_num(7, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : itt_num[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : itt_num[0]
								// output_left_conversion : itt_num[i_0]
								// output_type_conversion : (itt_num_lv0_0_0_1[hls_map_index++]).to_uint64()
								if (&(itt_num[0]) != NULL) // check the null address if the c port is array or others
								{
									itt_num[i_0] = (itt_num_lv0_0_0_1[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] itt_num_pc_buffer;
		}

		AESL_transaction_pc++;
	}
	else
	{
		CodeState = ENTER_WRAPC;
		static unsigned AESL_transaction;

		static AESL_FILE_HANDLER aesl_fh;

		// "pR"
		char* tvin_pR = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR);

		// "pR1"
		char* tvin_pR1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR1);

		// "pR2"
		char* tvin_pR2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR2);

		// "pR3"
		char* tvin_pR3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR3);

		// "pR4"
		char* tvin_pR4 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR4);

		// "pR5"
		char* tvin_pR5 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR5);

		// "pR6"
		char* tvin_pR6 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR6);

		// "pR7"
		char* tvin_pR7 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR7);

		// "pR8"
		char* tvin_pR8 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR8);

		// "pR9"
		char* tvin_pR9 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pR9);

		// "pbhat0"
		char* tvin_pbhat0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat0);
		char* tvout_pbhat0 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat0);

		// "pbhat1"
		char* tvin_pbhat1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat1);
		char* tvout_pbhat1 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat1);

		// "pbhat2"
		char* tvin_pbhat2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat2);
		char* tvout_pbhat2 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat2);

		// "pbhat3"
		char* tvin_pbhat3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat3);
		char* tvout_pbhat3 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat3);

		// "pbhat4"
		char* tvin_pbhat4 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat4);
		char* tvout_pbhat4 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat4);

		// "pbhat5"
		char* tvin_pbhat5 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat5);
		char* tvout_pbhat5 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat5);

		// "pbhat6"
		char* tvin_pbhat6 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat6);
		char* tvout_pbhat6 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat6);

		// "pbhat7"
		char* tvin_pbhat7 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pbhat7);
		char* tvout_pbhat7 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_pbhat7);

		// "cnt"
		char* tvout_cnt = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_cnt);

		// "pMaxIterations"
		char* tvin_pMaxIterations = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_pMaxIterations);

		// "itt_num"
		char* tvout_itt_num = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_itt_num);

		// "numbits"
		char* tvin_numbits = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_numbits);

		// "mux"
		char* tvin_mux = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_mux);

		CodeState = DUMP_INPUTS;
		static INTER_TCL_FILE tcl_file(INTER_TCL);
		int leading_zero;

		// [[transaction]]
		sprintf(tvin_pR, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR, tvin_pR);

		sc_bv<8>* pR_tvin_wrapc_buffer = new sc_bv<8>[2048];

		// RTL Name: pR
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR(7, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR[0]
						// regulate_c_name       : pR
						// input_type_conversion : pR[i_0]
						if (&(pR[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR_tmp_mem;
							pR_tmp_mem = pR[i_0];
							pR_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pR, "%s\n", (pR_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR, tvin_pR);
		}

		tcl_file.set_num(2048, &tcl_file.pR_depth);
		sprintf(tvin_pR, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR, tvin_pR);

		// release memory allocation
		delete [] pR_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR1, tvin_pR1);

		sc_bv<8>* pR1_tvin_wrapc_buffer = new sc_bv<8>[2048];

		// RTL Name: pR1
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR1(7, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR1[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR1[0]
						// regulate_c_name       : pR1
						// input_type_conversion : pR1[i_0]
						if (&(pR1[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR1_tmp_mem;
							pR1_tmp_mem = pR1[i_0];
							pR1_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR1_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pR1, "%s\n", (pR1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR1, tvin_pR1);
		}

		tcl_file.set_num(2048, &tcl_file.pR1_depth);
		sprintf(tvin_pR1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR1, tvin_pR1);

		// release memory allocation
		delete [] pR1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR2, tvin_pR2);

		sc_bv<8>* pR2_tvin_wrapc_buffer = new sc_bv<8>[2048];

		// RTL Name: pR2
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR2(7, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR2[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR2[0]
						// regulate_c_name       : pR2
						// input_type_conversion : pR2[i_0]
						if (&(pR2[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR2_tmp_mem;
							pR2_tmp_mem = pR2[i_0];
							pR2_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR2_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pR2, "%s\n", (pR2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR2, tvin_pR2);
		}

		tcl_file.set_num(2048, &tcl_file.pR2_depth);
		sprintf(tvin_pR2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR2, tvin_pR2);

		// release memory allocation
		delete [] pR2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR3, tvin_pR3);

		sc_bv<8>* pR3_tvin_wrapc_buffer = new sc_bv<8>[2048];

		// RTL Name: pR3
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR3(7, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR3[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR3[0]
						// regulate_c_name       : pR3
						// input_type_conversion : pR3[i_0]
						if (&(pR3[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR3_tmp_mem;
							pR3_tmp_mem = pR3[i_0];
							pR3_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR3_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pR3, "%s\n", (pR3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR3, tvin_pR3);
		}

		tcl_file.set_num(2048, &tcl_file.pR3_depth);
		sprintf(tvin_pR3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR3, tvin_pR3);

		// release memory allocation
		delete [] pR3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR4, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR4, tvin_pR4);

		sc_bv<8>* pR4_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR4
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR4(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR4[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR4[0]
						// regulate_c_name       : pR4
						// input_type_conversion : pR4[i_0]
						if (&(pR4[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR4_tmp_mem;
							pR4_tmp_mem = pR4[i_0];
							pR4_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR4_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR4, "%s\n", (pR4_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR4, tvin_pR4);
		}

		tcl_file.set_num(1024, &tcl_file.pR4_depth);
		sprintf(tvin_pR4, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR4, tvin_pR4);

		// release memory allocation
		delete [] pR4_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR5, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR5, tvin_pR5);

		sc_bv<8>* pR5_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR5
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR5(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR5[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR5[0]
						// regulate_c_name       : pR5
						// input_type_conversion : pR5[i_0]
						if (&(pR5[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR5_tmp_mem;
							pR5_tmp_mem = pR5[i_0];
							pR5_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR5_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR5, "%s\n", (pR5_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR5, tvin_pR5);
		}

		tcl_file.set_num(1024, &tcl_file.pR5_depth);
		sprintf(tvin_pR5, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR5, tvin_pR5);

		// release memory allocation
		delete [] pR5_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR6, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR6, tvin_pR6);

		sc_bv<8>* pR6_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR6
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR6(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR6[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR6[0]
						// regulate_c_name       : pR6
						// input_type_conversion : pR6[i_0]
						if (&(pR6[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR6_tmp_mem;
							pR6_tmp_mem = pR6[i_0];
							pR6_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR6_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR6, "%s\n", (pR6_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR6, tvin_pR6);
		}

		tcl_file.set_num(1024, &tcl_file.pR6_depth);
		sprintf(tvin_pR6, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR6, tvin_pR6);

		// release memory allocation
		delete [] pR6_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR7, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR7, tvin_pR7);

		sc_bv<8>* pR7_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR7
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR7(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR7[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR7[0]
						// regulate_c_name       : pR7
						// input_type_conversion : pR7[i_0]
						if (&(pR7[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR7_tmp_mem;
							pR7_tmp_mem = pR7[i_0];
							pR7_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR7_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR7, "%s\n", (pR7_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR7, tvin_pR7);
		}

		tcl_file.set_num(1024, &tcl_file.pR7_depth);
		sprintf(tvin_pR7, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR7, tvin_pR7);

		// release memory allocation
		delete [] pR7_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR8, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR8, tvin_pR8);

		sc_bv<8>* pR8_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR8
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR8(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR8[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR8[0]
						// regulate_c_name       : pR8
						// input_type_conversion : pR8[i_0]
						if (&(pR8[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR8_tmp_mem;
							pR8_tmp_mem = pR8[i_0];
							pR8_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR8_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR8, "%s\n", (pR8_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR8, tvin_pR8);
		}

		tcl_file.set_num(1024, &tcl_file.pR8_depth);
		sprintf(tvin_pR8, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR8, tvin_pR8);

		// release memory allocation
		delete [] pR8_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pR9, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pR9, tvin_pR9);

		sc_bv<8>* pR9_tvin_wrapc_buffer = new sc_bv<8>[1024];

		// RTL Name: pR9
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: pR9(7, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pR9[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pR9[0]
						// regulate_c_name       : pR9
						// input_type_conversion : pR9[i_0]
						if (&(pR9[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> pR9_tmp_mem;
							pR9_tmp_mem = pR9[i_0];
							pR9_tvin_wrapc_buffer[hls_map_index++].range(7, 0) = pR9_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pR9, "%s\n", (pR9_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pR9, tvin_pR9);
		}

		tcl_file.set_num(1024, &tcl_file.pR9_depth);
		sprintf(tvin_pR9, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pR9, tvin_pR9);

		// release memory allocation
		delete [] pR9_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat0, tvin_pbhat0);

		sc_bv<1>* pbhat0_tvin_wrapc_buffer = new sc_bv<1>[2048];

		// RTL Name: pbhat0
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat0(0, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat0[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat0[0]
						// regulate_c_name       : pbhat0
						// input_type_conversion : pbhat0[i_0]
						if (&(pbhat0[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat0_tmp_mem;
							pbhat0_tmp_mem = pbhat0[i_0];
							pbhat0_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat0_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pbhat0, "%s\n", (pbhat0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat0, tvin_pbhat0);
		}

		tcl_file.set_num(2048, &tcl_file.pbhat0_depth);
		sprintf(tvin_pbhat0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat0, tvin_pbhat0);

		// release memory allocation
		delete [] pbhat0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat1, tvin_pbhat1);

		sc_bv<1>* pbhat1_tvin_wrapc_buffer = new sc_bv<1>[2048];

		// RTL Name: pbhat1
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat1(0, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat1[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat1[0]
						// regulate_c_name       : pbhat1
						// input_type_conversion : pbhat1[i_0]
						if (&(pbhat1[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat1_tmp_mem;
							pbhat1_tmp_mem = pbhat1[i_0];
							pbhat1_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat1_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvin_pbhat1, "%s\n", (pbhat1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat1, tvin_pbhat1);
		}

		tcl_file.set_num(2048, &tcl_file.pbhat1_depth);
		sprintf(tvin_pbhat1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat1, tvin_pbhat1);

		// release memory allocation
		delete [] pbhat1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat2, tvin_pbhat2);

		sc_bv<1>* pbhat2_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat2
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat2(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat2[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat2[0]
						// regulate_c_name       : pbhat2
						// input_type_conversion : pbhat2[i_0]
						if (&(pbhat2[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat2_tmp_mem;
							pbhat2_tmp_mem = pbhat2[i_0];
							pbhat2_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat2_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat2, "%s\n", (pbhat2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat2, tvin_pbhat2);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat2_depth);
		sprintf(tvin_pbhat2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat2, tvin_pbhat2);

		// release memory allocation
		delete [] pbhat2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat3, tvin_pbhat3);

		sc_bv<1>* pbhat3_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat3
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat3(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat3[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat3[0]
						// regulate_c_name       : pbhat3
						// input_type_conversion : pbhat3[i_0]
						if (&(pbhat3[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat3_tmp_mem;
							pbhat3_tmp_mem = pbhat3[i_0];
							pbhat3_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat3_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat3, "%s\n", (pbhat3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat3, tvin_pbhat3);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat3_depth);
		sprintf(tvin_pbhat3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat3, tvin_pbhat3);

		// release memory allocation
		delete [] pbhat3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat4, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat4, tvin_pbhat4);

		sc_bv<1>* pbhat4_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat4
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat4(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat4[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat4[0]
						// regulate_c_name       : pbhat4
						// input_type_conversion : pbhat4[i_0]
						if (&(pbhat4[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat4_tmp_mem;
							pbhat4_tmp_mem = pbhat4[i_0];
							pbhat4_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat4_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat4, "%s\n", (pbhat4_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat4, tvin_pbhat4);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat4_depth);
		sprintf(tvin_pbhat4, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat4, tvin_pbhat4);

		// release memory allocation
		delete [] pbhat4_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat5, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat5, tvin_pbhat5);

		sc_bv<1>* pbhat5_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat5
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat5(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat5[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat5[0]
						// regulate_c_name       : pbhat5
						// input_type_conversion : pbhat5[i_0]
						if (&(pbhat5[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat5_tmp_mem;
							pbhat5_tmp_mem = pbhat5[i_0];
							pbhat5_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat5_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat5, "%s\n", (pbhat5_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat5, tvin_pbhat5);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat5_depth);
		sprintf(tvin_pbhat5, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat5, tvin_pbhat5);

		// release memory allocation
		delete [] pbhat5_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat6, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat6, tvin_pbhat6);

		sc_bv<1>* pbhat6_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat6
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat6(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat6[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat6[0]
						// regulate_c_name       : pbhat6
						// input_type_conversion : pbhat6[i_0]
						if (&(pbhat6[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat6_tmp_mem;
							pbhat6_tmp_mem = pbhat6[i_0];
							pbhat6_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat6_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat6, "%s\n", (pbhat6_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat6, tvin_pbhat6);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat6_depth);
		sprintf(tvin_pbhat6, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat6, tvin_pbhat6);

		// release memory allocation
		delete [] pbhat6_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pbhat7, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pbhat7, tvin_pbhat7);

		sc_bv<1>* pbhat7_tvin_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat7
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat7(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat7[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat7[0]
						// regulate_c_name       : pbhat7
						// input_type_conversion : pbhat7[i_0]
						if (&(pbhat7[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat7_tmp_mem;
							pbhat7_tmp_mem = pbhat7[i_0];
							pbhat7_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat7_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvin_pbhat7, "%s\n", (pbhat7_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pbhat7, tvin_pbhat7);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat7_depth);
		sprintf(tvin_pbhat7, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pbhat7, tvin_pbhat7);

		// release memory allocation
		delete [] pbhat7_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_pMaxIterations, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_pMaxIterations, tvin_pMaxIterations);

		sc_bv<16> pMaxIterations_tvin_wrapc_buffer;

		// RTL Name: pMaxIterations
		{
			// bitslice(15, 0)
			{
				// celement: pMaxIterations(15, 0)
				{
					// carray: (0) => (0) @ (0)
					{
						// sub                   : 
						// ori_name              : pMaxIterations
						// sub_1st_elem          : 
						// ori_name_1st_elem     : pMaxIterations
						// regulate_c_name       : pMaxIterations
						// input_type_conversion : pMaxIterations
						if (&(pMaxIterations) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> pMaxIterations_tmp_mem;
							pMaxIterations_tmp_mem = pMaxIterations;
							pMaxIterations_tvin_wrapc_buffer.range(15, 0) = pMaxIterations_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_pMaxIterations, "%s\n", (pMaxIterations_tvin_wrapc_buffer).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_pMaxIterations, tvin_pMaxIterations);
		}

		tcl_file.set_num(1, &tcl_file.pMaxIterations_depth);
		sprintf(tvin_pMaxIterations, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_pMaxIterations, tvin_pMaxIterations);

		// [[transaction]]
		sprintf(tvin_numbits, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_numbits, tvin_numbits);

		sc_bv<16> numbits_tvin_wrapc_buffer;

		// RTL Name: numbits
		{
			// bitslice(15, 0)
			{
				// celement: numbits(15, 0)
				{
					// carray: (0) => (0) @ (0)
					{
						// sub                   : 
						// ori_name              : numbits
						// sub_1st_elem          : 
						// ori_name_1st_elem     : numbits
						// regulate_c_name       : numbits
						// input_type_conversion : numbits
						if (&(numbits) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> numbits_tmp_mem;
							numbits_tmp_mem = numbits;
							numbits_tvin_wrapc_buffer.range(15, 0) = numbits_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_numbits, "%s\n", (numbits_tvin_wrapc_buffer).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_numbits, tvin_numbits);
		}

		tcl_file.set_num(1, &tcl_file.numbits_depth);
		sprintf(tvin_numbits, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_numbits, tvin_numbits);

		// [[transaction]]
		sprintf(tvin_mux, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_mux, tvin_mux);

		sc_bv<1>* mux_tvin_wrapc_buffer = new sc_bv<1>[1];

		// RTL Name: mux
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: mux(0, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : mux[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : mux[0]
						// regulate_c_name       : mux
						// input_type_conversion : mux[i_0]
						if (&(mux[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> mux_tmp_mem;
							mux_tmp_mem = mux[i_0];
							mux_tvin_wrapc_buffer[hls_map_index++].range(0, 0) = mux_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_mux, "%s\n", (mux_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_mux, tvin_mux);
		}

		tcl_file.set_num(1, &tcl_file.mux_depth);
		sprintf(tvin_mux, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_mux, tvin_mux);

		// release memory allocation
		delete [] mux_tvin_wrapc_buffer;

// [call_c_dut] ---------->

		CodeState = CALL_C_DUT;
		HLSLdpcLogDecScaledMin(pR, pR1, pR2, pR3, pR4, pR5, pR6, pR7, pR8, pR9, pR10, pbhat0, pbhat1, pbhat2, pbhat3, pbhat4, pbhat5, pbhat6, pbhat7, cnt, nR_M, etaIndexM_M, pCodeM, pMaxIterations, itt_num, numbits, mux);

		CodeState = DUMP_OUTPUTS;

		// [[transaction]]
		sprintf(tvout_pbhat0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat0, tvout_pbhat0);

		sc_bv<1>* pbhat0_tvout_wrapc_buffer = new sc_bv<1>[2048];

		// RTL Name: pbhat0
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat0(0, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat0[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat0[0]
						// regulate_c_name       : pbhat0
						// input_type_conversion : pbhat0[i_0]
						if (&(pbhat0[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat0_tmp_mem;
							pbhat0_tmp_mem = pbhat0[i_0];
							pbhat0_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat0_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvout_pbhat0, "%s\n", (pbhat0_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat0, tvout_pbhat0);
		}

		tcl_file.set_num(2048, &tcl_file.pbhat0_depth);
		sprintf(tvout_pbhat0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat0, tvout_pbhat0);

		// release memory allocation
		delete [] pbhat0_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat1, tvout_pbhat1);

		sc_bv<1>* pbhat1_tvout_wrapc_buffer = new sc_bv<1>[2048];

		// RTL Name: pbhat1
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat1(0, 0)
				{
					// carray: (0) => (2047) @ (1)
					for (int i_0 = 0; i_0 <= 2047; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat1[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat1[0]
						// regulate_c_name       : pbhat1
						// input_type_conversion : pbhat1[i_0]
						if (&(pbhat1[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat1_tmp_mem;
							pbhat1_tmp_mem = pbhat1[i_0];
							pbhat1_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat1_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 2048; i++)
		{
			sprintf(tvout_pbhat1, "%s\n", (pbhat1_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat1, tvout_pbhat1);
		}

		tcl_file.set_num(2048, &tcl_file.pbhat1_depth);
		sprintf(tvout_pbhat1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat1, tvout_pbhat1);

		// release memory allocation
		delete [] pbhat1_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat2, tvout_pbhat2);

		sc_bv<1>* pbhat2_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat2
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat2(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat2[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat2[0]
						// regulate_c_name       : pbhat2
						// input_type_conversion : pbhat2[i_0]
						if (&(pbhat2[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat2_tmp_mem;
							pbhat2_tmp_mem = pbhat2[i_0];
							pbhat2_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat2_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat2, "%s\n", (pbhat2_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat2, tvout_pbhat2);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat2_depth);
		sprintf(tvout_pbhat2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat2, tvout_pbhat2);

		// release memory allocation
		delete [] pbhat2_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat3, tvout_pbhat3);

		sc_bv<1>* pbhat3_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat3
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat3(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat3[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat3[0]
						// regulate_c_name       : pbhat3
						// input_type_conversion : pbhat3[i_0]
						if (&(pbhat3[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat3_tmp_mem;
							pbhat3_tmp_mem = pbhat3[i_0];
							pbhat3_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat3_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat3, "%s\n", (pbhat3_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat3, tvout_pbhat3);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat3_depth);
		sprintf(tvout_pbhat3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat3, tvout_pbhat3);

		// release memory allocation
		delete [] pbhat3_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat4, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat4, tvout_pbhat4);

		sc_bv<1>* pbhat4_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat4
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat4(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat4[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat4[0]
						// regulate_c_name       : pbhat4
						// input_type_conversion : pbhat4[i_0]
						if (&(pbhat4[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat4_tmp_mem;
							pbhat4_tmp_mem = pbhat4[i_0];
							pbhat4_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat4_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat4, "%s\n", (pbhat4_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat4, tvout_pbhat4);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat4_depth);
		sprintf(tvout_pbhat4, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat4, tvout_pbhat4);

		// release memory allocation
		delete [] pbhat4_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat5, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat5, tvout_pbhat5);

		sc_bv<1>* pbhat5_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat5
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat5(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat5[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat5[0]
						// regulate_c_name       : pbhat5
						// input_type_conversion : pbhat5[i_0]
						if (&(pbhat5[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat5_tmp_mem;
							pbhat5_tmp_mem = pbhat5[i_0];
							pbhat5_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat5_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat5, "%s\n", (pbhat5_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat5, tvout_pbhat5);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat5_depth);
		sprintf(tvout_pbhat5, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat5, tvout_pbhat5);

		// release memory allocation
		delete [] pbhat5_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat6, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat6, tvout_pbhat6);

		sc_bv<1>* pbhat6_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat6
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat6(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat6[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat6[0]
						// regulate_c_name       : pbhat6
						// input_type_conversion : pbhat6[i_0]
						if (&(pbhat6[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat6_tmp_mem;
							pbhat6_tmp_mem = pbhat6[i_0];
							pbhat6_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat6_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat6, "%s\n", (pbhat6_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat6, tvout_pbhat6);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat6_depth);
		sprintf(tvout_pbhat6, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat6, tvout_pbhat6);

		// release memory allocation
		delete [] pbhat6_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_pbhat7, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_pbhat7, tvout_pbhat7);

		sc_bv<1>* pbhat7_tvout_wrapc_buffer = new sc_bv<1>[1024];

		// RTL Name: pbhat7
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: pbhat7(0, 0)
				{
					// carray: (0) => (1023) @ (1)
					for (int i_0 = 0; i_0 <= 1023; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : pbhat7[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : pbhat7[0]
						// regulate_c_name       : pbhat7
						// input_type_conversion : pbhat7[i_0]
						if (&(pbhat7[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> pbhat7_tmp_mem;
							pbhat7_tmp_mem = pbhat7[i_0];
							pbhat7_tvout_wrapc_buffer[hls_map_index++].range(0, 0) = pbhat7_tmp_mem.range(0, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1024; i++)
		{
			sprintf(tvout_pbhat7, "%s\n", (pbhat7_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_pbhat7, tvout_pbhat7);
		}

		tcl_file.set_num(1024, &tcl_file.pbhat7_depth);
		sprintf(tvout_pbhat7, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_pbhat7, tvout_pbhat7);

		// release memory allocation
		delete [] pbhat7_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_cnt, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_cnt, tvout_cnt);

		sc_bv<32>* cnt_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: cnt
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: cnt(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : cnt[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : cnt[0]
						// regulate_c_name       : cnt
						// input_type_conversion : cnt[i_0]
						if (&(cnt[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> cnt_tmp_mem;
							cnt_tmp_mem = cnt[i_0];
							cnt_tvout_wrapc_buffer[hls_map_index++].range(31, 0) = cnt_tmp_mem.range(31, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_cnt, "%s\n", (cnt_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_cnt, tvout_cnt);
		}

		tcl_file.set_num(1, &tcl_file.cnt_depth);
		sprintf(tvout_cnt, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_cnt, tvout_cnt);

		// release memory allocation
		delete [] cnt_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_itt_num, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_itt_num, tvout_itt_num);

		sc_bv<8>* itt_num_tvout_wrapc_buffer = new sc_bv<8>[1];

		// RTL Name: itt_num
		{
			// bitslice(7, 0)
			{
				int hls_map_index = 0;
				// celement: itt_num(7, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : itt_num[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : itt_num[0]
						// regulate_c_name       : itt_num
						// input_type_conversion : itt_num[i_0]
						if (&(itt_num[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<8> itt_num_tmp_mem;
							itt_num_tmp_mem = itt_num[i_0];
							itt_num_tvout_wrapc_buffer[hls_map_index++].range(7, 0) = itt_num_tmp_mem.range(7, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_itt_num, "%s\n", (itt_num_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_itt_num, tvout_itt_num);
		}

		tcl_file.set_num(1, &tcl_file.itt_num_depth);
		sprintf(tvout_itt_num, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_itt_num, tvout_itt_num);

		// release memory allocation
		delete [] itt_num_tvout_wrapc_buffer;

		CodeState = DELETE_CHAR_BUFFERS;
		// release memory allocation: "pR"
		delete [] tvin_pR;
		// release memory allocation: "pR1"
		delete [] tvin_pR1;
		// release memory allocation: "pR2"
		delete [] tvin_pR2;
		// release memory allocation: "pR3"
		delete [] tvin_pR3;
		// release memory allocation: "pR4"
		delete [] tvin_pR4;
		// release memory allocation: "pR5"
		delete [] tvin_pR5;
		// release memory allocation: "pR6"
		delete [] tvin_pR6;
		// release memory allocation: "pR7"
		delete [] tvin_pR7;
		// release memory allocation: "pR8"
		delete [] tvin_pR8;
		// release memory allocation: "pR9"
		delete [] tvin_pR9;
		// release memory allocation: "pbhat0"
		delete [] tvout_pbhat0;
		delete [] tvin_pbhat0;
		// release memory allocation: "pbhat1"
		delete [] tvout_pbhat1;
		delete [] tvin_pbhat1;
		// release memory allocation: "pbhat2"
		delete [] tvout_pbhat2;
		delete [] tvin_pbhat2;
		// release memory allocation: "pbhat3"
		delete [] tvout_pbhat3;
		delete [] tvin_pbhat3;
		// release memory allocation: "pbhat4"
		delete [] tvout_pbhat4;
		delete [] tvin_pbhat4;
		// release memory allocation: "pbhat5"
		delete [] tvout_pbhat5;
		delete [] tvin_pbhat5;
		// release memory allocation: "pbhat6"
		delete [] tvout_pbhat6;
		delete [] tvin_pbhat6;
		// release memory allocation: "pbhat7"
		delete [] tvout_pbhat7;
		delete [] tvin_pbhat7;
		// release memory allocation: "cnt"
		delete [] tvout_cnt;
		// release memory allocation: "pMaxIterations"
		delete [] tvin_pMaxIterations;
		// release memory allocation: "itt_num"
		delete [] tvout_itt_num;
		// release memory allocation: "numbits"
		delete [] tvin_numbits;
		// release memory allocation: "mux"
		delete [] tvin_mux;

		AESL_transaction++;

		tcl_file.set_num(AESL_transaction , &tcl_file.trans_num);
	}
}

