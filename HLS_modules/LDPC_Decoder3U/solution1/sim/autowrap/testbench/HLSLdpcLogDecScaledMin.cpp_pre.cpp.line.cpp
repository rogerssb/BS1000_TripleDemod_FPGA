#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
#pragma line 1 "<built-in>"
#pragma line 1 "<command-line>"
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
#pragma line 24 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 1 3
#pragma line 16 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
#pragma empty_line
#pragma line 17 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 1 3
#pragma line 32 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 3
#pragma empty_line
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 3
#pragma line 21 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 2 3
#pragma line 90 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern "C" {
#pragma line 134 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
struct _exception
{
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};
#pragma empty_line
 double __attribute__((__cdecl__)) sin (double);
 double __attribute__((__cdecl__)) cos (double);
 double __attribute__((__cdecl__)) tan (double);
 double __attribute__((__cdecl__)) sinh (double);
 double __attribute__((__cdecl__)) cosh (double);
 double __attribute__((__cdecl__)) tanh (double);
 double __attribute__((__cdecl__)) asin (double);
 double __attribute__((__cdecl__)) acos (double);
 double __attribute__((__cdecl__)) atan (double);
 double __attribute__((__cdecl__)) atan2 (double, double);
 double __attribute__((__cdecl__)) exp (double);
 double __attribute__((__cdecl__)) log (double);
 double __attribute__((__cdecl__)) log10 (double);
 double __attribute__((__cdecl__)) pow (double, double);
 double __attribute__((__cdecl__)) sqrt (double);
 double __attribute__((__cdecl__)) ceil (double);
 double __attribute__((__cdecl__)) floor (double);
 double __attribute__((__cdecl__)) fabs (double);
 double __attribute__((__cdecl__)) ldexp (double, int);
 double __attribute__((__cdecl__)) frexp (double, int*);
 double __attribute__((__cdecl__)) modf (double, double*);
 double __attribute__((__cdecl__)) fmod (double, double);
#pragma line 210 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
struct _complex
{
 double x;
 double y;
};
#pragma empty_line
 double __attribute__((__cdecl__)) _cabs (struct _complex);
#pragma empty_line
 double __attribute__((__cdecl__)) _hypot (double, double);
 double __attribute__((__cdecl__)) _j0 (double);
 double __attribute__((__cdecl__)) _j1 (double);
 double __attribute__((__cdecl__)) _jn (int, double);
 double __attribute__((__cdecl__)) _y0 (double);
 double __attribute__((__cdecl__)) _y1 (double);
 double __attribute__((__cdecl__)) _yn (int, double);
 int __attribute__((__cdecl__)) _matherr (struct _exception *);
#pragma line 234 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 double __attribute__((__cdecl__)) _chgsign (double);
 double __attribute__((__cdecl__)) _copysign (double, double);
 double __attribute__((__cdecl__)) _logb (double);
 double __attribute__((__cdecl__)) _nextafter (double, double);
 double __attribute__((__cdecl__)) _scalb (double, long);
#pragma empty_line
 int __attribute__((__cdecl__)) _finite (double);
 int __attribute__((__cdecl__)) _fpclass (double);
 int __attribute__((__cdecl__)) _isnan (double);
#pragma line 254 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 double __attribute__((__cdecl__)) j0 (double);
 double __attribute__((__cdecl__)) j1 (double);
 double __attribute__((__cdecl__)) jn (int, double);
 double __attribute__((__cdecl__)) y0 (double);
 double __attribute__((__cdecl__)) y1 (double);
 double __attribute__((__cdecl__)) yn (int, double);
#pragma empty_line
 double __attribute__((__cdecl__)) chgsign (double);
#pragma line 270 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 int __attribute__((__cdecl__)) finite (double);
 int __attribute__((__cdecl__)) fpclass (double);
#pragma line 324 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
typedef long double float_t;
typedef long double double_t;
#pragma line 354 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __fpclassifyf (float);
extern int __attribute__((__cdecl__)) __fpclassify (double);
extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
#pragma line 379 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __isnan (double);
extern int __attribute__((__cdecl__)) __isnanf (float);
extern int __attribute__((__cdecl__)) __isnanl (long double);
#pragma line 419 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __signbit (double);
extern int __attribute__((__cdecl__)) __signbitf (float);
extern int __attribute__((__cdecl__)) __signbitl (long double);
#pragma line 447 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern float __attribute__((__cdecl__)) sinf (float);
extern long double __attribute__((__cdecl__)) sinl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) cosf (float);
extern long double __attribute__((__cdecl__)) cosl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) tanf (float);
extern long double __attribute__((__cdecl__)) tanl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) asinf (float);
extern long double __attribute__((__cdecl__)) asinl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) acosf (float);
extern long double __attribute__((__cdecl__)) acosl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) atan2f (float, float);
extern long double __attribute__((__cdecl__)) atan2l (long double, long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) sinhf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) sinhl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) coshf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) coshl (long double);
#pragma empty_line
extern float __attribute__((__cdecl__)) tanhf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) tanhl (long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) acosh (double);
extern float __attribute__((__cdecl__)) acoshf (float);
extern long double __attribute__((__cdecl__)) acoshl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) asinh (double);
extern float __attribute__((__cdecl__)) asinhf (float);
extern long double __attribute__((__cdecl__)) asinhl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) atanh (double);
extern float __attribute__((__cdecl__)) atanhf (float);
extern long double __attribute__((__cdecl__)) atanhl (long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) expf (float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) expl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) exp2(double);
extern float __attribute__((__cdecl__)) exp2f(float);
extern long double __attribute__((__cdecl__)) exp2l(long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) expm1(double);
extern float __attribute__((__cdecl__)) expm1f(float);
extern long double __attribute__((__cdecl__)) expm1l(long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) frexpf (float, int*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) frexpl (long double, int*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern int __attribute__((__cdecl__)) ilogb (double);
extern int __attribute__((__cdecl__)) ilogbf (float);
extern int __attribute__((__cdecl__)) ilogbl (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) ldexpf (float, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) ldexpl (long double, int);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) logf (float);
extern long double __attribute__((__cdecl__)) logl (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) log10f (float);
extern long double __attribute__((__cdecl__)) log10l (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) log1p(double);
extern float __attribute__((__cdecl__)) log1pf(float);
extern long double __attribute__((__cdecl__)) log1pl(long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) log2 (double);
extern float __attribute__((__cdecl__)) log2f (float);
extern long double __attribute__((__cdecl__)) log2l (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) logb (double);
extern float __attribute__((__cdecl__)) logbf (float);
extern long double __attribute__((__cdecl__)) logbl (long double);
#pragma line 603 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern float __attribute__((__cdecl__)) modff (float, float*);
extern long double __attribute__((__cdecl__)) modfl (long double, long double*);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) scalbn (double, int);
extern float __attribute__((__cdecl__)) scalbnf (float, int);
extern long double __attribute__((__cdecl__)) scalbnl (long double, int);
#pragma empty_line
extern double __attribute__((__cdecl__)) scalbln (double, long);
extern float __attribute__((__cdecl__)) scalblnf (float, long);
extern long double __attribute__((__cdecl__)) scalblnl (long double, long);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) cbrt (double);
extern float __attribute__((__cdecl__)) cbrtf (float);
extern long double __attribute__((__cdecl__)) cbrtl (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) fabsf (float x);
extern long double __attribute__((__cdecl__)) fabsl (long double x);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) hypot (double, double);
extern float __attribute__((__cdecl__)) hypotf (float, float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) hypotl (long double, long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) powf (float, float);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern long double __attribute__((__cdecl__)) powl (long double, long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) sqrtf (float);
extern long double __attribute__((__cdecl__)) sqrtl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) erf (double);
extern float __attribute__((__cdecl__)) erff (float);
extern long double __attribute__((__cdecl__)) erfl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) erfc (double);
extern float __attribute__((__cdecl__)) erfcf (float);
extern long double __attribute__((__cdecl__)) erfcl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) lgamma (double);
extern float __attribute__((__cdecl__)) lgammaf (float);
extern long double __attribute__((__cdecl__)) lgammal (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) tgamma (double);
extern float __attribute__((__cdecl__)) tgammaf (float);
extern long double __attribute__((__cdecl__)) tgammal (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) ceilf (float);
extern long double __attribute__((__cdecl__)) ceill (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) floorf (float);
extern long double __attribute__((__cdecl__)) floorl (long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) nearbyint ( double);
extern float __attribute__((__cdecl__)) nearbyintf (float);
extern long double __attribute__((__cdecl__)) nearbyintl (long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);
#pragma empty_line
#pragma empty_line
extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);
#pragma empty_line
extern long long __attribute__((__cdecl__)) llrint (double);
extern long long __attribute__((__cdecl__)) llrintf (float);
extern long long __attribute__((__cdecl__)) llrintl (long double);
#pragma line 771 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern double __attribute__((__cdecl__)) round (double);
extern float __attribute__((__cdecl__)) roundf (float);
extern long double __attribute__((__cdecl__)) roundl (long double);
#pragma empty_line
#pragma empty_line
extern long __attribute__((__cdecl__)) lround (double);
extern long __attribute__((__cdecl__)) lroundf (float);
extern long __attribute__((__cdecl__)) lroundl (long double);
#pragma empty_line
extern long long __attribute__((__cdecl__)) llround (double);
extern long long __attribute__((__cdecl__)) llroundf (float);
extern long long __attribute__((__cdecl__)) llroundl (long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) trunc (double);
extern float __attribute__((__cdecl__)) truncf (float);
extern long double __attribute__((__cdecl__)) truncl (long double);
#pragma empty_line
#pragma empty_line
extern float __attribute__((__cdecl__)) fmodf (float, float);
extern long double __attribute__((__cdecl__)) fmodl (long double, long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) remainder (double, double);
extern float __attribute__((__cdecl__)) remainderf (float, float);
extern long double __attribute__((__cdecl__)) remainderl (long double, long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) remquo(double, double, int *);
extern float __attribute__((__cdecl__)) remquof(float, float, int *);
extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) copysign (double, double);
extern float __attribute__((__cdecl__)) copysignf (float, float);
extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) nan(const char *tagp);
extern float __attribute__((__cdecl__)) nanf(const char *tagp);
extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
#pragma line 821 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern double __attribute__((__cdecl__)) nextafter (double, double);
extern float __attribute__((__cdecl__)) nextafterf (float, float);
extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) nexttoward (double, long double);
extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) fdim (double x, double y);
extern float __attribute__((__cdecl__)) fdimf (float x, float y);
extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) fmax (double, double);
extern float __attribute__((__cdecl__)) fmaxf (float, float);
extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) fmin (double, double);
extern float __attribute__((__cdecl__)) fminf (float, float);
extern long double __attribute__((__cdecl__)) fminl (long double, long double);
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern double __attribute__((__cdecl__)) fma (double, double, double);
extern float __attribute__((__cdecl__)) fmaf (float, float, float);
extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
#pragma line 910 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
}
#pragma line 25 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 1 3
#pragma line 24 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 212 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef unsigned int size_t;
#pragma line 25 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern "C" {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memchr (const void*, int, size_t) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcmp (const void*, const void*, size_t) __attribute__ ((__pure__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcpy (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memmove (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memset (void*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcat (char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strchr (const char*, int) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmp (const char*, const char*) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcpy (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strerror (int);
#pragma empty_line
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlen (const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncat (char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncmp (const char*, const char*, size_t) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncpy (char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strpbrk (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrchr (const char*, int) __attribute__ ((__pure__));
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strstr (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtok (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strxfrm (char*, const char*, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strerror (const char *);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricmp (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicmp (const char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strupr (char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _swab (const char*, char*, size_t);
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strncoll(const char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicoll(const char*, const char*, size_t);
#pragma line 90 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricmp (const char*, const char*);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcasecmp (const char*, const char *);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnicmp (const char*, const char*, size_t);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncasecmp (const char *, const char *, size_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strupr (char*);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swab (const char*, char*, size_t);
#pragma line 126 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscat (wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcschr (const wchar_t*, wchar_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscpy (wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscspn (const wchar_t*, const wchar_t*);
#pragma empty_line
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslen (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncat (wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncmp(const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncpy(wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcspbrk(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrchr(const wchar_t*, wchar_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsspn(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsstr(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstok(wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsxfrm(wchar_t*, const wchar_t*, size_t);
#pragma line 152 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsupr (wchar_t*);
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsncoll(const wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicoll(const wchar_t*, const wchar_t*, size_t);
#pragma line 173 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmpi (const wchar_t * __ws1, const wchar_t * __ws2);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsupr (wchar_t*);
#pragma line 196 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
}
#pragma line 26 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 1 3
#pragma line 26 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 353 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef short unsigned int wint_t;
#pragma line 27 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdarg.h" 1 3 4
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
#pragma line 29 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3
#pragma line 129 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
typedef struct _iobuf
{
 char* _ptr;
 int _cnt;
 char* _base;
 int _flag;
 int _file;
 int _charbuf;
 int _bufsiz;
 char* _tmpfname;
} FILE;
#pragma line 154 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern __attribute__ ((__dllimport__)) FILE _iob[];
#pragma line 163 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) freopen (const char*, const char*, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fflush (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fclose (FILE*);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) remove (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rename (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpfile (void);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpnam (char*);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _unlink (const char*);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) unlink (const char*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setvbuf (FILE*, char*, int, size_t);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setbuf (FILE*, char*);
#pragma line 204 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_fprintf(FILE*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_printf(const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_sprintf(char*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_snprintf(char*, size_t, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vfprintf(FILE*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vprintf(const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsprintf(char*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsnprintf(char*, size_t, const char*, __gnuc_va_list);
#pragma line 293 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fprintf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) printf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sprintf (char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfprintf (FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vprintf (const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsprintf (char*, const char*, __gnuc_va_list);
#pragma line 308 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_fprintf(FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_printf(const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_sprintf(char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vfprintf(FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vprintf(const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vsprintf(char*, const char*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snprintf (char*, size_t, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnprintf (char*, size_t, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscprintf (const char*, __gnuc_va_list);
#pragma line 331 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snprintf (char *, size_t, const char *, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnprintf (char *, size_t, const char *, __gnuc_va_list);
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vscanf (const char * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfscanf (FILE * __restrict__, const char * __restrict__,
       __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsscanf (const char * __restrict__,
       const char * __restrict__, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fscanf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) scanf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sscanf (const char*, const char*, ...);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetc (FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgets (char*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputc (int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputs (const char*, FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gets (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) puts (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetc (int, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filbuf (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flsbuf (int, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getc (FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) *__F->_ptr++
    : _filbuf (__F);
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    : _flsbuf (__c, __F);
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getchar (void)
{
  return (--(&_iob[0])->_cnt >= 0)
    ? (int) (unsigned char) *(&_iob[0])->_ptr++
    : _filbuf ((&_iob[0]));
}
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putchar(int __c)
{
  return (--(&_iob[1])->_cnt >= 0)
    ? (int) (unsigned char) (*(&_iob[1])->_ptr++ = (char)__c)
    : _flsbuf (__c, (&_iob[1]));}
#pragma line 412 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fread (void*, size_t, size_t, FILE*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwrite (const void*, size_t, size_t, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseek (FILE*, long, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftell (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rewind (FILE*);
#pragma line 455 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
typedef long long fpos_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetpos (FILE*, fpos_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fsetpos (FILE*, const fpos_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE*);
#pragma empty_line
#pragma empty_line
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE* __F)
  { return __F->_flag & 0x0010; }
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE* __F)
  { return __F->_flag & 0x0020; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clearerr (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) perror (const char*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _pclose (FILE*);
#pragma empty_line
#pragma empty_line
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) pclose (FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flushall (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fileno (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcloseall (void);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fsopen (const char*, const char*, int);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getmaxstdio (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _setmaxstdio (int);
#pragma line 522 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fileno (FILE*);
#pragma line 534 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 1 3
#pragma line 21 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 150 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef int ptrdiff_t;
#pragma line 22 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long __time32_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long __time64_t;
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 3
typedef __time32_t time_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long _off_t;
#pragma empty_line
#pragma empty_line
typedef _off_t off_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned int _dev_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef _dev_t dev_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef short _ino_t;
#pragma empty_line
#pragma empty_line
typedef _ino_t ino_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _pid_t;
#pragma empty_line
#pragma empty_line
typedef _pid_t pid_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned short _mode_t;
#pragma empty_line
#pragma empty_line
typedef _mode_t mode_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _sigset_t;
#pragma empty_line
#pragma empty_line
typedef _sigset_t sigset_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int _ssize_t;
#pragma empty_line
#pragma empty_line
typedef _ssize_t ssize_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long fpos64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long off64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned int useconds_t;
#pragma line 535 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3
inline FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen64 (const char* filename, const char* mode)
{
  return fopen (filename, mode);
}
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseeko64 (FILE*, off64_t, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline off64_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftello64 (FILE * stream)
{
  fpos_t pos;
  if (fgetpos(stream, &pos))
    return -1LL;
  else
   return ((off64_t) pos);
}
#pragma line 563 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwprintf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wprintf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snwprintf (wchar_t*, size_t, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwprintf (FILE*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnwprintf (wchar_t*, size_t, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwscanf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wscanf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swscanf (const wchar_t*, const wchar_t*, ...);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwc (wchar_t, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetwc (wchar_t, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swprintf (wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswprintf (wchar_t*, const wchar_t*, __gnuc_va_list);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetws (wchar_t*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputws (const wchar_t*, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwchar (void);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getws (wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwc (wint_t, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putws (const wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwchar (wint_t);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfdopen(int, const wchar_t *);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfopen (const wchar_t*, const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfreopen (const wchar_t*, const wchar_t*, FILE*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfsopen (const wchar_t*, const wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtmpnam (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtempnam (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrename (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wremove (const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wperror (const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wpopen (const wchar_t*, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snwprintf (wchar_t* s, size_t n, const wchar_t* format, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnwprintf (wchar_t* s, size_t n, const wchar_t* format, __gnuc_va_list arg);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwscanf (const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwscanf (FILE * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswscanf (const wchar_t * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
#pragma line 625 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wpopen (const wchar_t*, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putw (int, FILE*);
#pragma empty_line
#pragma empty_line
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putw (int, FILE*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 27 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdint.h" 1 3 4
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 1 3 4
#pragma line 24 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 25 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 2 3 4
#pragma empty_line
#pragma empty_line
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;
#pragma empty_line
#pragma empty_line
typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;
#pragma line 66 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
  typedef int intptr_t;
#pragma line 75 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
  typedef unsigned int uintptr_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
#pragma line 4 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdint.h" 2 3 4
#pragma line 28 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Xilinx/Vivado_HLS/2016.4/include/ap_int.h" 1
#pragma line 74 "C:/Xilinx/Vivado_HLS/2016.4/include/ap_int.h"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h" 1
#pragma line 76 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3
#pragma empty_line
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 1 3
#pragma line 153 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 393 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/os_defines.h" 1 3
#pragma line 394 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/cpu_defines.h" 1 3
#pragma line 397 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 2 3
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 3
#pragma empty_line
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _Alloc>
    class allocator;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<class _CharT>
    struct char_traits;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;
#pragma empty_line
  template<> struct char_traits<char>;
#pragma empty_line
  typedef basic_string<char> string;
#pragma empty_line
#pragma empty_line
  template<> struct char_traits<wchar_t>;
#pragma empty_line
  typedef basic_string<wchar_t> wstring;
#pragma line 85 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3
#pragma empty_line
}
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 1 3
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
#pragma empty_line
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 1 3
#pragma line 26 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 27 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 2 3
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 1 3
#pragma line 32 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 2 3
#pragma line 54 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef wchar_t wctype_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#pragma line 148 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
typedef wchar_t wctrans_t;
#pragma line 157 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towctrans(wint_t, wctrans_t);
wctrans_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctrans(const char*);
wctype_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctype(const char*);
#pragma empty_line
#pragma empty_line
}
#pragma line 46 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 2 3
#pragma line 63 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
extern "C" {
#pragma line 87 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        };
#pragma line 164 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstol (const wchar_t*, wchar_t**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoul (const wchar_t*, wchar_t**, int);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstod (const wchar_t*, wchar_t**);
#pragma empty_line
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstof (const wchar_t * __restrict__, wchar_t ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);
#pragma empty_line
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetenv(const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wputenv(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsystem(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfullpath (wchar_t*, const wchar_t*, size_t);
#pragma line 187 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wasctime (const struct tm*);
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wctime (const time_t*);
#pragma empty_line
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrdate (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrtime (wchar_t*);
#pragma line 207 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsftime (wchar_t*, size_t, const wchar_t*, const struct tm*);
#pragma line 292 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
typedef wchar_t _Wint_t;
#pragma empty_line
#pragma empty_line
typedef int mbstate_t;
#pragma empty_line
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) btowc(int);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrlen(const char * __restrict__, size_t,
        mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrtowc(wchar_t * __restrict__, const char * __restrict__,
         size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsrtowcs(wchar_t * __restrict__, const char ** __restrict__,
    size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcrtomb(char * __restrict__, wchar_t,
         mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrtombs(char * __restrict__, const wchar_t ** __restrict__,
    size_t, mbstate_t * __restrict__);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctob(wint_t);
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwide(FILE*, int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsinit(const mbstate_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemset(wchar_t *, wchar_t, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemchr(const wchar_t*, wchar_t, size_t);
int wmemcmp(const wchar_t*, const wchar_t *, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemcpy(wchar_t* __restrict__,
           const wchar_t* __restrict__,
    size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemmove(wchar_t* s1, const wchar_t *, size_t);
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoll(const wchar_t * __restrict__,
     wchar_t** __restrict__, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoull(const wchar_t * __restrict__,
       wchar_t ** __restrict__, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned long _fsize_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct _wfinddata_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 _fsize_t size;
 wchar_t name[260];
};
struct _wfinddatai64_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 long long size;
 wchar_t name[260];
};
#pragma line 407 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _waccess (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchmod (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcreat (const wchar_t*, int);
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirst (const wchar_t*, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnext (long, struct _wfinddata_t *);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wunlink (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wopen (const wchar_t*, int, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsopen (const wchar_t*, int, int, ...);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmktemp (wchar_t*);
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirsti64 (const wchar_t*, struct _wfinddatai64_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnexti64 (long, struct _wfinddatai64_t*);
#pragma line 454 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchdir (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetcwd (wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetdcwd (int, wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmkdir (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrmdir (const wchar_t*);
#pragma line 471 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
struct _stat
{
 _dev_t st_dev;
 _ino_t st_ino;
 _mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 _dev_t st_rdev;
 _off_t st_size;
 time_t st_atime;
#pragma empty_line
 time_t st_mtime;
 time_t st_ctime;
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct stat
{
 dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 dev_t st_rdev;
 off_t st_size;
 time_t st_atime;
#pragma empty_line
 time_t st_mtime;
 time_t st_ctime;
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct _stati64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
};
#pragma line 589 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstat (const wchar_t*, struct _stat*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstati64 (const wchar_t*, struct _stati64*);
#pragma line 612 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsetlocale (int, const wchar_t*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecl (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecle (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclp (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclpe (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecv (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecve (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvp (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvpe (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
#pragma empty_line
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnl (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnle (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlp (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlpe (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnv (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnve (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvp (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvpe (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 47 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 2 3
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
#pragma line 137 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
namespace std
{
#pragma empty_line
#pragma empty_line
  using ::wint_t;
#pragma empty_line
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
#pragma empty_line
  using ::vfwscanf;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::vswscanf;
#pragma empty_line
  using ::vwprintf;
#pragma empty_line
  using ::vwscanf;
#pragma empty_line
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
#pragma empty_line
  using ::wcstof;
#pragma empty_line
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
#pragma empty_line
#pragma empty_line
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }
#pragma empty_line
  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }
#pragma empty_line
  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }
#pragma empty_line
  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }
#pragma empty_line
  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::wcstold;
#pragma line 259 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;
#pragma empty_line
}
#pragma empty_line
namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 2 3
#pragma line 70 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
namespace std
{
#pragma empty_line
#pragma line 92 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
  typedef long long streamoff;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef ptrdiff_t streamsize;
#pragma line 113 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;
#pragma empty_line
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      fpos()
      : _M_off(0), _M_state() { }
#pragma line 135 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }
#pragma empty_line
#pragma empty_line
      operator streamoff() const { return _M_off; }
#pragma empty_line
#pragma empty_line
      void
      state(_StateT __st)
      { _M_state = __st; }
#pragma empty_line
#pragma empty_line
      _StateT
      state() const
      { return _M_state; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }
#pragma empty_line
  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef fpos<mbstate_t> streampos;
#pragma empty_line
  typedef fpos<mbstate_t> wstreampos;
#pragma line 241 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
#pragma empty_line
}
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 76 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3
  class ios_base;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
#pragma empty_line
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef basic_ios<char> ios;
#pragma empty_line
#pragma empty_line
  typedef basic_streambuf<char> streambuf;
#pragma empty_line
#pragma empty_line
  typedef basic_istream<char> istream;
#pragma empty_line
#pragma empty_line
  typedef basic_ostream<char> ostream;
#pragma empty_line
#pragma empty_line
  typedef basic_iostream<char> iostream;
#pragma empty_line
#pragma empty_line
  typedef basic_stringbuf<char> stringbuf;
#pragma empty_line
#pragma empty_line
  typedef basic_istringstream<char> istringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_ostringstream<char> ostringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_stringstream<char> stringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_filebuf<char> filebuf;
#pragma empty_line
#pragma empty_line
  typedef basic_ifstream<char> ifstream;
#pragma empty_line
#pragma empty_line
  typedef basic_ofstream<char> ofstream;
#pragma empty_line
#pragma empty_line
  typedef basic_fstream<char> fstream;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef basic_ios<wchar_t> wios;
#pragma empty_line
#pragma empty_line
  typedef basic_streambuf<wchar_t> wstreambuf;
#pragma empty_line
#pragma empty_line
  typedef basic_istream<wchar_t> wistream;
#pragma empty_line
#pragma empty_line
  typedef basic_ostream<wchar_t> wostream;
#pragma empty_line
#pragma empty_line
  typedef basic_iostream<wchar_t> wiostream;
#pragma empty_line
#pragma empty_line
  typedef basic_stringbuf<wchar_t> wstringbuf;
#pragma empty_line
#pragma empty_line
  typedef basic_istringstream<wchar_t> wistringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_ostringstream<wchar_t> wostringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_stringstream<wchar_t> wstringstream;
#pragma empty_line
#pragma empty_line
  typedef basic_filebuf<wchar_t> wfilebuf;
#pragma empty_line
#pragma empty_line
  typedef basic_ifstream<wchar_t> wifstream;
#pragma empty_line
#pragma empty_line
  typedef basic_ofstream<wchar_t> wofstream;
#pragma empty_line
#pragma empty_line
  typedef basic_fstream<wchar_t> wfstream;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 1 3
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
#pragma empty_line
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern "C++" {
#pragma empty_line
namespace std
{
#pragma line 61 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
    virtual const char* what() const throw();
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    virtual ~bad_exception() throw();
#pragma empty_line
#pragma empty_line
    virtual const char* what() const throw();
  };
#pragma empty_line
#pragma empty_line
  typedef void (*terminate_handler) ();
#pragma empty_line
#pragma empty_line
  typedef void (*unexpected_handler) ();
#pragma empty_line
#pragma empty_line
  terminate_handler set_terminate(terminate_handler) throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  void terminate() throw() __attribute__ ((__noreturn__));
#pragma empty_line
#pragma empty_line
  unexpected_handler set_unexpected(unexpected_handler) throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  void unexpected() __attribute__ ((__noreturn__));
#pragma line 118 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma line 143 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  void __verbose_terminate_handler();
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
}
#pragma empty_line
#pragma GCC visibility pop
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 1 3
#pragma line 61 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/exception_defines.h" 1 3
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_length_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_range_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_system_error(int) __attribute__((__noreturn__));
#pragma empty_line
  void
  __throw_future_error(int) __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
  void
  __throw_bad_function_call() __attribute__((__noreturn__));
#pragma empty_line
#pragma empty_line
}
#pragma line 62 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 1 3
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
#pragma empty_line
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
#pragma line 69 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
namespace __gnu_cxx
{
#pragma empty_line
#pragma empty_line
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  struct __true_type { };
  struct __false_type { };
#pragma empty_line
  template<bool>
    struct __truth_type
    { typedef __false_type __type; };
#pragma empty_line
  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };
#pragma empty_line
#pragma empty_line
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma line 199 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma empty_line
  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#pragma line 422 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
#pragma empty_line
}
#pragma line 63 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 1 3
#pragma line 32 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 3
#pragma empty_line
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<bool, typename>
    struct __enable_if
    { };
#pragma empty_line
  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };
#pragma empty_line
  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
#pragma empty_line
    public:
      typedef typename __if_type::__type __type;
    };
#pragma empty_line
  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };
#pragma empty_line
  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };
#pragma empty_line
#pragma empty_line
  template<>
    struct __add_unsigned<bool>;
#pragma empty_line
  template<>
    struct __add_unsigned<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
#pragma empty_line
    public:
      typedef typename __if_type::__type __type;
    };
#pragma empty_line
  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };
#pragma empty_line
  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };
#pragma empty_line
#pragma empty_line
  template<>
    struct __remove_unsigned<bool>;
#pragma empty_line
  template<>
    struct __remove_unsigned<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }
#pragma empty_line
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };
#pragma empty_line
  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };
#pragma empty_line
  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
#pragma empty_line
    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };
#pragma empty_line
  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
#pragma empty_line
    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };
#pragma empty_line
  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;
#pragma empty_line
    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };
#pragma empty_line
#pragma empty_line
}
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 1 3
#pragma line 32 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
#pragma empty_line
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma line 54 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {
#pragma empty_line
      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };
#pragma empty_line
  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;
#pragma empty_line
  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;
#pragma empty_line
  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;
#pragma empty_line
  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
#pragma line 99 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {
#pragma empty_line
      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
#pragma empty_line
#pragma empty_line
      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
#pragma empty_line
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;
#pragma empty_line
  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;
#pragma empty_line
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;
#pragma empty_line
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;
#pragma empty_line
  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };
#pragma empty_line
#pragma empty_line
}
#pragma line 65 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 1 3
#pragma line 60 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 1 3
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 3
#pragma empty_line
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 3
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }
#pragma empty_line
#pragma empty_line
}
#pragma line 109 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
namespace std
{
#pragma empty_line
#pragma line 120 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }
#pragma empty_line
#pragma empty_line
}
#pragma line 61 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 86 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;
#pragma empty_line
      _T1 first;
      _T2 second;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      pair()
      : first(), second() { }
#pragma empty_line
#pragma empty_line
      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
#pragma empty_line
#pragma empty_line
      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
#pragma line 196 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
    };
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }
#pragma empty_line
#pragma empty_line
  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
#pragma line 270 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 66 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 1 3
#pragma line 63 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
#pragma empty_line
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 90 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };
#pragma empty_line
#pragma empty_line
  struct output_iterator_tag { };
#pragma empty_line
#pragma empty_line
  struct forward_iterator_tag : public input_iterator_tag { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  struct bidirectional_iterator_tag : public forward_iterator_tag { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
#pragma line 117 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
#pragma empty_line
      typedef _Category iterator_category;
#pragma empty_line
      typedef _Tp value_type;
#pragma empty_line
      typedef _Distance difference_type;
#pragma empty_line
      typedef _Pointer pointer;
#pragma empty_line
      typedef _Reference reference;
    };
#pragma line 163 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };
#pragma empty_line
  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };
#pragma empty_line
#pragma empty_line
}
#pragma line 67 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 1 3
#pragma line 63 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
#pragma empty_line
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }
#pragma empty_line
  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      return __last - __first;
    }
#pragma line 111 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
#pragma empty_line
      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }
#pragma empty_line
  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
#pragma empty_line
#pragma empty_line
      while (__n--)
 ++__i;
    }
#pragma empty_line
  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }
#pragma empty_line
  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __i += __n;
    }
#pragma line 169 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
#pragma empty_line
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
#pragma line 200 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
#pragma empty_line
}
#pragma line 68 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 1 3
#pragma line 68 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
namespace std
{
#pragma empty_line
#pragma line 96 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;
#pragma empty_line
      typedef iterator_traits<_Iterator> __traits_type;
#pragma empty_line
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator() : current() { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      iterator_type
      base() const
      { return current; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      pointer
      operator->() const
      { return &(operator*()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
#pragma line 283 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }
#pragma empty_line
  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }
#pragma empty_line
  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }
#pragma empty_line
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR>
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
#pragma empty_line
    { return __y.base() - __x.base(); }
#pragma line 395 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
#pragma empty_line
    public:
#pragma empty_line
      typedef _Container container_type;
#pragma empty_line
#pragma empty_line
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
#pragma line 422 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
#pragma line 445 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
#pragma empty_line
      back_insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
#pragma empty_line
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
#pragma line 471 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
#pragma line 486 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
#pragma empty_line
    public:
#pragma empty_line
      typedef _Container container_type;
#pragma empty_line
#pragma empty_line
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
#pragma line 512 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
#pragma line 535 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
#pragma empty_line
      front_insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
#pragma empty_line
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
#pragma line 561 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
#pragma line 580 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;
#pragma empty_line
    public:
#pragma empty_line
      typedef _Container container_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
#pragma line 623 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
#pragma line 649 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }
#pragma empty_line
#pragma empty_line
      insert_iterator&
      operator++()
      { return *this; }
#pragma empty_line
#pragma empty_line
      insert_iterator&
      operator++(int)
      { return *this; }
    };
#pragma line 675 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma line 699 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;
#pragma empty_line
      typedef iterator_traits<_Iterator> __traits_type;
#pragma empty_line
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;
#pragma empty_line
      __normal_iterator() : _M_current(_Iterator()) { }
#pragma empty_line
      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
#pragma empty_line
#pragma empty_line
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }
#pragma empty_line
#pragma empty_line
      reference
      operator*() const
      { return *_M_current; }
#pragma empty_line
      pointer
      operator->() const
      { return _M_current; }
#pragma empty_line
      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }
#pragma empty_line
      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }
#pragma empty_line
#pragma empty_line
      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }
#pragma empty_line
      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }
#pragma empty_line
#pragma empty_line
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }
#pragma empty_line
      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }
#pragma empty_line
      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }
#pragma empty_line
      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }
#pragma empty_line
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }
#pragma empty_line
      const _Iterator&
      base() const
      { return _M_current; }
    };
#pragma line 797 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
#pragma empty_line
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _IteratorL, typename _IteratorR, typename _Container>
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
#pragma empty_line
    { return __lhs.base() - __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
#pragma empty_line
  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
#pragma empty_line
#pragma empty_line
}
#pragma line 69 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/debug/debug.h" 1 3
#pragma line 47 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_debug
{
  using namespace std::__debug;
}
#pragma line 71 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };
#pragma empty_line
  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
#pragma line 116 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
#pragma line 157 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
#pragma line 185 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__b < __a)
 return __b;
      return __a;
    }
#pragma line 208 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__a < __b)
 return __b;
      return __a;
    }
#pragma line 231 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
#pragma empty_line
      if (__comp(__b, __a))
 return __b;
      return __a;
    }
#pragma line 252 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
#pragma empty_line
      if (__comp(__a, __b))
 return __b;
      return __a;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };
#pragma empty_line
  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }
#pragma empty_line
#pragma empty_line
  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };
#pragma empty_line
  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
#pragma line 319 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
#pragma line 357 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };
#pragma empty_line
  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);
#pragma empty_line
      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    struct char_traits;
#pragma empty_line
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;
#pragma empty_line
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
#pragma empty_line
  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
#pragma line 442 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#pragma line 494 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
#pragma line 522 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
#pragma line 552 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };
#pragma empty_line
  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
#pragma empty_line
      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }
#pragma empty_line
  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
#pragma line 611 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#pragma line 669 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }
#pragma empty_line
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
#pragma line 713 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }
#pragma empty_line
  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }
#pragma empty_line
  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }
#pragma empty_line
  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
#pragma line 773 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }
#pragma empty_line
  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };
#pragma empty_line
  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };
#pragma empty_line
  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
#pragma empty_line
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
#pragma empty_line
#pragma empty_line
  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }
#pragma empty_line
      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };
#pragma empty_line
  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }
#pragma empty_line
      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };
#pragma empty_line
  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };
#pragma empty_line
  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;
#pragma empty_line
 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }
#pragma empty_line
  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };
#pragma empty_line
  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);
#pragma empty_line
      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
#pragma line 934 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      _DistanceType __len = std::distance(__first, __last);
#pragma empty_line
      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }
#pragma empty_line
  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }
#pragma empty_line
  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }
#pragma empty_line
  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1008 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
#pragma line 1040 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
#pragma line 1071 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
#pragma empty_line
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
#pragma line 1105 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
      ;
#pragma empty_line
      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
#pragma line 1145 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#pragma line 1182 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ;
#pragma empty_line
      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#pragma empty_line
#pragma empty_line
}
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 2 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 2 3
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma line 59 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
#pragma line 84 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static std::size_t
      length(const char_type* __s);
#pragma empty_line
      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
#pragma empty_line
      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
#pragma empty_line
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof()
      { return static_cast<int_type>(-1); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };
#pragma empty_line
  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }
#pragma empty_line
  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }
#pragma empty_line
  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
#pragma empty_line
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }
#pragma empty_line
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
#pragma empty_line
      std::fill_n(__s, __n, __a);
      return __s;
    }
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 228 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }
#pragma empty_line
      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }
#pragma empty_line
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }
#pragma empty_line
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof()
      { return static_cast<int_type>(-1); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;
#pragma empty_line
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
#pragma empty_line
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
#pragma empty_line
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }
#pragma empty_line
      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }
#pragma empty_line
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }
#pragma empty_line
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }
#pragma empty_line
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }
#pragma empty_line
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }
#pragma empty_line
      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }
#pragma empty_line
      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }
#pragma empty_line
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
#pragma empty_line
      static int_type
      eof()
      { return static_cast<int_type>((wchar_t)(0xFFFF)); }
#pragma empty_line
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 1 3
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 3
#pragma empty_line
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 1 3
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct lconv
{
 char* decimal_point;
 char* thousands_sep;
 char* grouping;
 char* int_curr_symbol;
 char* currency_symbol;
 char* mon_decimal_point;
 char* mon_thousands_sep;
 char* mon_grouping;
 char* positive_sign;
 char* negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
};
#pragma empty_line
#pragma empty_line
extern "C" {
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setlocale (int, const char*);
 struct lconv* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localeconv (void);
#pragma line 82 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 3
}
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 2 3
#pragma line 53 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  typedef int* __c_locale;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }
#pragma empty_line
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
#pragma empty_line
#pragma empty_line
    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    __builtin_va_end(__args);
#pragma empty_line
    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }
#pragma empty_line
#pragma empty_line
}
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 2 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 1 3
#pragma line 20 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 21 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 2 3
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalnum(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalpha(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscntrl(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isdigit(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isgraph(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) islower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isprint(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ispunct(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isspace(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isupper(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isxdigit(int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isblank (int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _isctype (int, int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toupper(int);
#pragma line 83 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _toupper(int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
   extern __attribute__ ((__dllimport__)) int __mb_cur_max;
#pragma line 112 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];
#pragma empty_line
#pragma empty_line
  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#pragma line 192 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);
#pragma line 246 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsym (int);
#pragma line 260 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsym (int);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 2 3
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 57 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3
  class locale;
#pragma empty_line
  template<typename _Facet>
    bool
    has_facet(const locale&) throw();
#pragma empty_line
  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    islower(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);
#pragma empty_line
  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);
#pragma empty_line
#pragma empty_line
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;
#pragma empty_line
  template<> class ctype<wchar_t>;
#pragma empty_line
  template<typename _CharT>
    class ctype_byname;
#pragma empty_line
#pragma empty_line
  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;
#pragma empty_line
  template<> class codecvt<wchar_t, char, mbstate_t>;
#pragma empty_line
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
#pragma empty_line
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;
#pragma empty_line
#pragma empty_line
  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;
#pragma empty_line
#pragma empty_line
  class money_base;
#pragma empty_line
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
#pragma empty_line
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
#pragma empty_line
#pragma empty_line
  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
#pragma empty_line
#pragma empty_line
}
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 1 3
#pragma line 30 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
#pragma line 162 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 1 3
#pragma line 70 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 1 3
#pragma line 80 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 3
extern "C" {
#pragma line 91 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 3
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 71 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 2 3
#pragma line 340 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
extern "C" {
#pragma empty_line
#pragma empty_line
typedef unsigned long __gthread_key_t;
#pragma empty_line
typedef struct {
  int done;
  long started;
} __gthread_once_t;
#pragma empty_line
typedef struct {
  long counter;
  void *sema;
} __gthread_mutex_t;
#pragma empty_line
typedef struct {
  long counter;
  long depth;
  unsigned long owner;
  void *sema;
} __gthread_recursive_mutex_t;
#pragma line 374 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
extern int _CRT_MT;
extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));
#pragma line 401 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
#pragma empty_line
  return _CRT_MT;
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));
extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));
extern int __gthr_win32_key_delete (__gthread_key_t);
extern void * __gthr_win32_getspecific (__gthread_key_t);
extern int __gthr_win32_setspecific (__gthread_key_t, const void *);
extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);
extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);
extern void
  __gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *);
extern int
  __gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *);
extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);
#pragma empty_line
static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthr_win32_once (__once, __func);
  else
    return -1;
}
#pragma empty_line
static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthr_win32_key_create (__key, __dtor);
}
#pragma empty_line
static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthr_win32_key_delete (__key);
}
#pragma empty_line
static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthr_win32_getspecific (__key);
}
#pragma empty_line
static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthr_win32_setspecific (__key, __ptr);
}
#pragma empty_line
static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_init_function (__mutex);
}
#pragma empty_line
static inline void
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_destroy (__mutex);
}
#pragma empty_line
static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_lock (__mutex);
  else
    return 0;
}
#pragma empty_line
static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_trylock (__mutex);
  else
    return 0;
}
#pragma empty_line
static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_unlock (__mutex);
  else
    return 0;
}
#pragma empty_line
static inline void
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
   __gthr_win32_recursive_mutex_init_function (__mutex);
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_lock (__mutex);
  else
    return 0;
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_trylock (__mutex);
  else
    return 0;
}
#pragma empty_line
static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_unlock (__mutex);
  else
    return 0;
}
#pragma line 767 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
}
#pragma line 163 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma GCC visibility pop
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/atomic_word.h" 1 3
#pragma line 32 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 2 3
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma line 54 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 3
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word*, int) throw ();
#pragma empty_line
  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word*, int) throw ();
#pragma empty_line
#pragma empty_line
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }
#pragma empty_line
  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }
#pragma empty_line
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#pragma empty_line
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
#pragma empty_line
#pragma empty_line
#pragma empty_line
  }
#pragma empty_line
  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
#pragma empty_line
    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);
#pragma empty_line
#pragma empty_line
#pragma empty_line
  }
#pragma empty_line
#pragma empty_line
}
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 2 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 1 3
#pragma line 48 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
extern "C++" {
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    virtual ~bad_alloc() throw();
#pragma empty_line
#pragma empty_line
    virtual const char* what() const throw();
  };
#pragma empty_line
  struct nothrow_t { };
#pragma empty_line
  extern const nothrow_t nothrow;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  typedef void (*new_handler)();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  new_handler set_new_handler(new_handler) throw();
}
#pragma line 93 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();
#pragma empty_line
#pragma empty_line
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
#pragma empty_line
#pragma empty_line
inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }
#pragma empty_line
}
#pragma empty_line
#pragma GCC visibility pop
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace __gnu_cxx
{
#pragma empty_line
#pragma empty_line
  using std::size_t;
  using std::ptrdiff_t;
#pragma line 53 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };
#pragma empty_line
      new_allocator() throw() { }
#pragma empty_line
      new_allocator(const new_allocator&) throw() { }
#pragma empty_line
      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }
#pragma empty_line
      ~new_allocator() throw() { }
#pragma empty_line
      pointer
      address(reference __x) const { return std::__addressof(__x); }
#pragma empty_line
      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
#pragma empty_line
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }
#pragma empty_line
#pragma empty_line
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
#pragma empty_line
      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
#pragma line 117 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
#pragma empty_line
#pragma empty_line
}
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 2 3
#pragma line 49 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 65 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;
#pragma empty_line
#pragma empty_line
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
#pragma line 91 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
#pragma empty_line
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
#pragma empty_line
      allocator() throw() { }
#pragma empty_line
      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }
#pragma empty_line
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
#pragma empty_line
      ~allocator() throw() { }
#pragma empty_line
#pragma empty_line
    };
#pragma empty_line
  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }
#pragma empty_line
  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
#pragma empty_line
  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };
#pragma empty_line
  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {
#pragma empty_line
 if (__one != __two)
   swap(__one, __two);
      }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };
#pragma empty_line
  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
#pragma line 236 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
#pragma empty_line
}
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 1 3
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 3
#pragma empty_line
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 3
#pragma empty_line
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 3
#pragma empty_line
#pragma GCC visibility push(default)
#pragma empty_line
#pragma empty_line
namespace __cxxabiv1
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
#pragma empty_line
#pragma empty_line
    virtual void __pure_dummy() = 0;
  };
}
#pragma empty_line
#pragma empty_line
#pragma GCC visibility pop
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
#pragma empty_line
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);
#pragma empty_line
#pragma empty_line
  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 47 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 1 3
#pragma line 60 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
namespace std
{
#pragma empty_line
#pragma line 101 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
#pragma empty_line
      typedef _Arg argument_type;
#pragma empty_line
#pragma empty_line
      typedef _Result result_type;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
#pragma empty_line
      typedef _Arg1 first_argument_type;
#pragma empty_line
#pragma empty_line
      typedef _Arg2 second_argument_type;
#pragma empty_line
#pragma empty_line
      typedef _Result result_type;
    };
#pragma line 140 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#pragma line 204 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
#pragma line 268 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };
#pragma empty_line
  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };
#pragma empty_line
  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
#pragma line 351 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
#pragma empty_line
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }
#pragma empty_line
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }
#pragma empty_line
#pragma empty_line
  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
#pragma empty_line
    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }
#pragma empty_line
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
#pragma line 422 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
#pragma empty_line
    public:
      pointer_to_unary_function() { }
#pragma empty_line
      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }
#pragma empty_line
      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }
#pragma empty_line
#pragma empty_line
  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
#pragma empty_line
    public:
      pointer_to_binary_function() { }
#pragma empty_line
      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }
#pragma empty_line
      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };
#pragma empty_line
#pragma empty_line
  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
#pragma empty_line
#pragma empty_line
  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }
#pragma empty_line
      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };
#pragma empty_line
  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }
#pragma empty_line
      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
#pragma line 508 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
    };
#pragma empty_line
  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }
#pragma empty_line
      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
#pragma line 541 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)();
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)() const;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)();
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)() const;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }
#pragma empty_line
      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
#pragma empty_line
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 1 3
#pragma line 60 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 3
namespace std
{
#pragma empty_line
#pragma line 99 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
#pragma empty_line
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }
#pragma empty_line
      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;
#pragma empty_line
#pragma empty_line
  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
#pragma empty_line
#pragma empty_line
  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
#pragma empty_line
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }
#pragma empty_line
      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;
#pragma empty_line
#pragma empty_line
  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 732 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 2 3
#pragma line 51 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 1 3
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 3
#pragma empty_line
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 3
#pragma line 54 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 1 3
#pragma line 33 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 3
#pragma empty_line
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 3
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 106 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
#pragma empty_line
#pragma empty_line
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
#pragma empty_line
    private:
#pragma line 143 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };
#pragma empty_line
      struct _Rep : _Rep_base
      {
#pragma empty_line
 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
#pragma line 168 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;
#pragma empty_line
#pragma empty_line
#pragma empty_line
        static size_type _S_empty_rep_storage[];
#pragma empty_line
        static _Rep&
        _S_empty_rep()
        {
#pragma empty_line
#pragma empty_line
#pragma empty_line
   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }
#pragma empty_line
        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }
#pragma empty_line
        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }
#pragma empty_line
        void
 _M_set_leaked()
        { this->_M_refcount = -1; }
#pragma empty_line
        void
 _M_set_sharable()
        { this->_M_refcount = 0; }
#pragma empty_line
 void
 _M_set_length_and_sharable(size_type __n)
 {
#pragma empty_line
   if (__builtin_expect(this != &_S_empty_rep(), false))
#pragma empty_line
     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);
#pragma empty_line
#pragma empty_line
     }
 }
#pragma empty_line
 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }
#pragma empty_line
 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }
#pragma empty_line
#pragma empty_line
 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);
#pragma empty_line
 void
 _M_dispose(const _Alloc& __a)
 {
#pragma empty_line
   if (__builtin_expect(this != &_S_empty_rep(), false))
#pragma empty_line
     {
#pragma empty_line
       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }
#pragma empty_line
 void
 _M_destroy(const _Alloc&) throw();
#pragma empty_line
 _CharT*
 _M_refcopy() throw()
 {
#pragma empty_line
   if (__builtin_expect(this != &_S_empty_rep(), false))
#pragma empty_line
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }
#pragma empty_line
 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };
#pragma empty_line
#pragma empty_line
      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }
#pragma empty_line
 _CharT* _M_p;
      };
#pragma empty_line
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const size_type npos = static_cast<size_type>(-1);
#pragma empty_line
    private:
#pragma empty_line
      mutable _Alloc_hider _M_dataplus;
#pragma empty_line
      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }
#pragma empty_line
      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }
#pragma empty_line
      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }
#pragma empty_line
      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }
#pragma empty_line
      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }
#pragma empty_line
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }
#pragma empty_line
      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }
#pragma empty_line
#pragma empty_line
      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }
#pragma empty_line
#pragma empty_line
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }
#pragma empty_line
      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }
#pragma empty_line
      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
#pragma empty_line
      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
#pragma empty_line
      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);
#pragma empty_line
 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }
#pragma empty_line
      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
#pragma empty_line
      void
      _M_leak_hard();
#pragma empty_line
      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }
#pragma empty_line
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string()
#pragma empty_line
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      explicit
      basic_string(const _Alloc& __a);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string(const basic_string& __str);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
#pragma line 478 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
#pragma line 526 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
#pragma line 559 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
#pragma line 599 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const_iterator
      begin() const
      { return const_iterator(_M_data()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
#pragma line 705 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      size_type
      size() const
      { return _M_rep()->_M_length; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      size_type
      length() const
      { return _M_rep()->_M_length; }
#pragma empty_line
#pragma empty_line
      size_type
      max_size() const
      { return _Rep::_S_max_size; }
#pragma line 734 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
#pragma line 747 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
#pragma line 767 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
#pragma line 788 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      clear()
      { _M_mutate(0, this->size(), 0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      bool
      empty() const
      { return this->size() == 0; }
#pragma line 817 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
#pragma line 834 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {
#pragma empty_line
 ;
#pragma empty_line
 ;
 _M_leak();
 return _M_data()[__pos];
      }
#pragma line 855 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
#pragma line 908 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
#pragma line 964 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
#pragma line 979 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      append(const _CharT* __s, size_type __n);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
#pragma line 1011 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
#pragma line 1033 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      assign(const basic_string& __str);
#pragma line 1089 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
#pragma line 1105 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
#pragma line 1117 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
#pragma line 1133 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
#pragma line 1145 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
#pragma line 1173 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
#pragma line 1188 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
#pragma line 1219 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
#pragma line 1241 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
#pragma line 1264 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
#pragma line 1282 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
#pragma line 1305 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
#pragma line 1322 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#pragma line 1346 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
#pragma line 1362 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
#pragma empty_line
                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#pragma line 1382 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
#pragma line 1401 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
#pragma line 1423 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
#pragma line 1447 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
#pragma line 1466 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
#pragma line 1489 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
#pragma line 1507 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
#pragma line 1525 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
#pragma empty_line
                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
#pragma line 1546 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
#pragma line 1567 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
#pragma empty_line
                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
#pragma line 1589 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
#pragma empty_line
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
#pragma empty_line
                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
#pragma empty_line
                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
#pragma empty_line
                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#pragma empty_line
      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
#pragma empty_line
                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#pragma line 1664 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
#pragma empty_line
      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);
#pragma empty_line
      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);
#pragma empty_line
      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }
#pragma empty_line
      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }
#pragma empty_line
      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }
#pragma empty_line
#pragma empty_line
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);
#pragma empty_line
      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
#pragma empty_line
    public:
#pragma line 1745 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
#pragma line 1755 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
#pragma line 1765 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const _CharT*
      data() const
      { return _M_data(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      allocator_type
      get_allocator() const
      { return _M_dataplus; }
#pragma line 1797 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma line 1810 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
#pragma line 1824 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
#pragma line 1841 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
#pragma line 1854 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
#pragma line 1869 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma line 1882 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
#pragma line 1899 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
#pragma line 1912 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
#pragma line 1927 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma line 1940 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
#pragma line 1959 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
#pragma line 1973 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
#pragma line 1988 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
#pragma line 2001 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
#pragma line 2020 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
#pragma line 2034 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
#pragma line 2049 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
#pragma line 2063 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
#pragma line 2080 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
#pragma line 2093 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
#pragma line 2109 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
#pragma line 2122 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
#pragma line 2139 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
#pragma line 2154 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
#pragma line 2172 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);
#pragma empty_line
 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
#pragma line 2202 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
#pragma line 2226 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
#pragma line 2244 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
#pragma line 2267 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
#pragma line 2292 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
#pragma line 2304 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
#pragma line 2425 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }
#pragma empty_line
  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
#pragma line 2471 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
#pragma line 2508 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
#pragma line 2545 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
#pragma line 2582 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
#pragma line 2619 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
#pragma line 2656 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
#pragma line 2673 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
#pragma empty_line
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
#pragma line 2691 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
#pragma empty_line
#pragma empty_line
      return __ostream_insert(__os, __str.data(), __str.size());
    }
#pragma line 2714 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
#pragma line 2732 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }
#pragma empty_line
  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 55 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 1 3
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
#pragma empty_line
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {
#pragma empty_line
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
#pragma empty_line
#pragma empty_line
 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {
#pragma empty_line
      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {
#pragma empty_line
 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();
#pragma empty_line
#pragma empty_line
 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));
#pragma empty_line
 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));
#pragma empty_line
 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
#pragma empty_line
      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();
#pragma empty_line
#pragma empty_line
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);
#pragma empty_line
      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
#pragma line 242 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {
#pragma empty_line
   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {
#pragma empty_line
   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
#pragma empty_line
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
#pragma empty_line
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }
#pragma empty_line
   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
#pragma empty_line
                           ;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }
#pragma empty_line
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {
#pragma empty_line
    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {
#pragma empty_line
    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {
#pragma empty_line
      if (_M_rep() == &_S_empty_rep())
 return;
#pragma empty_line
      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;
#pragma empty_line
      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {
#pragma empty_line
   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
#pragma empty_line
   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);
#pragma empty_line
   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {
#pragma empty_line
   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
#pragma empty_line
   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }
#pragma empty_line
      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
#pragma empty_line
#pragma empty_line
      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
#pragma line 579 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
#pragma empty_line
      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);
#pragma empty_line
   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __p->_M_set_sharable();
      return __p;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
#pragma empty_line
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
#pragma empty_line
      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);
#pragma empty_line
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);
#pragma empty_line
      return __n;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();
#pragma empty_line
      if (__n == 0)
 return __pos <= __size ? __pos : npos;
#pragma empty_line
      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;
#pragma empty_line
      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
#pragma empty_line
       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();
#pragma empty_line
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {
#pragma empty_line
#pragma empty_line
#pragma empty_line
       __in._M_setstate(__ios_base::badbit);
     }
 }
#pragma empty_line
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
#pragma empty_line
      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();
#pragma empty_line
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {
#pragma empty_line
#pragma empty_line
#pragma empty_line
       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
#pragma empty_line
#pragma empty_line
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 56 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 2 3
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale
  {
  public:
#pragma empty_line
#pragma empty_line
    typedef int category;
#pragma empty_line
#pragma empty_line
    class facet;
    class id;
    class _Impl;
#pragma empty_line
    friend class facet;
    friend class _Impl;
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Cache>
      friend struct __use_cache;
#pragma line 100 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
#pragma line 119 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale() throw();
#pragma line 128 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
#pragma line 138 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
#pragma line 153 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
#pragma line 166 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
#pragma line 178 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);
#pragma empty_line
#pragma empty_line
    ~locale() throw();
#pragma line 192 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
#pragma line 207 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    string
    name() const;
#pragma line 226 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
#pragma line 254 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
#pragma line 270 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    static locale
    global(const locale&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const locale&
    classic();
#pragma empty_line
  private:
#pragma empty_line
    _Impl* _M_impl;
#pragma empty_line
#pragma empty_line
    static _Impl* _S_classic;
#pragma empty_line
#pragma empty_line
    static _Impl* _S_global;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const char* const* const _S_categories;
#pragma line 305 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };
#pragma empty_line
#pragma empty_line
    static __gthread_once_t _S_once;
#pragma empty_line
#pragma empty_line
    explicit
    locale(_Impl*) throw();
#pragma empty_line
    static void
    _S_initialize();
#pragma empty_line
    static void
    _S_initialize_once() throw();
#pragma empty_line
    static category
    _S_normalize_category(category);
#pragma empty_line
    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
#pragma line 339 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;
#pragma empty_line
    mutable _Atomic_word _M_refcount;
#pragma empty_line
#pragma empty_line
    static __c_locale _S_c_locale;
#pragma empty_line
#pragma empty_line
    static const char _S_c_name[2];
#pragma empty_line
#pragma empty_line
    static __gthread_once_t _S_once;
#pragma empty_line
#pragma empty_line
    static void
    _S_initialize_once();
#pragma empty_line
  protected:
#pragma line 370 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }
#pragma empty_line
#pragma empty_line
    virtual
    ~facet();
#pragma empty_line
    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);
#pragma empty_line
    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();
#pragma empty_line
    static void
    _S_destroy_c_locale(__c_locale& __cloc);
#pragma empty_line
    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static __c_locale
    _S_get_c_locale();
#pragma empty_line
    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
#pragma empty_line
  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
    void
    _M_remove_reference() const throw()
    {
#pragma empty_line
      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }
#pragma empty_line
    facet(const facet&);
#pragma empty_line
    facet&
    operator=(const facet&);
  };
#pragma line 437 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    mutable size_t _M_index;
#pragma empty_line
#pragma empty_line
    static _Atomic_word _S_refcount;
#pragma empty_line
    void
    operator=(const id&);
#pragma empty_line
    id(const id&);
#pragma empty_line
  public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
    id() { }
#pragma empty_line
    size_t
    _M_id() const throw();
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  class locale::_Impl
  {
  public:
#pragma empty_line
    friend class locale;
    friend class locale::facet;
#pragma empty_line
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
#pragma empty_line
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
#pragma empty_line
    template<typename _Cache>
      friend struct __use_cache;
#pragma empty_line
  private:
#pragma empty_line
    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];
#pragma empty_line
    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
    void
    _M_remove_reference() throw()
    {
#pragma empty_line
      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }
#pragma empty_line
    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();
#pragma empty_line
   ~_Impl() throw();
#pragma empty_line
    _Impl(const _Impl&);
#pragma empty_line
    void
    operator=(const _Impl&);
#pragma empty_line
    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
#pragma empty_line
 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }
#pragma empty_line
    void
    _M_replace_categories(const _Impl*, category);
#pragma empty_line
    void
    _M_replace_category(const _Impl*, const locale::id* const*);
#pragma empty_line
    void
    _M_replace_facet(const _Impl*, const locale::id*);
#pragma empty_line
    void
    _M_install_facet(const locale::id*, const facet*);
#pragma empty_line
    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }
#pragma empty_line
    void
    _M_install_cache(const facet*, size_t);
  };
#pragma line 583 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
#pragma line 600 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
#pragma line 617 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
#pragma empty_line
    protected:
#pragma empty_line
#pragma empty_line
      __c_locale _M_c_locale_collate;
#pragma empty_line
    public:
#pragma empty_line
      static locale::id id;
#pragma line 644 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
#pragma line 658 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
#pragma line 675 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
#pragma line 694 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
#pragma line 708 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }
#pragma empty_line
#pragma empty_line
      int
      _M_compare(const _CharT*, const _CharT*) const throw();
#pragma empty_line
      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();
#pragma empty_line
  protected:
#pragma empty_line
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
#pragma line 737 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
#pragma line 753 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
#pragma line 766 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };
#pragma empty_line
  template<typename _CharT>
    locale::id collate<_CharT>::id;
#pragma empty_line
#pragma empty_line
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();
#pragma empty_line
  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();
#pragma empty_line
#pragma empty_line
  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();
#pragma empty_line
  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
#pragma empty_line
      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~collate_byname() { }
    };
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 3
#pragma empty_line
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
#pragma empty_line
      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }
#pragma empty_line
  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
#pragma empty_line
#pragma empty_line
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size
#pragma empty_line
       && dynamic_cast<const _Facet*>(__facets[__i]));
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();
#pragma empty_line
      return dynamic_cast<const _Facet&>(*__facets[__i]);
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }
#pragma empty_line
  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {
#pragma empty_line
#pragma empty_line
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);
#pragma empty_line
      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;
#pragma empty_line
   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;
#pragma empty_line
   __p++;
   __q++;
 }
    }
#pragma empty_line
  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;
#pragma empty_line
#pragma empty_line
      const string_type __str(__lo, __hi);
#pragma empty_line
      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();
#pragma empty_line
      size_t __len = (__hi - __lo) * 2;
#pragma empty_line
      _CharT* __c = new _CharT[__len];
#pragma empty_line
      try
 {
#pragma empty_line
#pragma empty_line
#pragma empty_line
   for (;;)
     {
#pragma empty_line
       size_t __res = _M_transform(__c, __p, __len);
#pragma empty_line
#pragma empty_line
       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }
#pragma empty_line
       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;
#pragma empty_line
       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }
#pragma empty_line
      delete [] __c;
#pragma empty_line
      return __ret;
    }
#pragma empty_line
  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class collate<char>;
  extern template class collate_byname<char>;
#pragma empty_line
  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<collate<char> >(const locale&);
#pragma empty_line
#pragma empty_line
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;
#pragma empty_line
  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 824 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 2 3
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }
#pragma empty_line
  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }
#pragma empty_line
#pragma empty_line
  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }
#pragma empty_line
  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }
#pragma empty_line
#pragma empty_line
  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };
#pragma empty_line
  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }
#pragma empty_line
  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }
#pragma empty_line
  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }
#pragma empty_line
  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }
#pragma empty_line
  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }
#pragma empty_line
#pragma empty_line
  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
#pragma line 201 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
  class ios_base
  {
  public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    class failure : public exception
    {
    public:
#pragma empty_line
#pragma empty_line
      explicit
      failure(const string& __str) throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~failure() throw();
#pragma empty_line
      virtual const char*
      what() const throw();
#pragma empty_line
    private:
      string _M_msg;
    };
#pragma line 257 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;
#pragma empty_line
#pragma empty_line
    static const fmtflags boolalpha = _S_boolalpha;
#pragma empty_line
#pragma empty_line
    static const fmtflags dec = _S_dec;
#pragma empty_line
#pragma empty_line
    static const fmtflags fixed = _S_fixed;
#pragma empty_line
#pragma empty_line
    static const fmtflags hex = _S_hex;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags internal = _S_internal;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags left = _S_left;
#pragma empty_line
#pragma empty_line
    static const fmtflags oct = _S_oct;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags right = _S_right;
#pragma empty_line
#pragma empty_line
    static const fmtflags scientific = _S_scientific;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags showbase = _S_showbase;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags showpoint = _S_showpoint;
#pragma empty_line
#pragma empty_line
    static const fmtflags showpos = _S_showpos;
#pragma empty_line
#pragma empty_line
    static const fmtflags skipws = _S_skipws;
#pragma empty_line
#pragma empty_line
    static const fmtflags unitbuf = _S_unitbuf;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const fmtflags uppercase = _S_uppercase;
#pragma empty_line
#pragma empty_line
    static const fmtflags adjustfield = _S_adjustfield;
#pragma empty_line
#pragma empty_line
    static const fmtflags basefield = _S_basefield;
#pragma empty_line
#pragma empty_line
    static const fmtflags floatfield = _S_floatfield;
#pragma line 332 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const iostate badbit = _S_badbit;
#pragma empty_line
#pragma empty_line
    static const iostate eofbit = _S_eofbit;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const iostate failbit = _S_failbit;
#pragma empty_line
#pragma empty_line
    static const iostate goodbit = _S_goodbit;
#pragma line 363 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;
#pragma empty_line
#pragma empty_line
    static const openmode app = _S_app;
#pragma empty_line
#pragma empty_line
    static const openmode ate = _S_ate;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const openmode binary = _S_bin;
#pragma empty_line
#pragma empty_line
    static const openmode in = _S_in;
#pragma empty_line
#pragma empty_line
    static const openmode out = _S_out;
#pragma empty_line
#pragma empty_line
    static const openmode trunc = _S_trunc;
#pragma line 395 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;
#pragma empty_line
#pragma empty_line
    static const seekdir beg = _S_beg;
#pragma empty_line
#pragma empty_line
    static const seekdir cur = _S_cur;
#pragma empty_line
#pragma empty_line
    static const seekdir end = _S_end;
#pragma empty_line
#pragma empty_line
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;
#pragma empty_line
    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
#pragma line 421 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
#pragma line 438 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
#pragma line 450 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);
#pragma empty_line
  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    struct _Callback_list
    {
#pragma empty_line
      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;
#pragma empty_line
      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }
#pragma empty_line
      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
#pragma empty_line
#pragma empty_line
      int
      _M_remove_reference()
      {
#pragma empty_line
        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };
#pragma empty_line
     _Callback_list* _M_callbacks;
#pragma empty_line
    void
    _M_call_callbacks(event __ev) throw();
#pragma empty_line
    void
    _M_dispose_callbacks(void) throw();
#pragma empty_line
#pragma empty_line
    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };
#pragma empty_line
#pragma empty_line
    _Words _M_word_zero;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];
#pragma empty_line
#pragma empty_line
    int _M_word_size;
    _Words* _M_word;
#pragma empty_line
    _Words&
    _M_grow_words(int __index, bool __iword);
#pragma empty_line
#pragma empty_line
    locale _M_ios_locale;
#pragma empty_line
    void
    _M_init() throw();
#pragma empty_line
  public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();
#pragma empty_line
    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    fmtflags
    flags() const
    { return _M_flags; }
#pragma line 563 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
#pragma line 579 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
#pragma line 596 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
#pragma line 622 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    streamsize
    width() const
    { return _M_width; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
#pragma line 673 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
#pragma line 685 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
#pragma line 696 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
#pragma line 707 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
#pragma line 726 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    static int
    xalloc() throw();
#pragma line 742 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
#pragma line 763 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
#pragma line 780 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    virtual ~ios_base();
#pragma empty_line
  protected:
    ios_base() throw ();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  private:
    ios_base(const ios_base&);
#pragma empty_line
    ios_base&
    operator=(const ios_base&);
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
#pragma empty_line
#pragma empty_line
}
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
#pragma empty_line
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
#pragma line 46 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
#pragma line 116 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
#pragma empty_line
#pragma empty_line
      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;
#pragma empty_line
      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);
#pragma empty_line
      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);
#pragma empty_line
      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
#pragma empty_line
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
#pragma empty_line
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);
#pragma empty_line
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);
#pragma empty_line
    protected:
#pragma line 182 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;
#pragma empty_line
#pragma empty_line
      locale _M_buf_locale;
#pragma empty_line
  public:
#pragma empty_line
      virtual
      ~basic_streambuf()
      { }
#pragma line 206 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
#pragma line 223 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
#pragma line 236 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
#pragma empty_line
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
#pragma empty_line
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }
#pragma empty_line
      int
      pubsync() { return this->sync(); }
#pragma line 263 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
#pragma line 277 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
#pragma line 295 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
#pragma line 317 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
#pragma line 336 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
#pragma line 351 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
#pragma line 376 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
#pragma line 403 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
#pragma line 429 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }
#pragma empty_line
    protected:
#pragma line 443 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
#pragma line 461 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }
#pragma empty_line
      char_type*
      gptr() const { return _M_in_cur; }
#pragma empty_line
      char_type*
      egptr() const { return _M_in_end; }
#pragma line 477 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
#pragma line 488 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
#pragma line 508 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }
#pragma empty_line
      char_type*
      pptr() const { return _M_out_cur; }
#pragma empty_line
      char_type*
      epptr() const { return _M_out_end; }
#pragma line 524 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
#pragma line 534 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
#pragma line 555 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
#pragma line 570 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
#pragma line 581 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#pragma line 593 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#pragma line 606 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int
      sync() { return 0; }
#pragma line 628 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
#pragma line 644 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
#pragma line 666 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
#pragma line 679 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
#pragma line 703 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
#pragma line 721 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
#pragma line 747 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    public:
#pragma line 762 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }
#pragma empty_line
      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }
#pragma empty_line
    private:
#pragma empty_line
#pragma empty_line
      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }
#pragma empty_line
      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
#pragma empty_line
#pragma empty_line
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);
#pragma empty_line
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }
#pragma empty_line
   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }
#pragma empty_line
   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);
#pragma empty_line
#pragma empty_line
  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 809 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 2 3
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 1 3
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
#pragma empty_line
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3
#pragma line 82 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
#pragma empty_line
  using ::iswalnum;
  using ::iswalpha;
#pragma empty_line
  using ::iswblank;
#pragma empty_line
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_base.h" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_base.h" 3
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  struct ctype_base
  {
#pragma empty_line
    typedef const int* __to_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);
  };
#pragma empty_line
#pragma empty_line
}
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 1 3
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3
#pragma empty_line
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 51 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
#pragma empty_line
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
#pragma empty_line
      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
#pragma empty_line
    private:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;
#pragma empty_line
    public:
#pragma empty_line
      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
#pragma empty_line
#pragma empty_line
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }
#pragma empty_line
#pragma empty_line
      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      char_type
      operator*() const
      {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 return traits_type::to_char_type(_M_get());
      }
#pragma empty_line
#pragma empty_line
      istreambuf_iterator&
      operator++()
      {
#pragma empty_line
#pragma empty_line
                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }
#pragma empty_line
#pragma empty_line
      istreambuf_iterator
      operator++(int)
      {
#pragma empty_line
#pragma empty_line
                        ;
#pragma empty_line
 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }
#pragma empty_line
    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }
#pragma empty_line
      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
#pragma empty_line
#pragma empty_line
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
#pragma empty_line
    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;
#pragma empty_line
    public:
#pragma empty_line
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }
#pragma empty_line
#pragma empty_line
      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }
#pragma empty_line
#pragma empty_line
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }
#pragma empty_line
#pragma empty_line
      ostreambuf_iterator&
      operator*()
      { return *this; }
#pragma empty_line
#pragma empty_line
      ostreambuf_iterator&
      operator++(int)
      { return *this; }
#pragma empty_line
#pragma empty_line
      ostreambuf_iterator&
      operator++()
      { return *this; }
#pragma empty_line
#pragma empty_line
      bool
      failed() const throw()
      { return _M_failed; }
#pragma empty_line
      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
#pragma empty_line
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
#pragma empty_line
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }
#pragma empty_line
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
#pragma empty_line
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }
#pragma empty_line
   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 51 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 66 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();
#pragma empty_line
#pragma empty_line
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();
#pragma empty_line
  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();
#pragma empty_line
  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
#pragma line 144 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
#pragma line 162 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
#pragma line 179 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
#pragma line 195 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
#pragma line 211 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
#pragma line 225 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#pragma line 240 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#pragma line 254 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#pragma line 269 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#pragma line 286 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
#pragma line 305 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
#pragma line 324 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
#pragma line 346 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }
#pragma empty_line
    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }
#pragma empty_line
      virtual
      ~__ctype_abstract_base() { }
#pragma line 371 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
#pragma line 390 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
#pragma line 409 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
#pragma line 428 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
#pragma line 446 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
#pragma line 463 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
#pragma line 479 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
#pragma line 496 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
#pragma line 515 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
#pragma line 536 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
#pragma line 558 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
#pragma line 582 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
#pragma line 605 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;
#pragma empty_line
#pragma empty_line
      static locale::id id;
#pragma empty_line
      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }
#pragma empty_line
   protected:
      virtual
      ~ctype();
#pragma empty_line
      virtual bool
      do_is(mask __m, char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#pragma empty_line
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_toupper(char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_tolower(char_type __c) const;
#pragma empty_line
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma empty_line
      virtual char_type
      do_widen(char __c) const;
#pragma empty_line
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#pragma empty_line
      virtual char
      do_narrow(char_type, char __dfault) const;
#pragma empty_line
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };
#pragma empty_line
  template<typename _CharT>
    locale::id ctype<_CharT>::id;
#pragma line 674 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
#pragma empty_line
#pragma empty_line
      typedef char char_type;
#pragma empty_line
    protected:
#pragma empty_line
      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;
#pragma empty_line
#pragma empty_line
    public:
#pragma empty_line
      static locale::id id;
#pragma empty_line
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
#pragma line 711 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
#pragma line 724 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
#pragma line 737 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
#pragma line 752 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
#pragma line 766 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
#pragma line 780 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
#pragma line 795 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#pragma line 812 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#pragma line 828 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#pragma line 845 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#pragma line 865 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
#pragma line 892 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
#pragma line 923 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
#pragma line 956 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const mask*
      table() const throw()
      { return _M_table; }
#pragma empty_line
#pragma empty_line
      static const mask*
      classic_table() throw();
    protected:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~ctype();
#pragma line 1005 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#pragma line 1022 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma line 1038 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#pragma line 1055 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma line 1075 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
#pragma line 1098 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#pragma line 1124 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
#pragma line 1150 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#pragma empty_line
    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
#pragma line 1175 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
#pragma empty_line
#pragma empty_line
      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;
#pragma empty_line
    protected:
      __c_locale _M_c_locale_ctype;
#pragma empty_line
#pragma empty_line
      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];
#pragma empty_line
#pragma empty_line
      mask _M_bit[16];
      __wmask_type _M_wmask[16];
#pragma empty_line
    public:
#pragma empty_line
#pragma empty_line
      static locale::id id;
#pragma line 1208 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
#pragma line 1219 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);
#pragma empty_line
    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();
#pragma empty_line
#pragma empty_line
      virtual
      ~ctype();
#pragma line 1243 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
#pragma line 1262 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#pragma line 1280 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#pragma line 1298 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#pragma line 1315 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#pragma line 1332 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#pragma line 1348 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#pragma line 1365 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#pragma line 1385 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
#pragma line 1407 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#pragma line 1430 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
#pragma line 1456 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
#pragma empty_line
#pragma empty_line
      void
      _M_initialize_ctype() throw();
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;
#pragma empty_line
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~ctype_byname() { };
    };
#pragma empty_line
#pragma empty_line
  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~ctype_byname();
    };
#pragma empty_line
#pragma empty_line
  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
#pragma empty_line
    protected:
      virtual
      ~ctype_byname();
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_inline.h" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_inline.h" 3
namespace std
{
#pragma empty_line
#pragma empty_line
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }
#pragma empty_line
#pragma empty_line
  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }
#pragma empty_line
  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }
#pragma empty_line
  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }
#pragma empty_line
#pragma empty_line
}
#pragma line 1513 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  class __num_base
  {
  public:
#pragma empty_line
#pragma empty_line
    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const char* _S_atoms_out;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const char* _S_atoms_in;
#pragma empty_line
    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };
#pragma empty_line
  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      _CharT _M_atoms_out[__num_base::_S_oend];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      _CharT _M_atoms_in[__num_base::_S_iend];
#pragma empty_line
      bool _M_allocated;
#pragma empty_line
      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }
#pragma empty_line
      ~__numpunct_cache();
#pragma empty_line
      void
      _M_cache(const locale& __loc);
#pragma empty_line
    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);
#pragma empty_line
      explicit
      __numpunct_cache(const __numpunct_cache&);
    };
#pragma empty_line
  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
#pragma line 1641 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
      typedef __numpunct_cache<_CharT> __cache_type;
#pragma empty_line
    protected:
      __cache_type* _M_data;
#pragma empty_line
    public:
#pragma empty_line
      static locale::id id;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
#pragma line 1679 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
#pragma line 1693 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
#pragma line 1707 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#pragma line 1720 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#pragma line 1751 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
#pragma line 1764 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
#pragma line 1777 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }
#pragma empty_line
    protected:
#pragma empty_line
      virtual
      ~numpunct();
#pragma line 1794 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#pragma line 1806 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#pragma line 1819 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#pragma line 1832 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
#pragma line 1845 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }
#pragma empty_line
#pragma empty_line
      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };
#pragma empty_line
  template<typename _CharT>
    locale::id numpunct<_CharT>::id;
#pragma empty_line
  template<>
    numpunct<char>::~numpunct();
#pragma empty_line
  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
#pragma empty_line
#pragma empty_line
  template<>
    numpunct<wchar_t>::~numpunct();
#pragma empty_line
  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
#pragma empty_line
      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
#pragma empty_line
    protected:
      virtual
      ~numpunct_byname() { }
    };
#pragma empty_line
#pragma empty_line
#pragma line 1915 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef _InIter iter_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static locale::id id;
#pragma line 1936 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
#pragma line 1962 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma line 1998 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma line 2057 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma line 2099 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#pragma empty_line
    protected:
#pragma empty_line
      virtual ~num_get() { }
#pragma empty_line
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;
#pragma empty_line
      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;
#pragma empty_line
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }
#pragma empty_line
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
#pragma line 2170 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
#pragma line 2235 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
    };
#pragma empty_line
  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
#pragma line 2253 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef _OutIter iter_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static locale::id id;
#pragma line 2274 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
#pragma line 2292 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma line 2334 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma line 2397 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma line 2422 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#pragma empty_line
    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;
#pragma empty_line
      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;
#pragma empty_line
      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;
#pragma empty_line
      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;
#pragma empty_line
      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;
#pragma empty_line
#pragma empty_line
      virtual
      ~num_put() { };
#pragma line 2470 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;
#pragma empty_line
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;
#pragma empty_line
#pragma empty_line
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    };
#pragma empty_line
  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 1 3
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
#pragma empty_line
#pragma line 36 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };
#pragma empty_line
  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
#pragma empty_line
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
#pragma empty_line
      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));
#pragma empty_line
   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;
#pragma empty_line
   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;
#pragma empty_line
   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();
#pragma empty_line
   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
#pragma line 138 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();
#pragma empty_line
#pragma empty_line
      bool __testeof = __beg == __end;
#pragma empty_line
#pragma empty_line
      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }
#pragma empty_line
#pragma empty_line
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }
#pragma empty_line
#pragma empty_line
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
#pragma empty_line
      if (!__lc->_M_allocated)
#pragma empty_line
 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {
#pragma empty_line
  __xtrc += 'e';
  __found_sci = true;
#pragma empty_line
#pragma empty_line
  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;
#pragma empty_line
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {
#pragma empty_line
#pragma empty_line
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {
#pragma empty_line
#pragma empty_line
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
#pragma empty_line
#pragma empty_line
   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {
#pragma empty_line
      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;
#pragma empty_line
#pragma empty_line
      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }
#pragma empty_line
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (__found_grouping.size())
        {
#pragma empty_line
   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);
#pragma empty_line
          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }
#pragma empty_line
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();
#pragma empty_line
#pragma empty_line
 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
#pragma empty_line
#pragma empty_line
 bool __testeof = __beg == __end;
#pragma empty_line
#pragma empty_line
 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }
#pragma empty_line
#pragma empty_line
#pragma empty_line
 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;
#pragma empty_line
     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }
#pragma empty_line
#pragma empty_line
#pragma empty_line
 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);
#pragma empty_line
#pragma empty_line
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
#pragma empty_line
 if (!__lc->_M_allocated)
#pragma empty_line
   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;
#pragma empty_line
       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {
#pragma empty_line
#pragma empty_line
       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {
#pragma empty_line
#pragma empty_line
    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;
#pragma empty_line
    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }
#pragma empty_line
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (__found_grouping.size())
   {
#pragma empty_line
     __found_grouping += static_cast<char>(__sep_pos);
#pragma empty_line
     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;
#pragma empty_line
 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
#pragma empty_line
#pragma empty_line
#pragma empty_line
   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {
#pragma empty_line
#pragma empty_line
       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {
#pragma empty_line
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
#pragma empty_line
   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }
#pragma empty_line
       const char_type __c = *__beg;
#pragma empty_line
       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];
#pragma empty_line
       if (!__testf && __donet)
  break;
#pragma empty_line
       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];
#pragma empty_line
       if (!__testt && __donef)
  break;
#pragma empty_line
       if (!__testt && !__testf)
  break;
#pragma empty_line
       ++__n;
       ++__beg;
#pragma empty_line
       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {
#pragma empty_line
#pragma empty_line
       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma line 732 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#pragma empty_line
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
#pragma empty_line
      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);
#pragma empty_line
      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
#pragma empty_line
      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
#pragma empty_line
#pragma empty_line
      __io.flags(__fmt);
#pragma empty_line
      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {
#pragma empty_line
#pragma empty_line
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {
#pragma empty_line
   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {
#pragma empty_line
   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {
#pragma empty_line
   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();
#pragma empty_line
#pragma empty_line
 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));
#pragma empty_line
#pragma empty_line
#pragma empty_line
 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;
#pragma empty_line
#pragma empty_line
 if (__lc->_M_use_grouping)
   {
#pragma empty_line
#pragma empty_line
     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }
#pragma empty_line
#pragma empty_line
 if (__builtin_expect(__dec, true))
   {
#pragma empty_line
     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {
#pragma empty_line
  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];
#pragma empty_line
  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }
#pragma empty_line
#pragma empty_line
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 return std::__write(__s, __cs, __len);
      }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);
#pragma empty_line
#pragma empty_line
      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
#pragma line 968 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
#pragma empty_line
#pragma empty_line
 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
#pragma empty_line
 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
#pragma empty_line
#pragma empty_line
 int __len;
#pragma empty_line
 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);
#pragma empty_line
#pragma empty_line
 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
#pragma line 1029 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);
#pragma empty_line
#pragma empty_line
 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {
#pragma empty_line
#pragma empty_line
     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
#pragma empty_line
     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }
#pragma empty_line
     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;
#pragma empty_line
     __ws = __ws2;
   }
#pragma empty_line
#pragma empty_line
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
 return std::__write(__s, __ws, __len);
      }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
#pragma empty_line
   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;
#pragma empty_line
   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));
#pragma empty_line
       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);
#pragma empty_line
       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#pragma line 1154 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }
#pragma empty_line
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
#pragma empty_line
      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
#pragma empty_line
      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
#pragma empty_line
#pragma empty_line
#pragma line 1191 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
#pragma empty_line
#pragma empty_line
      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }
#pragma empty_line
      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {
#pragma empty_line
#pragma empty_line
#pragma empty_line
          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
#pragma empty_line
   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
#pragma empty_line
 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
#pragma empty_line
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;
#pragma empty_line
      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }
#pragma empty_line
      while (__first != __last)
 *__s++ = *__first++;
#pragma empty_line
      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
#pragma empty_line
      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
#pragma empty_line
      return __s;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;
#pragma empty_line
  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);
#pragma empty_line
  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);
#pragma empty_line
  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);
#pragma empty_line
  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<ctype<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<numpunct<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_put<char> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_get<char> >(const locale&);
#pragma empty_line
#pragma empty_line
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;
#pragma empty_line
  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);
#pragma empty_line
 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);
#pragma empty_line
  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 2609 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 2 3
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
#pragma line 63 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;
#pragma empty_line
#pragma empty_line
      const __ctype_type* _M_ctype;
#pragma empty_line
      const __num_put_type* _M_num_put;
#pragma empty_line
      const __num_get_type* _M_num_get;
#pragma empty_line
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
#pragma empty_line
      bool
      operator!() const
      { return this->fail(); }
#pragma line 128 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
#pragma line 139 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      _M_setstate(iostate __state)
      {
#pragma empty_line
#pragma empty_line
 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      bool
      good() const
      { return this->rdstate() == 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
#pragma line 192 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
#pragma line 213 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
#pragma line 248 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~basic_ios() { }
#pragma line 286 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
#pragma line 298 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
#pragma line 338 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
#pragma line 352 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
#pragma line 381 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
#pragma line 401 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
#pragma line 421 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
#pragma line 440 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
#pragma empty_line
    protected:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);
#pragma empty_line
      void
      _M_cache_locale(const locale& __loc);
    };
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 1 3
#pragma line 34 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3
#pragma empty_line
#pragma line 35 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
#pragma empty_line
#pragma empty_line
      if (this != &__rhs)
 {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];
#pragma empty_line
#pragma empty_line
   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();
#pragma empty_line
#pragma empty_line
   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;
#pragma empty_line
   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);
#pragma empty_line
   _M_call_callbacks(copyfmt_event);
#pragma empty_line
#pragma empty_line
   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
#pragma empty_line
      ios_base::_M_init();
#pragma empty_line
#pragma empty_line
      _M_cache_locale(_M_ios_locale);
#pragma line 147 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;
#pragma empty_line
      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;
#pragma empty_line
      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;
#pragma empty_line
      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_ios<char>;
#pragma empty_line
#pragma empty_line
  extern template class basic_ios<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 474 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 2 3
#pragma line 46 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 2 3
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 56 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
#pragma line 83 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~basic_ostream() { }
#pragma empty_line
#pragma empty_line
      class sentry;
      friend class sentry;
#pragma line 109 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
#pragma empty_line
#pragma empty_line
#pragma empty_line
 return __pf(*this);
      }
#pragma empty_line
      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {
#pragma empty_line
#pragma empty_line
#pragma empty_line
 __pf(*this);
 return *this;
      }
#pragma empty_line
      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {
#pragma empty_line
#pragma empty_line
#pragma empty_line
 __pf(*this);
 return *this;
      }
#pragma line 166 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(short __n);
#pragma empty_line
      __ostream_type&
      operator<<(unsigned short __n)
      {
#pragma empty_line
#pragma empty_line
 return _M_insert(static_cast<unsigned long>(__n));
      }
#pragma empty_line
      __ostream_type&
      operator<<(int __n);
#pragma empty_line
      __ostream_type&
      operator<<(unsigned int __n)
      {
#pragma empty_line
#pragma empty_line
 return _M_insert(static_cast<unsigned long>(__n));
      }
#pragma empty_line
#pragma empty_line
      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }
#pragma empty_line
      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
#pragma empty_line
#pragma empty_line
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
#pragma empty_line
      __ostream_type&
      operator<<(float __f)
      {
#pragma empty_line
#pragma empty_line
 return _M_insert(static_cast<double>(__f));
      }
#pragma empty_line
      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
#pragma empty_line
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
#pragma line 251 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
#pragma line 284 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      put(char_type __c);
#pragma empty_line
#pragma empty_line
      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
#pragma line 312 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
#pragma line 325 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      flush();
#pragma line 336 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      pos_type
      tellp();
#pragma line 347 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      seekp(pos_type);
#pragma line 359 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
#pragma empty_line
    protected:
      basic_ostream()
      { this->init(0); }
#pragma empty_line
      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
#pragma line 378 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
#pragma empty_line
      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;
#pragma empty_line
    public:
#pragma line 397 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
#pragma line 407 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      ~sentry()
      {
#pragma empty_line
 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {
#pragma empty_line
     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma line 428 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
#pragma line 449 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }
#pragma empty_line
#pragma empty_line
  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }
#pragma empty_line
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
#pragma line 491 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
#pragma empty_line
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
#pragma empty_line
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#pragma empty_line
  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#pragma line 541 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
#pragma line 585 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
#pragma empty_line
      if (__os.tie() && __os.good())
 __os.tie()->flush();
#pragma empty_line
      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
#pragma empty_line
#pragma empty_line
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
#pragma empty_line
#pragma empty_line
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
#pragma empty_line
#pragma empty_line
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);
#pragma empty_line
#pragma empty_line
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
#pragma empty_line
#pragma empty_line
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);
#pragma empty_line
#pragma empty_line
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {
#pragma empty_line
#pragma empty_line
   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);
#pragma empty_line
       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
#pragma empty_line
  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);
#pragma empty_line
  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);
#pragma empty_line
  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);
#pragma empty_line
#pragma empty_line
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
#pragma empty_line
  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);
#pragma empty_line
  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);
#pragma empty_line
  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 589 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 2 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 56 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
    protected:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      streamsize _M_gcount;
#pragma empty_line
    public:
#pragma line 92 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
#pragma empty_line
#pragma empty_line
      class sentry;
      friend class sentry;
#pragma line 121 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }
#pragma empty_line
      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }
#pragma empty_line
      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
#pragma line 168 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(short& __n);
#pragma empty_line
      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(int& __n);
#pragma empty_line
      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }
#pragma empty_line
#pragma empty_line
      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }
#pragma empty_line
      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
#pragma empty_line
#pragma empty_line
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
#pragma empty_line
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
#pragma line 240 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
#pragma line 250 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
#pragma line 282 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int_type
      get();
#pragma line 296 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type& __c);
#pragma line 323 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
#pragma line 334 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
#pragma line 357 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
#pragma line 367 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
#pragma line 396 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
#pragma line 407 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
#pragma line 431 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      ignore();
#pragma empty_line
      __istream_type&
      ignore(streamsize __n);
#pragma empty_line
      __istream_type&
      ignore(streamsize __n, int_type __delim);
#pragma line 448 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int_type
      peek();
#pragma line 466 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
#pragma line 485 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
#pragma line 502 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      putback(char_type __c);
#pragma line 518 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      unget();
#pragma line 536 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int
      sync();
#pragma line 551 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      pos_type
      tellg();
#pragma line 566 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      seekg(pos_type);
#pragma line 582 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);
#pragma empty_line
#pragma empty_line
    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
#pragma empty_line
      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);
#pragma empty_line
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);
#pragma empty_line
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#pragma line 637 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
#pragma empty_line
      bool _M_ok;
#pragma empty_line
    public:
#pragma empty_line
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
#pragma line 673 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
#pragma line 686 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      operator bool() const
      { return _M_ok; }
    };
#pragma line 703 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#pragma line 745 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);
#pragma empty_line
#pragma empty_line
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#pragma empty_line
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#pragma line 773 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
#pragma empty_line
#pragma empty_line
#pragma empty_line
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      virtual
      ~basic_iostream() { }
#pragma empty_line
    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
#pragma line 834 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
#pragma line 856 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
#pragma empty_line
       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }
#pragma empty_line
      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
#pragma empty_line
#pragma empty_line
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
#pragma empty_line
#pragma empty_line
#pragma empty_line
       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
#pragma empty_line
#pragma empty_line
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
#pragma empty_line
#pragma empty_line
#pragma empty_line
       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();
#pragma empty_line
       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();
#pragma empty_line
       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();
#pragma empty_line
       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
#pragma empty_line
#pragma empty_line
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
#pragma empty_line
       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma empty_line
              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }
#pragma empty_line
#pragma empty_line
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
#pragma empty_line
       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma line 515 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }
#pragma empty_line
       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
#pragma empty_line
       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#pragma empty_line
#pragma empty_line
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }
#pragma empty_line
       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
#pragma empty_line
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
#pragma empty_line
       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
#pragma empty_line
#pragma empty_line
      _M_gcount = 0;
#pragma empty_line
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
#pragma empty_line
#pragma empty_line
      _M_gcount = 0;
#pragma empty_line
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
#pragma empty_line
#pragma empty_line
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
#pragma empty_line
#pragma empty_line
      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {
#pragma empty_line
    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);
#pragma empty_line
#pragma empty_line
    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
#pragma empty_line
#pragma empty_line
#pragma empty_line
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {
#pragma empty_line
    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);
#pragma empty_line
#pragma empty_line
    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
#pragma empty_line
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
#pragma empty_line
       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;
#pragma empty_line
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
#pragma empty_line
       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();
#pragma empty_line
       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
#pragma empty_line
#pragma empty_line
#pragma empty_line
       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;
#pragma empty_line
      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();
#pragma empty_line
      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();
#pragma empty_line
       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);
#pragma empty_line
  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);
#pragma empty_line
  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);
#pragma empty_line
  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);
#pragma empty_line
  extern template class basic_iostream<char>;
#pragma empty_line
#pragma empty_line
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
#pragma empty_line
  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);
#pragma empty_line
  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);
#pragma empty_line
  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);
#pragma empty_line
  extern template class basic_iostream<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 860 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 2 3
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 61 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;
#pragma empty_line
#pragma empty_line
  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  static ios_base::Init __ioinit;
#pragma empty_line
#pragma empty_line
}
#pragma line 77 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h" 2
#pragma line 97 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/limits.h" 1 3
#pragma line 98 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h" 2
#pragma line 1 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 1
#pragma line 103 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
namespace AESL_std {
    template <class DataType>
    DataType inline min(DataType a, DataType b) {
#pragma empty_line
#pragma empty_line
        return (a>=b) ? b : a;
    }
#pragma empty_line
    template <class DataType>
    DataType inline max(DataType a, DataType b) {
#pragma empty_line
#pragma empty_line
        return (a>=b) ? a : b;
    }
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 1 3
#pragma line 43 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 3
#pragma empty_line
#pragma line 44 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 3
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 1 3
#pragma line 23 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
extern "C" {
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _assert (const char*, const char*, int) __attribute__ ((__noreturn__));
#pragma line 48 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
}
#pragma line 45 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 2 3
#pragma line 120 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
#pragma line 148 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  enum float_denorm_style
  {
#pragma empty_line
    denorm_indeterminate = -1,
#pragma empty_line
    denorm_absent = 0,
#pragma empty_line
    denorm_present = 1
  };
#pragma line 192 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  struct __numeric_limits_base
  {
#pragma empty_line
#pragma empty_line
    static const bool is_specialized = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int digits = 0;
#pragma empty_line
#pragma empty_line
    static const int digits10 = 0;
#pragma line 213 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
    static const bool is_signed = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool is_integer = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool is_exact = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int radix = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int min_exponent = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int min_exponent10 = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int max_exponent = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const int max_exponent10 = 0;
#pragma empty_line
#pragma empty_line
    static const bool has_infinity = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool has_quiet_NaN = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool has_signaling_NaN = false;
#pragma empty_line
#pragma empty_line
    static const float_denorm_style has_denorm = denorm_absent;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool has_denorm_loss = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool is_iec559 = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool is_bounded = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const bool is_modulo = false;
#pragma empty_line
#pragma empty_line
    static const bool traps = false;
#pragma empty_line
#pragma empty_line
    static const bool tinyness_before = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static const float_round_style round_style =
          round_toward_zero;
  };
#pragma line 303 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
#pragma empty_line
#pragma empty_line
      static _Tp
      min() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
      static _Tp
      max() throw() { return static_cast<_Tp>(0); }
#pragma line 324 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
      static _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
      static _Tp
      round_error() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
      static _Tp
      infinity() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };
#pragma line 370 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static bool
      min() throw() { return false; }
#pragma empty_line
      static bool
      max() throw() { return true; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = 1;
      static const int digits10 = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static bool
      epsilon() throw() { return false; }
#pragma empty_line
      static bool
      round_error() throw() { return false; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static bool
      infinity() throw() { return false; }
#pragma empty_line
      static bool
      quiet_NaN() throw() { return false; }
#pragma empty_line
      static bool
      signaling_NaN() throw() { return false; }
#pragma empty_line
      static bool
      denorm_min() throw() { return false; }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
#pragma empty_line
      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static char
      epsilon() throw() { return 0; }
#pragma empty_line
      static char
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static
      char infinity() throw() { return char(); }
#pragma empty_line
      static char
      quiet_NaN() throw() { return char(); }
#pragma empty_line
      static char
      signaling_NaN() throw() { return char(); }
#pragma empty_line
      static char
      denorm_min() throw() { return static_cast<char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static signed char
      min() throw() { return -127 - 1; }
#pragma empty_line
      static signed char
      max() throw() { return 127; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static signed char
      epsilon() throw() { return 0; }
#pragma empty_line
      static signed char
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static signed char
      infinity() throw() { return static_cast<signed char>(0); }
#pragma empty_line
      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }
#pragma empty_line
      static signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }
#pragma empty_line
      static signed char
      denorm_min() throw() { return static_cast<signed char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned char
      min() throw() { return 0; }
#pragma empty_line
      static unsigned char
      max() throw() { return 127 * 2U + 1; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static unsigned char
      epsilon() throw() { return 0; }
#pragma empty_line
      static unsigned char
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }
#pragma empty_line
      static unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }
#pragma empty_line
      static unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }
#pragma empty_line
      static unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
#pragma empty_line
      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static wchar_t
      epsilon() throw() { return 0; }
#pragma empty_line
      static wchar_t
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static wchar_t
      infinity() throw() { return wchar_t(); }
#pragma empty_line
      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }
#pragma empty_line
      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }
#pragma empty_line
      static wchar_t
      denorm_min() throw() { return wchar_t(); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma line 852 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static short
      min() throw() { return -32767 - 1; }
#pragma empty_line
      static short
      max() throw() { return 32767; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static short
      epsilon() throw() { return 0; }
#pragma empty_line
      static short
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static short
      infinity() throw() { return short(); }
#pragma empty_line
      static short
      quiet_NaN() throw() { return short(); }
#pragma empty_line
      static short
      signaling_NaN() throw() { return short(); }
#pragma empty_line
      static short
      denorm_min() throw() { return short(); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned short
      min() throw() { return 0; }
#pragma empty_line
      static unsigned short
      max() throw() { return 32767 * 2U + 1; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static unsigned short
      epsilon() throw() { return 0; }
#pragma empty_line
      static unsigned short
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }
#pragma empty_line
      static unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }
#pragma empty_line
      static unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }
#pragma empty_line
      static unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static int
      min() throw() { return -2147483647 - 1; }
#pragma empty_line
      static int
      max() throw() { return 2147483647; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static int
      epsilon() throw() { return 0; }
#pragma empty_line
      static int
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static int
      infinity() throw() { return static_cast<int>(0); }
#pragma empty_line
      static int
      quiet_NaN() throw() { return static_cast<int>(0); }
#pragma empty_line
      static int
      signaling_NaN() throw() { return static_cast<int>(0); }
#pragma empty_line
      static int
      denorm_min() throw() { return static_cast<int>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned int
      min() throw() { return 0; }
#pragma empty_line
      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static unsigned int
      epsilon() throw() { return 0; }
#pragma empty_line
      static unsigned int
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }
#pragma empty_line
      static unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }
#pragma empty_line
      static unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }
#pragma empty_line
      static unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long
      min() throw() { return -2147483647L - 1; }
#pragma empty_line
      static long
      max() throw() { return 2147483647L; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static long
      epsilon() throw() { return 0; }
#pragma empty_line
      static long
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static long
      infinity() throw() { return static_cast<long>(0); }
#pragma empty_line
      static long
      quiet_NaN() throw() { return static_cast<long>(0); }
#pragma empty_line
      static long
      signaling_NaN() throw() { return static_cast<long>(0); }
#pragma empty_line
      static long
      denorm_min() throw() { return static_cast<long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned long
      min() throw() { return 0; }
#pragma empty_line
      static unsigned long
      max() throw() { return 2147483647L * 2UL + 1; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static unsigned long
      epsilon() throw() { return 0; }
#pragma empty_line
      static unsigned long
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }
#pragma empty_line
      static unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }
#pragma empty_line
      static unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }
#pragma empty_line
      static unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long long
      min() throw() { return -9223372036854775807LL - 1; }
#pragma empty_line
      static long long
      max() throw() { return 9223372036854775807LL; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static long long
      epsilon() throw() { return 0; }
#pragma empty_line
      static long long
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static long long
      infinity() throw() { return static_cast<long long>(0); }
#pragma empty_line
      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }
#pragma empty_line
      static long long
      signaling_NaN() throw() { return static_cast<long long>(0); }
#pragma empty_line
      static long long
      denorm_min() throw() { return static_cast<long long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static unsigned long long
      min() throw() { return 0; }
#pragma empty_line
      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
#pragma empty_line
      static unsigned long long
      epsilon() throw() { return 0; }
#pragma empty_line
      static unsigned long long
      round_error() throw() { return 0; }
#pragma empty_line
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
#pragma empty_line
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;
#pragma empty_line
      static unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }
#pragma empty_line
      static unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }
#pragma empty_line
      static unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }
#pragma empty_line
      static unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }
#pragma empty_line
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
#pragma empty_line
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static float
      min() throw() { return 1.17549435082228750797e-38F; }
#pragma empty_line
      static float
      max() throw() { return 3.40282346638528859812e+38F; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = 24;
      static const int digits10 = 6;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
#pragma empty_line
      static float
      epsilon() throw() { return 1.19209289550781250000e-7F; }
#pragma empty_line
      static float
      round_error() throw() { return 0.5F; }
#pragma empty_line
      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;
#pragma empty_line
      static float
      infinity() throw() { return __builtin_huge_valf (); }
#pragma empty_line
      static float
      quiet_NaN() throw() { return __builtin_nanf (""); }
#pragma empty_line
      static float
      signaling_NaN() throw() { return __builtin_nansf (""); }
#pragma empty_line
      static float
      denorm_min() throw() { return 1.40129846432481707092e-45F; }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static double
      min() throw() { return double(2.22507385850720138309e-308L); }
#pragma empty_line
      static double
      max() throw() { return double(1.79769313486231570815e+308L); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = 53;
      static const int digits10 = 15;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
#pragma empty_line
      static double
      epsilon() throw() { return double(2.22044604925031308085e-16L); }
#pragma empty_line
      static double
      round_error() throw() { return 0.5; }
#pragma empty_line
      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;
#pragma empty_line
      static double
      infinity() throw() { return __builtin_huge_val(); }
#pragma empty_line
      static double
      quiet_NaN() throw() { return __builtin_nan (""); }
#pragma empty_line
      static double
      signaling_NaN() throw() { return __builtin_nans (""); }
#pragma empty_line
      static double
      denorm_min() throw() { return double(4.94065645841246544177e-324L); }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;
#pragma empty_line
      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }
#pragma empty_line
      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const int digits = 64;
      static const int digits10 = 18;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
#pragma empty_line
      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }
#pragma empty_line
      static long double
      round_error() throw() { return 0.5L; }
#pragma empty_line
      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;
#pragma empty_line
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;
#pragma empty_line
      static long double
      infinity() throw() { return __builtin_huge_vall (); }
#pragma empty_line
      static long double
      quiet_NaN() throw() { return __builtin_nanl (""); }
#pragma empty_line
      static long double
      signaling_NaN() throw() { return __builtin_nansl (""); }
#pragma empty_line
      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }
#pragma empty_line
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
#pragma empty_line
      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 124 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3
#pragma line 73 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3
namespace std
{
#pragma empty_line
#pragma empty_line
  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
#pragma empty_line
#pragma empty_line
  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }
#pragma empty_line
  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }
#pragma empty_line
  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }
#pragma empty_line
  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }
#pragma empty_line
  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 125 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 1 3
#pragma line 41 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
#pragma empty_line
#pragma line 42 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
#pragma line 66 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 1 3
#pragma line 21 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#pragma line 22 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 2 3
#pragma line 60 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern "C" {
#pragma line 71 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern int _argc;
extern char** _argv;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argc(void);
extern char*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argv(void);
extern wchar_t*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___wargv(void);
#pragma line 137 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);
#pragma empty_line
#pragma empty_line
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __doserrno(void);
#pragma line 149 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
  extern char *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__environ(void);
  extern wchar_t *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wenviron(void);
#pragma line 172 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
  extern __attribute__ ((__dllimport__)) int _sys_nerr;
#pragma line 196 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) char* _sys_errlist[];
#pragma line 209 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__osver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winmajor(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winminor(void);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
extern __attribute__ ((__dllimport__)) unsigned int _osver;
extern __attribute__ ((__dllimport__)) unsigned int _winver;
extern __attribute__ ((__dllimport__)) unsigned int _winmajor;
extern __attribute__ ((__dllimport__)) unsigned int _winminor;
#pragma line 260 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__pgmptr(void);
#pragma empty_line
 wchar_t** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wpgmptr(void);
#pragma line 293 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) int _fmode;
#pragma line 303 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atof (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoi (const char*);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atol (const char*);
#pragma empty_line
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtof (const wchar_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi (const wchar_t *);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtol (const wchar_t *);
#pragma empty_line
#pragma empty_line
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __strtod (const char*, char**);
extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
strtod (const char* __restrict__ __nptr, char** __restrict__ __endptr);
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof (const char * __restrict__, char ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold (const char * __restrict__, char ** __restrict__);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtol (const char*, char**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoul (const char*, char**, int);
#pragma line 345 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstombs (char*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctomb (char*, wchar_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mblen (const char*, size_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbstowcs (wchar_t*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbtowc (wchar_t*, const char*, size_t);
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rand (void);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) srand (unsigned int);
#pragma empty_line
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) calloc (size_t, size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) malloc (size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) realloc (void*, size_t);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) free (void*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abort (void) __attribute__ ((__noreturn__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit (int) __attribute__ ((__noreturn__));
#pragma empty_line
#pragma empty_line
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atexit (void (*)(void));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) system (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getenv (const char*);
#pragma empty_line
#pragma empty_line
 void* __attribute__((__cdecl__)) bsearch (const void*, const void*, size_t, size_t,
          int (*)(const void*, const void*));
 void __attribute__((__cdecl__)) qsort(void*, size_t, size_t,
      int (*)(const void*, const void*));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abs (int) __attribute__ ((__const__));
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) labs (long) __attribute__ ((__const__));
#pragma line 385 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
#pragma empty_line
 div_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) div (int, int) __attribute__ ((__const__));
 ldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ldiv (long, long) __attribute__ ((__const__));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _beep (unsigned int, unsigned int) __attribute__ ((__deprecated__));
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _seterrormode (int) __attribute__ ((__deprecated__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _sleep (unsigned long) __attribute__ ((__deprecated__));
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit (int) __attribute__ ((__noreturn__));
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef int (* _onexit_t)(void);
_onexit_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _onexit( _onexit_t );
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _searchenv (const char*, const char*, char*);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _gcvt (double, int, char*);
#pragma empty_line
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _makepath (char*, const char*, const char*, const char*, const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _splitpath (const char*, char*, char*, char*, char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fullpath (char*, const char*, size_t);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltoa (long, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultoa(unsigned long, char*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itow (int, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltow (long, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultow (unsigned long, wchar_t*, int);
#pragma empty_line
#pragma empty_line
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _atoi64(const char *);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64toa(long long, char *, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64toa(unsigned long long, char *, int);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi64(const wchar_t *);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64tow(long long, wchar_t *, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64tow(unsigned long long, wchar_t *, int);
#pragma empty_line
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_rotl)(unsigned int, int) __attribute__ ((__const__));
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_rotr)(unsigned int, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_lrotl)(unsigned long, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_lrotr)(unsigned long, int) __attribute__ ((__const__));
#pragma empty_line
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _set_error_mode (int);
#pragma line 477 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) searchenv (const char*, const char*, char*);
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ltoa (long, char*, int);
#pragma empty_line
#pragma empty_line
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gcvt (double, int, char*);
#pragma line 497 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _Exit(int) __attribute__ ((__noreturn__));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef struct { long long quot, rem; } lldiv_t;
#pragma empty_line
lldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lldiv (long long, long long) __attribute__ ((__const__));
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) llabs(long long);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoll (const char* __restrict__, char** __restrict, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoull (const char* __restrict__, char** __restrict__, int);
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoll (const char *);
#pragma empty_line
#pragma empty_line
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wtoll (const wchar_t *);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltoa (long long, char *, int);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltoa (unsigned long long , char *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltow (long long, wchar_t *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltow (unsigned long long, wchar_t *, int);
#pragma line 549 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
}
#pragma line 67 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 2 3
#pragma line 98 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
namespace std
{
#pragma empty_line
#pragma empty_line
  using ::div_t;
  using ::ldiv_t;
#pragma empty_line
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
#pragma empty_line
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
#pragma empty_line
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
#pragma empty_line
  using ::wcstombs;
  using ::wctomb;
#pragma empty_line
#pragma empty_line
  inline long
  abs(long __i) { return labs(__i); }
#pragma empty_line
  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
#pragma empty_line
#pragma empty_line
}
#pragma line 158 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
namespace __gnu_cxx
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::lldiv_t;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  using ::_Exit;
#pragma empty_line
#pragma empty_line
  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }
#pragma empty_line
#pragma empty_line
  using ::llabs;
#pragma empty_line
  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
#pragma empty_line
  using ::lldiv;
#pragma line 193 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
#pragma empty_line
  using ::strtof;
  using ::strtold;
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
namespace std
{
#pragma empty_line
  using ::__gnu_cxx::lldiv_t;
#pragma empty_line
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;
#pragma empty_line
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
#pragma empty_line
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
#pragma line 126 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 1 3
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
#pragma empty_line
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
#pragma line 48 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
namespace std
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
#pragma line 64 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }
#pragma empty_line
#pragma empty_line
  struct _Setiosflags { ios_base::fmtflags _M_mask; };
#pragma line 94 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }
#pragma empty_line
#pragma empty_line
  struct _Setbase { int _M_base; };
#pragma line 125 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }
#pragma empty_line
#pragma empty_line
  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
#pragma line 162 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }
#pragma empty_line
#pragma empty_line
  struct _Setprecision { int _M_n; };
#pragma line 193 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }
#pragma empty_line
#pragma empty_line
  struct _Setw { int _M_n; };
#pragma line 223 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }
#pragma empty_line
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
#pragma line 320 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);
#pragma empty_line
#pragma empty_line
  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 127 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 1 3
#pragma line 37 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
#pragma empty_line
#pragma line 38 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma line 59 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
#pragma empty_line
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
#pragma empty_line
    protected:
#pragma empty_line
      ios_base::openmode _M_mode;
#pragma empty_line
#pragma empty_line
      __string_type _M_string;
#pragma empty_line
    public:
#pragma line 93 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
#pragma line 106 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
#pragma line 121 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {
#pragma empty_line
     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
#pragma line 145 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      void
      str(const __string_type& __s)
      {
#pragma empty_line
 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }
#pragma empty_line
    protected:
#pragma empty_line
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }
#pragma empty_line
      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }
#pragma empty_line
      virtual int_type
      underflow();
#pragma empty_line
      virtual int_type
      pbackfail(int_type __c = traits_type::eof());
#pragma empty_line
      virtual int_type
      overflow(int_type __c = traits_type::eof());
#pragma line 197 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
     _M_string.clear();
#pragma empty_line
#pragma empty_line
     _M_sync(__s, __n, 0);
   }
 return this;
      }
#pragma empty_line
      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);
#pragma empty_line
      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
#pragma line 262 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
#pragma empty_line
#pragma empty_line
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;
#pragma empty_line
    private:
      __stringbuf_type _M_stringbuf;
#pragma empty_line
    public:
#pragma line 298 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
#pragma line 316 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ~basic_istringstream()
      { }
#pragma line 338 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __string_type
      str() const
      { return _M_stringbuf.str(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#pragma line 372 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
#pragma empty_line
#pragma empty_line
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;
#pragma empty_line
    private:
      __stringbuf_type _M_stringbuf;
#pragma empty_line
    public:
#pragma line 408 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
#pragma line 426 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ~basic_ostringstream()
      { }
#pragma line 448 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __string_type
      str() const
      { return _M_stringbuf.str(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#pragma line 482 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:
#pragma empty_line
      typedef _CharT char_type;
      typedef _Traits traits_type;
#pragma empty_line
#pragma empty_line
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
#pragma empty_line
#pragma empty_line
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;
#pragma empty_line
    private:
      __stringbuf_type _M_stringbuf;
#pragma empty_line
    public:
#pragma line 516 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
#pragma line 532 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      ~basic_stringstream()
      { }
#pragma line 554 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      __string_type
      str() const
      { return _M_stringbuf.str(); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma line 1 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 1 3
#pragma line 39 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3
#pragma empty_line
#pragma line 40 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3
#pragma empty_line
namespace std
{
#pragma empty_line
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {
#pragma empty_line
#pragma empty_line
   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();
#pragma empty_line
      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);
#pragma empty_line
      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
#pragma line 112 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {
#pragma empty_line
   _M_update_egptr();
#pragma empty_line
   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);
#pragma empty_line
#pragma empty_line
#pragma empty_line
      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();
#pragma empty_line
   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;
#pragma empty_line
   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
#pragma empty_line
      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();
#pragma empty_line
   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();
#pragma empty_line
      if (__base != _M_string.data())
 {
#pragma empty_line
   __endg += __i;
   __i = 0;
   __endp = __endg;
 }
#pragma empty_line
      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);
#pragma empty_line
#pragma empty_line
#pragma empty_line
   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }
#pragma empty_line
  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;
#pragma empty_line
#pragma empty_line
  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma line 581 "c:\\xilinx\\vivado_hls\\2016.4\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 2 3
#pragma line 128 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h" 2
#pragma empty_line
template<int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64> class ap_private;
namespace ap_private_ops {
#pragma empty_line
inline uint32_t Hi_32(uint64_t Value) {
    return static_cast<uint32_t>(Value >> 32);
}
#pragma empty_line
#pragma empty_line
inline uint32_t Lo_32(uint64_t Value) {
    return static_cast<uint32_t>(Value);
}
#pragma empty_line
template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
    return false;
}
#pragma empty_line
#pragma empty_line
template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
    enum {APINT_BITS_PER_WORD=64,_AP_N=(_AP_W+APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD};
    static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) %APINT_BITS_PER_WORD);
 return (sign_mask & a.get_pVal(_AP_N-1)) != 0;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline unsigned CountLeadingZeros_32(uint32_t Value) {
    unsigned Count;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    if (Value == 0) return 32;
#pragma empty_line
    Count = __builtin_clz(Value);
#pragma line 179 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    return Count;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline unsigned CountLeadingZeros_64(uint64_t Value) {
    unsigned Count;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    if (!Value) return 64;
#pragma empty_line
    Count = __builtin_clzll(Value);
#pragma line 223 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    return Count;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline unsigned CountTrailingZeros_64(uint64_t Value) {
#pragma empty_line
    return (Value != 0) ? __builtin_ctzll(Value) : 64;
#pragma line 243 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline unsigned CountPopulation_64(uint64_t Value) {
#pragma empty_line
    return __builtin_popcountll(Value);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
    uint32_t Count = 0;
    if (skip)
        (__V) <<= (skip);
    while (__V && (__V & (1ULL << 63))) {
        Count++;
        (__V) <<= 1;
    }
    return Count;
}
#pragma empty_line
static inline std::string oct2Bin(char oct) {
    switch (oct) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "000";
        }
        case '1': {
            return "001";
        }
        case '2': {
            return "010";
        }
        case '3': {
            return "011";
        }
        case '4': {
            return "100";
        }
        case '5': {
            return "101";
        }
        case '6': {
            return "110";
        }
        case '7': {
            return "111";
        }
    }
#pragma empty_line
    ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 303));
    return "";
}
#pragma empty_line
static inline std::string hex2Bin(char hex) {
    switch (hex) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "0000";
        }
        case '1': {
            return "0001";
        }
        case '2': {
            return "0010";
        }
        case '3': {
            return "0011";
        }
        case '4': {
            return "0100";
        }
        case '5': {
            return "0101";
        }
        case '6': {
            return "0110";
        }
        case '7': {
            return "0111";
        }
        case '8': {
            return "1000";
        }
        case '9': {
            return "1001";
        }
        case 'A':
        case 'a': {
            return "1010";
        }
        case 'B':
        case 'b': {
            return "1011";
        }
        case 'C':
        case 'c': {
            return "1100";
        }
        case 'D':
        case 'd': {
            return "1101";
        }
        case 'E':
        case 'e': {
            return "1110";
        }
        case 'F':
        case 'f': {
            return "1111";
        }
    }
    ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 370));
    return "";
}
#pragma empty_line
static inline uint32_t decode_digit(char cdigit, int radix) {
    uint32_t digit = 0;
    if (radix == 16) {
#pragma empty_line
#pragma empty_line
            if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                ((0 && "Invalid hex digit in string") ? (void)0 : _assert("0 && \"Invalid hex digit in string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 380));
            if (((cdigit) >= '0' && (cdigit) <= '9'))
                digit = cdigit - '0';
            else if (cdigit >= 'a')
                digit = cdigit - 'a' + 10;
            else if (cdigit >= 'A')
                digit = cdigit - 'A' + 10;
            else
                ((0 && "huh? we shouldn't get here") ? (void)0 : _assert("0 && \"huh? we shouldn't get here\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 388));
        } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
            digit = cdigit - '0';
        } else {
            ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 392));
        }
#pragma empty_line
#pragma empty_line
        return digit;
}
#pragma empty_line
#pragma empty_line
static inline std::string parseString(const std::string& input, int& radix) {
#pragma empty_line
    size_t len = input.length();
    if(len == 0) return input;
#pragma empty_line
    size_t startPos = 0;
#pragma empty_line
    while(input[startPos] == ' ' && startPos < len) startPos++;
    while(input[len-1] == ' ' && startPos < len) len--;
#pragma empty_line
    std::string val = input.substr(startPos, len-startPos);
#pragma empty_line
    len = val.length();
    startPos = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    if (len < 2)
        return val;
#pragma empty_line
    bool isNegative = false;
    std::string ans;
#pragma empty_line
#pragma empty_line
    if (val[0] == '-') {
        ans = "-";
        ++startPos;
        isNegative = true;
    } else if (val[0] == '+')
        ++startPos;
#pragma empty_line
    if (len - startPos < 2)
        return val;
#pragma empty_line
    if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {
#pragma empty_line
        radix = 16;
        startPos += 2;
    } else if (val.substr(startPos, 2) == "0b" || val.substr(startPos, 2) == "0B") {
#pragma empty_line
        radix = 2;
        startPos += 2;
    } if (val.substr(startPos, 2) == "0o" || val.substr(startPos, 2) == "0O") {
#pragma empty_line
        radix = 8;
        startPos += 2;
    }
#pragma empty_line
    int exp = 0;
    if (radix == 10) {
#pragma empty_line
#pragma empty_line
        size_t expPos = val.find('e');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('E');
        if (expPos == std::string::npos) {
#pragma empty_line
            expPos = len;
            has_exponent = false;
        }
#pragma empty_line
#pragma empty_line
        ans += val.substr(startPos, expPos-startPos);
        if(has_exponent) {
#pragma empty_line
            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    } else {
#pragma empty_line
        size_t expPos = val.find('p');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('P');
        if (expPos == std::string::npos) {
#pragma empty_line
            expPos = len;
            has_exponent = false;
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
        ((startPos <= expPos) ? (void)0 : _assert("startPos <= expPos", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 483));
#pragma empty_line
        for (size_t i=startPos; i<expPos; ++i) {
            if(radix == 16) {
                ans += hex2Bin(val[i]);
            } else if(radix == 8) {
                ans += oct2Bin(val[i]);
            } else {
                ans += val[i];
            }
        }
#pragma empty_line
        radix = 2;
        if (has_exponent) {
#pragma empty_line
            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    }
    if (exp == 0)
        return ans;
#pragma empty_line
    size_t decPos = ans.find('.');
    if (decPos == std::string::npos)
        decPos = ans.length();
    if ((int) decPos + exp >= (int) ans.length()) {
        int i = decPos;
        for (; i< (int) ans.length()-1; ++i)
            ans[i] = ans[i+1];
        for (; i< (int) ans.length(); ++i)
            ans[i] = '0';
        for (; i< (int) decPos + exp; ++i)
            ans += '0';
        return ans;
    } else if ((int) decPos + exp < (int) isNegative) {
        std::string dupAns = "0.";
        if (ans[0] == '-')
            dupAns = "-0.";
        for (int i=0; i<isNegative-(int)decPos-exp; ++i)
            dupAns += '0';
        for (size_t i=isNegative; i< ans.length(); ++i)
            if (ans[i] != '.')
                dupAns += ans[i];
        return dupAns;
    }
#pragma empty_line
    if (exp > 0)
        for (size_t i=decPos; i<decPos+exp; ++i)
            ans[i] = ans[i+1];
    else {
        if (decPos == ans.length())
            ans += ' ';
        for (int i=decPos; i>(int)decPos+exp; --i)
            ans[i] = ans[i-1];
    }
    ans[decPos+exp] = '.';
    return ans;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        uint64_t __X = x[i];
        x[i] -= y;
        if (y > __X)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        dest[i] = y + x[i];
        if (dest[i] < y)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
static inline bool add(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool carry = false;
    uint32_t len = AESL_std::min(xlen, ylen);
    uint32_t i;
    for (i = 0; i< len && i < destlen; ++i) {
        uint64_t limit = AESL_std::min(x[i],y[i]);
        dest[i] = x[i] + y[i] + carry;
        carry = dest[i] < limit || (carry && dest[i] == limit);
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(x[i], yext);
            dest[i] = x[i] + yext + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == limit);
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(xext, y[i]);
            dest[i] = xext + y[i] + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == limit);
        }
    }
    return carry;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
static inline bool sub(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool borrow = false;
    uint32_t i;
    uint32_t len = AESL_std::min(xlen, ylen);
    for (i = 0; i < len && i < destlen; ++i) {
        uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
        borrow = y[i] > x_tmp || (borrow && x[i] == 0);
        dest[i] = x_tmp - y[i];
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
            borrow = yext > x_tmp || (borrow && x[i] == 0);
            dest[i] = x_tmp - yext;
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? xext - 1 : xext;
            borrow = y[i] > x_tmp || (borrow && xext==0);
            dest[i] = x_tmp - y[i];
        }
    }
    return borrow;
}
#pragma line 649 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len, uint64_t y) {
#pragma empty_line
    uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
    uint64_t carry = 0;
    static const uint64_t two_power_32 = 1ULL << 32;
#pragma empty_line
    for (uint32_t i = 0; i < len; ++i) {
#pragma empty_line
        uint64_t lx = x[i] & 0xffffffffULL;
        uint64_t hx = (x[i]) >> 32;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        uint8_t hasCarry = 0;
        dest[i] = carry + lx * ly;
#pragma empty_line
        hasCarry = (dest[i] < carry) ? 1 : 0;
        carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);
#pragma empty_line
#pragma empty_line
        hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
#pragma empty_line
        carry += (lx * hy) & 0xffffffffULL;
        dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
        carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
    }
    return carry;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen, const uint64_t y[],
                uint32_t ylen, uint32_t destlen) {
    ((xlen > 0) ? (void)0 : _assert("xlen > 0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 687));
    ((ylen > 0) ? (void)0 : _assert("ylen > 0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 688));
    ((destlen >= xlen + ylen) ? (void)0 : _assert("destlen >= xlen + ylen", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 689));
    if(xlen < destlen)
        dest[xlen] = mul_1(dest, x, xlen, y[0]);
    for (uint32_t i = 1; i < ylen; ++i) {
        uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
        uint64_t carry = 0, lx = 0, hx = 0;
        for (uint32_t j = 0; j < xlen; ++j) {
            lx = x[j] & 0xffffffffULL;
            hx = (x[j]) >> 32;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
            uint8_t hasCarry = 0;
            uint64_t resul = carry + lx * ly;
            hasCarry = (resul < carry) ? 1 : 0;
            carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
            hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
            carry += (lx * hy) & 0xffffffffULL;
            resul = ((carry) << 32) | (resul & 0xffffffffULL);
            if(i+j < destlen)
                dest[i+j] += resul;
            carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0)+
                ((carry) >> 32) + (dest[i+j] < resul ? 1 : 0) +
                ((lx * hy) >> 32) + hx * hy;
        }
        if (i+xlen < destlen)
            dest[i+xlen] = carry;
    }
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
static inline void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,
                     uint32_t m, uint32_t n) {
    ((u && "Must provide dividend") ? (void)0 : _assert("u && \"Must provide dividend\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 726));
    ((v && "Must provide divisor") ? (void)0 : _assert("v && \"Must provide divisor\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 727));
    ((q && "Must provide quotient") ? (void)0 : _assert("q && \"Must provide quotient\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 728));
    ((u != v && u != q && v != q && "Must us different memory") ? (void)0 : _assert("u != v && u != q && v != q && \"Must us different memory\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 729));
    ((n>1 && "n must be > 1") ? (void)0 : _assert("n>1 && \"n must be > 1\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 730));
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint64_t b = uint64_t(1) << 32;
#pragma line 750 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    uint32_t shift = CountLeadingZeros_32(v[n-1]);
    uint32_t v_carry = 0;
    uint32_t u_carry = 0;
    if (shift) {
        for (uint32_t i = 0; i < m+n; ++i) {
            uint32_t u_tmp = (u[i]) >> (32 - shift);
            u[i] = ((u[i]) << (shift)) | u_carry;
            u_carry = u_tmp;
        }
        for (uint32_t i = 0; i < n; ++i) {
            uint32_t v_tmp = (v[i]) >> (32 - shift);
            v[i] = ((v[i]) << (shift)) | v_carry;
            v_carry = v_tmp;
        }
    }
    u[m+n] = u_carry;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    int j = m;
    do {
#pragma line 784 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        uint64_t dividend = ((uint64_t(u[j+n]) << 32) + u[j+n-1]);
#pragma empty_line
        uint64_t qp = dividend / v[n-1];
        uint64_t rp = dividend % v[n-1];
        if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {
            qp--;
            rp += v[n-1];
            if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))
                qp--;
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        bool isNeg = false;
        for (uint32_t i = 0; i < n; ++i) {
            uint64_t u_tmp = uint64_t(u[j+i]) | ((uint64_t(u[j+i+1])) << 32);
            uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
            bool borrow = subtrahend > u_tmp;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
            uint64_t result = u_tmp - subtrahend;
            uint32_t k = j + i;
            u[k++] = (uint32_t)(result & (b-1));
            u[k++] = (uint32_t)((result) >> 32);
            while (borrow && k <= m+n) {
                borrow = u[k] == 0;
                u[k]--;
                k++;
            }
            isNeg |= borrow;
#pragma empty_line
#pragma empty_line
        }
#pragma line 830 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        if (isNeg) {
            bool carry = true;
            for (uint32_t i = 0; i <= m+n; ++i) {
                u[i] = ~u[i] + carry;
                carry = carry && u[i] == 0;
            }
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        q[j] = (uint32_t)qp;
        if (isNeg) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
            q[j]--;
#pragma empty_line
#pragma empty_line
#pragma empty_line
            bool carry = false;
            for (uint32_t i = 0; i < n; i++) {
                uint32_t limit = AESL_std::min(u[j+i],v[i]);
                u[j+i] += v[i] + carry;
                carry = u[j+i] < limit || (carry && u[j+i] == limit);
            }
            u[j+n] += carry;
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    } while (--j >= 0);
#pragma line 874 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    if (r) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shift) {
            uint32_t carry = 0;
#pragma empty_line
            for (int i = n-1; i >= 0; i--) {
                r[i] = ((u[i]) >> (shift)) | carry;
                carry = (u[i]) << (32 - shift);
#pragma empty_line
            }
        } else {
            for (int i = n-1; i >= 0; i--) {
                r[i] = u[i];
#pragma empty_line
            }
        }
#pragma empty_line
    }
#pragma empty_line
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    ((lhsWords >= rhsWords && "Fractional result") ? (void)0 : _assert("lhsWords >= rhsWords && \"Fractional result\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 901));
    enum {APINT_BITS_PER_WORD=64};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = rhsWords * 2;
    uint32_t m = (lhsWords * 2) - n;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }
#pragma empty_line
#pragma empty_line
    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = (uint32_t)(tmp & mask);
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;
#pragma empty_line
#pragma empty_line
    memset(__V, 0, (n)*sizeof(uint32_t));
    for (unsigned i = 0; i < rhsWords; ++i) {
        uint64_t tmp = RHS.get_pVal(i);
        __V[i * 2] = (uint32_t)(tmp & mask);
        __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
#pragma empty_line
#pragma empty_line
    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ((n != 0 && "Divide by zero?") ? (void)0 : _assert("n != 0 && \"Divide by zero?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 974));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = (uint32_t)partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = (uint32_t)(partial_dividend / divisor);
                remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {
#pragma empty_line
#pragma empty_line
        KnuthDiv(__U, __V, __Q, __R, m, n);
    }
#pragma empty_line
#pragma empty_line
    if (Quotient) {
#pragma empty_line
        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? (void)0 : _assert("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1018));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    if (Remainder) {
#pragma empty_line
        if (Remainder->BitWidth != RHS.BitWidth) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? (void)0 : _assert("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1042));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    uint32_t rhsWords=1;
    ((lhsWords >= rhsWords && "Fractional result") ? (void)0 : _assert("lhsWords >= rhsWords && \"Fractional result\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1064));
    enum {APINT_BITS_PER_WORD=64};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = 2;
    uint32_t m = (lhsWords * 2) - n;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }
#pragma empty_line
#pragma empty_line
    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = tmp & mask;
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;
#pragma empty_line
#pragma empty_line
    memset(__V, 0, (n)*sizeof(uint32_t));
    __V[0] = RHS & mask;
    __V[1] = (RHS) >> (sizeof(uint32_t)*8);
#pragma empty_line
#pragma empty_line
    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ((n != 0 && "Divide by zero?") ? (void)0 : _assert("n != 0 && \"Divide by zero?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1134));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = partial_dividend / divisor;
                remainder = partial_dividend - (__Q[i] * divisor);
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {
#pragma empty_line
#pragma empty_line
        KnuthDiv(__U, __V, __Q, __R, m, n);
    }
#pragma empty_line
#pragma empty_line
    if (Quotient) {
#pragma empty_line
        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? (void)0 : _assert("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1178));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    if (Remainder) {
#pragma empty_line
        if (Remainder->BitWidth != 64 ) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? (void)0 : _assert("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1202));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> lshr(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.lshr(shiftAmt);
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> shl(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.shl(shiftAmt);
}
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
enum ap_q_mode {
    AP_RND,
    AP_RND_ZERO,
    AP_RND_MIN_INF,
    AP_RND_INF,
    AP_RND_CONV,
    AP_TRN,
    AP_TRN_ZERO
#pragma empty_line
};
enum ap_o_mode {
    AP_SAT,
    AP_SAT_ZERO,
    AP_SAT_SYM,
    AP_WRAP,
    AP_WRAP_SM
};
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
    ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;
#pragma empty_line
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2> struct ap_concat_ref;
#pragma empty_line
#pragma empty_line
    enum {
        MIN_INT_BITS = 1,
#pragma empty_line
        MAX_INT_BITS = (1<<23)-1
#pragma empty_line
    };
#pragma line 1313 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    typedef unsigned long long ap_ulong;
    typedef signed long long ap_slong;
#pragma empty_line
template <int _AP_N8, bool _AP_S> struct valtype;
#pragma empty_line
template<int _AP_N8> struct valtype<_AP_N8, false> {
    typedef uint64_t Type;
};
#pragma empty_line
template<int _AP_N8> struct valtype<_AP_N8, true> {
    typedef int64_t Type;
};
#pragma empty_line
template<> struct valtype<1, false> {
    typedef unsigned char Type;
};
template<> struct valtype<2, false> {
    typedef unsigned short Type;
};
template<> struct valtype<3, false> {
    typedef unsigned int Type;
};
template<> struct valtype<4, false> {
    typedef unsigned int Type;
};
template<> struct valtype<1, true> {
    typedef signed char Type;
};
template<> struct valtype<2, true> {
    typedef short Type;
};
template<> struct valtype<3, true> {
    typedef int Type;
};
template<> struct valtype<4, true> {
    typedef int Type;
};
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> class ap_private <_AP_W, _AP_S, true> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
  typedef typename valtype<(_AP_W+7)/8, _AP_S>::Type ValType;
    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };
    enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
    static const uint64_t not_mask = ~mask;
    static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD-1);
    template<int _AP_W1> struct sign_ext_mask { static const uint64_t mask=~0ULL<<_AP_W1;};
    static const int width = _AP_W;
#pragma empty_line
#pragma empty_line
    enum { BitWidth=_AP_W, _AP_N = 1, };
    ValType VAL;
#pragma line 1403 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    void check_canary() {}
    void set_canary() {}
#pragma empty_line
#pragma empty_line
    inline ValType& get_VAL(void) {
        return VAL;
    }
    inline ValType get_VAL(void) const{
        return VAL;
    }
    inline ValType get_VAL(void) const volatile{
        return VAL;
    }
    inline void set_VAL(uint64_t value) {
        VAL = (ValType)value;
    }
    inline ValType& get_pVal(int i) {
        return VAL;
    }
    inline ValType get_pVal(int i) const{
        return VAL;
    }
    inline const uint64_t* get_pVal() const{
        ((0 && "invalid usage") ? (void)0 : _assert("0 && \"invalid usage\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1426));
        return 0;
    }
    inline ValType get_pVal(int i) const volatile {
        return VAL;
    }
    inline uint64_t* get_pVal() const volatile {
        ((0 && "invalid usage") ? (void)0 : _assert("0 && \"invalid usage\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1433));
        return 0;
    }
    inline void set_pVal(int i, uint64_t value) {
        VAL = (ValType)value;
    }
#pragma empty_line
    inline uint32_t getBitWidth() const {
        return BitWidth;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
    void operator=(const ap_private& RHS) volatile {
#pragma empty_line
        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const ap_private& RHS) {
#pragma empty_line
        VAL = RHS.get_VAL();
        return *this;
    }
#pragma empty_line
    void operator=(const volatile ap_private& RHS) volatile {
#pragma empty_line
        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const volatile ap_private& RHS) {
#pragma empty_line
        VAL = RHS.get_VAL();
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        *this = ap_private<_AP_W2, false>(op2);
        return *this;
    }
#pragma empty_line
private:
    explicit inline ap_private(uint64_t* val):VAL(val[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    inline bool isSingleWord() const { return true; }
#pragma empty_line
    inline void fromString(const char *strStart, uint32_t slen,
                           uint8_t radix) {
#pragma empty_line
        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
#pragma line 1497 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        ,
 1498
#pragma line 1497 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        ))
                                                   ;
        ((strStart && "String is null?") ? (void)0 : _assert("strStart && \"String is null?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1499));
        uint64_t tmpVAL = VAL;
        bool isNeg = false;
        if (*strStart == '-') {
            isNeg = true;
            strStart++;
        }
        switch(radix) {
            case 2:
#pragma empty_line
#pragma empty_line
                for (;*strStart; ++strStart) {
                    (((*strStart=='0'|| *strStart=='1')&&("Wrong binary number")) ? (void)0 : _assert("(*strStart=='0'|| *strStart=='1')&&(\"Wrong binary number\")", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1511));
                    tmpVAL <<=1;
                    tmpVAL |= (*strStart-'0');
                }
                break;
            case 8:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
                sscanf(strStart,"%I64o",&tmpVAL);
#pragma line 1533 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
                break;
            case 10:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
                sscanf(strStart,"%I64u",&tmpVAL);
#pragma line 1551 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
                break;
            case 16:
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
                sscanf(strStart,"%I64x",&tmpVAL);
#pragma line 1569 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
                break;
            default:
                ((true && "Unknown radix") ? (void)0 : _assert("true && \"Unknown radix\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1571));
#pragma empty_line
        }
        VAL = isNeg ? (ValType)(-tmpVAL) : (ValType) (tmpVAL);
#pragma empty_line
        clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    ap_private(const std::string& val, uint8_t radix=2): VAL(0) {
        ((!val.empty() && "String empty?") ? (void)0 : _assert("!val.empty() && \"String empty?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 1581));
        set_canary();
        fromString(val.c_str(), val.size(), radix);
        check_canary();
    }
#pragma empty_line
    ap_private(const char strStart[], uint32_t slen, uint8_t radix) : VAL(0) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }
#pragma empty_line
    ap_private(uint32_t numWords, const uint64_t bigVal[]): VAL(bigVal[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
public:
    inline ap_private() {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
#pragma empty_line
    ap_private(const ap_private& that) : VAL(that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    ap_private(const ap_private<_AP_W, !_AP_S>& that) : VAL(that.get_VAL()) {
        set_canary();
     clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private(const ap_private<_AP_W1, _AP_S1>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private(const volatile ap_private<_AP_W1, _AP_S1>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    explicit ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
#pragma empty_line
        if (pos != std::string::npos)
            str = str.substr(pos);
#pragma empty_line
        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }
#pragma empty_line
    ap_private(const char* val, signed char rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
#pragma empty_line
        if (pos != std::string::npos)
            str = str.substr(pos);
#pragma empty_line
        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }
#pragma empty_line
    ~ap_private() {check_canary();}
#pragma empty_line
    inline bool isNegative() const {
        static const uint64_t sign_mask = 1ULL << (_AP_W-1);
        return _AP_S && (sign_mask & VAL);
    }
#pragma empty_line
    inline bool isPositive() const {
        return !isNegative();
    }
#pragma empty_line
    inline bool isStrictlyPositive() const {
        return !isNegative() && VAL!=0;
    }
#pragma empty_line
    inline bool isAllOnesValue() const {
        return (mask & VAL) == mask;
    }
#pragma empty_line
    inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL == RHS.get_VAL(); }
    inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL == (uint64_t)RHS.get_VAL(); }
#pragma empty_line
    inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
    inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
    inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL != RHS.get_VAL(); }
    inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL != (uint64_t)RHS.get_VAL(); }
    const ap_private operator++() { ++VAL; clearUnusedBits(); return *this; }
    const ap_private operator--(int) {
           ap_private orig(*this);
           --VAL; clearUnusedBits();
           return orig;
    }
    const ap_private operator--() { --VAL; clearUnusedBits(); return *this;}
    inline bool operator !() const { return !VAL;}
#pragma empty_line
    const ap_private operator++(int) {
        ap_private orig(*this);
        VAL++; clearUnusedBits();
        return orig;
    }
#pragma empty_line
    inline ap_private<((64) < (_AP_W + 1) ? (64) : (_AP_W + 1)), true>
                          operator-() const {
        return ap_private<1,false>(0) - (*this);
    }
#pragma empty_line
    inline std::string toString(uint8_t radix, bool wantSigned) const ;
    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }
    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }
    inline void clear() {
        VAL=0;
    }
    inline ap_private& clear(uint32_t bitPosition) { VAL &= ~(1ULL<<(bitPosition)); clearUnusedBits(); return *this;}
#pragma empty_line
    inline ap_private ashr(uint32_t shiftAmt) const {
        if (_AP_S)
            return ap_private((shiftAmt == BitWidth) ? 0 : ((int64_t)VAL) >> (shiftAmt));
        else
            return ap_private((shiftAmt == BitWidth) ? 0 : ((uint64_t)VAL) >> (shiftAmt));
    }
#pragma empty_line
    inline ap_private lshr(uint32_t shiftAmt) const {
        return ap_private((shiftAmt == BitWidth) ? ap_private(0) : ap_private((VAL&mask) >> (shiftAmt)));
    }
#pragma empty_line
    inline ap_private shl(uint32_t shiftAmt) const
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    {
        if (shiftAmt > BitWidth) {
            if (!isNegative())
                return ap_private(0);
            else return ap_private(-1);
        }
        if (shiftAmt == BitWidth) return ap_private(0);
        else return ap_private((VAL) << (shiftAmt));
#pragma empty_line
    }
#pragma empty_line
    inline int64_t getSExtValue() const {
        return VAL;
    }
#pragma empty_line
    inline uint64_t getZExtValue() const {
        return VAL & mask;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = ((val.operator ap_private<_AP_W2, false> ()));
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        check_canary();
    }
#pragma empty_line
    inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
        *this = (op2);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    operator ValType () const {
        return get_VAL();
    }
#pragma empty_line
    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }
#pragma empty_line
    inline int to_char() const {
        return (signed char) get_VAL();
    }
#pragma empty_line
    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }
#pragma empty_line
    inline int to_short() const {
        return (short) get_VAL();
    }
#pragma empty_line
    inline int to_int() const {
#pragma empty_line
        return (int) get_VAL();
    }
#pragma empty_line
    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }
#pragma empty_line
    inline long to_long() const {
        return (long) get_VAL();
    }
#pragma empty_line
    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }
#pragma empty_line
    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }
#pragma empty_line
    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }
#pragma empty_line
    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }
#pragma empty_line
    inline unsigned length() const { return _AP_W; }
#pragma empty_line
    inline bool isMinValue() const { return VAL == 0;}
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)&RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)|RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)^RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)*RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)+RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)-RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
    inline const ap_private& operator<<=(uint32_t shiftAmt) { VAL<<=shiftAmt; clearUnusedBits(); return *this; }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator&(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) & RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret & RHS;
        }
    }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator^(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^ RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret ^ RHS;
        }
    }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator|(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) | RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret | RHS;
        }
    }
#pragma empty_line
    inline ap_private And(const ap_private& RHS) const {
        return ap_private(VAL & RHS.get_VAL());
    }
#pragma empty_line
    inline ap_private Or(const ap_private& RHS) const {
        return ap_private(VAL | RHS.get_VAL());
    }
#pragma empty_line
    inline ap_private Xor(const ap_private& RHS) const {
        return ap_private(VAL ^ RHS.get_VAL());
    }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) * RHS.get_VAL());
            return Result;
        } else {
            typename RType<_AP_W1, _AP_S1>::mult Result(*this);
            Result *= RHS;
            return Result;
        }
    }
#pragma empty_line
    inline ap_private Mul(const ap_private& RHS) const {
        return ap_private(VAL * RHS.get_VAL());
    }
#pragma empty_line
    inline ap_private Add(const ap_private& RHS) const {
        return ap_private(VAL + RHS.get_VAL());
    }
#pragma empty_line
    inline ap_private Sub(const ap_private& RHS) const {
        return ap_private(VAL - RHS.get_VAL());
    }
#pragma empty_line
#pragma empty_line
    inline ap_private& operator&=(uint64_t RHS) { VAL &= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator|=(uint64_t RHS) { VAL |= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator^=(uint64_t RHS){ VAL ^= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator*=(uint64_t RHS){ VAL *= (ValType)RHS; clearUnusedBits(); return *this; }
    inline ap_private& operator+=(uint64_t RHS){ VAL += (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator-=(uint64_t RHS){ VAL -= (ValType)RHS; clearUnusedBits(); return *this; }
#pragma line 1994 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline bool isMinSignedValue() const {
        static const uint64_t min_mask = ~(~0ULL << (_AP_W-1));
        return BitWidth == 1 ? VAL == 1 :
           (ap_private_ops::isNegative<_AP_W>(*this) && ((min_mask & VAL)==0));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::plus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::plus(RType<_AP_W1,_AP_S1>::plus_s ? int64_t(((uint64_t)VAL)+RHS.get_VAL()):uint64_t(((uint64_t)VAL)+RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::plus Result=RHS;
        Result += VAL;
        return Result;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::minus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::minus(int64_t(((uint64_t)VAL)-RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::minus Result=*this;
        Result -= RHS;
        return Result;
    }
#pragma empty_line
    inline ap_private& flip() {
        VAL = (ValType)((~0ULL^VAL)&mask);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    uint32_t countPopulation() const { return ap_private_ops::CountPopulation_64(VAL);}
    uint32_t countLeadingZeros() const {
        int remainder = BitWidth % 64;
        int excessBits = (64 - remainder) % 64;
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
        if (Count)
            Count-=excessBits;
        return AESL_std::min(Count, (uint32_t)_AP_W);
    }
#pragma empty_line
#pragma empty_line
    ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(*this);
        ret = (ret)>>(BitWidth - numBits);
        return ret;
    }
#pragma empty_line
#pragma empty_line
    ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
        ret = (ret)>>(BitWidth - numBits);
        return ret;
#pragma empty_line
    }
#pragma empty_line
    ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
        VAL |= (1ULL << (bitPosition));
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    void set() {
        VAL = (ValType)~0ULL;
        clearUnusedBits();
    }
#pragma empty_line
    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }
#pragma empty_line
    inline void set(const ap_private & val) {
        operator = (val);
    }
#pragma empty_line
    bool operator[](uint32_t bitPosition) const {
        return (((1ULL << (bitPosition)) & VAL) != 0);
    }
#pragma empty_line
    inline void clearUnusedBits(void)
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        VAL = (ValType)(_AP_S ? ((((int64_t)VAL)<<(excess_bits))>> (excess_bits)) : (excess_bits ? (((uint64_t)VAL)<<(excess_bits))>>(excess_bits) : (uint64_t)VAL));
    }
#pragma empty_line
    inline void clearUnusedBitsToZero(void) {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        static uint64_t mask = ~0ULL >> (excess_bits);
        VAL &= mask;
    }
#pragma empty_line
    inline ap_private udiv(const ap_private& RHS) const {
        return ap_private((uint64_t)VAL / RHS.get_VAL());
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return ((uint64_t)(0 -(*this))) / (uint64_t) (0-RHS);
            else
                return 0 -((uint64_t)(0-(*this)) / (uint64_t)(RHS));
        else if (RHS.isNegative())
            return 0 -(this->udiv((ap_private)(0-RHS)));
        return this->udiv(RHS);
    }
#pragma empty_line
    template<bool _AP_S2>
    inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        ((RHS.get_VAL() != 0 && "Divide by 0") ? (void)0 : _assert("RHS.get_VAL() != 0 && \"Divide by 0\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2109));
        return ap_private(((uint64_t)VAL)%((uint64_t)RHS.get_VAL()));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S2>
    inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        if (isNegative()) {
            ap_private lhs = 0 -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = 0 -RHS;
                return 0 -(lhs.urem(rhs));
            } else
                return 0 -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = 0-RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (_AP_W1 <= 64) {
            uint64_t lhsZext = ((uint64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            uint64_t rhsZext = ((uint64_t(RHS.get_VAL())) <<
                                 (64-_AP_W1)) >> (64-_AP_W1);
            return lhsZext < rhsZext;
        } else
            return RHS.uge(*this);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    {
        if (_AP_W1 <= 64) {
            int64_t lhsSext = ((int64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            int64_t rhsSext = ((int64_t(RHS.get_VAL())) << (64-_AP_W1))
                                >> (64-_AP_W1);
            return lhsSext < rhsSext;
        } else
            return RHS.sge(*this);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1> inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS);
    }
#pragma empty_line
    inline ap_private abs() const {
        if (isNegative())
            return -(*this);
        return *this;
    }
#pragma empty_line
    ap_private<_AP_W, false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }
#pragma empty_line
    inline static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        return _AP_W;
    }
#pragma empty_line
    inline uint32_t getActiveBits() const {
        uint32_t bits=_AP_W - countLeadingZeros();
        return bits?bits:1;
    }
#pragma empty_line
    inline double roundToDouble(bool isSigned=false) const {
        return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
    }
#pragma empty_line
#pragma empty_line
    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
    inline bool iszero () const {
        return isMinValue();
    }
#pragma empty_line
    inline bool to_bool() const {
        return !iszero();
    }
#pragma empty_line
#pragma empty_line
    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }
#pragma empty_line
#pragma empty_line
    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2280));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2281));
        flip(i);
    }
#pragma empty_line
#pragma empty_line
    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2287));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2288));
        return operator[](i);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2295));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2296));
        operator = (shl(n) | lshr(_AP_W - n));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2303));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2304));
        operator = (lshr(n) | shl(_AP_W - n));
    }
#pragma empty_line
#pragma empty_line
    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2310));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2311));
        v ? set(i) : clear(i);
    }
#pragma empty_line
#pragma empty_line
    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2317));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2318));
        v ? set(i) : clear(i);
    }
#pragma empty_line
#pragma empty_line
    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2324));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2325));
        return operator [](i);
    }
#pragma empty_line
#pragma empty_line
    inline void b_not() {
        flip();
    }
#pragma line 2352 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod (_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#pragma line 2378 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#pragma line 2397 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const bool op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#pragma line 2439 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const bool op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#pragma line 2473 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator >> (op.get_VAL()); return *this; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline bool operator == (const ap_private<_AP_W1, _AP_S1>& op) const {
        enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32))};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        if (_AP_MAX_W <= 64) {
            return (uint64_t) lhs.get_VAL() ==
                   (uint64_t) rhs.get_VAL();
        } else
            return lhs == rhs;
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
#pragma empty_line
#pragma empty_line
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)
#pragma empty_line
            return lhs.sgt(rhs);
        else
#pragma empty_line
#pragma empty_line
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this>op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)
            return lhs.slt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this<op);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
#pragma empty_line
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (uint32_t index) {
        return ap_bit_ref<_AP_W,_AP_S> (*this, (int)index);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br =operator [] (index);
        return br.to_bool();
    }
#pragma empty_line
    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }
#pragma empty_line
    inline bool bit (int index) const {
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_private<_AP_W, _AP_S>*>(this), index);
        return br.to_bool();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool and_reduce() const {
        return (VAL & mask) == mask;
    }
#pragma empty_line
    inline bool nand_reduce() const {
        return (VAL & mask) != mask;
    }
#pragma empty_line
    inline bool or_reduce() const {
        return (bool)VAL;
    }
#pragma empty_line
    inline bool nor_reduce() const {
        return VAL==0;
    }
#pragma empty_line
    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }
#pragma empty_line
    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }
#pragma empty_line
    inline std::string to_string(uint8_t radix=2, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};
#pragma empty_line
template<int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
#pragma line 2791 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ,
 2792
#pragma line 2791 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"
    };
    std::string result;
    if (radix != 10) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (*this == (uint64_t)(0)) {
#pragma empty_line
#pragma empty_line
            switch (radix) {
                case 2: result = "0b0"; break;
                case 8: result = "0o0"; break;
                case 16: result = "0x0"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2810));
            }
        } else {
            ap_private<_AP_W, false, true> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
                tmp.flip();
                tmp++;
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2830));
            }
            insert_at += 2;
#pragma empty_line
#pragma empty_line
            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false, true> zero(0);
            unsigned bits = 0;
            bool msb = false;
            while (tmp.ne(zero)) {
                unsigned digit = (unsigned)(tmp.get_VAL() & mask);
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                bits++;
                msb = (digit >> (shift - 1)) == 1;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero && msb)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }
#pragma empty_line
    ap_private<_AP_W, false, true> tmp(*this);
    ap_private<6, false, true> divisor(radix);
    ap_private<_AP_W, _AP_S, true> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false, true>(0ULL))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false, true> APdigit = tmp%divisor;
        ap_private<_AP_W, false, true> tmp2 = tmp/divisor;
        uint32_t digit = (uint32_t)(APdigit.getZExtValue());
        ((digit < radix && "divide failed") ? (void)0 : _assert("digit < radix && \"divide failed\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2873));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }
    return result;
#pragma empty_line
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
class ap_private <_AP_W, _AP_S, false> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
    enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
    static const int width = _AP_W;
#pragma empty_line
private:
#pragma line 2900 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private(uint32_t numWords, const uint64_t bigVal[]) {
        set_canary();
        ((bigVal && "Null pointer detected!") ? (void)0 : _assert("bigVal && \"Null pointer detected!\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2902));
        {
#pragma empty_line
            memset(pVal, 0, _AP_N * sizeof(uint64_t));
#pragma empty_line
#pragma empty_line
            uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);
#pragma empty_line
            memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
            if (words >= _AP_W)
                clearUnusedBits();
#pragma empty_line
        }
        check_canary();
    }
#pragma line 2927 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private(const std::string& val, uint8_t radix=2) {
        set_canary();
        ((!val.empty() && "The input string is empty.") ? (void)0 : _assert("!val.empty() && \"The input string is empty.\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 2929));
        const char *c_str = val.c_str();
        fromString(c_str, val.size(), radix);
        check_canary();
    }
#pragma line 2946 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }
#pragma empty_line
    inline void report() {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
            if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
                fprintf((&_iob[2]), "[E] ap_%sint<%d>: Bitwidth exceeds the "
                        "default max value %d. Please use macro "
                        "AP_INT_MAX_W to set a larger max value.\n",
                        _AP_S?"":"u", _AP_W,
                        ((1024 + 1023) / 1024) * 1024);
                exit(1);
            }
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    uint64_t pVal[_AP_N];
#pragma line 2984 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    void check_canary() {}
    void set_canary() {}
#pragma empty_line
#pragma empty_line
public:
    typedef typename valtype<8, _AP_S>::Type ValType;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct ap_fixed_base;
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };
#pragma empty_line
#pragma empty_line
   inline uint64_t& get_VAL(void) {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const volatile{
        return pVal[0];
    }
    inline void set_VAL(uint64_t value) {
        pVal[0] = value;
    }
    inline uint64_t& get_pVal(int index) {
        return pVal[index];
    }
    inline uint64_t* get_pVal() {
        return pVal;
    }
    inline const uint64_t* get_pVal() const{
        return pVal;
    }
    inline uint64_t get_pVal(int index) const{
        return pVal[index];
    }
    inline uint64_t* get_pVal() const volatile {
        return pVal;
    }
    inline uint64_t get_pVal(int index) const volatile {
        return pVal[index];
    }
    inline void set_pVal(int i, uint64_t value) {
        pVal[i] = value;
    }
#pragma empty_line
#pragma empty_line
    enum {
        APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
        APINT_WORD_SIZE = sizeof(uint64_t)
    };
#pragma empty_line
    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
#pragma empty_line
public:
#pragma empty_line
    ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();
        check_canary();
    }
#pragma empty_line
    ap_private(const char* val, int rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();
#pragma empty_line
        report();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        report();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
       *this = ((val.operator ap_private<_AP_W2, false> ()));
        report();
        check_canary();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        report();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private(const volatile ap_private<_AP_W1, _AP_S1>& that) {
        set_canary();
        operator = (const_cast<const ap_private<_AP_W1, _AP_S1>& >(that));
        check_canary();
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private(const ap_private<_AP_W1, _AP_S1>& that) {
        set_canary();
        operator = (that);
        check_canary();
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    explicit ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
        set_canary();
        static const uint64_t that_sign_ext_mask = (_AP_W1==APINT_BITS_PER_WORD)?0:~0ULL>>(_AP_W1%APINT_BITS_PER_WORD)<<(_AP_W1%APINT_BITS_PER_WORD);
        if (that.isNegative()) {
            pVal[0] = that.get_VAL()|that_sign_ext_mask;
            memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1));
        } else {
            pVal[0] = that.get_VAL();
            memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1));
        }
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    ap_private(const ap_private& that) {
        set_canary();
        memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ~ap_private() {check_canary();}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private(){
        set_canary();
        clearUnusedBits();
        check_canary();
    }
#pragma empty_line
    ap_private(uint64_t* val, uint32_t bits=_AP_W) {((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3188));}
    ap_private(const uint64_t *const val, uint32_t bits) {((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3189));}
#pragma line 3214 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private(int val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(bool val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(signed char val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned char val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(short val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned short val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned int val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned long long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(long long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(float val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(double val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
#pragma line 3236 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline bool isSingleWord() const {
        return false;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static uint32_t whichWord(uint32_t bitPosition) {
#pragma empty_line
        return (bitPosition) >> 6;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static uint32_t whichBit(uint32_t bitPosition) {
#pragma empty_line
        return bitPosition & 0x3f;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static uint64_t maskBit(uint32_t bitPosition) {
        return 1ULL << (whichBit(bitPosition));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint64_t getWord(uint32_t bitPosition) const {
        return pVal[whichWord(bitPosition)];
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void clearUnusedBits(void)
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    {
        pVal[_AP_N-1] = _AP_S ? ((((int64_t)pVal[_AP_N-1])<<(excess_bits))>> excess_bits) : (excess_bits ? ((pVal[_AP_N-1])<<(excess_bits))>>(excess_bits) : pVal[_AP_N-1]);
    }
#pragma empty_line
    inline void clearUnusedBitsToZero(void) {
        pVal[_AP_N-1] &= mask;
    }
#pragma empty_line
    inline void clearUnusedBitsToOne(void) {
        pVal[_AP_N-1] |= mask;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void fromString(const char *str, uint32_t slen,
            uint8_t radix) {
        enum { numbits=_AP_W};
#pragma empty_line
        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
#pragma line 3297 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        ,
 3298
#pragma line 3297 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
        ))
                                                   ;
        ((str && "String is null?") ? (void)0 : _assert("str && \"String is null?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3299));
        bool isNeg = str[0] == '-';
        if (isNeg)
            str++, slen--;
#pragma empty_line
#pragma empty_line
        while(*str == '0' && *(str+1) != '\0') {str++; slen--;}
        (((slen <= numbits || radix != 2) && "Insufficient bit width") ? (void)0 : _assert("(slen <= numbits || radix != 2) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3306));
        ((((slen - 1)*3 <= numbits || radix != 8) && "Insufficient bit width") ? (void)0 : _assert("((slen - 1)*3 <= numbits || radix != 8) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3307));
        ((((slen - 1)*4 <= numbits || radix != 16) && "Insufficient bit width") ? (void)0 : _assert("((slen - 1)*4 <= numbits || radix != 16) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3308));
        (((((slen -1)*64)/22 <= numbits || radix != 10) && "Insufficient bit width") ? (void)0 : _assert("(((slen -1)*64)/22 <= numbits || radix != 10) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3309));
#pragma empty_line
        memset(pVal, 0, _AP_N * sizeof(uint64_t));
#pragma empty_line
#pragma empty_line
        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
        uint64_t bigVal[_AP_N];
        memset(bigVal, 0, _AP_N * sizeof(uint64_t));
        ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
        ap_private<_AP_W, _AP_S> apradix(radix);
#pragma empty_line
#pragma empty_line
        for (unsigned i = 0; i < slen; i++) {
#pragma empty_line
            uint32_t digit = 0;
            char cdigit = str[i];
            if (radix == 16) {
#pragma empty_line
#pragma empty_line
                if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                    ((0 && "Invalid hex digit in string") ? (void)0 : _assert("0 && \"Invalid hex digit in string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3332));
                if (((cdigit) >= '0' && (cdigit) <= '9'))
                    digit = cdigit - '0';
                else if (cdigit >= 'a')
                    digit = cdigit - 'a' + 10;
                else if (cdigit >= 'A')
                    digit = cdigit - 'A' + 10;
                else
                    ((0 && "huh? we shouldn't get here") ? (void)0 : _assert("0 && \"huh? we shouldn't get here\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3340));
            } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
                digit = cdigit - '0';
            } else if (cdigit != '\0'){
                ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3344));
            }
#pragma empty_line
#pragma empty_line
#pragma empty_line
            if (shift)
                *this <<= shift;
            else
                *this *= apradix;
#pragma empty_line
#pragma empty_line
            apdigit.set_VAL(digit);
            *this += apdigit;
        }
#pragma empty_line
        if (isNeg) {
            (*this)--;
            this->flip();
        }
        clearUnusedBits();
    }
#pragma empty_line
    inline ap_private read() volatile {
        return *this;
    }
#pragma empty_line
    inline void write(const ap_private& op2) volatile {
        *this = (op2);
    }
#pragma empty_line
    operator ValType () const {
        return get_VAL();
    }
#pragma empty_line
    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }
#pragma empty_line
    inline int to_char() const {
        return (signed char) get_VAL();
    }
#pragma empty_line
    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }
#pragma empty_line
    inline int to_short() const {
        return (short) get_VAL();
    }
#pragma empty_line
    inline int to_int() const {
        return (int) get_VAL();
    }
#pragma empty_line
    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }
#pragma empty_line
    inline long to_long() const {
        return (long) get_VAL();
    }
#pragma empty_line
    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }
#pragma empty_line
    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }
#pragma empty_line
    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }
#pragma empty_line
    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }
#pragma empty_line
    inline unsigned length() const { return _AP_W; }
#pragma empty_line
#pragma empty_line
    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
    inline bool iszero () const {
        return isMinValue();
    }
#pragma empty_line
    inline bool to_bool() const {
        return !iszero();
    }
#pragma empty_line
#pragma empty_line
    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }
#pragma empty_line
#pragma empty_line
    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3462));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3463));
        flip(i);
    }
#pragma empty_line
#pragma empty_line
    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3469));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3470));
        return operator[](i);
    }
#pragma empty_line
#pragma empty_line
    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3476));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3477));
        v ? set(i) : clear(i);
    }
#pragma empty_line
#pragma empty_line
    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3483));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3484));
        v ? set(i) : clear(i);
    }
#pragma empty_line
    inline ap_private& set(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    inline void set() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] = ~0ULL;
        clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    inline bool get (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3502));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3503));
        return operator [](i);
    }
#pragma empty_line
#pragma empty_line
    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3509));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3510));
        return operator [](i);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3517));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3518));
        operator = (shl(n) | lshr(_AP_W - n));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3525));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3526));
        operator = (lshr(n) | shl(_AP_W - n));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private& clear(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
    void clear() {
        memset(pVal, 0, _AP_N * APINT_WORD_SIZE);
    }
#pragma empty_line
#pragma empty_line
    ap_private& flip() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] ^= ~0ULL;
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private& flip(uint32_t bitPosition) {
        ((bitPosition < BitWidth && "Out of the bit-width range!") ? (void)0 : _assert("bitPosition < BitWidth && \"Out of the bit-width range!\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 3555));
        if ((*this)[bitPosition]) clear(bitPosition);
        else set(bitPosition);
        return *this;
    }
#pragma empty_line
#pragma empty_line
    inline void b_not() {
        flip();
    }
#pragma empty_line
    ap_private getLoBits(uint32_t numBits) const {
        return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
               _AP_W - numBits);
    }
#pragma empty_line
    ap_private getHiBits(uint32_t numBits) const {
        return ap_private_ops::lshr(*this, _AP_W - numBits);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }
#pragma line 3617 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {
#pragma empty_line
        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
        if (!lhsWords) {
#pragma empty_line
            return *this;
        }
#pragma empty_line
        ap_private dupRHS = RHS;
#pragma empty_line
        uint32_t rhsBits = dupRHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
        if (!rhsWords) {
#pragma empty_line
            clear();
            return *this;
        }
#pragma empty_line
#pragma empty_line
        uint32_t destWords = rhsWords + lhsWords;
        uint64_t *dest = (uint64_t*) malloc(destWords*sizeof(uint64_t));
#pragma empty_line
#pragma empty_line
        ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords, destWords);
#pragma empty_line
#pragma empty_line
        clear();
        uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;
#pragma empty_line
        memcpy(pVal, dest, wordsToCopy* APINT_WORD_SIZE);
#pragma empty_line
        uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
        for (int i=wordsToCopy; i<_AP_N; i++)
            pVal[i]=ext;
        clearUnusedBits();
#pragma empty_line
        free(dest);
        return *this;
    }
#pragma line 3697 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#pragma line 3731 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator | (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] | ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator & (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] & ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^ (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] ^ ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1,_AP_S1>::plus Result, lhs(*this), rhs(RHS);
        const int Result_AP_N = (RType<_AP_W1,_AP_S1>::plus_w + 63) / 64;
        ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(), Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
        Result.clearUnusedBits();
        return Result;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1,_AP_S1>::minus Result, lhs(*this), rhs(RHS);
        const int Result_AP_N = (RType<_AP_W1,_AP_S1>::minus_w + 63) / 64;
        ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(), Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
        Result.clearUnusedBits();
        return Result;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1, _AP_S1>::mult temp = *this;
        temp *= RHS;
        return temp;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs= op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod(_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#pragma line 3789 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const bool op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#pragma line 3833 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const bool op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#pragma line 3880 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >> (op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >> (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator >> (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator << (op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator << (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator << (op); return *this; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    bool operator==(const ap_private& RHS) const {
#pragma empty_line
        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();
#pragma empty_line
#pragma empty_line
        if (n1 != n2)
            return false;
#pragma empty_line
#pragma empty_line
        if (n1 <= APINT_BITS_PER_WORD)
            return pVal[0] == RHS.get_pVal(0);
#pragma empty_line
#pragma empty_line
        for (int i = whichWord(n1 - 1); i >= 0; --i)
            if (pVal[i] != RHS.get_pVal(i))
                return false;
        return true;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        return lhs==rhs;
    }
#pragma empty_line
    bool operator==(uint64_t Val) const {
        uint32_t n = getActiveBits();
        if (n <= APINT_BITS_PER_WORD)
            return pVal[0] == Val;
        else
            return false;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }
#pragma empty_line
    template<bool _AP_S1>
    inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }
#pragma empty_line
    inline bool operator!=(uint64_t Val) const {
        return !((*this) == Val);
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this>op);
    }
#pragma empty_line
    inline bool operator <(const ap_private& op) const {
        return _AP_S ? slt(op):ult(op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this<op);
    }
#pragma empty_line
    inline bool operator >(const ap_private& op) const {
        return _AP_S ? sgt(op):ugt(op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
#pragma empty_line
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }
#pragma empty_line
    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private*>(this), Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }
#pragma empty_line
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (uint32_t index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br =operator [] (index);
        return br.to_bool();
    }
#pragma empty_line
    inline bool operator [](uint32_t bitPosition) const {
      return (maskBit(bitPosition) & (pVal[whichWord(bitPosition)])) != 0;
    }
#pragma empty_line
    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }
#pragma empty_line
    inline bool bit (int index) const {
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_private<_AP_W, _AP_S>*>(this), index);
        return br.to_bool();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }
#pragma empty_line
    inline ap_private<_AP_W,false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }
#pragma empty_line
    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isNegative() const {
#pragma empty_line
        enum {shift = (_AP_W-APINT_BITS_PER_WORD*(_AP_N-1)-1)};
        static const uint64_t mask = 1ULL << (shift);
        return _AP_S && (pVal[_AP_N-1]&mask);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isPositive() const {
        return !isNegative();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isStrictlyPositive() const {
        return isPositive() && (*this) != 0;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isAllOnesValue() const {
        return countPopulation() == _AP_W;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isMaxValue() const {
        return countPopulation() == _AP_W;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isMaxSignedValue() const {
        return !isNegative() && countPopulation() == _AP_W - 1;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isMinValue() const {
        return countPopulation() == 0;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool isMinSignedValue() const {
        return isNegative() && countPopulation() == 1;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline const uint64_t* getRawData() const {
        return &pVal[0];
    }
#pragma line 4301 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private sqrt() const {
#pragma empty_line
#pragma empty_line
        uint32_t magnitude = getActiveBits();
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (magnitude <= 5) {
            static const uint8_t results[32] = {
                            0,
                            1, 1,
                            2, 2, 2, 2,
                            3, 3, 3, 3, 3, 3,
                            4, 4, 4, 4, 4, 4, 4, 4,
                            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                            6
            };
            return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (magnitude < 52) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
            return ap_private<_AP_W, _AP_S>(
                    uint64_t(::round(::sqrt(double(get_VAL())))));
#pragma empty_line
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        uint32_t nbits = BitWidth, i = 4;
        ap_private<_AP_W, _AP_S> testy(16);
        ap_private<_AP_W, _AP_S> x_old( 1);
        ap_private<_AP_W, _AP_S> x_new(0);
        ap_private<_AP_W, _AP_S> two( 2);
#pragma empty_line
#pragma empty_line
        for ( ; ; i += 2, testy = testy.shl(2))
            if (i >= nbits || this->ule(testy)) {
                x_old = x_old.shl(i / 2);
                break;
            }
#pragma empty_line
#pragma empty_line
        for ( ; ; ) {
            x_new = (this->udiv(x_old) + x_old).udiv(two);
            if (x_old.ule(x_new))
                break;
            x_old = x_new;
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        ap_private<_AP_W, _AP_S> square(x_old * x_old);
        ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old +1));
        if (this->ult(square))
            return x_old;
        else if (this->ule(nextSquare)) {
            ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
            ap_private<_AP_W, _AP_S> offset(*this - square);
            if (offset.ult(midpoint))
                return x_old;
            else
                return x_old + 1;
        } else
            ((0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation") ? (void)0 : _assert("0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4380));
        return x_old + 1;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private& operator=(const ap_private& RHS) {
        if (this != &RHS)
            memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
        return *this;
    }
    inline ap_private& operator=(const volatile ap_private& RHS) {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
        return *this;
    }
    inline void operator=(const ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }
    inline void operator=(const volatile ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }
#pragma line 4464 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline const ap_private operator++(int) {
        ap_private API(*this);
        ++(*this);
        return API;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private& operator++() {
        ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline const ap_private operator--(int) {
        ap_private API(*this);
        --(*this);
        return API;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private& operator--() {
        ap_private_ops::sub_1(pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private<_AP_W + !_AP_S, true> operator~() const {
        ap_private<_AP_W + !_AP_S, true> Result(*this);
        Result.flip();
        return Result;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline typename RType<1,false>::minus operator-() const {
        return ap_private<1,false>(0) - (*this);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool operator !() const {
        for (int i = 0; i < _AP_N; ++i)
            if (pVal[i])
                return false;
        return true;
    }
#pragma empty_line
    template<bool _AP_S1>
    inline ap_private<_AP_W, _AP_S||_AP_S1> And(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator&(RHS);
    }
    template<bool _AP_S1>
    inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator|(RHS);
    }
    template<bool _AP_S1>
    ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator^(RHS);
    }
#pragma empty_line
    ap_private Mul(const ap_private& RHS) const {
        ap_private Result(*this);
        Result *= RHS;
        return Result;
    }
#pragma empty_line
    ap_private Add(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }
#pragma empty_line
    ap_private Sub(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private ashr(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? (void)0 : _assert("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4556));
#pragma empty_line
        if (shiftAmt == 0)
            return *this;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shiftAmt == BitWidth) {
            if (isNegative())
                return ap_private(-1);
            else
                return ap_private(0);
        }
#pragma empty_line
#pragma empty_line
        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();
#pragma empty_line
#pragma empty_line
        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
        uint32_t breakWord = _AP_N - 1 - offset;
        uint32_t bitsInWord = whichBit(BitWidth);
        if (bitsInWord == 0)
            bitsInWord = APINT_BITS_PER_WORD;
#pragma empty_line
#pragma empty_line
        if (wordShift == 0) {
#pragma empty_line
            for (uint32_t i = 0; i <= breakWord; ++i)
                val[i] = pVal[i+offset];
#pragma empty_line
#pragma empty_line
            if (isNegative())
                if (bitsInWord < APINT_BITS_PER_WORD)
                    val[breakWord] |= ~0ULL << (bitsInWord);
        } else {
#pragma empty_line
            for (uint32_t i = 0; i < breakWord; ++i) {
#pragma empty_line
#pragma empty_line
                val[i] = ((pVal[i+offset]) >> (wordShift));
                val[i] |= ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));
            }
#pragma empty_line
#pragma empty_line
#pragma empty_line
            val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);
#pragma empty_line
#pragma empty_line
#pragma empty_line
            if (isNegative()) {
                if (wordShift > bitsInWord) {
                    if (breakWord > 0)
                        val[breakWord-1] |=
                            ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
                    val[breakWord] |= ~0ULL;
                } else
                    val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
            }
        }
#pragma empty_line
#pragma empty_line
        uint64_t fillValue = (isNegative() ? ~0ULL : 0);
        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = fillValue;
        Retval.clearUnusedBits();
        return Retval;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private lshr(uint32_t shiftAmt) const {
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shiftAmt == BitWidth)
            return ap_private(0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shiftAmt == 0)
            return *this;
#pragma empty_line
#pragma empty_line
        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();
#pragma empty_line
#pragma empty_line
        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = _AP_N-1; i >= 0; --i) {
                val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
                carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }
#pragma empty_line
#pragma empty_line
        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
#pragma empty_line
#pragma empty_line
        if (wordShift == 0) {
            for (uint32_t i = 0; i < _AP_N - offset; ++i)
                val[i] = pVal[i+offset];
            for (uint32_t i = _AP_N-offset; i < _AP_N; i++)
                val[i] = 0;
            Retval.clearUnusedBits();
            return Retval;
        }
#pragma empty_line
#pragma empty_line
        uint32_t breakWord = _AP_N - offset -1;
        for (uint32_t i = 0; i < breakWord; ++i)
            val[i] = ((pVal[i+offset]) >> (wordShift)) |
                ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));
#pragma empty_line
        val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);
#pragma empty_line
#pragma empty_line
        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private shl(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? (void)0 : _assert("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4689));
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shiftAmt == BitWidth)
            return ap_private(0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (shiftAmt == 0)
            return *this;
#pragma empty_line
#pragma empty_line
        ap_private Retval(0);
        uint64_t* val = Retval.get_pVal();
#pragma empty_line
        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = 0; i < _AP_N; i++) {
                val[i] = ((pVal[i]) << (shiftAmt)) | carry;
                carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }
#pragma empty_line
#pragma empty_line
        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
#pragma empty_line
#pragma empty_line
        if (wordShift == 0) {
            for (uint32_t i = 0; i < offset; i++)
                val[i] = 0;
            for (int i = offset; i < _AP_N; i++)
                val[i] = pVal[i-offset];
            Retval.clearUnusedBits();
            return Retval;
        }
#pragma empty_line
#pragma empty_line
        uint32_t i = _AP_N - 1;
        for (; i > offset; --i)
            val[i] = (pVal[i-offset]) << (wordShift) |
                (pVal[i-offset-1]) >> (APINT_BITS_PER_WORD - wordShift);
        val[offset] = (pVal[0]) << (wordShift);
        for (i = 0; i < offset; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }
#pragma empty_line
    inline ap_private rotl(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;
#pragma empty_line
        ap_private hi(*this);
        ap_private lo(*this);
        hi.shl(rotateAmt);
        lo.lshr(BitWidth - rotateAmt);
        return hi | lo;
    }
#pragma empty_line
    inline ap_private rotr(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;
#pragma empty_line
        ap_private hi(*this);
        ap_private lo(*this);
        lo.lshr(rotateAmt);
        hi.shl(BitWidth - rotateAmt);
        return hi | lo;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private udiv(const ap_private& RHS) const {
#pragma empty_line
        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Divided by zero???") ? (void)0 : _assert("rhsWords && \"Divided by zero???\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4772));
        uint32_t lhsBits = this->getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);
#pragma empty_line
#pragma empty_line
        if (!lhsWords)
#pragma empty_line
            return ap_private(0);
        else if (lhsWords < rhsWords || this->ult(RHS)) {
#pragma empty_line
            return ap_private(0);
        } else if (*this == RHS) {
#pragma empty_line
            return ap_private(1);
        } else if (lhsWords == 1 && rhsWords == 1) {
#pragma empty_line
            return ap_private(this->pVal[0] / RHS.get_pVal(0));
        }
#pragma empty_line
#pragma empty_line
        ap_private Quotient(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient, (ap_private*)0);
        return Quotient;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return (-(*this)).udiv(-RHS);
            else
                return -((-(*this)).udiv(RHS));
        else if (RHS.isNegative())
            return -(this->udiv((ap_private)(-RHS)));
        return this->udiv(RHS);
    }
#pragma line 4817 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ap_private urem(const ap_private& RHS) const {
#pragma empty_line
        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);
#pragma empty_line
#pragma empty_line
        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Performing remainder operation by zero ???") ? (void)0 : _assert("rhsWords && \"Performing remainder operation by zero ???\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4825));
#pragma empty_line
#pragma empty_line
        if (lhsWords == 0) {
#pragma empty_line
            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {
#pragma empty_line
            return *this;
        } else if (*this == RHS) {
#pragma empty_line
            return ap_private(0);
        } else if (lhsWords == 1) {
#pragma empty_line
            return ap_private(pVal[0] % RHS.get_pVal(0));
        }
#pragma empty_line
#pragma empty_line
        ap_private Remainder(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0), &Remainder);
        return Remainder;
    }
#pragma empty_line
    ap_private urem(uint64_t RHS) const {
#pragma empty_line
        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);
#pragma empty_line
        uint32_t rhsWords = 1;
        ((rhsWords && "Performing remainder operation by zero ???") ? (void)0 : _assert("rhsWords && \"Performing remainder operation by zero ???\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4854));
#pragma empty_line
        if (lhsWords == 0) {
#pragma empty_line
            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {
#pragma empty_line
            return *this;
        } else if (*this == RHS) {
#pragma empty_line
            return ap_private(0);
        } else if (lhsWords == 1) {
#pragma empty_line
            return ap_private(pVal[0] % RHS);
        }
#pragma empty_line
#pragma empty_line
        ap_private Remainder(0);
        divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
        return Remainder;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private srem(const ap_private& RHS) const {
        if (isNegative()) {
            ap_private lhs = -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = -RHS;
                return -(lhs.urem(rhs));
            } else
                return -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = -RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private srem(int64_t RHS) const {
        if (isNegative())
            if (RHS<0)
                return -((-(*this)).urem(-RHS));
            else
                return -((-(*this)).urem(RHS));
        else if (RHS<0)
            return this->urem(-RHS);
        return this->urem(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool ne(const ap_private<_AP_W, _AP_S1> &RHS) const {
        return !((*this) == RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {
#pragma empty_line
        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();
#pragma empty_line
#pragma empty_line
        if (n1 < n2)
            return true;
#pragma empty_line
#pragma empty_line
        if (n2 < n1)
            return false;
#pragma empty_line
#pragma empty_line
        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS.get_pVal(0);
#pragma empty_line
#pragma empty_line
        uint32_t topWord = whichWord(AESL_std::max(n1,n2)-1);
        for (int i = topWord; i >= 0; --i) {
            if (pVal[i] > RHS.get_pVal(i))
                return false;
            if (pVal[i] < RHS.get_pVal(i))
                return true;
        }
        return false;
    }
#pragma empty_line
    inline bool ult(uint64_t RHS) const {
#pragma empty_line
        uint32_t n1 = getActiveBits();
        uint32_t n2 = 64 - ap_private_ops::CountLeadingZeros_64(RHS);
#pragma empty_line
#pragma empty_line
        if (n1 < n2)
            return true;
#pragma empty_line
#pragma empty_line
        if (n2 < n1)
            return false;
#pragma empty_line
#pragma empty_line
        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS;
        ((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 4973));
    }
#pragma empty_line
    template<bool _AP_S1>
    inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        ap_private lhs(*this);
        ap_private<_AP_W, _AP_S1> rhs(RHS);
        bool lhsNeg = isNegative();
        bool rhsNeg = rhs.isNegative();
        if (lhsNeg) {
#pragma empty_line
            lhs.flip();
            lhs++;
        }
        if (rhsNeg) {
#pragma empty_line
            rhs.flip();
            rhs++;
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (lhsNeg)
            if (rhsNeg)
                return lhs.ugt(rhs);
            else
                return true;
        else if (rhsNeg)
            return false;
        else
            return lhs.ult(rhs);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
        return !ult(RHS);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<bool _AP_S1>
    inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS);
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private SignExtend request") ? (void)0 : _assert("_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5063));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? (void)0 : _assert("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5064));
#pragma empty_line
        if (!that.isNegative()) {
            cpZext(that);
            return;
        }
#pragma empty_line
#pragma empty_line
        enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD};
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
#pragma empty_line
        if (_AP_N1 == _AP_N) {
            enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};
#pragma empty_line
            static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
            for (int i = 0; i < _AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            pVal[_AP_N-1] |= mask;
            return;
        }
#pragma empty_line
        enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};
#pragma empty_line
        static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
        int i;
        for (i = 0; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        pVal[i - 1] |= mask;
        for (; i < _AP_N-1; i++)
            pVal[i] = ~0ULL;
        pVal[i] = ~0ULL;
        clearUnusedBits();
        return;
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W1, bool _AP_S1>
    void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request") ? (void)0 : _assert("_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5102));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? (void)0 : _assert("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5103));
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        int i = 0;
        for (; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        for (; i < _AP_N; ++i)
            pVal[i] = 0;
        clearUnusedBits();
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpZext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i]=that.get_pVal(i);
            clearUnusedBits();
        }
    }
#pragma empty_line
    template<int _AP_W1, bool _AP_S1>
    void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpSext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            clearUnusedBits();
        }
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t getBitWidth() const {
        return BitWidth;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t getNumWords() const {
        return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t getActiveBits() const {
        uint32_t bits=BitWidth - countLeadingZeros();
        return bits?bits:1;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint64_t getZExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for uint64_t") ? (void)0 : _assert("getActiveBits() <= 64 && \"Too many bits for uint64_t\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5165));
        return *pVal;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline int64_t getSExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for int64_t") ? (void)0 : _assert("getActiveBits() <= 64 && \"Too many bits for int64_t\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5174));
        return int64_t(pVal[0]);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        ((str != 0 && "Invalid value string") ? (void)0 : _assert("str != 0 && \"Invalid value string\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5182));
        ((slen > 0 && "Invalid string length") ? (void)0 : _assert("slen > 0 && \"Invalid string length\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5183));
#pragma empty_line
#pragma empty_line
        uint32_t isNegative = str[0] == '-';
        if (isNegative) {
            slen--;
            str++;
        }
#pragma empty_line
#pragma empty_line
        if (radix == 2)
            return slen + isNegative;
        if (radix == 8)
            return slen * 3 + isNegative;
        if (radix == 16)
            return slen * 4 + isNegative;
#pragma empty_line
#pragma empty_line
        ((radix == 10 && "Invalid radix") ? (void)0 : _assert("radix == 10 && \"Invalid radix\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5201));
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        return isNegative + slen * 4;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t countLeadingZeros() const {
        enum { msw_bits = (BitWidth % APINT_BITS_PER_WORD)?(BitWidth % APINT_BITS_PER_WORD):APINT_BITS_PER_WORD,
            excessBits = APINT_BITS_PER_WORD - msw_bits };
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N-1]);
        if (Count>=excessBits)
            Count -= excessBits;
        if (!pVal[_AP_N-1]) {
            for (int i = _AP_N-1 ; i ; --i) {
                if (!pVal[i-1])
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += ap_private_ops::CountLeadingZeros_64(pVal[i-1]);
                    break;
                }
            }
        }
        return Count;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t countLeadingOnes() const {
        if (isSingleWord())
            return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);
#pragma empty_line
        uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
        uint32_t shift = (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
        int i = _AP_N - 1;
        uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
        if (Count == highWordBits) {
            for (i--; i >= 0; --i) {
                if (get_pVal(i) == ~0ULL)
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += countLeadingOnes_64(get_pVal(i), 0);
                    break;
                }
            }
        }
        return Count;
    }
#pragma line 5269 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    inline uint32_t countTrailingZeros() const {
        uint32_t Count = 0;
        uint32_t i = 0;
        for (; i < _AP_N && get_pVal(i) == 0; ++i)
            Count += APINT_BITS_PER_WORD;
        if (i < _AP_N)
            Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
        return AESL_std::min(Count, BitWidth);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline uint32_t countPopulation() const {
        uint32_t Count = 0;
        for (int i = 0; i<_AP_N-1 ; ++i)
            Count += ap_private_ops::CountPopulation_64(pVal[i]);
        Count += ap_private_ops::CountPopulation_64(pVal[_AP_N-1]&mask);
        return Count;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline std::string toString(uint8_t radix, bool wantSigned) const
        ;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }
#pragma empty_line
#pragma empty_line
    inline double roundToDouble(bool isSigned) const {
#pragma empty_line
#pragma empty_line
        if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
            uint64_t val = pVal[0];
            if (isSigned) {
                int64_t sext = ((int64_t(val)) << (64-BitWidth)) >> (64-BitWidth);
                return double(sext);
            } else
                return double(val);
        }
#pragma empty_line
#pragma empty_line
        bool isNeg = isSigned ? (*this)[BitWidth-1] : false;
#pragma empty_line
#pragma empty_line
        ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));
#pragma empty_line
#pragma empty_line
        uint32_t n = Tmp.getActiveBits();
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        uint64_t exp = n;
#pragma empty_line
#pragma empty_line
        if (exp > 1023) {
            if (!isSigned || !isNeg)
                return std::numeric_limits<double>::infinity();
            else
                return -std::numeric_limits<double>::infinity();
        }
        exp += 1023;
#pragma empty_line
#pragma empty_line
#pragma empty_line
        uint64_t mantissa;
        unsigned hiWord = whichWord(n-1);
        if (hiWord == 0) {
            mantissa = Tmp.get_pVal(0);
            if (n > 52)
                (mantissa) >>= (n - 52);
        } else {
            ((hiWord > 0 && "High word is negative?") ? (void)0 : _assert("hiWord > 0 && \"High word is negative?\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5362));
            uint64_t hibits = (Tmp.get_pVal(hiWord)) << (52 - n % APINT_BITS_PER_WORD);
            uint64_t lobits = (Tmp.get_pVal(hiWord-1)) >> (11 + n % APINT_BITS_PER_WORD);
            mantissa = hibits | lobits;
        }
#pragma empty_line
#pragma empty_line
        uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
        union {
            double __D;
            uint64_t __I;
        } __T;
        __T.__I = sign | ((exp) << 52) | mantissa;
        return __T.__D;
    }
#pragma empty_line
#pragma empty_line
    inline double roundToDouble() const {
        return roundToDouble(false);
    }
#pragma empty_line
#pragma empty_line
    inline double signedRoundToDouble() const {
        return roundToDouble(true);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline double bitsToDouble() const {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__I = pVal[0];
        return __T.__D;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline float bitsToFloat() const {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__I = uint32_t(pVal[0]);
        return __T.__F;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private& doubleToBits(double __V) {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__D = __V;
        pVal[0] = __T.__I;
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private& floatToBits(float __V) {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__F = __V;
        pVal[0] = __T.__I;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool and_reduce() const {
        return isMaxValue();
    }
#pragma empty_line
    inline bool nand_reduce() const {
        return isMinValue();
    }
#pragma empty_line
    inline bool or_reduce() const {
        return (bool)countPopulation();
    }
#pragma empty_line
    inline bool nor_reduce() const {
        return countPopulation()==0;
    }
#pragma empty_line
    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }
#pragma empty_line
    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }
    inline std::string to_string(uint8_t radix=16, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};
#pragma empty_line
namespace ap_private_ops {
    enum {APINT_BITS_PER_WORD=64};
    template<int _AP_W, bool _AP_S>
    inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 == V1;
    }
#pragma empty_line
    template<int _AP_W, bool _AP_S>
    inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 != V1;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W, bool _AP_S, int index>
    inline bool get(const ap_private<_AP_W, _AP_S>& a) {
        static const uint64_t mask=1ULL << (index&0x3f);
        return ((mask & a.get_pVal((index)>>6)) != 0);
    }
#pragma empty_line
    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word==lsb_word) {
            const uint64_t mask = ~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1);
#pragma empty_line
            a.get_pVal(msb_word) |= mask;
        } else {
            const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
            const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1);
#pragma empty_line
            a.get_pVal(lsb_word) |=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {
                a.set_pVal(i, ~0ULL);
#pragma empty_line
            }
#pragma empty_line
#pragma empty_line
            a.get_pVal(msb_word) |= msb_mask;
        }
        a.clearUnusedBits();
    }
#pragma empty_line
    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word == lsb_word) {
            const uint64_t mask = ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1));
#pragma empty_line
            a.get_pVal(msb_word) &= mask;
        } else {
            const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
            const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1));
#pragma empty_line
            a.get_pVal(lsb_word) &=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {
#pragma empty_line
                a.get_pVal(i)=0;
            }
#pragma empty_line
            a.get_pVal(msb_word) &= msb_mask;
        }
        a.clearUnusedBits();
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W, bool _AP_S, int index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=1ULL << (index%APINT_BITS_PER_WORD);
#pragma empty_line
        a.get_pVal(word) |= mask;
        a.clearUnusedBits();
    }
#pragma empty_line
    template<int _AP_W, bool _AP_S, int index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                      const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=~(1ULL << (index%APINT_BITS_PER_WORD));
#pragma empty_line
        a.get_pVal(word) &= mask;
        a.clearUnusedBits();
    }
#pragma empty_line
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, false>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
#pragma line 5574 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ,
 5575
#pragma line 5574 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h"
    ))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"
    };
    std::string result;
#pragma empty_line
    if (radix != 10) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (*this == (uint64_t)(0))
            result = "0";
        else {
            ap_private<_AP_W, false> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
                tmp.flip();
                tmp++;
                tmp.clearUnusedBitsToZero();
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5608));
            }
            insert_at += 2;
#pragma empty_line
            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false> zero(0);
            unsigned bits = 0;
            while (tmp.ne(zero)) {
                uint64_t digit = tmp.get_VAL() & mask;
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                ++bits;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }
#pragma empty_line
    ap_private<_AP_W, false> tmp(*this);
    ap_private<_AP_W, false> divisor(radix);
    ap_private<_AP_W, false> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false>(0))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false> APdigit(0);
        ap_private<_AP_W, false> tmp2(0);
        ap_private_ops::divide(tmp, tmp.getNumWords(), divisor, divisor.getNumWords(), &tmp2,
                &APdigit);
        uint64_t digit = APdigit.getZExtValue();
        ((digit < radix && "divide failed") ? (void)0 : _assert("digit < radix && \"divide failed\"", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_private.h", 5651));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }
#pragma empty_line
    return result;
}
#pragma line 99 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h" 2
#pragma line 170 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;
template<int _AP_W> class ap_uint;
#pragma empty_line
enum {AP_BIN=2,AP_OCT=8,AP_DEC=10,AP_HEX=16};
#pragma line 193 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
#pragma empty_line
#pragma empty_line
#pragma empty_line
    enum {_AP_WR=_AP_W1+_AP_W2,};
    _AP_T1& mbv1;
    _AP_T2& mbv2;
#pragma empty_line
    inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1,
          _AP_W2, _AP_T2>& ref):
           mbv1(ref.mbv1), mbv2(ref.mbv2) {}
#pragma empty_line
    inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2):mbv1(bv1),mbv2(bv2) {}
#pragma empty_line
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator = (const ap_private<_AP_W3,_AP_S3>& val) {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
        return *this;
    }
#pragma empty_line
#pragma empty_line
    inline ap_concat_ref& operator = (unsigned long long val) {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator =(tmpVal);
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_range_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = ((const ap_private<_AP_W3, false>)(val));
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = (val.to_ap_private());
    }
#pragma empty_line
    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator=((unsigned long long)(bool)(val));
     }
#pragma empty_line
#pragma empty_line
    inline operator ap_private<_AP_WR, false> () const
    {
        return get();
    }
#pragma empty_line
    inline operator unsigned long long () const
    {
         return get().to_uint64();
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >
        operator, (const ap_range_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_range_ref<_AP_W3, _AP_S3> &>(a2));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (const ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this,
                               const_cast<ap_private<_AP_W3, _AP_S3>&>(a2));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
        operator, (const ap_bit_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               1, ap_bit_ref<_AP_W3, _AP_S3> >(*this,
                          const_cast<ap_bit_ref<_AP_W3, _AP_S3> &>(a2));
    }
#pragma empty_line
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >
        operator, (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,
                               _AP_T4> >(*this, const_cast<ap_concat_ref<_AP_W3,
                               _AP_T3,_AP_W4, _AP_T4>& >(a2));
    }
#pragma empty_line
    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_range_ref<_AP_W3,_AP_I3, _AP_S3, _AP_Q3,
                _AP_O3, _AP_N3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_bit_ref<_AP_W3,_AP_I3, _AP_S3,
                _AP_Q3, _AP_O3, _AP_N3>& >(a2));
    }
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator & (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() & a2;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator | (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() | a2;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator ^ (const ap_private<_AP_W3,_AP_S3>& a2)
    {
      return ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>(get() ^ a2);
    }
#pragma empty_line
#pragma empty_line
    inline const ap_private<_AP_WR, false> get() const
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal = ap_private<_AP_W1+_AP_W2, false> (mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }
#pragma empty_line
#pragma empty_line
    inline const ap_private<_AP_WR, false> get()
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal =ap_private<_AP_W1+_AP_W2, false> ( mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3,false> & val)
    {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
    }
#pragma empty_line
#pragma empty_line
    inline int length() const {
        return mbv1.length()+mbv2.length();
    }
#pragma empty_line
    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S>
struct ap_range_ref {
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private<_AP_W,_AP_S> &d_bv;
    int l_index;
    int h_index;
#pragma empty_line
public:
    inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref):
         d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}
#pragma empty_line
    inline ap_range_ref(ap_private<_AP_W,_AP_S>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h)
    {
        if (h < 0 || l < 0)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
#pragma empty_line
    inline operator ap_private<_AP_W, false> () const
    {
        ap_private<_AP_W, false> val(0);
        if(h_index>=l_index) {
   if (_AP_W > 64) {
            val=d_bv;
            ap_private<_AP_W,false> mask(-1);
            mask>>=_AP_W-(h_index-l_index+1);
            val>>=l_index;
            val&=mask;
   } else {
     const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
     val = (d_bv >> l_index) & (mask >>(_AP_W-(h_index-l_index+1)));
   }
        } else {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    if((d_bv)[j]) val.set(i);
        }
        return val;
    }
#pragma empty_line
    inline operator unsigned long long () const
    {
        return to_uint64();
    }
#pragma empty_line
    template<int _AP_W2,bool _AP_S2>
    inline ap_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
      ap_private<_AP_W,false> vval=ap_private<_AP_W,false>(val);
      if(l_index>h_index)
 {
   for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
     (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
 if (_AP_W > 64) {
   ap_private<_AP_W,false> mask(-1);
   if(l_index>0)
     {
       mask<<=l_index;
       vval<<=l_index;
     }
   if(h_index<_AP_W-1)
     {
       ap_private<_AP_W,false> mask2(-1);
       mask2>>=_AP_W-h_index-1;
       mask&=mask2;
       vval&=mask2;
     }
   mask.flip();
   d_bv&=mask;
   d_bv|=vval;
 } else {
   unsigned shift = 64-_AP_W;
   uint64_t mask = ~0ULL>>(shift);
   if(l_index>0)
     {
       vval = mask & vval << l_index;
       mask = mask & mask << l_index;
     }
   if(h_index<_AP_W-1)
     {
       uint64_t mask2 = mask;
       mask2 >>= (_AP_W-h_index-1);
       mask&=mask2;
       vval&=mask2;
     }
   mask = ~mask;
   d_bv&=mask;
   d_bv|=vval;
 }
      }
      return *this;
    }
#pragma empty_line
  inline ap_range_ref& operator = (unsigned long long val)
    {
        const ap_private<_AP_W,_AP_S> vval=val;
        return operator = (vval);
    }
#pragma empty_line
#pragma empty_line
    inline ap_range_ref& operator =(const ap_range_ref<_AP_W, _AP_S>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline ap_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, _AP_S2>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                   ap_range_ref<_AP_W2,_AP_S2> >(*this,
                   const_cast<ap_range_ref<_AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2,_AP_S2>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W,ap_private<_AP_W,_AP_S> >
    operator , (ap_private<_AP_W, _AP_S>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                          ap_private<_AP_W,_AP_S> >(*this, a2);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,1,ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, 1,
                      ap_bit_ref<_AP_W2,_AP_S2> >(*this, const_cast<ap_bit_ref<
                      _AP_W2,_AP_S2>& >(a2));
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2)
    {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                       const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                       _AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val)
    {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index)
        {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
   if (_AP_W>64 ) {
            ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0)
       {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;
#pragma empty_line
                vval<<=l_index;
       }
            if(h_index<_AP_W-1)
       {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
       }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
   } else {
     uint64_t mask = ~0ULL >> (64-_AP_W);
            if(l_index>0)
       {
  uint64_t mask1 = mask;
  mask1=mask & (mask1>>(_AP_W-l_index));
  vval =mask&( vval <<l_index);
  mask=~mask1&mask;
#pragma empty_line
       }
            if(h_index<_AP_W-1) {
  uint64_t mask2 = ~0ULL >> (64-_AP_W);
  mask2 = mask &(mask2<<(h_index+1));
  mask&=~mask2;
  vval&=~mask2;
       }
            d_bv&=(~mask&(~0ULL >> (64-_AP_W)));
            d_bv|=vval;
   }
 }
    }
#pragma empty_line
#pragma empty_line
    inline ap_private<_AP_W,false> get() const
    {
      ap_private<_AP_W,false> val(0);
      if(h_index<l_index) {
 for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
   if((d_bv)[j]) val.set(i);
      } else {
 val=d_bv;
 val>>=l_index;
 if(h_index<_AP_W-1)
   {
     if (_AP_W <= 64) {
       const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
       val &= (mask>> (_AP_W-(h_index-l_index+1)));
     } else {
       ap_private<_AP_W,false> mask(-1);
       mask>>=_AP_W-(h_index-l_index+1);
       val&=mask;
     }
   }
      }
      return val;
    }
#pragma empty_line
#pragma empty_line
  inline ap_private<_AP_W,false> get()
  {
    ap_private<_AP_W,false> val(0);
    if(h_index<l_index) {
      for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
 if((d_bv)[j]) val.set(i);
    } else {
      val=d_bv;
      val>>=l_index;
      if(h_index<_AP_W-1)
 {
   if (_AP_W <= 64 ) {
     static const uint64_t mask = ~0ULL>> (64>_AP_W ? (64-_AP_W):0);
     return val &= ( (mask) >> (_AP_W - (h_index-l_index+1)));
   } else {
     ap_private<_AP_W,false> mask(-1);
     mask>>=_AP_W-(h_index-l_index+1);
     val&=mask;
   }
 }
    }
    return val;
  }
#pragma empty_line
#pragma empty_line
    inline int length() const
    {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }
#pragma empty_line
#pragma empty_line
    inline int to_int() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }
#pragma empty_line
#pragma empty_line
    inline unsigned int to_uint() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }
#pragma empty_line
#pragma empty_line
    inline long to_long() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }
#pragma empty_line
#pragma empty_line
    inline unsigned long to_ulong() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }
#pragma empty_line
#pragma empty_line
    inline ap_slong to_int64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }
#pragma empty_line
#pragma empty_line
    inline ap_ulong to_uint64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }
#pragma empty_line
    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }
#pragma empty_line
    inline bool and_reduce() {
        bool ret = true;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret &= d_bv[i];
        return ret;
    }
#pragma empty_line
    inline bool or_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret |= d_bv[i];
        return ret;
    }
#pragma empty_line
    inline bool xor_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret ^= d_bv[i];
        return ret;
    }
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_private<_AP_W,_AP_S>& d_bv;
    int d_index;
#pragma empty_line
public:
    inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref):
            d_bv(ref.d_bv), d_index(ref.d_index) {}
#pragma empty_line
    inline ap_bit_ref(ap_private<_AP_W,_AP_S>& bv, int index=0):
        d_bv(bv),d_index(index)
    {
        if (d_index < 0 )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
#pragma empty_line
    inline operator bool () const
    {
      return d_bv.get_bit(d_index);
    }
#pragma empty_line
#pragma empty_line
    inline bool to_bool() const
    {
        return operator bool ();
    }
#pragma empty_line
#pragma empty_line
    inline ap_bit_ref& operator = (unsigned long long val)
    {
        if(val)
            d_bv.set(d_index);
        else
            d_bv.clear(d_index);
        return *this;
    }
#pragma line 972 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(val != 0));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }
#pragma empty_line
    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W,_AP_S>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_range_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool) val);
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2, _AP_S2>& a2)
     {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >(*this,
                    const_cast<ap_range_ref<_AP_W2, _AP_S2> &>(a2));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
                    const_cast<ap_bit_ref<_AP_W2, _AP_S2> &>(a2));
    }
#pragma empty_line
#pragma empty_line
    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >
    operator, (const ap_bit_ref &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >(*this,
                const_cast<ap_bit_ref&>(a2));
    }
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >
    operator, (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &a2)
    {
        return
            ap_concat_ref<1,ap_bit_ref,_AP_W2+_AP_W3,
                    ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >(*this,
                    const_cast<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() == op.get();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() != op.get();
    }
#pragma empty_line
#pragma empty_line
    inline bool get() const
    {
        return operator bool ();
    }
#pragma empty_line
#pragma empty_line
    inline bool get()
    {
        return operator bool ();
    }
#pragma empty_line
#pragma empty_line
    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3, false>& val)
    {
        operator = (val);
    }
#pragma empty_line
    inline bool operator ~ () const {
        bool bit = (d_bv)[d_index];
        return bit ? false : true;
    }
#pragma empty_line
    inline int length() const { return 1; }
#pragma empty_line
    inline std::string to_string() const {
        bool val = get();
        return val ? "1" : "0";
    }
};
#pragma line 1147 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; }
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#pragma line 1172 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline float operator * (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline float operator * (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline float operator / (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline float operator / (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline float operator + (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline float operator + (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline float operator - (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline float operator - (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
template<int _AP_W, bool _AP_S> inline double operator * (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline double operator * (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline double operator / (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline double operator / (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline double operator + (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline double operator + (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline double operator - (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline double operator - (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#pragma line 1271 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mult operator * ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator * (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::plus operator + ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator + (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::minus operator - ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator - (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::div operator / ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator / (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mod operator % ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator % (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator & ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator & (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator | ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator | (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator ^ (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> bool operator >> ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> bool operator << ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator == (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator != (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator > (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator >= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator < (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator <= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator += (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator -= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator *= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator /= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator %= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator &= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator |= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator ^= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::mult operator * ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator * (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::plus operator + ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator + (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::minus operator - ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator - (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::div operator / ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::div operator / ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator / (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::mod operator % ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator % (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator & ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator & (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator | ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator | (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator ^ ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator ^ (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> char operator >> ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> char operator << ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator == (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator != (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator > (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator >= (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator < (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator <= (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator += (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator -= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator *= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator /= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator %= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator &= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator |= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator ^= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mult operator * ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator * (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::plus operator + ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator + (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::minus operator - ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator - (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::div operator / ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator / (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mod operator % ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator % (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator & ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator & (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator | ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator | (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator ^ (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> signed char operator >> ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> signed char operator << ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator == (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator != (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator > (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator >= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator < (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator <= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator += (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator -= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator *= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator /= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator %= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator &= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator |= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator ^= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator * (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator + (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator - (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator / (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator % (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator & (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator | (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator ^ (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned char operator >> ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned char operator << ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator == (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator != (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator > (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator < (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator += (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator -= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator *= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator /= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator %= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator &= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator |= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator ^= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mult operator * ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator * (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::plus operator + ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator + (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::minus operator - ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator - (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::div operator / ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator / (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mod operator % ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator % (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator & ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator & (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator | ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator | (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator ^ (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> short operator >> ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> short operator << ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator == (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator != (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator > (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator >= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator < (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator <= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator += (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator -= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator *= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator /= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator %= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator &= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator |= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator ^= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator * (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator + (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator - (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator / (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator % (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator & (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator | (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator ^ (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned short operator >> ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned short operator << ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator == (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator != (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator > (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator < (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator += (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator -= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator *= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator /= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator %= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator &= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator |= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator ^= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator * (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator + (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator - (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::div operator / ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator / (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator % (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator & (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator | (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator ^ (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> int operator >> ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> int operator << ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator == (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator != (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator > (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator >= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator < (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator <= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator += (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator -= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator *= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator /= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator %= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator &= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator |= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator ^= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator * (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator + (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator - (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator / (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator % (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator & (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator | (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator ^ (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned int operator >> ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned int operator << ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator == (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator != (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator > (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator < (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator += (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator -= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator *= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator /= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator %= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator &= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator |= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator ^= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator << (op2); return op; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator * (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator + (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator - (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::div operator / ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator / (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator % (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator & (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator | (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator ^ (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> long operator >> ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> long operator << ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator == (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator != (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator > (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator >= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator < (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator <= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator += (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator -= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator *= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator /= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator %= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator &= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator |= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator ^= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator * (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator + (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator - (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator / (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator % (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator & (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator | (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator ^ (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned long operator >> ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned long operator << ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator == (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator != (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator > (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator < (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator += (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator -= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator *= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator /= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator %= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator &= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator |= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator ^= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator << (op2); return op; }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mult operator * ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator * (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::plus operator + ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator + (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::minus operator - ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator - (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::div operator / ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator / (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mod operator % ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator % (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator & ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator & (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator | ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator | (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator ^ (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> ap_slong operator >> ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_slong operator << ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator == (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator != (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator > (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator < (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator += (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator -= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator *= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator /= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator %= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator &= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator |= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator ^= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mult operator * ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator * (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::plus operator + ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator + (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::minus operator - ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator - (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::div operator / ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator / (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mod operator % ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator % (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator & ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator & (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator | ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator | (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator ^ (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> ap_ulong operator >> ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_ulong operator << ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator == (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator != (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator > (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator < (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator += (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator -= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator *= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator /= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator %= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator &= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator |= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator ^= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator << (op2); return op; }
#pragma line 1325 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator += (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator -= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator *= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator /= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator %= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator >>= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator <<= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator &= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator |= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator ^= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (op2.operator ap_private<_AP_W2, false>()); }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<_AP_W2, false>(op2)); }
#pragma line 1390 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator += ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator -= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator *= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator /= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator %= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator >>= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator <<= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator &= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator |= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator ^= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (ap_private<1, false>(op2)); }
#pragma empty_line
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<1, false>(op2)); }
#pragma line 1453 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
#pragma line 1495 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::plus operator + ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::minus operator - ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mult operator * ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::div operator / ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mod operator % ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator >> ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator << ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator & ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator | ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator ^ ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::plus operator + ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::minus operator - ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::mult operator * ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::div operator / ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::mod operator % ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::arg1 operator >> ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::arg1 operator << ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator & ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator | ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator ^ ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::plus operator + ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::minus operator - ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mult operator * ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::div operator / ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mod operator % ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator >> ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator << ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator & ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator | ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator ^ ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::plus operator + ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::minus operator - ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mult operator * ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::div operator / ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mod operator % ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator & ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator | ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::plus operator + ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::minus operator - ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mult operator * ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::div operator / ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mod operator % ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator >> ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator << ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator & ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator | ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator ^ ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::plus operator + ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::minus operator - ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mult operator * ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::div operator / ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mod operator % ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator & ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator | ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::plus operator + ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::minus operator - ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mult operator * ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::div operator / ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mod operator % ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator >> ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator << ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator & ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator | ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator ^ ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::plus operator + ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::minus operator - ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mult operator * ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::div operator / ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mod operator % ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator & ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator | ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::plus operator + ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::minus operator - ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mult operator * ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::div operator / ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mod operator % ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator >> ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator << ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator & ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator | ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator ^ ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::plus operator + ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::minus operator - ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mult operator * ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::div operator / ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mod operator % ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator & ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator | ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::plus operator + ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::minus operator - ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mult operator * ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::div operator / ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mod operator % ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator >> ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator << ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator & ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator | ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator ^ ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::plus operator + ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::minus operator - ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mult operator * ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::div operator / ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mod operator % ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator >> ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator << ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator & ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator | ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator ^ ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
#pragma line 1520 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator + (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator + (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator - (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator - (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator * (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator * (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator / (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator / (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator % (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator % (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >> (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator >> (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator << (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator << (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator & (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator & (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator | (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator | (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^ (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator ^ (ap_private<_AP_W2, false>(rhs)); }
#pragma line 1672 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_private<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op2); ap_private<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op1); ap_private<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_private<8 + _AP_W + _AP_W2, (-128) != 0> val(op2); ap_private<8 + _AP_W + _AP_W2, (-128) != 0> ret(op1); if ((-128) != 0) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, (-128) != 0> val(op1); ap_private<8 + _AP_W + _AP_W2, (-128) != 0> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + 1, (-128) != 0> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, (-128) != 0> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op2); ap_private<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op1); ap_private<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + 1, true> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op2); ap_private<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op1); ap_private<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op2); ap_private<16 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op1); ap_private<16 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + 1, true> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op2); ap_private<16 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op1); ap_private<16 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op2); ap_private<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op1); ap_private<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op2); ap_private<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op1); ap_private<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op2); ap_private<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op1); ap_private<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op2); ap_private<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op1); ap_private<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#pragma empty_line
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op2); ap_private<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op1); ap_private<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op2); ap_private<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op1); ap_private<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#pragma line 1698 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
#pragma line 1719 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_private<_AP_W,_AP_S> &op)
{
  ap_private<_AP_W, _AP_S> v=op;
    const std::ios_base::fmtflags basefield = out.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    std::string str=v.toString(radix,_AP_S);
    out<<str;
    return out;
#pragma empty_line
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_private<_AP_W,_AP_S> &op)
{
    std::string str;
    in >> str;
    const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    op = ap_private<_AP_W, _AP_S>(str.c_str(), radix);
    return in;
#pragma empty_line
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator<<(out, ap_private<_AP_W, _AP_S>(op));
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator>>(in, ap_private<_AP_W, _AP_S>(op));
}
#pragma empty_line
template<int _AP_W, bool _AP_S>
inline void print(const ap_private<_AP_W,_AP_S> &op, bool fill=true )
{
    ap_private<_AP_W, _AP_S> v=op;
    uint32_t ws=v.getNumWords();
    const uint64_t *ptr=v.getRawData();
    int i=ws-1;
#pragma empty_line
    if(_AP_W%64 != 0) {
        uint32_t offset=_AP_W%64;
        uint32_t count=(offset+3)/4;
        int64_t data=*(ptr+i);
        if(_AP_S)
            data=(data<<(64-offset))>>(64-offset);
        else
            count=(offset+4)/4;
        while(count-->0)
#pragma empty_line
#pragma empty_line
#pragma empty_line
            printf("%llx",(data>>(count*4))&0xf);
#pragma empty_line
    } else {
        if(_AP_S==false)
            printf("0");
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        printf("%016llx",*(ptr+i));
#pragma empty_line
    }
    for(--i;i>=0;i--)
#pragma empty_line
#pragma empty_line
#pragma empty_line
        printf("%016llx",*(ptr+i));
#pragma empty_line
    printf("\n");
#pragma empty_line
}
#pragma line 75 "C:/Xilinx/Vivado_HLS/2016.4/include/ap_int.h" 2
#pragma line 1 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h" 1
#pragma line 75 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
#pragma line 1 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_int_sim.h" 1
#pragma line 76 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h" 2
#pragma line 93 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_bit_ref {
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& d_bv;
    int d_index;
public:
    inline af_bit_ref(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), d_index(ref.d_index) {
        if (d_index < 0 )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    inline af_bit_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>* bv, int index=0):
    d_bv(*bv),d_index(index) {}
#pragma empty_line
    inline operator bool() const {
        return d_bv.V[d_index];
    }
#pragma empty_line
    inline af_bit_ref& operator=(unsigned long long val) {
        if(val)
            d_bv.V.set(d_index);
        else
            d_bv.V.clear(d_index);
        return *this;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
        return operator=(val!=0);
    }
#pragma empty_line
    inline af_bit_ref& operator =(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        return operator=((unsigned long long)(bool)val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref operator=(const af_bit_ref<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)val);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_bit_ref<_AP_W2, _AP_S2> &val) {
        return operator =((unsigned long long) (bool) val);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator =((const ap_private<_AP_W2, false>) val);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline af_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2> >(*this, const_cast<af_range_ref<_AP_W2, _AP_I2,
             _AP_S2, _AP_Q2, _AP_O2,_AP_N2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
              _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() == op.get();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() != op.get();
    }
#pragma empty_line
    inline bool operator ~ () const {
        bool bit = (d_bv.V)[d_index];
        return bit ? false : true;
    }
#pragma empty_line
    inline int length() const {
        return 1;
    }
#pragma empty_line
    inline bool get() {
        return d_bv.V[d_index];
    }
#pragma empty_line
    inline bool get() const {
        return d_bv.V[d_index];
    }
#pragma empty_line
    inline std::string to_string() const {
        return d_bv.V[d_index] ? "1" : "0";
    }
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_range_ref {
#pragma empty_line
#pragma empty_line
#pragma empty_line
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &d_bv;
    int l_index;
    int h_index;
#pragma empty_line
public:
    inline af_range_ref(const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}
#pragma empty_line
    inline af_range_ref(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h) {
        if (h < 0 || l < 0)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    inline operator ap_private<_AP_W, false> () const {
        if(h_index >= l_index) {
          ap_private<_AP_W, false> val(d_bv.V);
          ap_private<_AP_W,false> mask(-1);
          mask>>=_AP_W-(h_index-l_index+1);
          val>>=l_index;
          return val&=mask;
        } else {
          ap_private<_AP_W, false> val = 0;
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        }
    }
#pragma empty_line
    inline operator unsigned long long() const {
        return get().to_uint64();
    }
#pragma empty_line
    template<int _AP_W2,bool _AP_S2>
    inline af_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
      ap_private<_AP_W, false> vval= ap_private<_AP_W, false>(val);
        if(l_index > h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,false> mask(-1);
            if(l_index>0) {
                mask<<=l_index;
                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
              ap_private<_AP_W,false> mask2(-1);
              mask2>>=_AP_W-h_index-1;
              mask&=mask2;
              vval&=mask2;
            }
            mask.flip();
            d_bv.V &= mask;
            d_bv.V |= vval;
        }
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline af_range_ref& operator = (const char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const signed char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
#pragma empty_line
#pragma empty_line
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline af_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }
#pragma empty_line
    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        const ap_private<_AP_W2, false> tmp= val.get();
        return operator = (tmp);
    }
#pragma empty_line
    inline af_range_ref& operator= (const char* val) {
        const ap_private<_AP_W, false> tmp(val);
        return operator = (tmp);
    }
#pragma empty_line
    inline af_range_ref& operator= (const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        const ap_private<_AP_W, false> tmp= val.get();
        return operator = (tmp);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const ap_fixed_base<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }
#pragma empty_line
    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val) {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0) {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;
#pragma empty_line
                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
            }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
        }
#pragma empty_line
    }
#pragma empty_line
    inline ap_private<_AP_W,false> get() const {
        if(h_index<l_index) {
          ap_private<_AP_W, false> val(0);
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        } else {
          ap_private<_AP_W, false> val = ap_private<_AP_W,false>(d_bv.V);
          val>>= l_index;
          if(h_index<_AP_W-1)
            {
              ap_private<_AP_W,false> mask(-1);
              mask>>=_AP_W-(h_index-l_index+1);
              val&=mask;
            }
          return val;
        }
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                  _AP_T3>& >(op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2>& > (op));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }
#pragma empty_line
    inline int length() const {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }
#pragma empty_line
    inline int to_int() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }
#pragma empty_line
    inline unsigned int to_uint() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }
#pragma empty_line
    inline long to_long() const {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }
#pragma empty_line
    inline unsigned long to_ulong() const {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }
#pragma empty_line
    inline ap_slong to_int64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }
#pragma empty_line
    inline ap_ulong to_uint64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }
#pragma empty_line
    inline std::string to_string(uint8_t radix) const {
        return get().to_string(radix);
    }
#pragma empty_line
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S=true, ap_q_mode _AP_Q=AP_TRN,
         ap_o_mode _AP_O=AP_WRAP, int _AP_N=0>
struct ap_fixed_base {
#pragma empty_line
#pragma empty_line
#pragma empty_line
private:
#pragma empty_line
    inline ap_fixed_base(const std::string& val) {
#pragma empty_line
#pragma empty_line
        fromString(val);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    void fromString(const std::string& val) {
        int radix = 10;
#pragma empty_line
        std::string s = ap_private_ops::parseString(val, radix);
#pragma empty_line
        fromString(s, radix);
    }
#pragma empty_line
    void fromString(const std::string& val, unsigned char radix) {
        ((radix == 2 || radix == 8 || radix == 10 || radix == 16) ? (void)0 : _assert("radix == 2 || radix == 8 || radix == 10 || radix == 16", "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h", 653));
        V = 0;
        int startPos = 0;
        int endPos = val.length();
        int decPos = val.find(".");
        if (decPos == -1)
            decPos = endPos;
        bool isNegative = false;
        if (val[0] == '-') {
            isNegative = true;
            ++startPos;
        } else if (val[0] == '+')
            ++startPos;
#pragma line 688 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
        ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4))+4, ((_AP_I) > (4) ? (_AP_I) : (4))+4, false> integer_bits = 0;
#pragma empty_line
#pragma empty_line
        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        bool sticky_int = false;
#pragma empty_line
#pragma empty_line
        for (int i = startPos; i < decPos; i++) {
#pragma empty_line
            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);
#pragma empty_line
            sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 1] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 2] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 4];
#pragma empty_line
            if (shift)
                integer_bits <<= shift;
            else
                integer_bits *= radix;
#pragma empty_line
#pragma empty_line
            integer_bits += digit;
#pragma empty_line
        }
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] = integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | sticky_int;
#pragma empty_line
        ap_fixed_base<((_AP_W-_AP_I) > (0) ? (_AP_W-_AP_I) : (0))+4+4, 4, false> fractional_bits = 0;
        bool sticky = false;
#pragma empty_line
#pragma empty_line
        for (int i = endPos-1; i >= decPos+1; i--) {
#pragma empty_line
            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);
#pragma empty_line
            fractional_bits += digit;
#pragma empty_line
            sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] | fractional_bits[3];
#pragma empty_line
            if (shift)
                fractional_bits >>= shift;
            else
                fractional_bits /= radix;
#pragma empty_line
#pragma empty_line
        }
#pragma empty_line
#pragma empty_line
#pragma empty_line
        fractional_bits[0] = fractional_bits[0] | sticky;
#pragma empty_line
        if(isNegative)
            *this = -(integer_bits + fractional_bits);
        else
            *this = integer_bits + fractional_bits;
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    inline void report() {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        if (!_AP_S && _AP_O == AP_WRAP_SM) {
            fprintf((&_iob[2]), "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
            exit(1);
        }
        if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
            fprintf((&_iob[2]), "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
                   "default max value %d. Please use macro "
                   "AP_INT_MAX_W to set a larger max value.\n",
                            _AP_S?"":"u", _AP_W,
                            ((1024 + 1023) / 1024) * 1024);
            exit(1);
        }
    }
#pragma empty_line
#pragma empty_line
    inline unsigned long long doubleToRawBits(double pf)const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__D=pf;
        return LD.__L;
    }
#pragma empty_line
#pragma empty_line
    inline double rawBitsToDouble(unsigned long long pi) const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__L=pi;
        return LD.__D;
    }
#pragma empty_line
    inline float rawBitsToFloat(uint32_t pi) const {
        union {
            uint32_t __L;
            float __D;
        }LD;
        LD.__L = pi;
        return LD.__D;
    }
#pragma empty_line
#pragma empty_line
public:
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
ap_fixed_base;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
af_bit_ref;
#pragma empty_line
    inline void overflow_adjust(bool underflow, bool overflow,
                                bool lD, bool sign) {
        if (!overflow && !underflow) return;
        switch (_AP_O) {
            case AP_WRAP:
                if (_AP_N == 0)
                    return;
                if (_AP_S) {
#pragma empty_line
#pragma empty_line
                    if (_AP_N > 1) {
                        ap_private<_AP_W, _AP_S> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= ~mask;
                    }
                    sign ? V.set(_AP_W - 1) : V.clear(_AP_W - 1);
                } else {
#pragma empty_line
                    ap_private<_AP_W, _AP_S> mask(-1);
                    if (_AP_N >= _AP_W) mask = 0;
                    else mask.lshr(_AP_N);
                    mask.flip();
                    V |= mask;
                }
                break;
            case AP_SAT_ZERO:
                V.clear();
                break;
            case AP_WRAP_SM:
                {
                bool Ro = ap_private_ops::get<_AP_W, _AP_S, _AP_W -1>(V);
                if (_AP_N == 0) {
                    if (lD != Ro) {
                        V.flip();
                        lD ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) :
                            ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                } else {
                    if (_AP_N == 1 && sign != Ro) {
                        V.flip();
                    } else if (_AP_N > 1) {
                        bool lNo = ap_private_ops::get<_AP_W, _AP_S, _AP_W - _AP_N> (V);
                        if (lNo == sign)
                            V.flip();
                        ap_private<_AP_W, false> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= mask.flip();
                        sign ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) : ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                }
                }
                break;
            default:
                if (_AP_S) {
                    if (overflow) {
                        V.set(); ap_private_ops::clear<_AP_W, _AP_S, _AP_W-1>(V);
                    } else if (underflow) {
                        V.clear();
                        ap_private_ops::set<_AP_W, _AP_S, _AP_W-1>(V);
                        if(_AP_O == AP_SAT_SYM)
                            ap_private_ops::set<_AP_W, _AP_S, 0>(V);
                    }
                } else {
                    if (overflow)
                        V.set();
                    else if (underflow)
                        V.clear();
                }
        }
    }
#pragma empty_line
    inline bool quantization_adjust(bool qb, bool r, bool s) {
        bool carry=ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V);
        switch (_AP_Q) {
            case AP_TRN:
                return false;
            case AP_RND_ZERO:
                qb &= s || r;
                break;
            case AP_RND_MIN_INF:
                qb &= r;
                break;
            case AP_RND_INF:
                qb &= !s || r;
                break;
            case AP_RND_CONV:
                qb &= ap_private_ops::get<_AP_W, _AP_S, 0>(V) || r;
                break;
            case AP_TRN_ZERO:
                qb = s && ( qb || r );
                break;
            default:;
#pragma empty_line
        }
        if(qb) ++V;
#pragma empty_line
        return carry && !(ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V));
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2>
    struct RType {
        enum {
            _AP_F=_AP_W-_AP_I,
            F2=_AP_W2-_AP_I2,
            mult_w = _AP_W+_AP_W2,
            mult_i = _AP_I+_AP_I2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            plus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            minus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
#pragma empty_line
            div_w = _AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)) + _AP_S2,
#pragma empty_line
#pragma empty_line
#pragma empty_line
            div_i = _AP_I + (_AP_W2-_AP_I2) + _AP_S2,
            div_s = _AP_S||_AP_S2,
            logic_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            logic_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
#pragma empty_line
        typedef ap_fixed_base<mult_w, mult_i, mult_s> mult;
        typedef ap_fixed_base<plus_w, plus_i, plus_s> plus;
        typedef ap_fixed_base<minus_w, minus_i, minus_s> minus;
        typedef ap_fixed_base<logic_w, logic_i, logic_s> logic;
        typedef ap_fixed_base<div_w, div_i, div_s> div;
        typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1;
    };
#pragma line 961 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base() {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base(const ap_fixed_base& op):V(op.V) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op):V(0) {
        enum {N2=_AP_W2,_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2,QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN ||
                (_AP_Q==AP_TRN_ZERO && !_AP_S2))};
        if (!op) return;
        bool carry=false;
#pragma empty_line
        enum { sh_amt =(F2>_AP_F)?F2-_AP_F:_AP_F-F2};
        const ap_private<_AP_W2, _AP_S2>& val = op.V;
        bool neg_src=val.isNegative();
        if (F2==_AP_F)
            V=val;
#pragma empty_line
        else if (F2>_AP_F) {
            if (sh_amt >= _AP_W2)
                V = neg_src ? -1 : 0;
            else
                V = _AP_S2?val.ashr(sh_amt):val.lshr(sh_amt);
            if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                bool qb = false;
                if (F2-_AP_F>_AP_W2)
                    qb = neg_src;
                else
                    qb = ap_private_ops::get<_AP_W2, _AP_S2, F2-_AP_F-1>(val);
#pragma empty_line
                bool r=false;
                enum { pos3 = F2-_AP_F-2};
                if(pos3>=_AP_W2-1)
                    r=val!=0;
                else if (pos3>=0)
                r = (val<<(_AP_W2-1-pos3))!=0;
                carry = quantization_adjust(qb,r,neg_src);
            }
        } else {
            if (sh_amt < _AP_W) {
                V=val;
                V <<= sh_amt;
            }
        }
#pragma empty_line
        if ((_AP_O!=AP_WRAP || _AP_N != 0) &&
                ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                 _AP_I2 - _AP_S2 + (QUAN_INC|| (_AP_S2 &&
                     _AP_O==AP_SAT_SYM)))) {
            bool deleted_zeros = _AP_S2?true:!carry,
                 deleted_ones = true;
            bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                ap_private_ops::get<_AP_W2, _AP_S2, _AP_W2-_AP_I2+_AP_I>(val);
            enum { pos1=F2-_AP_F+_AP_W, pos2=F2-_AP_F+_AP_W+1};
            if (pos1 < _AP_W2) {
                bool Range1_all_ones= true;
                bool Range1_all_zeros= true;
                if (pos1 >= 0) {
                    enum { __W = (_AP_W2-pos1) > 0 ? (_AP_W2-pos1) : 1 };
                    const ap_private<__W, _AP_S2> Range1=ap_private<__W, _AP_S2>(val.lshr(pos1));
                    Range1_all_ones=Range1.isAllOnesValue();
                    Range1_all_zeros=Range1.isMinValue();
                } else {
                    Range1_all_ones=false;
                    Range1_all_zeros=val.isMinValue();
                }
                bool Range2_all_ones=true;
                if (pos2<_AP_W2 && pos2>=0) {
                    enum { __W = (_AP_W2-pos2)>0 ? (_AP_W2-pos2) : 1};
                    ap_private<__W, true> Range2=ap_private<__W, true>(val.lshr(pos2));
                    Range2_all_ones=Range2.isAllOnesValue();
                } else if(pos2<0)
                    Range2_all_ones=false;
#pragma empty_line
                deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD)
                    :Range1_all_ones;
                neg_src= neg_src&&!(carry && Range1_all_ones);
            } else
                neg_src = neg_src && V[_AP_W-1];
#pragma empty_line
            bool neg_trg= V.isNegative();
            bool overflow=(neg_trg||!deleted_zeros) && !val.isNegative();
            bool underflow=(!neg_trg||!deleted_ones)&&neg_src;
#pragma empty_line
#pragma empty_line
#pragma empty_line
            if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
            overflow_adjust(underflow, overflow, lD, neg_src);
        }
        report();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const volatile ap_fixed_base<_AP_W2,_AP_I2,
                _AP_S2,_AP_Q2,_AP_O2, _AP_N2> &op) : V(op.V) {
        *this = const_cast<ap_fixed_base<_AP_W2,_AP_I2,
        _AP_S2,_AP_Q2,_AP_O2, _AP_N2>&>(op);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_private<_AP_W2,_AP_S2>& op) {
        ap_fixed_base<_AP_W2,_AP_W2,_AP_S2> f_op;
        f_op.V=op;
        *this = f_op;
    }
#pragma empty_line
    inline ap_fixed_base(bool b) {
        *this=(ap_private<1,false>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(char b) {
        *this=(ap_private<8,false>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(signed char b) {
        *this=(ap_private<8,true>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(unsigned char b) {
        *this=(ap_private<8,false>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(signed short b) {
        *this=(ap_private<16,true>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(unsigned short b) {
        *this=(ap_private<16,false>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(signed int b) {
        *this=(ap_private<32,true>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(unsigned int b) {
        *this=(ap_private<32,false>)b;
        report();
    }
#pragma line 1119 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base(signed long b) {
        *this=(ap_private<32,true>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(unsigned long b) {
        *this=(ap_private<32,false>)b;
        report();
    }
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base(ap_slong b) {
        *this=(ap_private<64,true>)b;
        report();
    }
#pragma empty_line
    inline ap_fixed_base(ap_ulong b) {
        *this=(ap_private<64,false>)b;
        report();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base(const char* val):V(0) {
#pragma empty_line
#pragma empty_line
        fromString(val);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    inline ap_fixed_base(const char* val, signed char radix): V(0) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        ap_private<_AP_W, _AP_S> Tmp(val, radix);
        V = Tmp;
#pragma empty_line
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        *this = ((bool)op);
        report();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
        *this = ap_private<_AP_W2, _AP_S2>(op);
        report();
    }
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        *this = ((const ap_private<_AP_W2 + _AP_W3, false>&)(op));
        report();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
         *this = (bool(op));
        report();
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        *this = (ap_private<_AP_W2, false>(op));
        report();
    }
#pragma empty_line
    inline ap_fixed_base(double d):V(0) {
        if(!d) return;
        const bool isneg=d<0;
#pragma empty_line
        const uint64_t ireg=doubleToRawBits(isneg?-d:d);
        if((ireg&0x7fffffffffffffffULL)!=0) {
            const int32_t exp=(((ireg)>>52)&0x07ff)-((1ULL<<(11 -1))-1);
            ap_private<52 +2, true> man = ireg & 0x3fffffffffffffULL;
#pragma empty_line
            if (exp == ((1ULL<<(11 -1))-1) + 1 &&
                man.range(52 - 1, 0) != 0) {
#pragma empty_line
                fprintf((&_iob[2]), "[E] ap_%sfixed<%d, ...>: trying to "
                   "assign NaN to fixed point value.\n",
                            _AP_S?"":"u", _AP_W);
                exit(1);
            }
            man.clear(52 +1);
            man.set(52);
            if(isneg) {
                man.flip();
                man++;
            }
#pragma empty_line
            enum {_AP_S2=true, _AP_W2=52 +2,_AP_F=_AP_W -_AP_I };
            const int _AP_I2=exp+2;
            const int F2=_AP_W2-_AP_I2;
            const bool QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN || (_AP_Q==AP_TRN_ZERO &&
                    !_AP_S2));
            bool carry=false;
#pragma empty_line
            const unsigned sh_amt=abs(F2-_AP_F);
            if (F2==_AP_F )
                V=man;
            else if (F2>_AP_F) {
                if(sh_amt >= 52 +2)
                    V=isneg?-1:0;
                else
                    V= ap_private<52 +2, true>((man>>sh_amt) |
                       ((man & 1ULL<<(52 +1))?
                        (0x3fffffffffffffULL>>(52 +2-sh_amt)
                        <<(52 +2-sh_amt)):0));
#pragma empty_line
                if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                    const bool qb=((F2-_AP_F > 52 +2) ? isneg : (man & (1ULL<<(F2-_AP_F-1))) != 0);
                    const int pos3=F2-_AP_F-2;
                    const bool r = (pos3>= 0) ? (man << ((0) > (_AP_W2-pos3-1) ? (0) : (_AP_W2-pos3-1))& 0x3fffffffffffffULL)!=0 : false;
                    carry = quantization_adjust(qb,r,isneg);
                }
            }
            else {
#pragma empty_line
                if (sh_amt < _AP_W) {
                    V = man;
                    V <<= sh_amt;
                }
            }
#pragma empty_line
            if((_AP_O != AP_WRAP || _AP_N != 0) &&
                    ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                     _AP_I2-_AP_S2+(QUAN_INC|| (_AP_S2 &&
                         _AP_O==AP_SAT_SYM)) )) {
                bool deleted_zeros = _AP_S2?true:!carry,
                     deleted_ones = true;
                bool neg_src;
                const bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                    (man & (1ULL <<(52 +2-_AP_I2+_AP_I)));
                int pos1=F2+_AP_W-_AP_F;
                if (pos1 < _AP_W2) {
                    int pos2=pos1+1;
                    bool Range1_all_ones=true;
                    bool Range1_all_zeros=true;
                    if (pos1>=0) {
                        ap_private<52 +2,_AP_S> Range1=
                            ap_private<52 +2,_AP_S>((man >> pos1) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos1) <<(52 +2-pos1)):0));
                        Range1_all_ones = Range1.isAllOnesValue();
                        Range1_all_zeros = Range1.isMinValue();
                    } else {
                        Range1_all_ones=false;
                        Range1_all_zeros = man==0;
                    }
                    bool Range2_all_ones=true;
                    if (pos2<_AP_W2 && pos2>=0) {
                        ap_private<52 +2, _AP_S> Range2=
                            ap_private<52 +2, _AP_S>((man >> pos2) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos2) <<(52 +2-pos2)):0));
                        Range2_all_ones=Range2.isAllOnesValue();
                    } else if (pos2<0)
                        Range2_all_ones=false;
                    deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                    deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD) : Range1_all_ones;
                    neg_src=isneg&&!(carry&Range1_all_ones);
                } else
                    neg_src = isneg && V[_AP_W -1];
#pragma empty_line
                const bool neg_trg=V.isNegative();
                const bool overflow=(neg_trg||!deleted_zeros) && !isneg;
                bool underflow=(!neg_trg||!deleted_ones)&&neg_src;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
                if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                    underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
                overflow_adjust(underflow,overflow,lD, neg_src);
            }
        }
        report();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline void operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }
#pragma empty_line
    inline ap_fixed_base& operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }
#pragma empty_line
    inline void operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }
#pragma empty_line
    inline ap_fixed_base& operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base& setBits(unsigned long long bv) {
        V=bv;
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    static inline ap_fixed_base bitsToFixed(unsigned long long bv) {
        ap_fixed_base Tmp=bv;
        return Tmp;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S>
    to_ap_private(bool Cnative = true) const {
        ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ret = ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ((_AP_I >= 1) ? (_AP_S==true ? V.ashr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I))) : V.lshr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I)))) : ap_private<_AP_W, _AP_S>(0));
#pragma empty_line
        if (Cnative) {
            bool r = false;
            if (_AP_I < _AP_W) {
                if (_AP_I > 0) r = !(V.getLoBits(_AP_W - _AP_I).isMinValue());
                else r = !(V.isMinValue());
            }
            if (r && V.isNegative()) {
                ++ret;
            }
        } else {
#pragma empty_line
        }
        return ret;
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline operator ap_private<_AP_W2,_AP_S2> () const {
        return (ap_private<_AP_W2,_AP_S2>)to_ap_private();
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_N2>
    inline operator ap_private<_AP_W2,_AP_S2,_AP_N2> () const {
        return (ap_private<_AP_W2,_AP_S2,_AP_N2>)to_ap_private();
    }
#pragma empty_line
#pragma empty_line
    inline int to_int() const {
        return to_ap_private().to_int();
    }
#pragma empty_line
    inline int to_uint() const {
        return to_ap_private().to_uint();
    }
#pragma empty_line
    inline ap_slong to_int64() const {
        return to_ap_private().to_int64();
    }
#pragma empty_line
    inline ap_ulong to_uint64() const {
        return to_ap_private().to_uint64();
    }
#pragma empty_line
    inline double to_double() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x8000000000000000ULL : 0;
        ap_private<_AP_W, false> tmp(V);
        if (isneg) tmp = ap_private<_AP_W, false>(-V);
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(11 -1))-1)))<<52;
        if(i!=0) {
            tmp.clear(i);
            uint64_t man = ((i>52)?tmp.lshr(i-52):tmp).to_uint64() & 0x3fffffffffffffULL;
            res |= i<52 ? (man)<<(52 -i)& 0x3fffffffffffffULL : man;
        }
        double dp=rawBitsToDouble(res);
        return dp;
    }
#pragma empty_line
    inline float to_float() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x80000000ULL : 0;
        ap_private<_AP_W, false> tmp = V;
        if (isneg) tmp = -tmp;
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(8 -1))-1)))<<23;
        if(i!=0) {
            tmp.clear(i);
            uint32_t man = ((i>23) ? tmp.lshr(i-23) : tmp).to_uint() & 0x7fffff;
            res |= i<23 ? (man)<<(23 -i)& 0x7fffff : man;
        }
        float dp=rawBitsToFloat(res);
        return dp;
    }
#pragma empty_line
    inline operator long double () const {
        return to_double();
    }
#pragma empty_line
    inline operator double () const {
        return to_double();
    }
#pragma empty_line
    inline operator float () const {
           return to_float();
    }
#pragma empty_line
    inline operator char () const {
        return (char) to_int();
    }
#pragma empty_line
    inline operator signed char () const {
        return (signed char) to_int();
    }
#pragma empty_line
    inline operator unsigned char () const {
        return (unsigned char) to_uint();
    }
#pragma empty_line
    inline operator short () const {
        return (short) to_int();
    }
#pragma empty_line
    inline operator unsigned short () const {
        return (unsigned short) to_uint();
    }
#pragma empty_line
    inline operator int () const {
        return to_int();
    }
#pragma empty_line
    inline operator unsigned int () const {
        return to_uint();
    }
#pragma line 1481 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    inline operator long () const {
        return to_int64();
    }
#pragma empty_line
    inline operator unsigned long () const {
        return to_uint64();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline operator unsigned long long () const {
        return to_uint64();
    }
#pragma empty_line
    inline operator long long () const {
        return to_int64();
    }
#pragma empty_line
#pragma empty_line
    inline std::string to_string(uint8_t radix=2, bool sign=_AP_S) const;
#pragma empty_line
    inline ap_slong bits_to_int64() const {
      ap_private<((_AP_W) < (64) ? (_AP_W) : (64)), _AP_S> res(V);
        return (ap_slong) res;
    }
#pragma empty_line
    inline ap_ulong bits_to_uint64() const {
      ap_private<((64) < (_AP_W) ? (64) : (_AP_W)), _AP_S> res(V);
      return (ap_ulong) res;
    }
#pragma empty_line
    inline int length() const {return _AP_W;}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline int countLeadingZeros() {
        return V.countLeadingZeros();
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::mult
    operator * (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::mult r;
        r.V = V * op2.V;
        return r;
    }
#pragma empty_line
    template<int _AP_W1, int _AP_I1, bool _AP_S1, int _AP_W2, int _AP_I2, bool _AP_S2>
    static inline ap_fixed_base multiply(const ap_fixed_base<_AP_W1,_AP_I1,_AP_S1>& op1, const
         ap_fixed_base<_AP_W2,_AP_I2,_AP_S2>& op2) {
        ap_private<_AP_W+_AP_W2, _AP_S> OP1=op1.V;
        ap_private<_AP_W2,_AP_S2> OP2=op2.V;
        return OP1*OP2;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::div
    operator / (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
        ap_private<_W1, _AP_S||_AP_S2> dividend = (ap_private<_W1, _AP_S>(V)) << ((F2) > (0) ? (F2) : (0));
        ap_private<_W1, _AP_S||_AP_S2> divisior = ap_private<_W1, _AP_S2>(op2.V);
        typename RType<_AP_W2, _AP_I2, _AP_S2>::div r;
        r.V = ((_AP_S||_AP_S2) ? dividend.sdiv(divisior): dividend.udiv(divisior));
        return r;
    }
#pragma line 1568 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::plus operator + (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::plus r, lhs(*this), rhs(op2); r.V = lhs.V.Add(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::plus operator + (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::plus r; r.V = V + op2.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::minus operator - (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::minus r, lhs(*this), rhs(op2); r.V = lhs.V.Sub(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::minus operator - (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::minus r; r.V = V - op2.V; return r; }
#pragma line 1591 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator & (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V & rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator & (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V & op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator &(int op2) const { return V & (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator | (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V | rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator | (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V | op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator |(int op2) const { return V | (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator ^ (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V ^ rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^ (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V ^ op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^(int op2) const { return V ^ (op2<<(_AP_W - _AP_I)); }
#pragma line 1605 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator += (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator + (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator - (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator & (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator | (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator ^ (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator * (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator / (op2) ; return *this; }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base& operator ++() {
        operator+=(ap_fixed_base<1,1,false>(1));
        return *this;
    }
#pragma empty_line
    inline ap_fixed_base& operator --() {
        operator-=(ap_fixed_base<1,1,false>(1));
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline const ap_fixed_base operator ++(int) {
        ap_fixed_base t(*this);
        operator++();
        return t;
    }
#pragma empty_line
    inline const ap_fixed_base operator --(int) {
        ap_fixed_base t = *this;
        operator--();
        return t;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base operator +() {return *this;}
#pragma empty_line
    inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator -() const {
        ap_fixed_base<_AP_W + 1, _AP_I + 1, true> Tmp(*this);
        Tmp.V = - Tmp.V;
        return Tmp;
    }
#pragma empty_line
    inline ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> getNeg() {
        ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> Tmp(*this);
        Tmp.V=-Tmp.V;
        return Tmp;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool operator !() const {
        return !V;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base<_AP_W, _AP_I, _AP_S>
         operator ~() const {
        ap_fixed_base<_AP_W, _AP_I, _AP_S> res(*this);
        res.V.flip();
        return res;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift () const {
        ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }
#pragma empty_line
    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift () const {
        ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed_base operator << (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        bool NegSrc = V.isNegative();
        if(isNeg) {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        } else {
            if(shiftoverflow)
                r.V.clear();
            else
                r.V=V<<sh;
        }
#pragma line 1738 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed_base operator<<(const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator << (sh);
    }
#pragma empty_line
    inline ap_fixed_base operator << (unsigned int sh ) const {
        ap_fixed_base r;
        bool shiftoverflow = sh >= _AP_W;
        r.V = shiftoverflow ? ap_private<_AP_W, _AP_S >(0) : V << sh;
        if (sh == 0) return r;
#pragma line 1773 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed_base operator << (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator << (sh);
    }
#pragma empty_line
    inline ap_fixed_base operator >> (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        bool NegSrc = V.isNegative();
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        if(isNeg && !shiftoverflow) r.V=V<<sh;
        else {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        }
#pragma line 1825 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator >> (sh);
    }
#pragma empty_line
    inline ap_fixed_base operator >> (unsigned int sh) const {
        ap_fixed_base r;
        bool NegSrc = V.isNegative();
        bool shiftoverflow = sh >= _AP_W;
        if(shiftoverflow)
            NegSrc?r.V.set():r.V.clear();
        else
            r.V=_AP_S?V.ashr(sh):V.lshr(sh);
#pragma line 1855 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
        return r;
    }
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator >> (sh);
    }
#pragma line 1874 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator <<=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator >>=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator >> (op2); return *this; }
#pragma line 1891 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator << (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator << (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator <<= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator >> (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator >> (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator >>= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator >> (op2); return *this; }
#pragma empty_line
    inline ap_fixed_base& operator >>= (unsigned int sh) {
        *this = operator >> (sh);
        return *this;
    }
#pragma empty_line
    inline ap_fixed_base& operator <<= (unsigned int sh) {
        *this = operator << (sh);
        return *this;
    }
#pragma empty_line
    inline ap_fixed_base& operator >>= (int sh) {
        *this = operator >> (sh);
        return *this;
    }
#pragma empty_line
    inline ap_fixed_base& operator <<= (int sh) {
        *this = operator << (sh);
        return *this;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        return OP1 == OP2;
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this==op2);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.sgt(OP2);
        else
            return OP1.ugt(OP2);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this>op2);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.slt(OP2);
        else
            return OP1.ult(OP2);
    }
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this<op2);
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline bool operator == (double d) const { return to_double() == d; }
    inline bool operator != (double d) const { return to_double() != d; }
    inline bool operator > (double d) const { return to_double() > d; }
    inline bool operator >= (double d) const { return to_double() >= d; }
    inline bool operator < (double d) const { return to_double() < d; }
    inline bool operator <= (double d) const { return to_double() <= d; }
#pragma empty_line
#pragma empty_line
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> operator [] (unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }
#pragma empty_line
    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit(unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit (const ap_private<_AP_W2,_AP_S2>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int());
    }
#pragma empty_line
    inline bool bit (unsigned int index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);
#pragma empty_line
        return V[index];
    }
#pragma empty_line
    inline bool operator [] (unsigned int index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);
#pragma empty_line
        return V[index];
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);
#pragma empty_line
        return V[index.to_uint()];
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);
#pragma empty_line
        return V[index.to_uint()];
    }
#pragma empty_line
    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit(int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index + _AP_W - _AP_I);
    }
#pragma empty_line
    template<int _AP_W2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit (const ap_private<_AP_W2, true>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int() + _AP_W - _AP_I);
    }
#pragma empty_line
    inline bool get_bit (int index) const {
        if (index < _AP_I - _AP_W )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", index);
        if (index >= _AP_I)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);
#pragma empty_line
#pragma empty_line
        return V[index + _AP_W - _AP_I];
    }
#pragma empty_line
    template<int _AP_W2>
    inline bool get_bit (const ap_private<_AP_W2, true>& index) const {
        if (index < _AP_I - _AP_W )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", index.to_int());
        if (index >= _AP_I)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);
#pragma empty_line
#pragma empty_line
        return V[index.to_int() + _AP_W - _AP_I];
    }
#pragma empty_line
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) const {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<ap_fixed_base*>(this), Hi, Lo);
    }
#pragma empty_line
    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }
#pragma empty_line
    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }
#pragma empty_line
    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() {
        return this->range(_AP_W - 1, 0);
    }
#pragma empty_line
    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() const {
        return this->range(_AP_W - 1, 0);
    }
#pragma empty_line
    inline bool is_zero () const {
        return V.isMinValue();
    }
#pragma empty_line
    inline bool is_neg () const {
        if (V.isNegative())
            return true;
        return false;
    }
#pragma empty_line
    inline int wl () const {
        return _AP_W;
    }
#pragma empty_line
    inline int iwl () const {
        return _AP_I;
    }
#pragma empty_line
    inline ap_q_mode q_mode () const {
        return _AP_Q;
    }
#pragma empty_line
    inline ap_o_mode o_mode () const {
        return _AP_O;
    }
#pragma empty_line
    inline int n_bits () const {
        return 0;
    }
#pragma empty_line
#pragma empty_line
public:
    ap_private<_AP_W, _AP_S> V;
    static const int width = _AP_W;
    static const int iwidth = _AP_I;
    static const ap_q_mode qmode = _AP_Q;
    static const ap_o_mode omode = _AP_O;
#pragma empty_line
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
std::string ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>::to_string(
                                            uint8_t radix, bool sign) const {
    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && V.isNegative();
#pragma empty_line
#pragma empty_line
    ap_fixed_base<_AP_W+1, _AP_I+1> tmp(*this);
    if (isNeg) {
        tmp = -tmp;
        str += '-';
    }
    std::string prefix;
    switch (radix) {
        case 2 : prefix = "0b"; step = 1; break;
        case 8 : prefix = "0o"; step = 3; break;
        case 16 : prefix = "0x"; step = 4; break;
        default : break;
    }
#pragma empty_line
    if (_AP_I > 0) {
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
        ap_fixed_base<((_AP_I+1) > (1) ? (_AP_I+1) : (1)), ((_AP_I+1) > (1) ? (_AP_I+1) : (1)), false> int_part = tmp;
        str += int_part.to_ap_private().to_string(radix, false);
    } else {
        str += prefix;
        str += '0';
    }
    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;
#pragma empty_line
    if (radix == 10) {
        if (frac_part != 0) {
            str += ".";
            while (frac_part != 0) {
                char digit = (char)(frac_part * radix).to_ap_private();
                str += static_cast<char>(digit + '0');
                frac_part *= radix;
            }
        }
    } else {
        if (frac_part != 0) {
            str += ".";
            for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
                char digit = (char)(frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))));
#pragma empty_line
#pragma empty_line
                int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
                digit <<= -offset;
                str += digit < 10 ? static_cast<char>(digit + '0') :
                    static_cast<char>(digit - 10 + 'a');
            }
            if (radix == 16)
                str += "p0";
        }
    }
    return str;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_not(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = op.V;
    ret.V.flip();
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_and(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V & op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_or(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V | op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_xor(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V ^ op2.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    ap_fixed_base<_AP_W2+!_AP_S2, _AP_I2+!_AP_S2, true, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = - op.V;
    ret = Tmp;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = -op.V;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_W2 - _AP_I2 + ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V <<= i;
    ret = Tmp;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = op.V << i;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_I2 + ((_AP_W - _AP_I) > (_AP_W2 - _AP_I2) ? (_AP_W - _AP_I) : (_AP_W2 - _AP_I2)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V = _AP_S2 ? Tmp.V.ashr(i): Tmp.V.lshr(i);
    ret = Tmp;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = _AP_S ? op.V.ashr(i): op.V.lshr(i);
}
#pragma line 2317 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<> inline ap_fixed_base<1,1,true,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { } template<> inline ap_fixed_base<1,1,false,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { }
#pragma empty_line
#pragma empty_line
#pragma empty_line
inline std::string scientificFormat(std::string& input) {
    if (input.length() == 0)
        return input;
#pragma empty_line
    size_t decPosition = input.find('.');
    if (decPosition == std::string::npos)
        decPosition = input.length();
#pragma empty_line
    size_t firstNonZeroPos = 0;
    for (; input[firstNonZeroPos] > '9' ||
           input[firstNonZeroPos] < '1';
         firstNonZeroPos++);
#pragma empty_line
    int exp;
    if (firstNonZeroPos > decPosition)
        exp = decPosition - firstNonZeroPos;
    else
        exp = decPosition - firstNonZeroPos - 1;
    std::string expString = "";
    if (exp == 0);
    else if (exp < 0) {
        expString += "e-";
        exp = -exp;
    } else
        expString += "e+";
#pragma empty_line
    if (exp < 10 && exp > 0) {
        expString += '0';
        expString += (char)('0' + exp);
    } else if (exp != 0) {
        std::string tmp;
#pragma empty_line
        std::ostringstream oss;
        oss<<exp;
#pragma empty_line
        tmp=oss.str();
        expString += tmp;
    }
#pragma empty_line
    int lastNonZeroPos = (int) (input.length() - 1);
    for (; lastNonZeroPos >= 0; --lastNonZeroPos)
        if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0')
            break;
#pragma empty_line
    std::string ans = "";
    ans += input[firstNonZeroPos];
    if (firstNonZeroPos != (size_t)lastNonZeroPos) {
        ans += '.';
        for (int i=firstNonZeroPos+1; i <= lastNonZeroPos; i++)
            if (input[i] != '.')
                ans += input[i];
    }
#pragma empty_line
    ans += expString;
    return ans;
}
#pragma empty_line
inline std::string reduceToPrecision(std::string& input, int precision) {
#pragma empty_line
    bool isZero = true;
    size_t inputLen = input.length();
    for (size_t i=0; i<inputLen && isZero; i++)
        if (input[i] != '.' && input[i] != '0')
            isZero = false;
    if (isZero)
        return "0";
#pragma empty_line
#pragma empty_line
    int FirstNonZeroPos = 0;
    int LastNonZeroPos = (int) inputLen - 1;
    int truncBitPosition = 0;
    size_t decPosition = input.find('.');
    for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
         FirstNonZeroPos++);
#pragma empty_line
    for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
         LastNonZeroPos--);
#pragma empty_line
    if (decPosition == std::string::npos)
        decPosition = inputLen;
#pragma empty_line
    if ((int) decPosition > LastNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision;
    } else if ((int) decPosition < FirstNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
            if (FirstNonZeroPos - decPosition - 1 < 4) {
                return input;
            } else {
                if (input[0] == '-') {
                    std::string tmp = input.substr(1, inputLen-1);
                    return std::string("-") +
                           scientificFormat(tmp);
                } else
                    return scientificFormat(input);
            }
        }
        truncBitPosition = FirstNonZeroPos + precision;
    } else {
        if (LastNonZeroPos - FirstNonZeroPos <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision + 1;
    }
#pragma empty_line
#pragma empty_line
#pragma empty_line
    std::string ans = "";
    std::string dupInput = "0";
    if (input[0] == '-') {
        ans += '-';
        dupInput += input.substr(1, inputLen-1);
    } else {
        dupInput += input.substr(0, inputLen);
        ++truncBitPosition;
    }
#pragma empty_line
#pragma empty_line
    bool carry = dupInput[truncBitPosition] > '4';
    for (int i = truncBitPosition-1; i >=0 && carry; i--) {
        if (dupInput[i] == '.')
            continue;
        if (dupInput[i] == '9')
            dupInput[i] = '0';
        else {
            ++dupInput[i];
            carry = false;
        }
    }
#pragma empty_line
#pragma empty_line
    if (dupInput[0] == '1')
        FirstNonZeroPos = 0;
    else {
        FirstNonZeroPos = 0;
        while (dupInput[FirstNonZeroPos] < '1' ||
               dupInput[FirstNonZeroPos] > '9')
            ++FirstNonZeroPos;
    }
#pragma empty_line
    unsigned it = FirstNonZeroPos;
    int NValidNumber = 0;
    while (it < dupInput.length()) {
        if (dupInput[it] == '.') {
            ++it;
            continue;
        }
        ++NValidNumber;
        if (NValidNumber > precision)
            dupInput[it] = '0';
        ++it;
    }
#pragma empty_line
#pragma empty_line
    decPosition = dupInput.find('.');
    if (decPosition == std::string::npos)
        truncBitPosition = (int) dupInput.length();
    else
        for (truncBitPosition = (int) (dupInput.length()-1);
             truncBitPosition >=0;
             --truncBitPosition) {
            if (dupInput[truncBitPosition] == '.')
                break;
            if (dupInput[truncBitPosition] != '0') {
                truncBitPosition++;
                break;
            }
        }
#pragma empty_line
    if (dupInput[0] == '1')
        dupInput = dupInput.substr(0,
                                   truncBitPosition);
    else
        dupInput = dupInput.substr(1, truncBitPosition-1);
#pragma empty_line
    decPosition = dupInput.find('.');
    if (decPosition != std::string::npos) {
        size_t it = 0;
        for (it = decPosition+1; dupInput[it]=='0'; it++);
        if (it - decPosition - 1 < 4) {
            ans += dupInput;
            return ans;
        } else {
            ans += scientificFormat(dupInput);
            return ans;
        }
    } else if ((int)(dupInput.length()) <= precision) {
        ans += dupInput;
        return ans;
    }
#pragma empty_line
    ans += scientificFormat(dupInput);
    return ans;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::ostream&
operator <<(std::ostream& out, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    unsigned width = out.width();
    unsigned precision = out.precision();
    char fill = out.fill();
    std::string str=x.to_string(10,_AP_S);
    str = reduceToPrecision(str, precision);
    if (width > str.length()) {
        char *padding = (char*)malloc((width - str.length() + 1)*sizeof(char));
        for (unsigned i=0; i<width - str.length(); ++i)
            padding[i] = fill;
        padding[width - str.length()] = 0;
        str = std::string(padding) + str;
        free(padding);
    }
    out<<str;
    return out;
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::istream&
operator >> (std::istream& os, ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
     double d;
     os >> d;
     x = ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(d);
     return os;
}
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void print(const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    ap_private<_AP_W,_AP_S> data=x.V;
    if(_AP_I>0) {
        const ap_private<_AP_I,_AP_S> p1=data>>(_AP_W-_AP_I);
        print(p1);
#pragma empty_line
    } else
        printf("0");
    printf(".");
    if(_AP_I<_AP_W) {
        const ap_private<_AP_W-_AP_I,false> p2=data;
        print(p2,false);
    }
}
#pragma line 2704 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator + (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator - (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator * (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator / (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator & (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator | (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^ (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator == (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator != (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator > (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator < (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator += (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator -= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator *= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator /= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator &= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator |= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^= (ap_fixed_base<1,1,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator + (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator - (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator * (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator / (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator & (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator | (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^ (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator == (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator != (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator > (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator < (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator += (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^= (ap_fixed_base<8,8,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator + (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator - (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator * (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator / (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator & (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator | (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^ (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator == (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator != (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator > (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator < (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator += (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator -= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator *= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator /= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator &= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator |= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^= (ap_fixed_base<16,16,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator + (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator - (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator * (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator / (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator & (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator | (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^ (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator == (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator != (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator > (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator < (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator += (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^= (ap_fixed_base<16,16,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }
#pragma line 2754 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::plus operator + ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator + (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::minus operator - ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator - (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::mult operator * ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator * (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::div operator / ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator / (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator & ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator & (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator | ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator | (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator ^ ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^ (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator == ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator == (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator != ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator != (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator > ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator > (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator >= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator >= (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator < ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator < (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator <= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator <= (op); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator += (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator += ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator += (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator -= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator -= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator -= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator *= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator *= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator *= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator /= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator /= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator /= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator &= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator &= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator &= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator |= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator |= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator |= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator ^= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator ^= (op.to_ap_private()); }
#pragma line 2807 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#pragma line 2847 "C:/Xilinx/Vivado_HLS/2016.4/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<1,false>(op)); }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator == ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator == (op1);
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator != ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator != (op1);
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator > ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator < (op1);
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator >= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator <= (op1);
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator < ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator > (op1);
}
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator <= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator >= (op1);
}
#pragma line 76 "C:/Xilinx/Vivado_HLS/2016.4/include/ap_int.h" 2
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_fixed;
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_ufixed;
template<int _AP_W> class ap_int;
template<int _AP_W> class ap_uint;
#pragma empty_line
#pragma empty_line
template<int _AP_W>
class ap_int: public ap_private<_AP_W, true> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
    typedef ap_private<_AP_W, true> Base;
#pragma empty_line
    inline ap_int(): Base() {}
    template<int _AP_W2>
    inline ap_int(const volatile ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_int(const ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_int(const ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_int(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_int(bool v):Base(v) {}
    inline ap_int(signed char v):Base(v) {}
    inline ap_int(unsigned char v):Base(v) {}
    inline ap_int(short v):Base(v) {}
    inline ap_int(unsigned short v):Base(v) {}
    inline ap_int(int v):Base(v) {}
    inline ap_int(unsigned int v):Base(v) {}
    inline ap_int(long v):Base(v) {}
    inline ap_int(unsigned long v):Base(v) {}
    inline ap_int(unsigned long long v):Base(v) {}
    inline ap_int(long long v):Base(v) {}
    inline ap_int(float v):Base(v) {}
    inline ap_int(double v):Base(v) {}
    inline ap_int(const char* v):Base(v) {}
#pragma empty_line
#pragma empty_line
    inline ap_int(const char* str, signed char rd):Base(str, rd) {}
#pragma empty_line
#pragma empty_line
    inline void operator = (const ap_int<_AP_W>& op2) volatile {
      const_cast<ap_int*>(this)->operator = (op2);
    }
#pragma empty_line
    inline void operator = (const volatile ap_int<_AP_W>& op2) volatile {
      const_cast<Base*>(this)->operator = (op2);
    }
#pragma empty_line
    inline ap_int<_AP_W>& operator = (const volatile ap_int<_AP_W>& op2) {
      Base::operator = (const_cast<ap_int<_AP_W>& >(op2));
        return *this;
    }
#pragma empty_line
    inline ap_int<_AP_W>& operator = (const ap_int<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, true>&)op2);
        return *this;
    }
#pragma empty_line
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W>
class ap_uint: public ap_private<_AP_W, false> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
    typedef ap_private<_AP_W, false> Base;
#pragma empty_line
    inline ap_uint(): Base() {}
  inline ap_uint(const ap_uint<_AP_W>& op) :Base(dynamic_cast<const ap_private<_AP_W, false>&>(op)) {}
  inline ap_uint(const volatile ap_uint<_AP_W>& op):Base(dynamic_cast<const volatile ap_private<_AP_W, false>&>(op)){}
    template<int _AP_W2>
    inline ap_uint(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2, false>&)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_uint(const ap_uint<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)){}
#pragma empty_line
    template<int _AP_W2>
    inline ap_uint(const ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, true>&)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_uint(const volatile ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_uint(bool v):Base(v) {}
    inline ap_uint(signed char v):Base(v) {}
    inline ap_uint(unsigned char v):Base(v) {}
    inline ap_uint(short v):Base(v) {}
    inline ap_uint(unsigned short v):Base(v) {}
    inline ap_uint(int v):Base(v) {}
    inline ap_uint(unsigned int v):Base(v) {}
    inline ap_uint(long v):Base(v) {}
    inline ap_uint(unsigned long v):Base(v) {}
    inline ap_uint(unsigned long long v):Base(v) {}
    inline ap_uint(long long v):Base(v) {}
    inline ap_uint(float v):Base(v) {}
    inline ap_uint(double v):Base(v) {}
    inline ap_uint(const char* v):Base(v) {}
#pragma empty_line
#pragma empty_line
    inline ap_uint(const char* str, signed char rd):Base(str, rd) {}
#pragma empty_line
#pragma empty_line
    inline void operator = (const ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }
#pragma empty_line
    inline void operator = (const volatile ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }
#pragma empty_line
    inline ap_uint<_AP_W>& operator = (const volatile ap_uint<_AP_W>& op2) {
      Base::operator = (op2);
        return *this;
    }
#pragma empty_line
    inline ap_uint<_AP_W>& operator = (const ap_uint<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, false>&)(op2));
        return *this;
    }
#pragma empty_line
};
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_fixed: public ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
    typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;
#pragma empty_line
    inline ap_fixed():Base() {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(op) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed(const ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed(const ap_uint<_AP_W2>& op):Base(ap_private<_AP_W2, false>(op)) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                    true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed(const volatile ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_fixed(const volatile ap_uint<_AP_W2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_fixed(bool v):Base(v) {}
    inline ap_fixed(signed char v):Base(v) {}
    inline ap_fixed(unsigned char v):Base(v) {}
    inline ap_fixed(short v):Base(v) {}
    inline ap_fixed(unsigned short v):Base(v) {}
    inline ap_fixed(int v):Base(v) {}
    inline ap_fixed(unsigned int v):Base(v) {}
    inline ap_fixed(long v):Base(v) {}
    inline ap_fixed(unsigned long v):Base(v) {}
    inline ap_fixed(unsigned long long v):Base(v) {}
    inline ap_fixed(long long v):Base(v) {}
    inline ap_fixed(float v):Base(v) {}
    inline ap_fixed(double v):Base(v) {}
    inline ap_fixed(const char* v):Base(v) {}
#pragma empty_line
#pragma empty_line
    inline ap_fixed(const char* str, signed char rd):Base(str, rd) {}
#pragma empty_line
#pragma empty_line
    inline ap_fixed& operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }
#pragma empty_line
    inline ap_fixed& operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::operator = (op);
        return *this;
    }
#pragma empty_line
    inline void operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }
#pragma empty_line
    inline void operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::operator = (op);
    }
#pragma empty_line
};
#pragma empty_line
#pragma empty_line
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_ufixed: public ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
#pragma empty_line
#pragma empty_line
#pragma empty_line
public:
    typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;
#pragma empty_line
    inline ap_ufixed():Base() {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_ufixed(const ap_int<_AP_W2>& op):
      Base((const ap_private<_AP_W2, true>&)(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_ufixed(const ap_uint<_AP_W2>& op):
      Base((const ap_private<_AP_W2, false>&)(op)) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
#pragma empty_line
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_int<_AP_W2>& op):
                     Base(ap_private<_AP_W2, true>(op)) {}
#pragma empty_line
    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_uint<_AP_W2>& op):
                     Base(ap_private<_AP_W2, false>(op)) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                     _AP_O2, _AP_N2>& op):Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}
#pragma empty_line
    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_ufixed(bool v):Base(v) {}
    inline ap_ufixed(signed char v):Base(v) {}
    inline ap_ufixed(unsigned char v):Base(v) {}
    inline ap_ufixed(short v):Base(v) {}
    inline ap_ufixed(unsigned short v):Base(v) {}
    inline ap_ufixed(int v):Base(v) {}
    inline ap_ufixed(unsigned int v):Base(v) {}
    inline ap_ufixed(long v):Base(v) {}
    inline ap_ufixed(unsigned long v):Base(v) {}
    inline ap_ufixed(unsigned long long v):Base(v) {}
    inline ap_ufixed(long long v):Base(v) {}
    inline ap_ufixed(float v):Base(v) {}
    inline ap_ufixed(double v):Base(v) {}
    inline ap_ufixed(const char* v):Base(v) {}
#pragma empty_line
#pragma empty_line
    inline ap_ufixed(const char* str, signed char rd):Base(str, rd) {}
#pragma empty_line
#pragma empty_line
#pragma empty_line
    inline ap_ufixed& operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }
#pragma empty_line
    inline ap_ufixed& operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = const_cast<ap_ufixed&>(op);
        return *this;
    }
#pragma empty_line
    inline void operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }
#pragma empty_line
    inline void operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = const_cast<ap_ufixed&>(op);
    }
#pragma empty_line
};
#pragma line 29 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
typedef ap_int<8> int8;
typedef ap_uint<7> uint7;
typedef ap_uint<9> uint9;
typedef ap_int<11> int11;
typedef ap_int<12> int12;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
struct vars_3_23
{
 int11 inx1;
 int11 inx2;
 int11 inx3;
};
#pragma empty_line
struct vars_3_45
{
 uint7 inx1;
 uint7 inx2;
 uint7 inx3;
};
#pragma empty_line
struct vars_3_45a
{
 uint9 inx1;
 uint9 inx2;
 uint9 inx3;
};
#pragma empty_line
struct vars_3_12
{
 int12 inx1;
 int12 inx2;
 int12 inx3;
};
#pragma empty_line
#pragma empty_line
struct pack_var
{
 int11 a;
 int11 b;
 int11 c;
};
#pragma empty_line
struct pvars_18
{
 int11 deg;
 pack_var one;
 pack_var two;
 pack_var three;
 pack_var four;
 pack_var five;
 pack_var six;
};
#pragma empty_line
struct xpeta
{
 int8 one;
 int8 two;
 int8 three;
 int8 four;
};
#pragma empty_line
struct peta
{
 int8 one;
 int8 two;
#pragma empty_line
};
#pragma empty_line
struct peta_a
{
 int8 three;
 int8 four;
 int8 five;
 int8 six;
#pragma empty_line
};
#pragma empty_line
struct peta_b
{
 int8 seven;
 int8 eight;
 int8 nine;
 int8 ten;
#pragma empty_line
};
#pragma empty_line
struct peta_c
{
 int8 eleven;
 int8 twelve;
 int8 thirteen;
 int8 fourteen;
#pragma empty_line
};
#pragma empty_line
struct peta_d
{
 int8 fifteen;
 int8 sixteen;
 int8 seventeen;
 int8 eighteen;
};
#pragma empty_line
#pragma empty_line
xpeta SpEtaPrev[2048];
xpeta SpEtaPrevC[2048];
#pragma empty_line
peta SpEtaPrevA[2048];
peta_a SpEtaPrevAa[2048];
peta_b SpEtaPrevAb[1024];
peta_c SpEtaPrevAc[512];
peta_d SpEtaPrevAd[512];
#pragma empty_line
peta SpEtaPrevB[2048];
peta_a SpEtaPrevBa[2048];
peta_b SpEtaPrevBb[1024];
peta_c SpEtaPrevBc[512];
peta_d SpEtaPrevBd[512];
#pragma empty_line
peta SpEtaPrevD[2048];
peta_a SpEtaPrevDa[2048];
peta_b SpEtaPrevDb[1024];
peta_c SpEtaPrevDc[512];
peta_d SpEtaPrevDd[512];
#pragma empty_line
peta SpEtaPrevE[2048];
peta_a SpEtaPrevEa[2048];
peta_b SpEtaPrevEb[1024];
peta_c SpEtaPrevEc[512];
peta_d SpEtaPrevEd[512];
#pragma empty_line
#pragma empty_line
short pLambda0[2048];
short pLambda1[2048];
short pLambda2[2048];
short pLambda3[2048];
short pLambda4[2048];
short pLambda5[1024];
short pLambda6[1024];
short pLambda7[1024];
short pLambda8[1024];
short pLambda9[1024];
short pLambda10[1024];
#pragma empty_line
short inxtab[8];
#pragma empty_line
short Lam_tabx[18], Peta_tabx[18], Eta_tabx[18], Eta_ans[18];
short Lam_taby[18], Peta_taby[18], Eta_taby[18], Eta_ans_1[18];
short Lam_tabz[18], Peta_tabz[18], Eta_tabz[18], Eta_ans_2[18];
short Lam_tabe[18], Peta_tabe[18], Eta_tabe[18], Eta_ans_3[18];
short Lam_tabf[18], Peta_tabf[18], Eta_tabf[18], Eta_ans_4[18];
short Lam_tabg[18], Peta_tabg[18], Eta_tabg[18], Eta_ans_5[18];
short Lam_tabh[18], Peta_tabh[18], Eta_tabh[18], Eta_ans_6[18];
short Lam_tabi[18], Peta_tabi[18], Eta_tabi[18], Eta_ans_7[18];
short Lam_tabj[18], Peta_tabj[18], Eta_tabj[18], Eta_ans_8[18];
short Lam_tabk[18], Peta_tabk[18], Eta_tabk[18], Eta_ans_9[18];
short Lam_tabl[18], Peta_tabl[18], Eta_tabl[18], Eta_ans_10[18];
short Lam_tabm[18], Peta_tabm[18], Eta_tabm[18], Eta_ans_11[18];
#pragma empty_line
short Lam_tabn[18], Peta_tabn[18], Eta_tabn[18], Eta_ans_12[18];
short Lam_tabo[18], Peta_tabo[18], Eta_tabo[18], Eta_ans_13[18];
short Lam_tabp[18], Peta_tabp[18], Eta_tabp[18], Eta_ans_14[18];
short Lam_tabq[18], Peta_tabq[18], Eta_tabq[18], Eta_ans_15[18];
#pragma empty_line
short Lam_buf2[1023+1], Lam_buf4[1023+1],Lam_buf4a[1023+1];
short Lam_buf6[1024], Lam_buf6a[1024];;
short Lam_buf8[1022+2], Lam_buf10[1022+2], Lam_buf10a[1022+2];
#pragma empty_line
short Lam_bufAa[1023+1], Lam_bufAb[1023+1], Lam_bufAc[1023+1], Lam_bufA1[1023+1], Lam_bufA2a[1023+1], Lam_bufA2b[1023+1],Lam_bufA2c[1023+1];
short Lam_bufA3[1023+1],Lam_bufA4a[1023+1], Lam_bufA4b[1023+1], Lam_bufA4c[1023+1];
short Lam_bufA5[1024], Lam_bufA6[1024], Lam_bufA6b[1024],Lam_bufA6c[1024];
short Lam_bufA7[1022+2], Lam_bufA9[1022+2], Lam_bufA10a[1022+2],Lam_bufA10b[1022+2],Lam_bufA10c[1022+2];
#pragma empty_line
short Lam_bufB[1023+1], Lam_bufB1a[1023+1], Lam_bufB1b[1023+1], Lam_bufB1c[1023+1], Lam_bufB2[1023+1];
short Lam_bufB3a[1023+1], Lam_bufB3b[1023+1], Lam_bufB3c[1023+1], Lam_bufB4[1023+1];
short Lam_bufB5a[1024],Lam_bufB5b[1024],Lam_bufB5c[1024], Lam_bufB6[1024];
short Lam_bufB7a[1022+2], Lam_bufB7b[1022+2], Lam_bufB9a[1022+2],Lam_bufB9b[1022+2],Lam_bufB10[1022+2];
#pragma empty_line
short prLam_buf2[1023+1], prLam_buf4[1023+1], prLam_buf4a[1023+1];
#pragma empty_line
short prLamC_buf[1023+1], prLamC_bufa[1023+1],prLamC_bufb[1023+1], prLamC_buf1[1023+1], prLamC_buf2[1023+1], prLamC_buf2a[1023+1], prLamC_buf2b[1023+1];
short prLamC_buf3[1023+1],prLamC_buf4[1023+1],prLamC_buf4a[1023+1],prLamC_buf4b[1023+1];
short prLamC_buf5[1024],prLamC_buf6[1024];
short prLamC_buf7[1022+2], prLamC_buf9[1022+2],prLamC_buf10[1022+2],prLamC_buf10a[1022+2],prLamC_buf10b[1022+2];
#pragma empty_line
short prLamB_buf[1023+1], prLamB_buf1[1023+1], prLamB_buf1a[1023+1],prLamB_buf1b[1023+1], prLamB_buf2[1023+1];
short prLamB_buf3[1023+1], prLamB_buf3a[1023+1], prLamB_buf3b[1023+1],prLamB_buf4[1023+1];
short prLamB_buf5[1024], prLamB_buf5a[1024], prLamB_buf5b[1024], prLamB_buf6[1024];
short prLamB_buf7[1022+2], prLamB_buf7a[1022+2], prLamB_buf9[1022+2],prLamB_buf9a[1022+2],prLamB_buf10[1022+2];
#pragma empty_line
short prLam2_buf2[1023+1], prLam2_buf4[1023+1], prLam2_buf4a[1023+1];
#pragma empty_line
short prLam2C_buf[1023+1], prLam2C_bufa[1023+1],prLam2C_bufb[1023+1], prLam2C_buf1[1023+1], prLam2C_buf2[1023+1], prLam2C_buf2a[1023+1], prLam2C_buf2b[1023+1];
short prLam2C_buf3[1023+1],prLam2C_buf4[1023+1],prLam2C_buf4a[1023+1],prLam2C_buf4b[1023+1];
short prLam2C_buf5[1024],prLam2C_buf6[1024];
short prLam2C_buf7[1022+2], prLam2C_buf9[1022+2],prLam2C_buf10[1022+2],prLam2C_buf10a[1022+2],prLam2C_buf10b[1022+2];
#pragma empty_line
short prLam2B_buf[1023+1], prLam2B_buf1[1023+1], prLam2B_buf1a[1023+1],prLam2B_buf1b[1023+1], prLam2B_buf2[1023+1];
short prLam2B_buf3[1023+1], prLam2B_buf3a[1023+1], prLam2B_buf3b[1023+1],prLam2B_buf4[1023+1];
short prLam2B_buf5[1024], prLam2B_buf5a[1024], prLam2B_buf5b[1024], prLam2B_buf6[1024];
short prLam2B_buf7[1022+2], prLam2B_buf7a[1022+2], prLam2B_buf9[1022+2],prLam2B_buf9a[1022+2],prLam2B_buf10[1022+2];
#pragma empty_line
bool prHat_buf[2048], prHat_buf1[2048], prHat_buf2[2048], prHat_buf3[2048], prHat_buf4[2048], prHat_buf4a[2048] ;
bool prHat_buf6[2048], prHat_buf6a[2048], prHat_buf8[2048], prHat_buf10[2048], prHat_buf10a[2048], prHat_buf10b[2048];
#pragma empty_line
bool prHat_bufA[2048], prHat_bufAa[2048], prHat_bufAb[2048], prHat_bufAc[2048], prHat_bufA1[2048], prHat_bufA2[2048];
bool prHat_bufA2a[2048], prHat_bufA2b[2048],prHat_bufA2c[2048],prHat_bufA3[2048],prHat_bufA4[2048], prHat_bufA4a[2048], prHat_bufA4b[2048], prHat_bufA5[2048];
bool prHat_bufA6[2048], prHat_bufA6a[2048], prHat_bufA6b[2048], prHat_bufA6c[2048], prHat_bufA7[2048], prHat_bufA9[2048],prHat_bufA10[2048], prHat_bufA10a[2048], prHat_bufA10b[2048], prHat_bufA10c[2048] ;
#pragma empty_line
bool prHat_bufB[2048], prHat_bufB1[2048], prHat_bufB1a[2048], prHat_bufB1b[2048], prHat_bufB1c[2048], prHat_bufB2[2048],prHat_bufB3[2048];
bool prHat_bufB3a[2048], prHat_bufB3b[2048],prHat_bufB3c[2048], prHat_bufB4[2048],prHat_bufB5[2048], prHat_bufB5a[2048], prHat_bufB5b[2048], prHat_bufB5c[2048];
bool prHat_bufB6[2048], prHat_bufB7[2048],prHat_bufB7a[2048], prHat_bufB9[2048], prHat_bufB9a[2048],prHat_bufB10[2048];
#pragma empty_line
short pest0, pest1, pest2, pest3, pest4, pest5, pest6, pest7, pest8, pest9, pest10;
bool bpest0, bpest1, bpest2, bpest3, bpest4, bpest5, bpest6, bpest7, bpest8, bpest9, bpest10;
#pragma empty_line
bool bAllChecksPassed = false;
short rows, cols, bitsperblock, numb;
short blk_val = 1;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
typedef unsigned short tab_int;
#pragma empty_line
tab_int nIterationCounter;
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_1_2_1_trichk.h" 1
 const vars_3_23 varinx6A_1024_a[] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127,
128, 128, 128,
129, 129, 129,
130, 130, 130,
131, 131, 131,
132, 132, 132,
133, 133, 133,
134, 134, 134,
135, 135, 135,
136, 136, 136,
137, 137, 137,
138, 138, 138,
139, 139, 139,
140, 140, 140,
141, 141, 141,
142, 142, 142,
143, 143, 143,
144, 144, 144,
145, 145, 145,
146, 146, 146,
147, 147, 147,
148, 148, 148,
149, 149, 149,
150, 150, 150,
151, 151, 151,
152, 152, 152,
153, 153, 153,
154, 154, 154,
155, 155, 155,
156, 156, 156,
157, 157, 157,
158, 158, 158,
159, 159, 159,
160, 160, 160,
161, 161, 161,
162, 162, 162,
163, 163, 163,
164, 164, 164,
165, 165, 165,
166, 166, 166,
167, 167, 167,
168, 168, 168,
169, 169, 169,
170, 170, 170,
171, 171, 171,
172, 172, 172,
173, 173, 173,
174, 174, 174,
175, 175, 175,
176, 176, 176,
177, 177, 177,
178, 178, 178,
179, 179, 179,
180, 180, 180,
181, 181, 181,
182, 182, 182,
183, 183, 183,
184, 184, 184,
185, 185, 185,
186, 186, 186,
187, 187, 187,
188, 188, 188,
189, 189, 189,
190, 190, 190,
191, 191, 191,
192, 192, 192,
193, 193, 193,
194, 194, 194,
195, 195, 195,
196, 196, 196,
197, 197, 197,
198, 198, 198,
199, 199, 199,
200, 200, 200,
201, 201, 201,
202, 202, 202,
203, 203, 203,
204, 204, 204,
205, 205, 205,
206, 206, 206,
207, 207, 207,
208, 208, 208,
209, 209, 209,
210, 210, 210,
211, 211, 211,
212, 212, 212,
213, 213, 213,
214, 214, 214,
215, 215, 215,
216, 216, 216,
217, 217, 217,
218, 218, 218,
219, 219, 219,
220, 220, 220,
221, 221, 221,
222, 222, 222,
223, 223, 223,
224, 224, 224,
225, 225, 225,
226, 226, 226,
227, 227, 227,
228, 228, 228,
229, 229, 229,
230, 230, 230,
231, 231, 231,
232, 232, 232,
233, 233, 233,
234, 234, 234,
235, 235, 235,
236, 236, 236,
237, 237, 237,
238, 238, 238,
239, 239, 239,
240, 240, 240,
241, 241, 241,
242, 242, 242,
243, 243, 243,
244, 244, 244,
245, 245, 245,
246, 246, 246,
247, 247, 247,
248, 248, 248,
249, 249, 249,
250, 250, 250,
251, 251, 251,
252, 252, 252,
253, 253, 253,
254, 254, 254,
255, 255, 255,
256, 256, 256,
257, 257, 257,
258, 258, 258,
259, 259, 259,
260, 260, 260,
261, 261, 261,
262, 262, 262,
263, 263, 263,
264, 264, 264,
265, 265, 265,
266, 266, 266,
267, 267, 267,
268, 268, 268,
269, 269, 269,
270, 270, 270,
271, 271, 271,
272, 272, 272,
273, 273, 273,
274, 274, 274,
275, 275, 275,
276, 276, 276,
277, 277, 277,
278, 278, 278,
279, 279, 279,
280, 280, 280,
281, 281, 281,
282, 282, 282,
283, 283, 283,
284, 284, 284,
285, 285, 285,
286, 286, 286,
287, 287, 287,
288, 288, 288,
289, 289, 289,
290, 290, 290,
291, 291, 291,
292, 292, 292,
293, 293, 293,
294, 294, 294,
295, 295, 295,
296, 296, 296,
297, 297, 297,
298, 298, 298,
299, 299, 299,
300, 300, 300,
301, 301, 301,
302, 302, 302,
303, 303, 303,
304, 304, 304,
305, 305, 305,
306, 306, 306,
307, 307, 307,
308, 308, 308,
309, 309, 309,
310, 310, 310,
311, 311, 311,
312, 312, 312,
313, 313, 313,
314, 314, 314,
315, 315, 315,
316, 316, 316,
317, 317, 317,
318, 318, 318,
319, 319, 319,
320, 320, 320,
321, 321, 321,
322, 322, 322,
323, 323, 323,
324, 324, 324,
325, 325, 325,
326, 326, 326,
327, 327, 327,
328, 328, 328,
329, 329, 329,
330, 330, 330,
331, 331, 331,
332, 332, 332,
333, 333, 333,
334, 334, 334,
335, 335, 335,
336, 336, 336,
337, 337, 337,
338, 338, 338,
339, 339, 339,
340, 340, 340,
341, 341, 341,
342, 342, 342,
343, 343, 343,
344, 344, 344,
345, 345, 345,
346, 346, 346,
347, 347, 347,
348, 348, 348,
349, 349, 349,
350, 350, 350,
351, 351, 351,
352, 352, 352,
353, 353, 353,
354, 354, 354,
355, 355, 355,
356, 356, 356,
357, 357, 357,
358, 358, 358,
359, 359, 359,
360, 360, 360,
361, 361, 361,
362, 362, 362,
363, 363, 363,
364, 364, 364,
365, 365, 365,
366, 366, 366,
367, 367, 367,
368, 368, 368,
369, 369, 369,
370, 370, 370,
371, 371, 371,
372, 372, 372,
373, 373, 373,
374, 374, 374,
375, 375, 375,
376, 376, 376,
377, 377, 377,
378, 378, 378,
379, 379, 379,
380, 380, 380,
381, 381, 381,
382, 382, 382,
383, 383, 383,
384, 384, 384,
385, 385, 385,
386, 386, 386,
387, 387, 387,
388, 388, 388,
389, 389, 389,
390, 390, 390,
391, 391, 391,
392, 392, 392,
393, 393, 393,
394, 394, 394,
395, 395, 395,
396, 396, 396,
397, 397, 397,
398, 398, 398,
399, 399, 399,
400, 400, 400,
401, 401, 401,
402, 402, 402,
403, 403, 403,
404, 404, 404,
405, 405, 405,
406, 406, 406,
407, 407, 407,
408, 408, 408,
409, 409, 409,
410, 410, 410,
411, 411, 411,
412, 412, 412,
413, 413, 413,
414, 414, 414,
415, 415, 415,
416, 416, 416,
417, 417, 417,
418, 418, 418,
419, 419, 419,
420, 420, 420,
421, 421, 421,
422, 422, 422,
423, 423, 423,
424, 424, 424,
425, 425, 425,
426, 426, 426,
427, 427, 427,
428, 428, 428,
429, 429, 429,
430, 430, 430,
431, 431, 431,
432, 432, 432,
433, 433, 433,
434, 434, 434,
435, 435, 435,
436, 436, 436,
437, 437, 437,
438, 438, 438,
439, 439, 439,
440, 440, 440,
441, 441, 441,
442, 442, 442,
443, 443, 443,
444, 444, 444,
445, 445, 445,
446, 446, 446,
447, 447, 447,
448, 448, 448,
449, 449, 449,
450, 450, 450,
451, 451, 451,
452, 452, 452,
453, 453, 453,
454, 454, 454,
455, 455, 455,
456, 456, 456,
457, 457, 457,
458, 458, 458,
459, 459, 459,
460, 460, 460,
461, 461, 461,
462, 462, 462,
463, 463, 463,
464, 464, 464,
465, 465, 465,
466, 466, 466,
467, 467, 467,
468, 468, 468,
469, 469, 469,
470, 470, 470,
471, 471, 471,
472, 472, 472,
473, 473, 473,
474, 474, 474,
475, 475, 475,
476, 476, 476,
477, 477, 477,
478, 478, 478,
479, 479, 479,
480, 480, 480,
481, 481, 481,
482, 482, 482,
483, 483, 483,
484, 484, 484,
485, 485, 485,
486, 486, 486,
487, 487, 487,
488, 488, 488,
489, 489, 489,
490, 490, 490,
491, 491, 491,
492, 492, 492,
493, 493, 493,
494, 494, 494,
495, 495, 495,
496, 496, 496,
497, 497, 497,
498, 498, 498,
499, 499, 499,
500, 500, 500,
501, 501, 501,
502, 502, 502,
503, 503, 503,
504, 504, 504,
505, 505, 505,
506, 506, 506,
507, 507, 507,
508, 508, 508,
509, 509, 509,
510, 510, 510,
511, 511, 511
 };
const vars_3_23 varinx6B_1024_a[] = {
0, 306, 413,
1, 307, 414,
2, 308, 415,
3, 309, 416,
4, 310, 417,
5, 311, 418,
6, 312, 419,
7, 313, 420,
8, 314, 421,
9, 315, 422,
10, 316, 423,
11, 317, 424,
12, 318, 425,
13, 319, 426,
14, 320, 427,
15, 321, 428,
16, 322, 429,
17, 323, 430,
18, 324, 431,
19, 325, 432,
20, 326, 433,
21, 327, 434,
22, 328, 435,
23, 329, 436,
24, 330, 437,
25, 331, 438,
26, 332, 439,
27, 333, 440,
28, 334, 441,
29, 335, 442,
30, 336, 443,
31, 337, 444,
32, 338, 445,
33, 339, 446,
34, 340, 447,
35, 341, 448,
36, 342, 449,
37, 343, 450,
38, 344, 451,
39, 345, 452,
40, 346, 453,
41, 347, 454,
42, 348, 455,
43, 349, 456,
44, 350, 457,
45, 351, 458,
46, 352, 459,
47, 353, 460,
48, 354, 461,
49, 355, 462,
50, 356, 463,
51, 357, 464,
52, 358, 465,
53, 359, 466,
54, 360, 467,
55, 361, 468,
56, 362, 469,
57, 363, 470,
58, 364, 471,
59, 365, 472,
60, 366, 473,
61, 367, 474,
62, 368, 475,
63, 369, 476,
64, 370, 477,
65, 371, 478,
66, 372, 479,
67, 373, 480,
68, 374, 481,
69, 375, 482,
70, 376, 483,
71, 377, 484,
72, 378, 485,
73, 379, 486,
74, 380, 487,
75, 381, 488,
76, 382, 489,
77, 383, 490,
78, 256, 491,
79, 257, 492,
80, 258, 493,
81, 259, 494,
82, 260, 495,
83, 261, 496,
84, 262, 497,
85, 263, 498,
86, 264, 499,
87, 265, 500,
88, 266, 501,
89, 267, 502,
90, 268, 503,
91, 269, 504,
92, 270, 505,
93, 271, 506,
94, 272, 507,
95, 273, 508,
96, 274, 509,
97, 275, 510,
98, 276, 511,
99, 277, 384,
100, 278, 385,
101, 279, 386,
102, 280, 387,
103, 281, 388,
104, 282, 389,
105, 283, 390,
106, 284, 391,
107, 285, 392,
108, 286, 393,
109, 287, 394,
110, 288, 395,
111, 289, 396,
112, 290, 397,
113, 291, 398,
114, 292, 399,
115, 293, 400,
116, 294, 401,
117, 295, 402,
118, 296, 403,
119, 297, 404,
120, 298, 405,
121, 299, 406,
122, 300, 407,
123, 301, 408,
124, 302, 409,
125, 303, 410,
126, 304, 411,
127, 305, 412,
128, 0, 431,
129, 1, 432,
130, 2, 433,
131, 3, 434,
132, 4, 435,
133, 5, 436,
134, 6, 437,
135, 7, 438,
136, 8, 439,
137, 9, 440,
138, 10, 441,
139, 11, 442,
140, 12, 443,
141, 13, 444,
142, 14, 445,
143, 15, 446,
144, 16, 447,
145, 17, 448,
146, 18, 449,
147, 19, 450,
148, 20, 451,
149, 21, 452,
150, 22, 453,
151, 23, 454,
152, 24, 455,
153, 25, 456,
154, 26, 457,
155, 27, 458,
156, 28, 459,
157, 29, 460,
158, 30, 461,
159, 31, 462,
160, 32, 463,
161, 33, 464,
162, 34, 465,
163, 35, 466,
164, 36, 467,
165, 37, 468,
166, 38, 469,
167, 39, 470,
168, 40, 471,
169, 41, 472,
170, 42, 473,
171, 43, 474,
172, 44, 475,
173, 45, 476,
174, 46, 477,
175, 47, 478,
176, 48, 479,
177, 49, 480,
178, 50, 481,
179, 51, 482,
180, 52, 483,
181, 53, 484,
182, 54, 485,
183, 55, 486,
184, 56, 487,
185, 57, 488,
186, 58, 489,
187, 59, 490,
188, 60, 491,
189, 61, 492,
190, 62, 493,
191, 63, 494,
192, 64, 495,
193, 65, 496,
194, 66, 497,
195, 67, 498,
196, 68, 499,
197, 69, 500,
198, 70, 501,
199, 71, 502,
200, 72, 503,
201, 73, 504,
202, 74, 505,
203, 75, 506,
204, 76, 507,
205, 77, 508,
206, 78, 509,
207, 79, 510,
208, 80, 511,
209, 81, 384,
210, 82, 385,
211, 83, 386,
212, 84, 387,
213, 85, 388,
214, 86, 389,
215, 87, 390,
216, 88, 391,
217, 89, 392,
218, 90, 393,
219, 91, 394,
220, 92, 395,
221, 93, 396,
222, 94, 397,
223, 95, 398,
224, 96, 399,
225, 97, 400,
226, 98, 401,
227, 99, 402,
228, 100, 403,
229, 101, 404,
230, 102, 405,
231, 103, 406,
232, 104, 407,
233, 105, 408,
234, 106, 409,
235, 107, 410,
236, 108, 411,
237, 109, 412,
238, 110, 413,
239, 111, 414,
240, 112, 415,
241, 113, 416,
242, 114, 417,
243, 115, 418,
244, 116, 419,
245, 117, 420,
246, 118, 421,
247, 119, 422,
248, 120, 423,
249, 121, 424,
250, 122, 425,
251, 123, 426,
252, 124, 427,
253, 125, 428,
254, 126, 429,
255, 127, 430,
256, 31, 250,
257, 32, 251,
258, 33, 252,
259, 34, 253,
260, 35, 254,
261, 36, 255,
262, 37, 128,
263, 38, 129,
264, 39, 130,
265, 40, 131,
266, 41, 132,
267, 42, 133,
268, 43, 134,
269, 44, 135,
270, 45, 136,
271, 46, 137,
272, 47, 138,
273, 48, 139,
274, 49, 140,
275, 50, 141,
276, 51, 142,
277, 52, 143,
278, 53, 144,
279, 54, 145,
280, 55, 146,
281, 56, 147,
282, 57, 148,
283, 58, 149,
284, 59, 150,
285, 60, 151,
286, 61, 152,
287, 62, 153,
288, 63, 154,
289, 64, 155,
290, 65, 156,
291, 66, 157,
292, 67, 158,
293, 68, 159,
294, 69, 160,
295, 70, 161,
296, 71, 162,
297, 72, 163,
298, 73, 164,
299, 74, 165,
300, 75, 166,
301, 76, 167,
302, 77, 168,
303, 78, 169,
304, 79, 170,
305, 80, 171,
306, 81, 172,
307, 82, 173,
308, 83, 174,
309, 84, 175,
310, 85, 176,
311, 86, 177,
312, 87, 178,
313, 88, 179,
314, 89, 180,
315, 90, 181,
316, 91, 182,
317, 92, 183,
318, 93, 184,
319, 94, 185,
320, 95, 186,
321, 96, 187,
322, 97, 188,
323, 98, 189,
324, 99, 190,
325, 100, 191,
326, 101, 192,
327, 102, 193,
328, 103, 194,
329, 104, 195,
330, 105, 196,
331, 106, 197,
332, 107, 198,
333, 108, 199,
334, 109, 200,
335, 110, 201,
336, 111, 202,
337, 112, 203,
338, 113, 204,
339, 114, 205,
340, 115, 206,
341, 116, 207,
342, 117, 208,
343, 118, 209,
344, 119, 210,
345, 120, 211,
346, 121, 212,
347, 122, 213,
348, 123, 214,
349, 124, 215,
350, 125, 216,
351, 126, 217,
352, 127, 218,
353, 0, 219,
354, 1, 220,
355, 2, 221,
356, 3, 222,
357, 4, 223,
358, 5, 224,
359, 6, 225,
360, 7, 226,
361, 8, 227,
362, 9, 228,
363, 10, 229,
364, 11, 230,
365, 12, 231,
366, 13, 232,
367, 14, 233,
368, 15, 234,
369, 16, 235,
370, 17, 236,
371, 18, 237,
372, 19, 238,
373, 20, 239,
374, 21, 240,
375, 22, 241,
376, 23, 242,
377, 24, 243,
378, 25, 244,
379, 26, 245,
380, 27, 246,
381, 28, 247,
382, 29, 248,
383, 30, 249,
384, 192, 349,
385, 193, 350,
386, 194, 351,
387, 195, 352,
388, 196, 353,
389, 197, 354,
390, 198, 355,
391, 199, 356,
392, 200, 357,
393, 201, 358,
394, 202, 359,
395, 203, 360,
396, 204, 361,
397, 205, 362,
398, 206, 363,
399, 207, 364,
400, 208, 365,
401, 209, 366,
402, 210, 367,
403, 211, 368,
404, 212, 369,
405, 213, 370,
406, 214, 371,
407, 215, 372,
408, 216, 373,
409, 217, 374,
410, 218, 375,
411, 219, 376,
412, 220, 377,
413, 221, 378,
414, 222, 379,
415, 223, 380,
416, 224, 381,
417, 225, 382,
418, 226, 383,
419, 227, 256,
420, 228, 257,
421, 229, 258,
422, 230, 259,
423, 231, 260,
424, 232, 261,
425, 233, 262,
426, 234, 263,
427, 235, 264,
428, 236, 265,
429, 237, 266,
430, 238, 267,
431, 239, 268,
432, 240, 269,
433, 241, 270,
434, 242, 271,
435, 243, 272,
436, 244, 273,
437, 245, 274,
438, 246, 275,
439, 247, 276,
440, 248, 277,
441, 249, 278,
442, 250, 279,
443, 251, 280,
444, 252, 281,
445, 253, 282,
446, 254, 283,
447, 255, 284,
448, 128, 285,
449, 129, 286,
450, 130, 287,
451, 131, 288,
452, 132, 289,
453, 133, 290,
454, 134, 291,
455, 135, 292,
456, 136, 293,
457, 137, 294,
458, 138, 295,
459, 139, 296,
460, 140, 297,
461, 141, 298,
462, 142, 299,
463, 143, 300,
464, 144, 301,
465, 145, 302,
466, 146, 303,
467, 147, 304,
468, 148, 305,
469, 149, 306,
470, 150, 307,
471, 151, 308,
472, 152, 309,
473, 153, 310,
474, 154, 311,
475, 155, 312,
476, 156, 313,
477, 157, 314,
478, 158, 315,
479, 159, 316,
480, 160, 317,
481, 161, 318,
482, 162, 319,
483, 163, 320,
484, 164, 321,
485, 165, 322,
486, 166, 323,
487, 167, 324,
488, 168, 325,
489, 169, 326,
490, 170, 327,
491, 171, 328,
492, 172, 329,
493, 173, 330,
494, 174, 331,
495, 175, 332,
496, 176, 333,
497, 177, 334,
498, 178, 335,
499, 179, 336,
500, 180, 337,
501, 181, 338,
502, 182, 339,
503, 183, 340,
504, 184, 341,
505, 185, 342,
506, 186, 343,
507, 187, 344,
508, 188, 345,
509, 189, 346,
510, 190, 347,
511, 191, 348
 };
#pragma line 264 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_1_2_2_trichk.h" 1
const vars_3_23 varinx6A_1024_b[] = {
103, 233, 256,
104, 234, 257,
105, 235, 258,
106, 236, 259,
107, 237, 260,
108, 238, 261,
109, 239, 262,
110, 240, 263,
111, 241, 264,
112, 242, 265,
113, 243, 266,
114, 244, 267,
115, 245, 268,
116, 246, 269,
117, 247, 270,
118, 248, 271,
119, 249, 272,
120, 250, 273,
121, 251, 274,
122, 252, 275,
123, 253, 276,
124, 254, 277,
125, 255, 278,
126, 128, 279,
127, 129, 280,
0, 130, 281,
1, 131, 282,
2, 132, 283,
3, 133, 284,
4, 134, 285,
5, 135, 286,
6, 136, 287,
7, 137, 288,
8, 138, 289,
9, 139, 290,
10, 140, 291,
11, 141, 292,
12, 142, 293,
13, 143, 294,
14, 144, 295,
15, 145, 296,
16, 146, 297,
17, 147, 298,
18, 148, 299,
19, 149, 300,
20, 150, 301,
21, 151, 302,
22, 152, 303,
23, 153, 304,
24, 154, 305,
25, 155, 306,
26, 156, 307,
27, 157, 308,
28, 158, 309,
29, 159, 310,
30, 160, 311,
31, 161, 312,
32, 162, 313,
33, 163, 314,
34, 164, 315,
35, 165, 316,
36, 166, 317,
37, 167, 318,
38, 168, 319,
39, 169, 320,
40, 170, 321,
41, 171, 322,
42, 172, 323,
43, 173, 324,
44, 174, 325,
45, 175, 326,
46, 176, 327,
47, 177, 328,
48, 178, 329,
49, 179, 330,
50, 180, 331,
51, 181, 332,
52, 182, 333,
53, 183, 334,
54, 184, 335,
55, 185, 336,
56, 186, 337,
57, 187, 338,
58, 188, 339,
59, 189, 340,
60, 190, 341,
61, 191, 342,
62, 192, 343,
63, 193, 344,
64, 194, 345,
65, 195, 346,
66, 196, 347,
67, 197, 348,
68, 198, 349,
69, 199, 350,
70, 200, 351,
71, 201, 352,
72, 202, 353,
73, 203, 354,
74, 204, 355,
75, 205, 356,
76, 206, 357,
77, 207, 358,
78, 208, 359,
79, 209, 360,
80, 210, 361,
81, 211, 362,
82, 212, 363,
83, 213, 364,
84, 214, 365,
85, 215, 366,
86, 216, 367,
87, 217, 368,
88, 218, 369,
89, 219, 370,
90, 220, 371,
91, 221, 372,
92, 222, 373,
93, 223, 374,
94, 224, 375,
95, 225, 376,
96, 226, 377,
97, 227, 378,
98, 228, 379,
99, 229, 380,
100, 230, 381,
101, 231, 382,
102, 232, 383,
181, 330, 429,
182, 331, 430,
183, 332, 431,
184, 333, 432,
185, 334, 433,
186, 335, 434,
187, 336, 435,
188, 337, 436,
189, 338, 437,
190, 339, 438,
191, 340, 439,
192, 341, 440,
193, 342, 441,
194, 343, 442,
195, 344, 443,
196, 345, 444,
197, 346, 445,
198, 347, 446,
199, 348, 447,
200, 349, 448,
201, 350, 449,
202, 351, 450,
203, 352, 451,
204, 353, 452,
205, 354, 453,
206, 355, 454,
207, 356, 455,
208, 357, 456,
209, 358, 457,
210, 359, 458,
211, 360, 459,
212, 361, 460,
213, 362, 461,
214, 363, 462,
215, 364, 463,
216, 365, 464,
217, 366, 465,
218, 367, 466,
219, 368, 467,
220, 369, 468,
221, 370, 469,
222, 371, 470,
223, 372, 471,
224, 373, 472,
225, 374, 473,
226, 375, 474,
227, 376, 475,
228, 377, 476,
229, 378, 477,
230, 379, 478,
231, 380, 479,
232, 381, 480,
233, 382, 481,
234, 383, 482,
235, 256, 483,
236, 257, 484,
237, 258, 485,
238, 259, 486,
239, 260, 487,
240, 261, 488,
241, 262, 489,
242, 263, 490,
243, 264, 491,
244, 265, 492,
245, 266, 493,
246, 267, 494,
247, 268, 495,
248, 269, 496,
249, 270, 497,
250, 271, 498,
251, 272, 499,
252, 273, 500,
253, 274, 501,
254, 275, 502,
255, 276, 503,
128, 277, 504,
129, 278, 505,
130, 279, 506,
131, 280, 507,
132, 281, 508,
133, 282, 509,
134, 283, 510,
135, 284, 511,
136, 285, 384,
137, 286, 385,
138, 287, 386,
139, 288, 387,
140, 289, 388,
141, 290, 389,
142, 291, 390,
143, 292, 391,
144, 293, 392,
145, 294, 393,
146, 295, 394,
147, 296, 395,
148, 297, 396,
149, 298, 397,
150, 299, 398,
151, 300, 399,
152, 301, 400,
153, 302, 401,
154, 303, 402,
155, 304, 403,
156, 305, 404,
157, 306, 405,
158, 307, 406,
159, 308, 407,
160, 309, 408,
161, 310, 409,
162, 311, 410,
163, 312, 411,
164, 313, 412,
165, 314, 413,
166, 315, 414,
167, 316, 415,
168, 317, 416,
169, 318, 417,
170, 319, 418,
171, 320, 419,
172, 321, 420,
173, 322, 421,
174, 323, 422,
175, 324, 423,
176, 325, 424,
177, 326, 425,
178, 327, 426,
179, 328, 427,
180, 329, 428,
89, 264, 503,
90, 265, 504,
91, 266, 505,
92, 267, 506,
93, 268, 507,
94, 269, 508,
95, 270, 509,
96, 271, 510,
97, 272, 511,
98, 273, 384,
99, 274, 385,
100, 275, 386,
101, 276, 387,
102, 277, 388,
103, 278, 389,
104, 279, 390,
105, 280, 391,
106, 281, 392,
107, 282, 393,
108, 283, 394,
109, 284, 395,
110, 285, 396,
111, 286, 397,
112, 287, 398,
113, 288, 399,
114, 289, 400,
115, 290, 401,
116, 291, 402,
117, 292, 403,
118, 293, 404,
119, 294, 405,
120, 295, 406,
121, 296, 407,
122, 297, 408,
123, 298, 409,
124, 299, 410,
125, 300, 411,
126, 301, 412,
127, 302, 413,
0, 303, 414,
1, 304, 415,
2, 305, 416,
3, 306, 417,
4, 307, 418,
5, 308, 419,
6, 309, 420,
7, 310, 421,
8, 311, 422,
9, 312, 423,
10, 313, 424,
11, 314, 425,
12, 315, 426,
13, 316, 427,
14, 317, 428,
15, 318, 429,
16, 319, 430,
17, 320, 431,
18, 321, 432,
19, 322, 433,
20, 323, 434,
21, 324, 435,
22, 325, 436,
23, 326, 437,
24, 327, 438,
25, 328, 439,
26, 329, 440,
27, 330, 441,
28, 331, 442,
29, 332, 443,
30, 333, 444,
31, 334, 445,
32, 335, 446,
33, 336, 447,
34, 337, 448,
35, 338, 449,
36, 339, 450,
37, 340, 451,
38, 341, 452,
39, 342, 453,
40, 343, 454,
41, 344, 455,
42, 345, 456,
43, 346, 457,
44, 347, 458,
45, 348, 459,
46, 349, 460,
47, 350, 461,
48, 351, 462,
49, 352, 463,
50, 353, 464,
51, 354, 465,
52, 355, 466,
53, 356, 467,
54, 357, 468,
55, 358, 469,
56, 359, 470,
57, 360, 471,
58, 361, 472,
59, 362, 473,
60, 363, 474,
61, 364, 475,
62, 365, 476,
63, 366, 477,
64, 367, 478,
65, 368, 479,
66, 369, 480,
67, 370, 481,
68, 371, 482,
69, 372, 483,
70, 373, 484,
71, 374, 485,
72, 375, 486,
73, 376, 487,
74, 377, 488,
75, 378, 489,
76, 379, 490,
77, 380, 491,
78, 381, 492,
79, 382, 493,
80, 383, 494,
81, 256, 495,
82, 257, 496,
83, 258, 497,
84, 259, 498,
85, 260, 499,
86, 261, 500,
87, 262, 501,
88, 263, 502,
97, 240, 419,
98, 241, 420,
99, 242, 421,
100, 243, 422,
101, 244, 423,
102, 245, 424,
103, 246, 425,
104, 247, 426,
105, 248, 427,
106, 249, 428,
107, 250, 429,
108, 251, 430,
109, 252, 431,
110, 253, 432,
111, 254, 433,
112, 255, 434,
113, 128, 435,
114, 129, 436,
115, 130, 437,
116, 131, 438,
117, 132, 439,
118, 133, 440,
119, 134, 441,
120, 135, 442,
121, 136, 443,
122, 137, 444,
123, 138, 445,
124, 139, 446,
125, 140, 447,
126, 141, 448,
127, 142, 449,
0, 143, 450,
1, 144, 451,
2, 145, 452,
3, 146, 453,
4, 147, 454,
5, 148, 455,
6, 149, 456,
7, 150, 457,
8, 151, 458,
9, 152, 459,
10, 153, 460,
11, 154, 461,
12, 155, 462,
13, 156, 463,
14, 157, 464,
15, 158, 465,
16, 159, 466,
17, 160, 467,
18, 161, 468,
19, 162, 469,
20, 163, 470,
21, 164, 471,
22, 165, 472,
23, 166, 473,
24, 167, 474,
25, 168, 475,
26, 169, 476,
27, 170, 477,
28, 171, 478,
29, 172, 479,
30, 173, 480,
31, 174, 481,
32, 175, 482,
33, 176, 483,
34, 177, 484,
35, 178, 485,
36, 179, 486,
37, 180, 487,
38, 181, 488,
39, 182, 489,
40, 183, 490,
41, 184, 491,
42, 185, 492,
43, 186, 493,
44, 187, 494,
45, 188, 495,
46, 189, 496,
47, 190, 497,
48, 191, 498,
49, 192, 499,
50, 193, 500,
51, 194, 501,
52, 195, 502,
53, 196, 503,
54, 197, 504,
55, 198, 505,
56, 199, 506,
57, 200, 507,
58, 201, 508,
59, 202, 509,
60, 203, 510,
61, 204, 511,
62, 205, 384,
63, 206, 385,
64, 207, 386,
65, 208, 387,
66, 209, 388,
67, 210, 389,
68, 211, 390,
69, 212, 391,
70, 213, 392,
71, 214, 393,
72, 215, 394,
73, 216, 395,
74, 217, 396,
75, 218, 397,
76, 219, 398,
77, 220, 399,
78, 221, 400,
79, 222, 401,
80, 223, 402,
81, 224, 403,
82, 225, 404,
83, 226, 405,
84, 227, 406,
85, 228, 407,
86, 229, 408,
87, 230, 409,
88, 231, 410,
89, 232, 411,
90, 233, 412,
91, 234, 413,
92, 235, 414,
93, 236, 415,
94, 237, 416,
95, 238, 417,
96, 239, 418
};
#pragma empty_line
const vars_3_23 varinx6B_1024_b[] = {
115, 158, 0,
116, 159, 1,
117, 160, 2,
118, 161, 3,
119, 162, 4,
120, 163, 5,
121, 164, 6,
122, 165, 7,
123, 166, 8,
124, 167, 9,
125, 168, 10,
126, 169, 11,
127, 170, 12,
0, 171, 13,
1, 172, 14,
2, 173, 15,
3, 174, 16,
4, 175, 17,
5, 176, 18,
6, 177, 19,
7, 178, 20,
8, 179, 21,
9, 180, 22,
10, 181, 23,
11, 182, 24,
12, 183, 25,
13, 184, 26,
14, 185, 27,
15, 186, 28,
16, 187, 29,
17, 188, 30,
18, 189, 31,
19, 190, 32,
20, 191, 33,
21, 192, 34,
22, 193, 35,
23, 194, 36,
24, 195, 37,
25, 196, 38,
26, 197, 39,
27, 198, 40,
28, 199, 41,
29, 200, 42,
30, 201, 43,
31, 202, 44,
32, 203, 45,
33, 204, 46,
34, 205, 47,
35, 206, 48,
36, 207, 49,
37, 208, 50,
38, 209, 51,
39, 210, 52,
40, 211, 53,
41, 212, 54,
42, 213, 55,
43, 214, 56,
44, 215, 57,
45, 216, 58,
46, 217, 59,
47, 218, 60,
48, 219, 61,
49, 220, 62,
50, 221, 63,
51, 222, 64,
52, 223, 65,
53, 224, 66,
54, 225, 67,
55, 226, 68,
56, 227, 69,
57, 228, 70,
58, 229, 71,
59, 230, 72,
60, 231, 73,
61, 232, 74,
62, 233, 75,
63, 234, 76,
64, 235, 77,
65, 236, 78,
66, 237, 79,
67, 238, 80,
68, 239, 81,
69, 240, 82,
70, 241, 83,
71, 242, 84,
72, 243, 85,
73, 244, 86,
74, 245, 87,
75, 246, 88,
76, 247, 89,
77, 248, 90,
78, 249, 91,
79, 250, 92,
80, 251, 93,
81, 252, 94,
82, 253, 95,
83, 254, 96,
84, 255, 97,
85, 128, 98,
86, 129, 99,
87, 130, 100,
88, 131, 101,
89, 132, 102,
90, 133, 103,
91, 134, 104,
92, 135, 105,
93, 136, 106,
94, 137, 107,
95, 138, 108,
96, 139, 109,
97, 140, 110,
98, 141, 111,
99, 142, 112,
100, 143, 113,
101, 144, 114,
102, 145, 115,
103, 146, 116,
104, 147, 117,
105, 148, 118,
106, 149, 119,
107, 150, 120,
108, 151, 121,
109, 152, 122,
110, 153, 123,
111, 154, 124,
112, 155, 125,
113, 156, 126,
114, 157, 127,
187, 358, 128,
188, 359, 129,
189, 360, 130,
190, 361, 131,
191, 362, 132,
192, 363, 133,
193, 364, 134,
194, 365, 135,
195, 366, 136,
196, 367, 137,
197, 368, 138,
198, 369, 139,
199, 370, 140,
200, 371, 141,
201, 372, 142,
202, 373, 143,
203, 374, 144,
204, 375, 145,
205, 376, 146,
206, 377, 147,
207, 378, 148,
208, 379, 149,
209, 380, 150,
210, 381, 151,
211, 382, 152,
212, 383, 153,
213, 256, 154,
214, 257, 155,
215, 258, 156,
216, 259, 157,
217, 260, 158,
218, 261, 159,
219, 262, 160,
220, 263, 161,
221, 264, 162,
222, 265, 163,
223, 266, 164,
224, 267, 165,
225, 268, 166,
226, 269, 167,
227, 270, 168,
228, 271, 169,
229, 272, 170,
230, 273, 171,
231, 274, 172,
232, 275, 173,
233, 276, 174,
234, 277, 175,
235, 278, 176,
236, 279, 177,
237, 280, 178,
238, 281, 179,
239, 282, 180,
240, 283, 181,
241, 284, 182,
242, 285, 183,
243, 286, 184,
244, 287, 185,
245, 288, 186,
246, 289, 187,
247, 290, 188,
248, 291, 189,
249, 292, 190,
250, 293, 191,
251, 294, 192,
252, 295, 193,
253, 296, 194,
254, 297, 195,
255, 298, 196,
128, 299, 197,
129, 300, 198,
130, 301, 199,
131, 302, 200,
132, 303, 201,
133, 304, 202,
134, 305, 203,
135, 306, 204,
136, 307, 205,
137, 308, 206,
138, 309, 207,
139, 310, 208,
140, 311, 209,
141, 312, 210,
142, 313, 211,
143, 314, 212,
144, 315, 213,
145, 316, 214,
146, 317, 215,
147, 318, 216,
148, 319, 217,
149, 320, 218,
150, 321, 219,
151, 322, 220,
152, 323, 221,
153, 324, 222,
154, 325, 223,
155, 326, 224,
156, 327, 225,
157, 328, 226,
158, 329, 227,
159, 330, 228,
160, 331, 229,
161, 332, 230,
162, 333, 231,
163, 334, 232,
164, 335, 233,
165, 336, 234,
166, 337, 235,
167, 338, 236,
168, 339, 237,
169, 340, 238,
170, 341, 239,
171, 342, 240,
172, 343, 241,
173, 344, 242,
174, 345, 243,
175, 346, 244,
176, 347, 245,
177, 348, 246,
178, 349, 247,
179, 350, 248,
180, 351, 249,
181, 352, 250,
182, 353, 251,
183, 354, 252,
184, 355, 253,
185, 356, 254,
186, 357, 255,
257, 453, 256,
258, 454, 257,
259, 455, 258,
260, 456, 259,
261, 457, 260,
262, 458, 261,
263, 459, 262,
264, 460, 263,
265, 461, 264,
266, 462, 265,
267, 463, 266,
268, 464, 267,
269, 465, 268,
270, 466, 269,
271, 467, 270,
272, 468, 271,
273, 469, 272,
274, 470, 273,
275, 471, 274,
276, 472, 275,
277, 473, 276,
278, 474, 277,
279, 475, 278,
280, 476, 279,
281, 477, 280,
282, 478, 281,
283, 479, 282,
284, 480, 283,
285, 481, 284,
286, 482, 285,
287, 483, 286,
288, 484, 287,
289, 485, 288,
290, 486, 289,
291, 487, 290,
292, 488, 291,
293, 489, 292,
294, 490, 293,
295, 491, 294,
296, 492, 295,
297, 493, 296,
298, 494, 297,
299, 495, 298,
300, 496, 299,
301, 497, 300,
302, 498, 301,
303, 499, 302,
304, 500, 303,
305, 501, 304,
306, 502, 305,
307, 503, 306,
308, 504, 307,
309, 505, 308,
310, 506, 309,
311, 507, 310,
312, 508, 311,
313, 509, 312,
314, 510, 313,
315, 511, 314,
316, 384, 315,
317, 385, 316,
318, 386, 317,
319, 387, 318,
320, 388, 319,
321, 389, 320,
322, 390, 321,
323, 391, 322,
324, 392, 323,
325, 393, 324,
326, 394, 325,
327, 395, 326,
328, 396, 327,
329, 397, 328,
330, 398, 329,
331, 399, 330,
332, 400, 331,
333, 401, 332,
334, 402, 333,
335, 403, 334,
336, 404, 335,
337, 405, 336,
338, 406, 337,
339, 407, 338,
340, 408, 339,
341, 409, 340,
342, 410, 341,
343, 411, 342,
344, 412, 343,
345, 413, 344,
346, 414, 345,
347, 415, 346,
348, 416, 347,
349, 417, 348,
350, 418, 349,
351, 419, 350,
352, 420, 351,
353, 421, 352,
354, 422, 353,
355, 423, 354,
356, 424, 355,
357, 425, 356,
358, 426, 357,
359, 427, 358,
360, 428, 359,
361, 429, 360,
362, 430, 361,
363, 431, 362,
364, 432, 363,
365, 433, 364,
366, 434, 365,
367, 435, 366,
368, 436, 367,
369, 437, 368,
370, 438, 369,
371, 439, 370,
372, 440, 371,
373, 441, 372,
374, 442, 373,
375, 443, 374,
376, 444, 375,
377, 445, 376,
378, 446, 377,
379, 447, 378,
380, 448, 379,
381, 449, 380,
382, 450, 381,
383, 451, 382,
256, 452, 383,
94, 483, 384,
95, 484, 385,
96, 485, 386,
97, 486, 387,
98, 487, 388,
99, 488, 389,
100, 489, 390,
101, 490, 391,
102, 491, 392,
103, 492, 393,
104, 493, 394,
105, 494, 395,
106, 495, 396,
107, 496, 397,
108, 497, 398,
109, 498, 399,
110, 499, 400,
111, 500, 401,
112, 501, 402,
113, 502, 403,
114, 503, 404,
115, 504, 405,
116, 505, 406,
117, 506, 407,
118, 507, 408,
119, 508, 409,
120, 509, 410,
121, 510, 411,
122, 511, 412,
123, 384, 413,
124, 385, 414,
125, 386, 415,
126, 387, 416,
127, 388, 417,
0, 389, 418,
1, 390, 419,
2, 391, 420,
3, 392, 421,
4, 393, 422,
5, 394, 423,
6, 395, 424,
7, 396, 425,
8, 397, 426,
9, 398, 427,
10, 399, 428,
11, 400, 429,
12, 401, 430,
13, 402, 431,
14, 403, 432,
15, 404, 433,
16, 405, 434,
17, 406, 435,
18, 407, 436,
19, 408, 437,
20, 409, 438,
21, 410, 439,
22, 411, 440,
23, 412, 441,
24, 413, 442,
25, 414, 443,
26, 415, 444,
27, 416, 445,
28, 417, 446,
29, 418, 447,
30, 419, 448,
31, 420, 449,
32, 421, 450,
33, 422, 451,
34, 423, 452,
35, 424, 453,
36, 425, 454,
37, 426, 455,
38, 427, 456,
39, 428, 457,
40, 429, 458,
41, 430, 459,
42, 431, 460,
43, 432, 461,
44, 433, 462,
45, 434, 463,
46, 435, 464,
47, 436, 465,
48, 437, 466,
49, 438, 467,
50, 439, 468,
51, 440, 469,
52, 441, 470,
53, 442, 471,
54, 443, 472,
55, 444, 473,
56, 445, 474,
57, 446, 475,
58, 447, 476,
59, 448, 477,
60, 449, 478,
61, 450, 479,
62, 451, 480,
63, 452, 481,
64, 453, 482,
65, 454, 483,
66, 455, 484,
67, 456, 485,
68, 457, 486,
69, 458, 487,
70, 459, 488,
71, 460, 489,
72, 461, 490,
73, 462, 491,
74, 463, 492,
75, 464, 493,
76, 465, 494,
77, 466, 495,
78, 467, 496,
79, 468, 497,
80, 469, 498,
81, 470, 499,
82, 471, 500,
83, 472, 501,
84, 473, 502,
85, 474, 503,
86, 475, 504,
87, 476, 505,
88, 477, 506,
89, 478, 507,
90, 479, 508,
91, 480, 509,
92, 481, 510,
93, 482, 511
 };
#pragma line 265 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_1_2_trichk.h" 1
#pragma empty_line
const vars_3_23 varinx3_1024_12[] = {
0, 0, 400,
1, 1, 401,
2, 2, 402,
3, 3, 403,
4, 4, 404,
5, 5, 405,
6, 6, 406,
7, 7, 407,
8, 8, 408,
9, 9, 409,
10, 10, 410,
11, 11, 411,
12, 12, 412,
13, 13, 413,
14, 14, 414,
15, 15, 415,
16, 16, 416,
17, 17, 417,
18, 18, 418,
19, 19, 419,
20, 20, 420,
21, 21, 421,
22, 22, 422,
23, 23, 423,
24, 24, 424,
25, 25, 425,
26, 26, 426,
27, 27, 427,
28, 28, 428,
29, 29, 429,
30, 30, 430,
31, 31, 431,
32, 32, 432,
33, 33, 433,
34, 34, 434,
35, 35, 435,
36, 36, 436,
37, 37, 437,
38, 38, 438,
39, 39, 439,
40, 40, 440,
41, 41, 441,
42, 42, 442,
43, 43, 443,
44, 44, 444,
45, 45, 445,
46, 46, 446,
47, 47, 447,
48, 48, 448,
49, 49, 449,
50, 50, 450,
51, 51, 451,
52, 52, 452,
53, 53, 453,
54, 54, 454,
55, 55, 455,
56, 56, 456,
57, 57, 457,
58, 58, 458,
59, 59, 459,
60, 60, 460,
61, 61, 461,
62, 62, 462,
63, 63, 463,
64, 64, 464,
65, 65, 465,
66, 66, 466,
67, 67, 467,
68, 68, 468,
69, 69, 469,
70, 70, 470,
71, 71, 471,
72, 72, 472,
73, 73, 473,
74, 74, 474,
75, 75, 475,
76, 76, 476,
77, 77, 477,
78, 78, 478,
79, 79, 479,
80, 80, 480,
81, 81, 481,
82, 82, 482,
83, 83, 483,
84, 84, 484,
85, 85, 485,
86, 86, 486,
87, 87, 487,
88, 88, 488,
89, 89, 489,
90, 90, 490,
91, 91, 491,
92, 92, 492,
93, 93, 493,
94, 94, 494,
95, 95, 495,
96, 96, 496,
97, 97, 497,
98, 98, 498,
99, 99, 499,
100, 100, 500,
101, 101, 501,
102, 102, 502,
103, 103, 503,
104, 104, 504,
105, 105, 505,
106, 106, 506,
107, 107, 507,
108, 108, 508,
109, 109, 509,
110, 110, 510,
111, 111, 511,
112, 112, 384,
113, 113, 385,
114, 114, 386,
115, 115, 387,
116, 116, 388,
117, 117, 389,
118, 118, 390,
119, 119, 391,
120, 120, 392,
121, 121, 393,
122, 122, 394,
123, 123, 395,
124, 124, 396,
125, 125, 397,
126, 126, 398,
127, 127, 399,
128, 0, 128,
129, 1, 129,
130, 2, 130,
131, 3, 131,
132, 4, 132,
133, 5, 133,
134, 6, 134,
135, 7, 135,
136, 8, 136,
137, 9, 137,
138, 10, 138,
139, 11, 139,
140, 12, 140,
141, 13, 141,
142, 14, 142,
143, 15, 143,
144, 16, 144,
145, 17, 145,
146, 18, 146,
147, 19, 147,
148, 20, 148,
149, 21, 149,
150, 22, 150,
151, 23, 151,
152, 24, 152,
153, 25, 153,
154, 26, 154,
155, 27, 155,
156, 28, 156,
157, 29, 157,
158, 30, 158,
159, 31, 159,
160, 32, 160,
161, 33, 161,
162, 34, 162,
163, 35, 163,
164, 36, 164,
165, 37, 165,
166, 38, 166,
167, 39, 167,
168, 40, 168,
169, 41, 169,
170, 42, 170,
171, 43, 171,
172, 44, 172,
173, 45, 173,
174, 46, 174,
175, 47, 175,
176, 48, 176,
177, 49, 177,
178, 50, 178,
179, 51, 179,
180, 52, 180,
181, 53, 181,
182, 54, 182,
183, 55, 183,
184, 56, 184,
185, 57, 185,
186, 58, 186,
187, 59, 187,
188, 60, 188,
189, 61, 189,
190, 62, 190,
191, 63, 191,
192, 64, 192,
193, 65, 193,
194, 66, 194,
195, 67, 195,
196, 68, 196,
197, 69, 197,
198, 70, 198,
199, 71, 199,
200, 72, 200,
201, 73, 201,
202, 74, 202,
203, 75, 203,
204, 76, 204,
205, 77, 205,
206, 78, 206,
207, 79, 207,
208, 80, 208,
209, 81, 209,
210, 82, 210,
211, 83, 211,
212, 84, 212,
213, 85, 213,
214, 86, 214,
215, 87, 215,
216, 88, 216,
217, 89, 217,
218, 90, 218,
219, 91, 219,
220, 92, 220,
221, 93, 221,
222, 94, 222,
223, 95, 223,
224, 96, 224,
225, 97, 225,
226, 98, 226,
227, 99, 227,
228, 100, 228,
229, 101, 229,
230, 102, 230,
231, 103, 231,
232, 104, 232,
233, 105, 233,
234, 106, 234,
235, 107, 235,
236, 108, 236,
237, 109, 237,
238, 110, 238,
239, 111, 239,
240, 112, 240,
241, 113, 241,
242, 114, 242,
243, 115, 243,
244, 116, 244,
245, 117, 245,
246, 118, 246,
247, 119, 247,
248, 120, 248,
249, 121, 249,
250, 122, 250,
251, 123, 251,
252, 124, 252,
253, 125, 253,
254, 126, 254,
255, 127, 255,
256, 128, 256,
257, 129, 257,
258, 130, 258,
259, 131, 259,
260, 132, 260,
261, 133, 261,
262, 134, 262,
263, 135, 263,
264, 136, 264,
265, 137, 265,
266, 138, 266,
267, 139, 267,
268, 140, 268,
269, 141, 269,
270, 142, 270,
271, 143, 271,
272, 144, 272,
273, 145, 273,
274, 146, 274,
275, 147, 275,
276, 148, 276,
277, 149, 277,
278, 150, 278,
279, 151, 279,
280, 152, 280,
281, 153, 281,
282, 154, 282,
283, 155, 283,
284, 156, 284,
285, 157, 285,
286, 158, 286,
287, 159, 287,
288, 160, 288,
289, 161, 289,
290, 162, 290,
291, 163, 291,
292, 164, 292,
293, 165, 293,
294, 166, 294,
295, 167, 295,
296, 168, 296,
297, 169, 297,
298, 170, 298,
299, 171, 299,
300, 172, 300,
301, 173, 301,
302, 174, 302,
303, 175, 303,
304, 176, 304,
305, 177, 305,
306, 178, 306,
307, 179, 307,
308, 180, 308,
309, 181, 309,
310, 182, 310,
311, 183, 311,
312, 184, 312,
313, 185, 313,
314, 186, 314,
315, 187, 315,
316, 188, 316,
317, 189, 317,
318, 190, 318,
319, 191, 319,
320, 192, 320,
321, 193, 321,
322, 194, 322,
323, 195, 323,
324, 196, 324,
325, 197, 325,
326, 198, 326,
327, 199, 327,
328, 200, 328,
329, 201, 329,
330, 202, 330,
331, 203, 331,
332, 204, 332,
333, 205, 333,
334, 206, 334,
335, 207, 335,
336, 208, 336,
337, 209, 337,
338, 210, 338,
339, 211, 339,
340, 212, 340,
341, 213, 341,
342, 214, 342,
343, 215, 343,
344, 216, 344,
345, 217, 345,
346, 218, 346,
347, 219, 347,
348, 220, 348,
349, 221, 349,
350, 222, 350,
351, 223, 351,
352, 224, 352,
353, 225, 353,
354, 226, 354,
355, 227, 355,
356, 228, 356,
357, 229, 357,
358, 230, 358,
359, 231, 359,
360, 232, 360,
361, 233, 361,
362, 234, 362,
363, 235, 363,
364, 236, 364,
365, 237, 365,
366, 238, 366,
367, 239, 367,
368, 240, 368,
369, 241, 369,
370, 242, 370,
371, 243, 371,
372, 244, 372,
373, 245, 373,
374, 246, 374,
375, 247, 375,
376, 248, 376,
377, 249, 377,
378, 250, 378,
379, 251, 379,
380, 252, 380,
381, 253, 381,
382, 254, 382,
383, 255, 383,
384, 256, 384,
385, 257, 385,
386, 258, 386,
387, 259, 387,
388, 260, 388,
389, 261, 389,
390, 262, 390,
391, 263, 391,
392, 264, 392,
393, 265, 393,
394, 266, 394,
395, 267, 395,
396, 268, 396,
397, 269, 397,
398, 270, 398,
399, 271, 399,
400, 272, 400,
401, 273, 401,
402, 274, 402,
403, 275, 403,
404, 276, 404,
405, 277, 405,
406, 278, 406,
407, 279, 407,
408, 280, 408,
409, 281, 409,
410, 282, 410,
411, 283, 411,
412, 284, 412,
413, 285, 413,
414, 286, 414,
415, 287, 415,
416, 288, 416,
417, 289, 417,
418, 290, 418,
419, 291, 419,
420, 292, 420,
421, 293, 421,
422, 294, 422,
423, 295, 423,
424, 296, 424,
425, 297, 425,
426, 298, 426,
427, 299, 427,
428, 300, 428,
429, 301, 429,
430, 302, 430,
431, 303, 431,
432, 304, 432,
433, 305, 433,
434, 306, 434,
435, 307, 435,
436, 308, 436,
437, 309, 437,
438, 310, 438,
439, 311, 439,
440, 312, 440,
441, 313, 441,
442, 314, 442,
443, 315, 443,
444, 316, 444,
445, 317, 445,
446, 318, 446,
447, 319, 447,
448, 320, 448,
449, 321, 449,
450, 322, 450,
451, 323, 451,
452, 324, 452,
453, 325, 453,
454, 326, 454,
455, 327, 455,
456, 328, 456,
457, 329, 457,
458, 330, 458,
459, 331, 459,
460, 332, 460,
461, 333, 461,
462, 334, 462,
463, 335, 463,
464, 336, 464,
465, 337, 465,
466, 338, 466,
467, 339, 467,
468, 340, 468,
469, 341, 469,
470, 342, 470,
471, 343, 471,
472, 344, 472,
473, 345, 473,
474, 346, 474,
475, 347, 475,
476, 348, 476,
477, 349, 477,
478, 350, 478,
479, 351, 479,
480, 352, 480,
481, 353, 481,
482, 354, 482,
483, 355, 483,
484, 356, 484,
485, 357, 485,
486, 358, 486,
487, 359, 487,
488, 360, 488,
489, 361, 489,
490, 362, 490,
491, 363, 491,
492, 364, 492,
493, 365, 493,
494, 366, 494,
495, 367, 495,
496, 368, 496,
497, 369, 497,
498, 370, 498,
499, 371, 499,
500, 372, 500,
501, 373, 501,
502, 374, 502,
503, 375, 503,
504, 376, 504,
505, 377, 505,
506, 378, 506,
507, 379, 507,
508, 380, 508,
509, 381, 509,
510, 382, 510,
511, 383, 511
 };
#pragma line 266 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_1_2_1_trichk.h" 1
vars_3_12 varinx6A_4096_a[] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127,
128, 128, 128,
129, 129, 129,
130, 130, 130,
131, 131, 131,
132, 132, 132,
133, 133, 133,
134, 134, 134,
135, 135, 135,
136, 136, 136,
137, 137, 137,
138, 138, 138,
139, 139, 139,
140, 140, 140,
141, 141, 141,
142, 142, 142,
143, 143, 143,
144, 144, 144,
145, 145, 145,
146, 146, 146,
147, 147, 147,
148, 148, 148,
149, 149, 149,
150, 150, 150,
151, 151, 151,
152, 152, 152,
153, 153, 153,
154, 154, 154,
155, 155, 155,
156, 156, 156,
157, 157, 157,
158, 158, 158,
159, 159, 159,
160, 160, 160,
161, 161, 161,
162, 162, 162,
163, 163, 163,
164, 164, 164,
165, 165, 165,
166, 166, 166,
167, 167, 167,
168, 168, 168,
169, 169, 169,
170, 170, 170,
171, 171, 171,
172, 172, 172,
173, 173, 173,
174, 174, 174,
175, 175, 175,
176, 176, 176,
177, 177, 177,
178, 178, 178,
179, 179, 179,
180, 180, 180,
181, 181, 181,
182, 182, 182,
183, 183, 183,
184, 184, 184,
185, 185, 185,
186, 186, 186,
187, 187, 187,
188, 188, 188,
189, 189, 189,
190, 190, 190,
191, 191, 191,
192, 192, 192,
193, 193, 193,
194, 194, 194,
195, 195, 195,
196, 196, 196,
197, 197, 197,
198, 198, 198,
199, 199, 199,
200, 200, 200,
201, 201, 201,
202, 202, 202,
203, 203, 203,
204, 204, 204,
205, 205, 205,
206, 206, 206,
207, 207, 207,
208, 208, 208,
209, 209, 209,
210, 210, 210,
211, 211, 211,
212, 212, 212,
213, 213, 213,
214, 214, 214,
215, 215, 215,
216, 216, 216,
217, 217, 217,
218, 218, 218,
219, 219, 219,
220, 220, 220,
221, 221, 221,
222, 222, 222,
223, 223, 223,
224, 224, 224,
225, 225, 225,
226, 226, 226,
227, 227, 227,
228, 228, 228,
229, 229, 229,
230, 230, 230,
231, 231, 231,
232, 232, 232,
233, 233, 233,
234, 234, 234,
235, 235, 235,
236, 236, 236,
237, 237, 237,
238, 238, 238,
239, 239, 239,
240, 240, 240,
241, 241, 241,
242, 242, 242,
243, 243, 243,
244, 244, 244,
245, 245, 245,
246, 246, 246,
247, 247, 247,
248, 248, 248,
249, 249, 249,
250, 250, 250,
251, 251, 251,
252, 252, 252,
253, 253, 253,
254, 254, 254,
255, 255, 255,
256, 256, 256,
257, 257, 257,
258, 258, 258,
259, 259, 259,
260, 260, 260,
261, 261, 261,
262, 262, 262,
263, 263, 263,
264, 264, 264,
265, 265, 265,
266, 266, 266,
267, 267, 267,
268, 268, 268,
269, 269, 269,
270, 270, 270,
271, 271, 271,
272, 272, 272,
273, 273, 273,
274, 274, 274,
275, 275, 275,
276, 276, 276,
277, 277, 277,
278, 278, 278,
279, 279, 279,
280, 280, 280,
281, 281, 281,
282, 282, 282,
283, 283, 283,
284, 284, 284,
285, 285, 285,
286, 286, 286,
287, 287, 287,
288, 288, 288,
289, 289, 289,
290, 290, 290,
291, 291, 291,
292, 292, 292,
293, 293, 293,
294, 294, 294,
295, 295, 295,
296, 296, 296,
297, 297, 297,
298, 298, 298,
299, 299, 299,
300, 300, 300,
301, 301, 301,
302, 302, 302,
303, 303, 303,
304, 304, 304,
305, 305, 305,
306, 306, 306,
307, 307, 307,
308, 308, 308,
309, 309, 309,
310, 310, 310,
311, 311, 311,
312, 312, 312,
313, 313, 313,
314, 314, 314,
315, 315, 315,
316, 316, 316,
317, 317, 317,
318, 318, 318,
319, 319, 319,
320, 320, 320,
321, 321, 321,
322, 322, 322,
323, 323, 323,
324, 324, 324,
325, 325, 325,
326, 326, 326,
327, 327, 327,
328, 328, 328,
329, 329, 329,
330, 330, 330,
331, 331, 331,
332, 332, 332,
333, 333, 333,
334, 334, 334,
335, 335, 335,
336, 336, 336,
337, 337, 337,
338, 338, 338,
339, 339, 339,
340, 340, 340,
341, 341, 341,
342, 342, 342,
343, 343, 343,
344, 344, 344,
345, 345, 345,
346, 346, 346,
347, 347, 347,
348, 348, 348,
349, 349, 349,
350, 350, 350,
351, 351, 351,
352, 352, 352,
353, 353, 353,
354, 354, 354,
355, 355, 355,
356, 356, 356,
357, 357, 357,
358, 358, 358,
359, 359, 359,
360, 360, 360,
361, 361, 361,
362, 362, 362,
363, 363, 363,
364, 364, 364,
365, 365, 365,
366, 366, 366,
367, 367, 367,
368, 368, 368,
369, 369, 369,
370, 370, 370,
371, 371, 371,
372, 372, 372,
373, 373, 373,
374, 374, 374,
375, 375, 375,
376, 376, 376,
377, 377, 377,
378, 378, 378,
379, 379, 379,
380, 380, 380,
381, 381, 381,
382, 382, 382,
383, 383, 383,
384, 384, 384,
385, 385, 385,
386, 386, 386,
387, 387, 387,
388, 388, 388,
389, 389, 389,
390, 390, 390,
391, 391, 391,
392, 392, 392,
393, 393, 393,
394, 394, 394,
395, 395, 395,
396, 396, 396,
397, 397, 397,
398, 398, 398,
399, 399, 399,
400, 400, 400,
401, 401, 401,
402, 402, 402,
403, 403, 403,
404, 404, 404,
405, 405, 405,
406, 406, 406,
407, 407, 407,
408, 408, 408,
409, 409, 409,
410, 410, 410,
411, 411, 411,
412, 412, 412,
413, 413, 413,
414, 414, 414,
415, 415, 415,
416, 416, 416,
417, 417, 417,
418, 418, 418,
419, 419, 419,
420, 420, 420,
421, 421, 421,
422, 422, 422,
423, 423, 423,
424, 424, 424,
425, 425, 425,
426, 426, 426,
427, 427, 427,
428, 428, 428,
429, 429, 429,
430, 430, 430,
431, 431, 431,
432, 432, 432,
433, 433, 433,
434, 434, 434,
435, 435, 435,
436, 436, 436,
437, 437, 437,
438, 438, 438,
439, 439, 439,
440, 440, 440,
441, 441, 441,
442, 442, 442,
443, 443, 443,
444, 444, 444,
445, 445, 445,
446, 446, 446,
447, 447, 447,
448, 448, 448,
449, 449, 449,
450, 450, 450,
451, 451, 451,
452, 452, 452,
453, 453, 453,
454, 454, 454,
455, 455, 455,
456, 456, 456,
457, 457, 457,
458, 458, 458,
459, 459, 459,
460, 460, 460,
461, 461, 461,
462, 462, 462,
463, 463, 463,
464, 464, 464,
465, 465, 465,
466, 466, 466,
467, 467, 467,
468, 468, 468,
469, 469, 469,
470, 470, 470,
471, 471, 471,
472, 472, 472,
473, 473, 473,
474, 474, 474,
475, 475, 475,
476, 476, 476,
477, 477, 477,
478, 478, 478,
479, 479, 479,
480, 480, 480,
481, 481, 481,
482, 482, 482,
483, 483, 483,
484, 484, 484,
485, 485, 485,
486, 486, 486,
487, 487, 487,
488, 488, 488,
489, 489, 489,
490, 490, 490,
491, 491, 491,
492, 492, 492,
493, 493, 493,
494, 494, 494,
495, 495, 495,
496, 496, 496,
497, 497, 497,
498, 498, 498,
499, 499, 499,
500, 500, 500,
501, 501, 501,
502, 502, 502,
503, 503, 503,
504, 504, 504,
505, 505, 505,
506, 506, 506,
507, 507, 507,
508, 508, 508,
509, 509, 509,
510, 510, 510,
511, 511, 511,
512, 512, 512,
513, 513, 513,
514, 514, 514,
515, 515, 515,
516, 516, 516,
517, 517, 517,
518, 518, 518,
519, 519, 519,
520, 520, 520,
521, 521, 521,
522, 522, 522,
523, 523, 523,
524, 524, 524,
525, 525, 525,
526, 526, 526,
527, 527, 527,
528, 528, 528,
529, 529, 529,
530, 530, 530,
531, 531, 531,
532, 532, 532,
533, 533, 533,
534, 534, 534,
535, 535, 535,
536, 536, 536,
537, 537, 537,
538, 538, 538,
539, 539, 539,
540, 540, 540,
541, 541, 541,
542, 542, 542,
543, 543, 543,
544, 544, 544,
545, 545, 545,
546, 546, 546,
547, 547, 547,
548, 548, 548,
549, 549, 549,
550, 550, 550,
551, 551, 551,
552, 552, 552,
553, 553, 553,
554, 554, 554,
555, 555, 555,
556, 556, 556,
557, 557, 557,
558, 558, 558,
559, 559, 559,
560, 560, 560,
561, 561, 561,
562, 562, 562,
563, 563, 563,
564, 564, 564,
565, 565, 565,
566, 566, 566,
567, 567, 567,
568, 568, 568,
569, 569, 569,
570, 570, 570,
571, 571, 571,
572, 572, 572,
573, 573, 573,
574, 574, 574,
575, 575, 575,
576, 576, 576,
577, 577, 577,
578, 578, 578,
579, 579, 579,
580, 580, 580,
581, 581, 581,
582, 582, 582,
583, 583, 583,
584, 584, 584,
585, 585, 585,
586, 586, 586,
587, 587, 587,
588, 588, 588,
589, 589, 589,
590, 590, 590,
591, 591, 591,
592, 592, 592,
593, 593, 593,
594, 594, 594,
595, 595, 595,
596, 596, 596,
597, 597, 597,
598, 598, 598,
599, 599, 599,
600, 600, 600,
601, 601, 601,
602, 602, 602,
603, 603, 603,
604, 604, 604,
605, 605, 605,
606, 606, 606,
607, 607, 607,
608, 608, 608,
609, 609, 609,
610, 610, 610,
611, 611, 611,
612, 612, 612,
613, 613, 613,
614, 614, 614,
615, 615, 615,
616, 616, 616,
617, 617, 617,
618, 618, 618,
619, 619, 619,
620, 620, 620,
621, 621, 621,
622, 622, 622,
623, 623, 623,
624, 624, 624,
625, 625, 625,
626, 626, 626,
627, 627, 627,
628, 628, 628,
629, 629, 629,
630, 630, 630,
631, 631, 631,
632, 632, 632,
633, 633, 633,
634, 634, 634,
635, 635, 635,
636, 636, 636,
637, 637, 637,
638, 638, 638,
639, 639, 639,
640, 640, 640,
641, 641, 641,
642, 642, 642,
643, 643, 643,
644, 644, 644,
645, 645, 645,
646, 646, 646,
647, 647, 647,
648, 648, 648,
649, 649, 649,
650, 650, 650,
651, 651, 651,
652, 652, 652,
653, 653, 653,
654, 654, 654,
655, 655, 655,
656, 656, 656,
657, 657, 657,
658, 658, 658,
659, 659, 659,
660, 660, 660,
661, 661, 661,
662, 662, 662,
663, 663, 663,
664, 664, 664,
665, 665, 665,
666, 666, 666,
667, 667, 667,
668, 668, 668,
669, 669, 669,
670, 670, 670,
671, 671, 671,
672, 672, 672,
673, 673, 673,
674, 674, 674,
675, 675, 675,
676, 676, 676,
677, 677, 677,
678, 678, 678,
679, 679, 679,
680, 680, 680,
681, 681, 681,
682, 682, 682,
683, 683, 683,
684, 684, 684,
685, 685, 685,
686, 686, 686,
687, 687, 687,
688, 688, 688,
689, 689, 689,
690, 690, 690,
691, 691, 691,
692, 692, 692,
693, 693, 693,
694, 694, 694,
695, 695, 695,
696, 696, 696,
697, 697, 697,
698, 698, 698,
699, 699, 699,
700, 700, 700,
701, 701, 701,
702, 702, 702,
703, 703, 703,
704, 704, 704,
705, 705, 705,
706, 706, 706,
707, 707, 707,
708, 708, 708,
709, 709, 709,
710, 710, 710,
711, 711, 711,
712, 712, 712,
713, 713, 713,
714, 714, 714,
715, 715, 715,
716, 716, 716,
717, 717, 717,
718, 718, 718,
719, 719, 719,
720, 720, 720,
721, 721, 721,
722, 722, 722,
723, 723, 723,
724, 724, 724,
725, 725, 725,
726, 726, 726,
727, 727, 727,
728, 728, 728,
729, 729, 729,
730, 730, 730,
731, 731, 731,
732, 732, 732,
733, 733, 733,
734, 734, 734,
735, 735, 735,
736, 736, 736,
737, 737, 737,
738, 738, 738,
739, 739, 739,
740, 740, 740,
741, 741, 741,
742, 742, 742,
743, 743, 743,
744, 744, 744,
745, 745, 745,
746, 746, 746,
747, 747, 747,
748, 748, 748,
749, 749, 749,
750, 750, 750,
751, 751, 751,
752, 752, 752,
753, 753, 753,
754, 754, 754,
755, 755, 755,
756, 756, 756,
757, 757, 757,
758, 758, 758,
759, 759, 759,
760, 760, 760,
761, 761, 761,
762, 762, 762,
763, 763, 763,
764, 764, 764,
765, 765, 765,
766, 766, 766,
767, 767, 767,
768, 768, 768,
769, 769, 769,
770, 770, 770,
771, 771, 771,
772, 772, 772,
773, 773, 773,
774, 774, 774,
775, 775, 775,
776, 776, 776,
777, 777, 777,
778, 778, 778,
779, 779, 779,
780, 780, 780,
781, 781, 781,
782, 782, 782,
783, 783, 783,
784, 784, 784,
785, 785, 785,
786, 786, 786,
787, 787, 787,
788, 788, 788,
789, 789, 789,
790, 790, 790,
791, 791, 791,
792, 792, 792,
793, 793, 793,
794, 794, 794,
795, 795, 795,
796, 796, 796,
797, 797, 797,
798, 798, 798,
799, 799, 799,
800, 800, 800,
801, 801, 801,
802, 802, 802,
803, 803, 803,
804, 804, 804,
805, 805, 805,
806, 806, 806,
807, 807, 807,
808, 808, 808,
809, 809, 809,
810, 810, 810,
811, 811, 811,
812, 812, 812,
813, 813, 813,
814, 814, 814,
815, 815, 815,
816, 816, 816,
817, 817, 817,
818, 818, 818,
819, 819, 819,
820, 820, 820,
821, 821, 821,
822, 822, 822,
823, 823, 823,
824, 824, 824,
825, 825, 825,
826, 826, 826,
827, 827, 827,
828, 828, 828,
829, 829, 829,
830, 830, 830,
831, 831, 831,
832, 832, 832,
833, 833, 833,
834, 834, 834,
835, 835, 835,
836, 836, 836,
837, 837, 837,
838, 838, 838,
839, 839, 839,
840, 840, 840,
841, 841, 841,
842, 842, 842,
843, 843, 843,
844, 844, 844,
845, 845, 845,
846, 846, 846,
847, 847, 847,
848, 848, 848,
849, 849, 849,
850, 850, 850,
851, 851, 851,
852, 852, 852,
853, 853, 853,
854, 854, 854,
855, 855, 855,
856, 856, 856,
857, 857, 857,
858, 858, 858,
859, 859, 859,
860, 860, 860,
861, 861, 861,
862, 862, 862,
863, 863, 863,
864, 864, 864,
865, 865, 865,
866, 866, 866,
867, 867, 867,
868, 868, 868,
869, 869, 869,
870, 870, 870,
871, 871, 871,
872, 872, 872,
873, 873, 873,
874, 874, 874,
875, 875, 875,
876, 876, 876,
877, 877, 877,
878, 878, 878,
879, 879, 879,
880, 880, 880,
881, 881, 881,
882, 882, 882,
883, 883, 883,
884, 884, 884,
885, 885, 885,
886, 886, 886,
887, 887, 887,
888, 888, 888,
889, 889, 889,
890, 890, 890,
891, 891, 891,
892, 892, 892,
893, 893, 893,
894, 894, 894,
895, 895, 895,
896, 896, 896,
897, 897, 897,
898, 898, 898,
899, 899, 899,
900, 900, 900,
901, 901, 901,
902, 902, 902,
903, 903, 903,
904, 904, 904,
905, 905, 905,
906, 906, 906,
907, 907, 907,
908, 908, 908,
909, 909, 909,
910, 910, 910,
911, 911, 911,
912, 912, 912,
913, 913, 913,
914, 914, 914,
915, 915, 915,
916, 916, 916,
917, 917, 917,
918, 918, 918,
919, 919, 919,
920, 920, 920,
921, 921, 921,
922, 922, 922,
923, 923, 923,
924, 924, 924,
925, 925, 925,
926, 926, 926,
927, 927, 927,
928, 928, 928,
929, 929, 929,
930, 930, 930,
931, 931, 931,
932, 932, 932,
933, 933, 933,
934, 934, 934,
935, 935, 935,
936, 936, 936,
937, 937, 937,
938, 938, 938,
939, 939, 939,
940, 940, 940,
941, 941, 941,
942, 942, 942,
943, 943, 943,
944, 944, 944,
945, 945, 945,
946, 946, 946,
947, 947, 947,
948, 948, 948,
949, 949, 949,
950, 950, 950,
951, 951, 951,
952, 952, 952,
953, 953, 953,
954, 954, 954,
955, 955, 955,
956, 956, 956,
957, 957, 957,
958, 958, 958,
959, 959, 959,
960, 960, 960,
961, 961, 961,
962, 962, 962,
963, 963, 963,
964, 964, 964,
965, 965, 965,
966, 966, 966,
967, 967, 967,
968, 968, 968,
969, 969, 969,
970, 970, 970,
971, 971, 971,
972, 972, 972,
973, 973, 973,
974, 974, 974,
975, 975, 975,
976, 976, 976,
977, 977, 977,
978, 978, 978,
979, 979, 979,
980, 980, 980,
981, 981, 981,
982, 982, 982,
983, 983, 983,
984, 984, 984,
985, 985, 985,
986, 986, 986,
987, 987, 987,
988, 988, 988,
989, 989, 989,
990, 990, 990,
991, 991, 991,
992, 992, 992,
993, 993, 993,
994, 994, 994,
995, 995, 995,
996, 996, 996,
997, 997, 997,
998, 998, 998,
999, 999, 999,
1000, 1000, 1000,
1001, 1001, 1001,
1002, 1002, 1002,
1003, 1003, 1003,
1004, 1004, 1004,
1005, 1005, 1005,
1006, 1006, 1006,
1007, 1007, 1007,
1008, 1008, 1008,
1009, 1009, 1009,
1010, 1010, 1010,
1011, 1011, 1011,
1012, 1012, 1012,
1013, 1013, 1013,
1014, 1014, 1014,
1015, 1015, 1015,
1016, 1016, 1016,
1017, 1017, 1017,
1018, 1018, 1018,
1019, 1019, 1019,
1020, 1020, 1020,
1021, 1021, 1021,
1022, 1022, 1022,
1023, 1023, 1023,
1024, 1024, 1024,
1025, 1025, 1025,
1026, 1026, 1026,
1027, 1027, 1027,
1028, 1028, 1028,
1029, 1029, 1029,
1030, 1030, 1030,
1031, 1031, 1031,
1032, 1032, 1032,
1033, 1033, 1033,
1034, 1034, 1034,
1035, 1035, 1035,
1036, 1036, 1036,
1037, 1037, 1037,
1038, 1038, 1038,
1039, 1039, 1039,
1040, 1040, 1040,
1041, 1041, 1041,
1042, 1042, 1042,
1043, 1043, 1043,
1044, 1044, 1044,
1045, 1045, 1045,
1046, 1046, 1046,
1047, 1047, 1047,
1048, 1048, 1048,
1049, 1049, 1049,
1050, 1050, 1050,
1051, 1051, 1051,
1052, 1052, 1052,
1053, 1053, 1053,
1054, 1054, 1054,
1055, 1055, 1055,
1056, 1056, 1056,
1057, 1057, 1057,
1058, 1058, 1058,
1059, 1059, 1059,
1060, 1060, 1060,
1061, 1061, 1061,
1062, 1062, 1062,
1063, 1063, 1063,
1064, 1064, 1064,
1065, 1065, 1065,
1066, 1066, 1066,
1067, 1067, 1067,
1068, 1068, 1068,
1069, 1069, 1069,
1070, 1070, 1070,
1071, 1071, 1071,
1072, 1072, 1072,
1073, 1073, 1073,
1074, 1074, 1074,
1075, 1075, 1075,
1076, 1076, 1076,
1077, 1077, 1077,
1078, 1078, 1078,
1079, 1079, 1079,
1080, 1080, 1080,
1081, 1081, 1081,
1082, 1082, 1082,
1083, 1083, 1083,
1084, 1084, 1084,
1085, 1085, 1085,
1086, 1086, 1086,
1087, 1087, 1087,
1088, 1088, 1088,
1089, 1089, 1089,
1090, 1090, 1090,
1091, 1091, 1091,
1092, 1092, 1092,
1093, 1093, 1093,
1094, 1094, 1094,
1095, 1095, 1095,
1096, 1096, 1096,
1097, 1097, 1097,
1098, 1098, 1098,
1099, 1099, 1099,
1100, 1100, 1100,
1101, 1101, 1101,
1102, 1102, 1102,
1103, 1103, 1103,
1104, 1104, 1104,
1105, 1105, 1105,
1106, 1106, 1106,
1107, 1107, 1107,
1108, 1108, 1108,
1109, 1109, 1109,
1110, 1110, 1110,
1111, 1111, 1111,
1112, 1112, 1112,
1113, 1113, 1113,
1114, 1114, 1114,
1115, 1115, 1115,
1116, 1116, 1116,
1117, 1117, 1117,
1118, 1118, 1118,
1119, 1119, 1119,
1120, 1120, 1120,
1121, 1121, 1121,
1122, 1122, 1122,
1123, 1123, 1123,
1124, 1124, 1124,
1125, 1125, 1125,
1126, 1126, 1126,
1127, 1127, 1127,
1128, 1128, 1128,
1129, 1129, 1129,
1130, 1130, 1130,
1131, 1131, 1131,
1132, 1132, 1132,
1133, 1133, 1133,
1134, 1134, 1134,
1135, 1135, 1135,
1136, 1136, 1136,
1137, 1137, 1137,
1138, 1138, 1138,
1139, 1139, 1139,
1140, 1140, 1140,
1141, 1141, 1141,
1142, 1142, 1142,
1143, 1143, 1143,
1144, 1144, 1144,
1145, 1145, 1145,
1146, 1146, 1146,
1147, 1147, 1147,
1148, 1148, 1148,
1149, 1149, 1149,
1150, 1150, 1150,
1151, 1151, 1151,
1152, 1152, 1152,
1153, 1153, 1153,
1154, 1154, 1154,
1155, 1155, 1155,
1156, 1156, 1156,
1157, 1157, 1157,
1158, 1158, 1158,
1159, 1159, 1159,
1160, 1160, 1160,
1161, 1161, 1161,
1162, 1162, 1162,
1163, 1163, 1163,
1164, 1164, 1164,
1165, 1165, 1165,
1166, 1166, 1166,
1167, 1167, 1167,
1168, 1168, 1168,
1169, 1169, 1169,
1170, 1170, 1170,
1171, 1171, 1171,
1172, 1172, 1172,
1173, 1173, 1173,
1174, 1174, 1174,
1175, 1175, 1175,
1176, 1176, 1176,
1177, 1177, 1177,
1178, 1178, 1178,
1179, 1179, 1179,
1180, 1180, 1180,
1181, 1181, 1181,
1182, 1182, 1182,
1183, 1183, 1183,
1184, 1184, 1184,
1185, 1185, 1185,
1186, 1186, 1186,
1187, 1187, 1187,
1188, 1188, 1188,
1189, 1189, 1189,
1190, 1190, 1190,
1191, 1191, 1191,
1192, 1192, 1192,
1193, 1193, 1193,
1194, 1194, 1194,
1195, 1195, 1195,
1196, 1196, 1196,
1197, 1197, 1197,
1198, 1198, 1198,
1199, 1199, 1199,
1200, 1200, 1200,
1201, 1201, 1201,
1202, 1202, 1202,
1203, 1203, 1203,
1204, 1204, 1204,
1205, 1205, 1205,
1206, 1206, 1206,
1207, 1207, 1207,
1208, 1208, 1208,
1209, 1209, 1209,
1210, 1210, 1210,
1211, 1211, 1211,
1212, 1212, 1212,
1213, 1213, 1213,
1214, 1214, 1214,
1215, 1215, 1215,
1216, 1216, 1216,
1217, 1217, 1217,
1218, 1218, 1218,
1219, 1219, 1219,
1220, 1220, 1220,
1221, 1221, 1221,
1222, 1222, 1222,
1223, 1223, 1223,
1224, 1224, 1224,
1225, 1225, 1225,
1226, 1226, 1226,
1227, 1227, 1227,
1228, 1228, 1228,
1229, 1229, 1229,
1230, 1230, 1230,
1231, 1231, 1231,
1232, 1232, 1232,
1233, 1233, 1233,
1234, 1234, 1234,
1235, 1235, 1235,
1236, 1236, 1236,
1237, 1237, 1237,
1238, 1238, 1238,
1239, 1239, 1239,
1240, 1240, 1240,
1241, 1241, 1241,
1242, 1242, 1242,
1243, 1243, 1243,
1244, 1244, 1244,
1245, 1245, 1245,
1246, 1246, 1246,
1247, 1247, 1247,
1248, 1248, 1248,
1249, 1249, 1249,
1250, 1250, 1250,
1251, 1251, 1251,
1252, 1252, 1252,
1253, 1253, 1253,
1254, 1254, 1254,
1255, 1255, 1255,
1256, 1256, 1256,
1257, 1257, 1257,
1258, 1258, 1258,
1259, 1259, 1259,
1260, 1260, 1260,
1261, 1261, 1261,
1262, 1262, 1262,
1263, 1263, 1263,
1264, 1264, 1264,
1265, 1265, 1265,
1266, 1266, 1266,
1267, 1267, 1267,
1268, 1268, 1268,
1269, 1269, 1269,
1270, 1270, 1270,
1271, 1271, 1271,
1272, 1272, 1272,
1273, 1273, 1273,
1274, 1274, 1274,
1275, 1275, 1275,
1276, 1276, 1276,
1277, 1277, 1277,
1278, 1278, 1278,
1279, 1279, 1279,
1280, 1280, 1280,
1281, 1281, 1281,
1282, 1282, 1282,
1283, 1283, 1283,
1284, 1284, 1284,
1285, 1285, 1285,
1286, 1286, 1286,
1287, 1287, 1287,
1288, 1288, 1288,
1289, 1289, 1289,
1290, 1290, 1290,
1291, 1291, 1291,
1292, 1292, 1292,
1293, 1293, 1293,
1294, 1294, 1294,
1295, 1295, 1295,
1296, 1296, 1296,
1297, 1297, 1297,
1298, 1298, 1298,
1299, 1299, 1299,
1300, 1300, 1300,
1301, 1301, 1301,
1302, 1302, 1302,
1303, 1303, 1303,
1304, 1304, 1304,
1305, 1305, 1305,
1306, 1306, 1306,
1307, 1307, 1307,
1308, 1308, 1308,
1309, 1309, 1309,
1310, 1310, 1310,
1311, 1311, 1311,
1312, 1312, 1312,
1313, 1313, 1313,
1314, 1314, 1314,
1315, 1315, 1315,
1316, 1316, 1316,
1317, 1317, 1317,
1318, 1318, 1318,
1319, 1319, 1319,
1320, 1320, 1320,
1321, 1321, 1321,
1322, 1322, 1322,
1323, 1323, 1323,
1324, 1324, 1324,
1325, 1325, 1325,
1326, 1326, 1326,
1327, 1327, 1327,
1328, 1328, 1328,
1329, 1329, 1329,
1330, 1330, 1330,
1331, 1331, 1331,
1332, 1332, 1332,
1333, 1333, 1333,
1334, 1334, 1334,
1335, 1335, 1335,
1336, 1336, 1336,
1337, 1337, 1337,
1338, 1338, 1338,
1339, 1339, 1339,
1340, 1340, 1340,
1341, 1341, 1341,
1342, 1342, 1342,
1343, 1343, 1343,
1344, 1344, 1344,
1345, 1345, 1345,
1346, 1346, 1346,
1347, 1347, 1347,
1348, 1348, 1348,
1349, 1349, 1349,
1350, 1350, 1350,
1351, 1351, 1351,
1352, 1352, 1352,
1353, 1353, 1353,
1354, 1354, 1354,
1355, 1355, 1355,
1356, 1356, 1356,
1357, 1357, 1357,
1358, 1358, 1358,
1359, 1359, 1359,
1360, 1360, 1360,
1361, 1361, 1361,
1362, 1362, 1362,
1363, 1363, 1363,
1364, 1364, 1364,
1365, 1365, 1365,
1366, 1366, 1366,
1367, 1367, 1367,
1368, 1368, 1368,
1369, 1369, 1369,
1370, 1370, 1370,
1371, 1371, 1371,
1372, 1372, 1372,
1373, 1373, 1373,
1374, 1374, 1374,
1375, 1375, 1375,
1376, 1376, 1376,
1377, 1377, 1377,
1378, 1378, 1378,
1379, 1379, 1379,
1380, 1380, 1380,
1381, 1381, 1381,
1382, 1382, 1382,
1383, 1383, 1383,
1384, 1384, 1384,
1385, 1385, 1385,
1386, 1386, 1386,
1387, 1387, 1387,
1388, 1388, 1388,
1389, 1389, 1389,
1390, 1390, 1390,
1391, 1391, 1391,
1392, 1392, 1392,
1393, 1393, 1393,
1394, 1394, 1394,
1395, 1395, 1395,
1396, 1396, 1396,
1397, 1397, 1397,
1398, 1398, 1398,
1399, 1399, 1399,
1400, 1400, 1400,
1401, 1401, 1401,
1402, 1402, 1402,
1403, 1403, 1403,
1404, 1404, 1404,
1405, 1405, 1405,
1406, 1406, 1406,
1407, 1407, 1407,
1408, 1408, 1408,
1409, 1409, 1409,
1410, 1410, 1410,
1411, 1411, 1411,
1412, 1412, 1412,
1413, 1413, 1413,
1414, 1414, 1414,
1415, 1415, 1415,
1416, 1416, 1416,
1417, 1417, 1417,
1418, 1418, 1418,
1419, 1419, 1419,
1420, 1420, 1420,
1421, 1421, 1421,
1422, 1422, 1422,
1423, 1423, 1423,
1424, 1424, 1424,
1425, 1425, 1425,
1426, 1426, 1426,
1427, 1427, 1427,
1428, 1428, 1428,
1429, 1429, 1429,
1430, 1430, 1430,
1431, 1431, 1431,
1432, 1432, 1432,
1433, 1433, 1433,
1434, 1434, 1434,
1435, 1435, 1435,
1436, 1436, 1436,
1437, 1437, 1437,
1438, 1438, 1438,
1439, 1439, 1439,
1440, 1440, 1440,
1441, 1441, 1441,
1442, 1442, 1442,
1443, 1443, 1443,
1444, 1444, 1444,
1445, 1445, 1445,
1446, 1446, 1446,
1447, 1447, 1447,
1448, 1448, 1448,
1449, 1449, 1449,
1450, 1450, 1450,
1451, 1451, 1451,
1452, 1452, 1452,
1453, 1453, 1453,
1454, 1454, 1454,
1455, 1455, 1455,
1456, 1456, 1456,
1457, 1457, 1457,
1458, 1458, 1458,
1459, 1459, 1459,
1460, 1460, 1460,
1461, 1461, 1461,
1462, 1462, 1462,
1463, 1463, 1463,
1464, 1464, 1464,
1465, 1465, 1465,
1466, 1466, 1466,
1467, 1467, 1467,
1468, 1468, 1468,
1469, 1469, 1469,
1470, 1470, 1470,
1471, 1471, 1471,
1472, 1472, 1472,
1473, 1473, 1473,
1474, 1474, 1474,
1475, 1475, 1475,
1476, 1476, 1476,
1477, 1477, 1477,
1478, 1478, 1478,
1479, 1479, 1479,
1480, 1480, 1480,
1481, 1481, 1481,
1482, 1482, 1482,
1483, 1483, 1483,
1484, 1484, 1484,
1485, 1485, 1485,
1486, 1486, 1486,
1487, 1487, 1487,
1488, 1488, 1488,
1489, 1489, 1489,
1490, 1490, 1490,
1491, 1491, 1491,
1492, 1492, 1492,
1493, 1493, 1493,
1494, 1494, 1494,
1495, 1495, 1495,
1496, 1496, 1496,
1497, 1497, 1497,
1498, 1498, 1498,
1499, 1499, 1499,
1500, 1500, 1500,
1501, 1501, 1501,
1502, 1502, 1502,
1503, 1503, 1503,
1504, 1504, 1504,
1505, 1505, 1505,
1506, 1506, 1506,
1507, 1507, 1507,
1508, 1508, 1508,
1509, 1509, 1509,
1510, 1510, 1510,
1511, 1511, 1511,
1512, 1512, 1512,
1513, 1513, 1513,
1514, 1514, 1514,
1515, 1515, 1515,
1516, 1516, 1516,
1517, 1517, 1517,
1518, 1518, 1518,
1519, 1519, 1519,
1520, 1520, 1520,
1521, 1521, 1521,
1522, 1522, 1522,
1523, 1523, 1523,
1524, 1524, 1524,
1525, 1525, 1525,
1526, 1526, 1526,
1527, 1527, 1527,
1528, 1528, 1528,
1529, 1529, 1529,
1530, 1530, 1530,
1531, 1531, 1531,
1532, 1532, 1532,
1533, 1533, 1533,
1534, 1534, 1534,
1535, 1535, 1535,
1536, 1536, 1536,
1537, 1537, 1537,
1538, 1538, 1538,
1539, 1539, 1539,
1540, 1540, 1540,
1541, 1541, 1541,
1542, 1542, 1542,
1543, 1543, 1543,
1544, 1544, 1544,
1545, 1545, 1545,
1546, 1546, 1546,
1547, 1547, 1547,
1548, 1548, 1548,
1549, 1549, 1549,
1550, 1550, 1550,
1551, 1551, 1551,
1552, 1552, 1552,
1553, 1553, 1553,
1554, 1554, 1554,
1555, 1555, 1555,
1556, 1556, 1556,
1557, 1557, 1557,
1558, 1558, 1558,
1559, 1559, 1559,
1560, 1560, 1560,
1561, 1561, 1561,
1562, 1562, 1562,
1563, 1563, 1563,
1564, 1564, 1564,
1565, 1565, 1565,
1566, 1566, 1566,
1567, 1567, 1567,
1568, 1568, 1568,
1569, 1569, 1569,
1570, 1570, 1570,
1571, 1571, 1571,
1572, 1572, 1572,
1573, 1573, 1573,
1574, 1574, 1574,
1575, 1575, 1575,
1576, 1576, 1576,
1577, 1577, 1577,
1578, 1578, 1578,
1579, 1579, 1579,
1580, 1580, 1580,
1581, 1581, 1581,
1582, 1582, 1582,
1583, 1583, 1583,
1584, 1584, 1584,
1585, 1585, 1585,
1586, 1586, 1586,
1587, 1587, 1587,
1588, 1588, 1588,
1589, 1589, 1589,
1590, 1590, 1590,
1591, 1591, 1591,
1592, 1592, 1592,
1593, 1593, 1593,
1594, 1594, 1594,
1595, 1595, 1595,
1596, 1596, 1596,
1597, 1597, 1597,
1598, 1598, 1598,
1599, 1599, 1599,
1600, 1600, 1600,
1601, 1601, 1601,
1602, 1602, 1602,
1603, 1603, 1603,
1604, 1604, 1604,
1605, 1605, 1605,
1606, 1606, 1606,
1607, 1607, 1607,
1608, 1608, 1608,
1609, 1609, 1609,
1610, 1610, 1610,
1611, 1611, 1611,
1612, 1612, 1612,
1613, 1613, 1613,
1614, 1614, 1614,
1615, 1615, 1615,
1616, 1616, 1616,
1617, 1617, 1617,
1618, 1618, 1618,
1619, 1619, 1619,
1620, 1620, 1620,
1621, 1621, 1621,
1622, 1622, 1622,
1623, 1623, 1623,
1624, 1624, 1624,
1625, 1625, 1625,
1626, 1626, 1626,
1627, 1627, 1627,
1628, 1628, 1628,
1629, 1629, 1629,
1630, 1630, 1630,
1631, 1631, 1631,
1632, 1632, 1632,
1633, 1633, 1633,
1634, 1634, 1634,
1635, 1635, 1635,
1636, 1636, 1636,
1637, 1637, 1637,
1638, 1638, 1638,
1639, 1639, 1639,
1640, 1640, 1640,
1641, 1641, 1641,
1642, 1642, 1642,
1643, 1643, 1643,
1644, 1644, 1644,
1645, 1645, 1645,
1646, 1646, 1646,
1647, 1647, 1647,
1648, 1648, 1648,
1649, 1649, 1649,
1650, 1650, 1650,
1651, 1651, 1651,
1652, 1652, 1652,
1653, 1653, 1653,
1654, 1654, 1654,
1655, 1655, 1655,
1656, 1656, 1656,
1657, 1657, 1657,
1658, 1658, 1658,
1659, 1659, 1659,
1660, 1660, 1660,
1661, 1661, 1661,
1662, 1662, 1662,
1663, 1663, 1663,
1664, 1664, 1664,
1665, 1665, 1665,
1666, 1666, 1666,
1667, 1667, 1667,
1668, 1668, 1668,
1669, 1669, 1669,
1670, 1670, 1670,
1671, 1671, 1671,
1672, 1672, 1672,
1673, 1673, 1673,
1674, 1674, 1674,
1675, 1675, 1675,
1676, 1676, 1676,
1677, 1677, 1677,
1678, 1678, 1678,
1679, 1679, 1679,
1680, 1680, 1680,
1681, 1681, 1681,
1682, 1682, 1682,
1683, 1683, 1683,
1684, 1684, 1684,
1685, 1685, 1685,
1686, 1686, 1686,
1687, 1687, 1687,
1688, 1688, 1688,
1689, 1689, 1689,
1690, 1690, 1690,
1691, 1691, 1691,
1692, 1692, 1692,
1693, 1693, 1693,
1694, 1694, 1694,
1695, 1695, 1695,
1696, 1696, 1696,
1697, 1697, 1697,
1698, 1698, 1698,
1699, 1699, 1699,
1700, 1700, 1700,
1701, 1701, 1701,
1702, 1702, 1702,
1703, 1703, 1703,
1704, 1704, 1704,
1705, 1705, 1705,
1706, 1706, 1706,
1707, 1707, 1707,
1708, 1708, 1708,
1709, 1709, 1709,
1710, 1710, 1710,
1711, 1711, 1711,
1712, 1712, 1712,
1713, 1713, 1713,
1714, 1714, 1714,
1715, 1715, 1715,
1716, 1716, 1716,
1717, 1717, 1717,
1718, 1718, 1718,
1719, 1719, 1719,
1720, 1720, 1720,
1721, 1721, 1721,
1722, 1722, 1722,
1723, 1723, 1723,
1724, 1724, 1724,
1725, 1725, 1725,
1726, 1726, 1726,
1727, 1727, 1727,
1728, 1728, 1728,
1729, 1729, 1729,
1730, 1730, 1730,
1731, 1731, 1731,
1732, 1732, 1732,
1733, 1733, 1733,
1734, 1734, 1734,
1735, 1735, 1735,
1736, 1736, 1736,
1737, 1737, 1737,
1738, 1738, 1738,
1739, 1739, 1739,
1740, 1740, 1740,
1741, 1741, 1741,
1742, 1742, 1742,
1743, 1743, 1743,
1744, 1744, 1744,
1745, 1745, 1745,
1746, 1746, 1746,
1747, 1747, 1747,
1748, 1748, 1748,
1749, 1749, 1749,
1750, 1750, 1750,
1751, 1751, 1751,
1752, 1752, 1752,
1753, 1753, 1753,
1754, 1754, 1754,
1755, 1755, 1755,
1756, 1756, 1756,
1757, 1757, 1757,
1758, 1758, 1758,
1759, 1759, 1759,
1760, 1760, 1760,
1761, 1761, 1761,
1762, 1762, 1762,
1763, 1763, 1763,
1764, 1764, 1764,
1765, 1765, 1765,
1766, 1766, 1766,
1767, 1767, 1767,
1768, 1768, 1768,
1769, 1769, 1769,
1770, 1770, 1770,
1771, 1771, 1771,
1772, 1772, 1772,
1773, 1773, 1773,
1774, 1774, 1774,
1775, 1775, 1775,
1776, 1776, 1776,
1777, 1777, 1777,
1778, 1778, 1778,
1779, 1779, 1779,
1780, 1780, 1780,
1781, 1781, 1781,
1782, 1782, 1782,
1783, 1783, 1783,
1784, 1784, 1784,
1785, 1785, 1785,
1786, 1786, 1786,
1787, 1787, 1787,
1788, 1788, 1788,
1789, 1789, 1789,
1790, 1790, 1790,
1791, 1791, 1791,
1792, 1792, 1792,
1793, 1793, 1793,
1794, 1794, 1794,
1795, 1795, 1795,
1796, 1796, 1796,
1797, 1797, 1797,
1798, 1798, 1798,
1799, 1799, 1799,
1800, 1800, 1800,
1801, 1801, 1801,
1802, 1802, 1802,
1803, 1803, 1803,
1804, 1804, 1804,
1805, 1805, 1805,
1806, 1806, 1806,
1807, 1807, 1807,
1808, 1808, 1808,
1809, 1809, 1809,
1810, 1810, 1810,
1811, 1811, 1811,
1812, 1812, 1812,
1813, 1813, 1813,
1814, 1814, 1814,
1815, 1815, 1815,
1816, 1816, 1816,
1817, 1817, 1817,
1818, 1818, 1818,
1819, 1819, 1819,
1820, 1820, 1820,
1821, 1821, 1821,
1822, 1822, 1822,
1823, 1823, 1823,
1824, 1824, 1824,
1825, 1825, 1825,
1826, 1826, 1826,
1827, 1827, 1827,
1828, 1828, 1828,
1829, 1829, 1829,
1830, 1830, 1830,
1831, 1831, 1831,
1832, 1832, 1832,
1833, 1833, 1833,
1834, 1834, 1834,
1835, 1835, 1835,
1836, 1836, 1836,
1837, 1837, 1837,
1838, 1838, 1838,
1839, 1839, 1839,
1840, 1840, 1840,
1841, 1841, 1841,
1842, 1842, 1842,
1843, 1843, 1843,
1844, 1844, 1844,
1845, 1845, 1845,
1846, 1846, 1846,
1847, 1847, 1847,
1848, 1848, 1848,
1849, 1849, 1849,
1850, 1850, 1850,
1851, 1851, 1851,
1852, 1852, 1852,
1853, 1853, 1853,
1854, 1854, 1854,
1855, 1855, 1855,
1856, 1856, 1856,
1857, 1857, 1857,
1858, 1858, 1858,
1859, 1859, 1859,
1860, 1860, 1860,
1861, 1861, 1861,
1862, 1862, 1862,
1863, 1863, 1863,
1864, 1864, 1864,
1865, 1865, 1865,
1866, 1866, 1866,
1867, 1867, 1867,
1868, 1868, 1868,
1869, 1869, 1869,
1870, 1870, 1870,
1871, 1871, 1871,
1872, 1872, 1872,
1873, 1873, 1873,
1874, 1874, 1874,
1875, 1875, 1875,
1876, 1876, 1876,
1877, 1877, 1877,
1878, 1878, 1878,
1879, 1879, 1879,
1880, 1880, 1880,
1881, 1881, 1881,
1882, 1882, 1882,
1883, 1883, 1883,
1884, 1884, 1884,
1885, 1885, 1885,
1886, 1886, 1886,
1887, 1887, 1887,
1888, 1888, 1888,
1889, 1889, 1889,
1890, 1890, 1890,
1891, 1891, 1891,
1892, 1892, 1892,
1893, 1893, 1893,
1894, 1894, 1894,
1895, 1895, 1895,
1896, 1896, 1896,
1897, 1897, 1897,
1898, 1898, 1898,
1899, 1899, 1899,
1900, 1900, 1900,
1901, 1901, 1901,
1902, 1902, 1902,
1903, 1903, 1903,
1904, 1904, 1904,
1905, 1905, 1905,
1906, 1906, 1906,
1907, 1907, 1907,
1908, 1908, 1908,
1909, 1909, 1909,
1910, 1910, 1910,
1911, 1911, 1911,
1912, 1912, 1912,
1913, 1913, 1913,
1914, 1914, 1914,
1915, 1915, 1915,
1916, 1916, 1916,
1917, 1917, 1917,
1918, 1918, 1918,
1919, 1919, 1919,
1920, 1920, 1920,
1921, 1921, 1921,
1922, 1922, 1922,
1923, 1923, 1923,
1924, 1924, 1924,
1925, 1925, 1925,
1926, 1926, 1926,
1927, 1927, 1927,
1928, 1928, 1928,
1929, 1929, 1929,
1930, 1930, 1930,
1931, 1931, 1931,
1932, 1932, 1932,
1933, 1933, 1933,
1934, 1934, 1934,
1935, 1935, 1935,
1936, 1936, 1936,
1937, 1937, 1937,
1938, 1938, 1938,
1939, 1939, 1939,
1940, 1940, 1940,
1941, 1941, 1941,
1942, 1942, 1942,
1943, 1943, 1943,
1944, 1944, 1944,
1945, 1945, 1945,
1946, 1946, 1946,
1947, 1947, 1947,
1948, 1948, 1948,
1949, 1949, 1949,
1950, 1950, 1950,
1951, 1951, 1951,
1952, 1952, 1952,
1953, 1953, 1953,
1954, 1954, 1954,
1955, 1955, 1955,
1956, 1956, 1956,
1957, 1957, 1957,
1958, 1958, 1958,
1959, 1959, 1959,
1960, 1960, 1960,
1961, 1961, 1961,
1962, 1962, 1962,
1963, 1963, 1963,
1964, 1964, 1964,
1965, 1965, 1965,
1966, 1966, 1966,
1967, 1967, 1967,
1968, 1968, 1968,
1969, 1969, 1969,
1970, 1970, 1970,
1971, 1971, 1971,
1972, 1972, 1972,
1973, 1973, 1973,
1974, 1974, 1974,
1975, 1975, 1975,
1976, 1976, 1976,
1977, 1977, 1977,
1978, 1978, 1978,
1979, 1979, 1979,
1980, 1980, 1980,
1981, 1981, 1981,
1982, 1982, 1982,
1983, 1983, 1983,
1984, 1984, 1984,
1985, 1985, 1985,
1986, 1986, 1986,
1987, 1987, 1987,
1988, 1988, 1988,
1989, 1989, 1989,
1990, 1990, 1990,
1991, 1991, 1991,
1992, 1992, 1992,
1993, 1993, 1993,
1994, 1994, 1994,
1995, 1995, 1995,
1996, 1996, 1996,
1997, 1997, 1997,
1998, 1998, 1998,
1999, 1999, 1999,
2000, 2000, 2000,
2001, 2001, 2001,
2002, 2002, 2002,
2003, 2003, 2003,
2004, 2004, 2004,
2005, 2005, 2005,
2006, 2006, 2006,
2007, 2007, 2007,
2008, 2008, 2008,
2009, 2009, 2009,
2010, 2010, 2010,
2011, 2011, 2011,
2012, 2012, 2012,
2013, 2013, 2013,
2014, 2014, 2014,
2015, 2015, 2015,
2016, 2016, 2016,
2017, 2017, 2017,
2018, 2018, 2018,
2019, 2019, 2019,
2020, 2020, 2020,
2021, 2021, 2021,
2022, 2022, 2022,
2023, 2023, 2023,
2024, 2024, 2024,
2025, 2025, 2025,
2026, 2026, 2026,
2027, 2027, 2027,
2028, 2028, 2028,
2029, 2029, 2029,
2030, 2030, 2030,
2031, 2031, 2031,
2032, 2032, 2032,
2033, 2033, 2033,
2034, 2034, 2034,
2035, 2035, 2035,
2036, 2036, 2036,
2037, 2037, 2037,
2038, 2038, 2038,
2039, 2039, 2039,
2040, 2040, 2040,
2041, 2041, 2041,
2042, 2042, 2042,
2043, 2043, 2043,
2044, 2044, 2044,
2045, 2045, 2045,
2046, 2046, 2046,
2047, 2047, 2047
 };
vars_3_12 varinx6B_4096_a[] = {
0, 1120, 1564,
1, 1121, 1565,
2, 1122, 1566,
3, 1123, 1567,
4, 1124, 1568,
5, 1125, 1569,
6, 1126, 1570,
7, 1127, 1571,
8, 1128, 1572,
9, 1129, 1573,
10, 1130, 1574,
11, 1131, 1575,
12, 1132, 1576,
13, 1133, 1577,
14, 1134, 1578,
15, 1135, 1579,
16, 1136, 1580,
17, 1137, 1581,
18, 1138, 1582,
19, 1139, 1583,
20, 1140, 1584,
21, 1141, 1585,
22, 1142, 1586,
23, 1143, 1587,
24, 1144, 1588,
25, 1145, 1589,
26, 1146, 1590,
27, 1147, 1591,
28, 1148, 1592,
29, 1149, 1593,
30, 1150, 1594,
31, 1151, 1595,
32, 1152, 1596,
33, 1153, 1597,
34, 1154, 1598,
35, 1155, 1599,
36, 1156, 1600,
37, 1157, 1601,
38, 1158, 1602,
39, 1159, 1603,
40, 1160, 1604,
41, 1161, 1605,
42, 1162, 1606,
43, 1163, 1607,
44, 1164, 1608,
45, 1165, 1609,
46, 1166, 1610,
47, 1167, 1611,
48, 1168, 1612,
49, 1169, 1613,
50, 1170, 1614,
51, 1171, 1615,
52, 1172, 1616,
53, 1173, 1617,
54, 1174, 1618,
55, 1175, 1619,
56, 1176, 1620,
57, 1177, 1621,
58, 1178, 1622,
59, 1179, 1623,
60, 1180, 1624,
61, 1181, 1625,
62, 1182, 1626,
63, 1183, 1627,
64, 1184, 1628,
65, 1185, 1629,
66, 1186, 1630,
67, 1187, 1631,
68, 1188, 1632,
69, 1189, 1633,
70, 1190, 1634,
71, 1191, 1635,
72, 1192, 1636,
73, 1193, 1637,
74, 1194, 1638,
75, 1195, 1639,
76, 1196, 1640,
77, 1197, 1641,
78, 1198, 1642,
79, 1199, 1643,
80, 1200, 1644,
81, 1201, 1645,
82, 1202, 1646,
83, 1203, 1647,
84, 1204, 1648,
85, 1205, 1649,
86, 1206, 1650,
87, 1207, 1651,
88, 1208, 1652,
89, 1209, 1653,
90, 1210, 1654,
91, 1211, 1655,
92, 1212, 1656,
93, 1213, 1657,
94, 1214, 1658,
95, 1215, 1659,
96, 1216, 1660,
97, 1217, 1661,
98, 1218, 1662,
99, 1219, 1663,
100, 1220, 1664,
101, 1221, 1665,
102, 1222, 1666,
103, 1223, 1667,
104, 1224, 1668,
105, 1225, 1669,
106, 1226, 1670,
107, 1227, 1671,
108, 1228, 1672,
109, 1229, 1673,
110, 1230, 1674,
111, 1231, 1675,
112, 1232, 1676,
113, 1233, 1677,
114, 1234, 1678,
115, 1235, 1679,
116, 1236, 1680,
117, 1237, 1681,
118, 1238, 1682,
119, 1239, 1683,
120, 1240, 1684,
121, 1241, 1685,
122, 1242, 1686,
123, 1243, 1687,
124, 1244, 1688,
125, 1245, 1689,
126, 1246, 1690,
127, 1247, 1691,
128, 1248, 1692,
129, 1249, 1693,
130, 1250, 1694,
131, 1251, 1695,
132, 1252, 1696,
133, 1253, 1697,
134, 1254, 1698,
135, 1255, 1699,
136, 1256, 1700,
137, 1257, 1701,
138, 1258, 1702,
139, 1259, 1703,
140, 1260, 1704,
141, 1261, 1705,
142, 1262, 1706,
143, 1263, 1707,
144, 1264, 1708,
145, 1265, 1709,
146, 1266, 1710,
147, 1267, 1711,
148, 1268, 1712,
149, 1269, 1713,
150, 1270, 1714,
151, 1271, 1715,
152, 1272, 1716,
153, 1273, 1717,
154, 1274, 1718,
155, 1275, 1719,
156, 1276, 1720,
157, 1277, 1721,
158, 1278, 1722,
159, 1279, 1723,
160, 1280, 1724,
161, 1281, 1725,
162, 1282, 1726,
163, 1283, 1727,
164, 1284, 1728,
165, 1285, 1729,
166, 1286, 1730,
167, 1287, 1731,
168, 1288, 1732,
169, 1289, 1733,
170, 1290, 1734,
171, 1291, 1735,
172, 1292, 1736,
173, 1293, 1737,
174, 1294, 1738,
175, 1295, 1739,
176, 1296, 1740,
177, 1297, 1741,
178, 1298, 1742,
179, 1299, 1743,
180, 1300, 1744,
181, 1301, 1745,
182, 1302, 1746,
183, 1303, 1747,
184, 1304, 1748,
185, 1305, 1749,
186, 1306, 1750,
187, 1307, 1751,
188, 1308, 1752,
189, 1309, 1753,
190, 1310, 1754,
191, 1311, 1755,
192, 1312, 1756,
193, 1313, 1757,
194, 1314, 1758,
195, 1315, 1759,
196, 1316, 1760,
197, 1317, 1761,
198, 1318, 1762,
199, 1319, 1763,
200, 1320, 1764,
201, 1321, 1765,
202, 1322, 1766,
203, 1323, 1767,
204, 1324, 1768,
205, 1325, 1769,
206, 1326, 1770,
207, 1327, 1771,
208, 1328, 1772,
209, 1329, 1773,
210, 1330, 1774,
211, 1331, 1775,
212, 1332, 1776,
213, 1333, 1777,
214, 1334, 1778,
215, 1335, 1779,
216, 1336, 1780,
217, 1337, 1781,
218, 1338, 1782,
219, 1339, 1783,
220, 1340, 1784,
221, 1341, 1785,
222, 1342, 1786,
223, 1343, 1787,
224, 1344, 1788,
225, 1345, 1789,
226, 1346, 1790,
227, 1347, 1791,
228, 1348, 1792,
229, 1349, 1793,
230, 1350, 1794,
231, 1351, 1795,
232, 1352, 1796,
233, 1353, 1797,
234, 1354, 1798,
235, 1355, 1799,
236, 1356, 1800,
237, 1357, 1801,
238, 1358, 1802,
239, 1359, 1803,
240, 1360, 1804,
241, 1361, 1805,
242, 1362, 1806,
243, 1363, 1807,
244, 1364, 1808,
245, 1365, 1809,
246, 1366, 1810,
247, 1367, 1811,
248, 1368, 1812,
249, 1369, 1813,
250, 1370, 1814,
251, 1371, 1815,
252, 1372, 1816,
253, 1373, 1817,
254, 1374, 1818,
255, 1375, 1819,
256, 1376, 1820,
257, 1377, 1821,
258, 1378, 1822,
259, 1379, 1823,
260, 1380, 1824,
261, 1381, 1825,
262, 1382, 1826,
263, 1383, 1827,
264, 1384, 1828,
265, 1385, 1829,
266, 1386, 1830,
267, 1387, 1831,
268, 1388, 1832,
269, 1389, 1833,
270, 1390, 1834,
271, 1391, 1835,
272, 1392, 1836,
273, 1393, 1837,
274, 1394, 1838,
275, 1395, 1839,
276, 1396, 1840,
277, 1397, 1841,
278, 1398, 1842,
279, 1399, 1843,
280, 1400, 1844,
281, 1401, 1845,
282, 1402, 1846,
283, 1403, 1847,
284, 1404, 1848,
285, 1405, 1849,
286, 1406, 1850,
287, 1407, 1851,
288, 1408, 1852,
289, 1409, 1853,
290, 1410, 1854,
291, 1411, 1855,
292, 1412, 1856,
293, 1413, 1857,
294, 1414, 1858,
295, 1415, 1859,
296, 1416, 1860,
297, 1417, 1861,
298, 1418, 1862,
299, 1419, 1863,
300, 1420, 1864,
301, 1421, 1865,
302, 1422, 1866,
303, 1423, 1867,
304, 1424, 1868,
305, 1425, 1869,
306, 1426, 1870,
307, 1427, 1871,
308, 1428, 1872,
309, 1429, 1873,
310, 1430, 1874,
311, 1431, 1875,
312, 1432, 1876,
313, 1433, 1877,
314, 1434, 1878,
315, 1435, 1879,
316, 1436, 1880,
317, 1437, 1881,
318, 1438, 1882,
319, 1439, 1883,
320, 1440, 1884,
321, 1441, 1885,
322, 1442, 1886,
323, 1443, 1887,
324, 1444, 1888,
325, 1445, 1889,
326, 1446, 1890,
327, 1447, 1891,
328, 1448, 1892,
329, 1449, 1893,
330, 1450, 1894,
331, 1451, 1895,
332, 1452, 1896,
333, 1453, 1897,
334, 1454, 1898,
335, 1455, 1899,
336, 1456, 1900,
337, 1457, 1901,
338, 1458, 1902,
339, 1459, 1903,
340, 1460, 1904,
341, 1461, 1905,
342, 1462, 1906,
343, 1463, 1907,
344, 1464, 1908,
345, 1465, 1909,
346, 1466, 1910,
347, 1467, 1911,
348, 1468, 1912,
349, 1469, 1913,
350, 1470, 1914,
351, 1471, 1915,
352, 1472, 1916,
353, 1473, 1917,
354, 1474, 1918,
355, 1475, 1919,
356, 1476, 1920,
357, 1477, 1921,
358, 1478, 1922,
359, 1479, 1923,
360, 1480, 1924,
361, 1481, 1925,
362, 1482, 1926,
363, 1483, 1927,
364, 1484, 1928,
365, 1485, 1929,
366, 1486, 1930,
367, 1487, 1931,
368, 1488, 1932,
369, 1489, 1933,
370, 1490, 1934,
371, 1491, 1935,
372, 1492, 1936,
373, 1493, 1937,
374, 1494, 1938,
375, 1495, 1939,
376, 1496, 1940,
377, 1497, 1941,
378, 1498, 1942,
379, 1499, 1943,
380, 1500, 1944,
381, 1501, 1945,
382, 1502, 1946,
383, 1503, 1947,
384, 1504, 1948,
385, 1505, 1949,
386, 1506, 1950,
387, 1507, 1951,
388, 1508, 1952,
389, 1509, 1953,
390, 1510, 1954,
391, 1511, 1955,
392, 1512, 1956,
393, 1513, 1957,
394, 1514, 1958,
395, 1515, 1959,
396, 1516, 1960,
397, 1517, 1961,
398, 1518, 1962,
399, 1519, 1963,
400, 1520, 1964,
401, 1521, 1965,
402, 1522, 1966,
403, 1523, 1967,
404, 1524, 1968,
405, 1525, 1969,
406, 1526, 1970,
407, 1527, 1971,
408, 1528, 1972,
409, 1529, 1973,
410, 1530, 1974,
411, 1531, 1975,
412, 1532, 1976,
413, 1533, 1977,
414, 1534, 1978,
415, 1535, 1979,
416, 1024, 1980,
417, 1025, 1981,
418, 1026, 1982,
419, 1027, 1983,
420, 1028, 1984,
421, 1029, 1985,
422, 1030, 1986,
423, 1031, 1987,
424, 1032, 1988,
425, 1033, 1989,
426, 1034, 1990,
427, 1035, 1991,
428, 1036, 1992,
429, 1037, 1993,
430, 1038, 1994,
431, 1039, 1995,
432, 1040, 1996,
433, 1041, 1997,
434, 1042, 1998,
435, 1043, 1999,
436, 1044, 2000,
437, 1045, 2001,
438, 1046, 2002,
439, 1047, 2003,
440, 1048, 2004,
441, 1049, 2005,
442, 1050, 2006,
443, 1051, 2007,
444, 1052, 2008,
445, 1053, 2009,
446, 1054, 2010,
447, 1055, 2011,
448, 1056, 2012,
449, 1057, 2013,
450, 1058, 2014,
451, 1059, 2015,
452, 1060, 2016,
453, 1061, 2017,
454, 1062, 2018,
455, 1063, 2019,
456, 1064, 2020,
457, 1065, 2021,
458, 1066, 2022,
459, 1067, 2023,
460, 1068, 2024,
461, 1069, 2025,
462, 1070, 2026,
463, 1071, 2027,
464, 1072, 2028,
465, 1073, 2029,
466, 1074, 2030,
467, 1075, 2031,
468, 1076, 2032,
469, 1077, 2033,
470, 1078, 2034,
471, 1079, 2035,
472, 1080, 2036,
473, 1081, 2037,
474, 1082, 2038,
475, 1083, 2039,
476, 1084, 2040,
477, 1085, 2041,
478, 1086, 2042,
479, 1087, 2043,
480, 1088, 2044,
481, 1089, 2045,
482, 1090, 2046,
483, 1091, 2047,
484, 1092, 1536,
485, 1093, 1537,
486, 1094, 1538,
487, 1095, 1539,
488, 1096, 1540,
489, 1097, 1541,
490, 1098, 1542,
491, 1099, 1543,
492, 1100, 1544,
493, 1101, 1545,
494, 1102, 1546,
495, 1103, 1547,
496, 1104, 1548,
497, 1105, 1549,
498, 1106, 1550,
499, 1107, 1551,
500, 1108, 1552,
501, 1109, 1553,
502, 1110, 1554,
503, 1111, 1555,
504, 1112, 1556,
505, 1113, 1557,
506, 1114, 1558,
507, 1115, 1559,
508, 1116, 1560,
509, 1117, 1561,
510, 1118, 1562,
511, 1119, 1563,
512, 84, 1796,
513, 85, 1797,
514, 86, 1798,
515, 87, 1799,
516, 88, 1800,
517, 89, 1801,
518, 90, 1802,
519, 91, 1803,
520, 92, 1804,
521, 93, 1805,
522, 94, 1806,
523, 95, 1807,
524, 96, 1808,
525, 97, 1809,
526, 98, 1810,
527, 99, 1811,
528, 100, 1812,
529, 101, 1813,
530, 102, 1814,
531, 103, 1815,
532, 104, 1816,
533, 105, 1817,
534, 106, 1818,
535, 107, 1819,
536, 108, 1820,
537, 109, 1821,
538, 110, 1822,
539, 111, 1823,
540, 112, 1824,
541, 113, 1825,
542, 114, 1826,
543, 115, 1827,
544, 116, 1828,
545, 117, 1829,
546, 118, 1830,
547, 119, 1831,
548, 120, 1832,
549, 121, 1833,
550, 122, 1834,
551, 123, 1835,
552, 124, 1836,
553, 125, 1837,
554, 126, 1838,
555, 127, 1839,
556, 128, 1840,
557, 129, 1841,
558, 130, 1842,
559, 131, 1843,
560, 132, 1844,
561, 133, 1845,
562, 134, 1846,
563, 135, 1847,
564, 136, 1848,
565, 137, 1849,
566, 138, 1850,
567, 139, 1851,
568, 140, 1852,
569, 141, 1853,
570, 142, 1854,
571, 143, 1855,
572, 144, 1856,
573, 145, 1857,
574, 146, 1858,
575, 147, 1859,
576, 148, 1860,
577, 149, 1861,
578, 150, 1862,
579, 151, 1863,
580, 152, 1864,
581, 153, 1865,
582, 154, 1866,
583, 155, 1867,
584, 156, 1868,
585, 157, 1869,
586, 158, 1870,
587, 159, 1871,
588, 160, 1872,
589, 161, 1873,
590, 162, 1874,
591, 163, 1875,
592, 164, 1876,
593, 165, 1877,
594, 166, 1878,
595, 167, 1879,
596, 168, 1880,
597, 169, 1881,
598, 170, 1882,
599, 171, 1883,
600, 172, 1884,
601, 173, 1885,
602, 174, 1886,
603, 175, 1887,
604, 176, 1888,
605, 177, 1889,
606, 178, 1890,
607, 179, 1891,
608, 180, 1892,
609, 181, 1893,
610, 182, 1894,
611, 183, 1895,
612, 184, 1896,
613, 185, 1897,
614, 186, 1898,
615, 187, 1899,
616, 188, 1900,
617, 189, 1901,
618, 190, 1902,
619, 191, 1903,
620, 192, 1904,
621, 193, 1905,
622, 194, 1906,
623, 195, 1907,
624, 196, 1908,
625, 197, 1909,
626, 198, 1910,
627, 199, 1911,
628, 200, 1912,
629, 201, 1913,
630, 202, 1914,
631, 203, 1915,
632, 204, 1916,
633, 205, 1917,
634, 206, 1918,
635, 207, 1919,
636, 208, 1920,
637, 209, 1921,
638, 210, 1922,
639, 211, 1923,
640, 212, 1924,
641, 213, 1925,
642, 214, 1926,
643, 215, 1927,
644, 216, 1928,
645, 217, 1929,
646, 218, 1930,
647, 219, 1931,
648, 220, 1932,
649, 221, 1933,
650, 222, 1934,
651, 223, 1935,
652, 224, 1936,
653, 225, 1937,
654, 226, 1938,
655, 227, 1939,
656, 228, 1940,
657, 229, 1941,
658, 230, 1942,
659, 231, 1943,
660, 232, 1944,
661, 233, 1945,
662, 234, 1946,
663, 235, 1947,
664, 236, 1948,
665, 237, 1949,
666, 238, 1950,
667, 239, 1951,
668, 240, 1952,
669, 241, 1953,
670, 242, 1954,
671, 243, 1955,
672, 244, 1956,
673, 245, 1957,
674, 246, 1958,
675, 247, 1959,
676, 248, 1960,
677, 249, 1961,
678, 250, 1962,
679, 251, 1963,
680, 252, 1964,
681, 253, 1965,
682, 254, 1966,
683, 255, 1967,
684, 256, 1968,
685, 257, 1969,
686, 258, 1970,
687, 259, 1971,
688, 260, 1972,
689, 261, 1973,
690, 262, 1974,
691, 263, 1975,
692, 264, 1976,
693, 265, 1977,
694, 266, 1978,
695, 267, 1979,
696, 268, 1980,
697, 269, 1981,
698, 270, 1982,
699, 271, 1983,
700, 272, 1984,
701, 273, 1985,
702, 274, 1986,
703, 275, 1987,
704, 276, 1988,
705, 277, 1989,
706, 278, 1990,
707, 279, 1991,
708, 280, 1992,
709, 281, 1993,
710, 282, 1994,
711, 283, 1995,
712, 284, 1996,
713, 285, 1997,
714, 286, 1998,
715, 287, 1999,
716, 288, 2000,
717, 289, 2001,
718, 290, 2002,
719, 291, 2003,
720, 292, 2004,
721, 293, 2005,
722, 294, 2006,
723, 295, 2007,
724, 296, 2008,
725, 297, 2009,
726, 298, 2010,
727, 299, 2011,
728, 300, 2012,
729, 301, 2013,
730, 302, 2014,
731, 303, 2015,
732, 304, 2016,
733, 305, 2017,
734, 306, 2018,
735, 307, 2019,
736, 308, 2020,
737, 309, 2021,
738, 310, 2022,
739, 311, 2023,
740, 312, 2024,
741, 313, 2025,
742, 314, 2026,
743, 315, 2027,
744, 316, 2028,
745, 317, 2029,
746, 318, 2030,
747, 319, 2031,
748, 320, 2032,
749, 321, 2033,
750, 322, 2034,
751, 323, 2035,
752, 324, 2036,
753, 325, 2037,
754, 326, 2038,
755, 327, 2039,
756, 328, 2040,
757, 329, 2041,
758, 330, 2042,
759, 331, 2043,
760, 332, 2044,
761, 333, 2045,
762, 334, 2046,
763, 335, 2047,
764, 336, 1536,
765, 337, 1537,
766, 338, 1538,
767, 339, 1539,
768, 340, 1540,
769, 341, 1541,
770, 342, 1542,
771, 343, 1543,
772, 344, 1544,
773, 345, 1545,
774, 346, 1546,
775, 347, 1547,
776, 348, 1548,
777, 349, 1549,
778, 350, 1550,
779, 351, 1551,
780, 352, 1552,
781, 353, 1553,
782, 354, 1554,
783, 355, 1555,
784, 356, 1556,
785, 357, 1557,
786, 358, 1558,
787, 359, 1559,
788, 360, 1560,
789, 361, 1561,
790, 362, 1562,
791, 363, 1563,
792, 364, 1564,
793, 365, 1565,
794, 366, 1566,
795, 367, 1567,
796, 368, 1568,
797, 369, 1569,
798, 370, 1570,
799, 371, 1571,
800, 372, 1572,
801, 373, 1573,
802, 374, 1574,
803, 375, 1575,
804, 376, 1576,
805, 377, 1577,
806, 378, 1578,
807, 379, 1579,
808, 380, 1580,
809, 381, 1581,
810, 382, 1582,
811, 383, 1583,
812, 384, 1584,
813, 385, 1585,
814, 386, 1586,
815, 387, 1587,
816, 388, 1588,
817, 389, 1589,
818, 390, 1590,
819, 391, 1591,
820, 392, 1592,
821, 393, 1593,
822, 394, 1594,
823, 395, 1595,
824, 396, 1596,
825, 397, 1597,
826, 398, 1598,
827, 399, 1599,
828, 400, 1600,
829, 401, 1601,
830, 402, 1602,
831, 403, 1603,
832, 404, 1604,
833, 405, 1605,
834, 406, 1606,
835, 407, 1607,
836, 408, 1608,
837, 409, 1609,
838, 410, 1610,
839, 411, 1611,
840, 412, 1612,
841, 413, 1613,
842, 414, 1614,
843, 415, 1615,
844, 416, 1616,
845, 417, 1617,
846, 418, 1618,
847, 419, 1619,
848, 420, 1620,
849, 421, 1621,
850, 422, 1622,
851, 423, 1623,
852, 424, 1624,
853, 425, 1625,
854, 426, 1626,
855, 427, 1627,
856, 428, 1628,
857, 429, 1629,
858, 430, 1630,
859, 431, 1631,
860, 432, 1632,
861, 433, 1633,
862, 434, 1634,
863, 435, 1635,
864, 436, 1636,
865, 437, 1637,
866, 438, 1638,
867, 439, 1639,
868, 440, 1640,
869, 441, 1641,
870, 442, 1642,
871, 443, 1643,
872, 444, 1644,
873, 445, 1645,
874, 446, 1646,
875, 447, 1647,
876, 448, 1648,
877, 449, 1649,
878, 450, 1650,
879, 451, 1651,
880, 452, 1652,
881, 453, 1653,
882, 454, 1654,
883, 455, 1655,
884, 456, 1656,
885, 457, 1657,
886, 458, 1658,
887, 459, 1659,
888, 460, 1660,
889, 461, 1661,
890, 462, 1662,
891, 463, 1663,
892, 464, 1664,
893, 465, 1665,
894, 466, 1666,
895, 467, 1667,
896, 468, 1668,
897, 469, 1669,
898, 470, 1670,
899, 471, 1671,
900, 472, 1672,
901, 473, 1673,
902, 474, 1674,
903, 475, 1675,
904, 476, 1676,
905, 477, 1677,
906, 478, 1678,
907, 479, 1679,
908, 480, 1680,
909, 481, 1681,
910, 482, 1682,
911, 483, 1683,
912, 484, 1684,
913, 485, 1685,
914, 486, 1686,
915, 487, 1687,
916, 488, 1688,
917, 489, 1689,
918, 490, 1690,
919, 491, 1691,
920, 492, 1692,
921, 493, 1693,
922, 494, 1694,
923, 495, 1695,
924, 496, 1696,
925, 497, 1697,
926, 498, 1698,
927, 499, 1699,
928, 500, 1700,
929, 501, 1701,
930, 502, 1702,
931, 503, 1703,
932, 504, 1704,
933, 505, 1705,
934, 506, 1706,
935, 507, 1707,
936, 508, 1708,
937, 509, 1709,
938, 510, 1710,
939, 511, 1711,
940, 0, 1712,
941, 1, 1713,
942, 2, 1714,
943, 3, 1715,
944, 4, 1716,
945, 5, 1717,
946, 6, 1718,
947, 7, 1719,
948, 8, 1720,
949, 9, 1721,
950, 10, 1722,
951, 11, 1723,
952, 12, 1724,
953, 13, 1725,
954, 14, 1726,
955, 15, 1727,
956, 16, 1728,
957, 17, 1729,
958, 18, 1730,
959, 19, 1731,
960, 20, 1732,
961, 21, 1733,
962, 22, 1734,
963, 23, 1735,
964, 24, 1736,
965, 25, 1737,
966, 26, 1738,
967, 27, 1739,
968, 28, 1740,
969, 29, 1741,
970, 30, 1742,
971, 31, 1743,
972, 32, 1744,
973, 33, 1745,
974, 34, 1746,
975, 35, 1747,
976, 36, 1748,
977, 37, 1749,
978, 38, 1750,
979, 39, 1751,
980, 40, 1752,
981, 41, 1753,
982, 42, 1754,
983, 43, 1755,
984, 44, 1756,
985, 45, 1757,
986, 46, 1758,
987, 47, 1759,
988, 48, 1760,
989, 49, 1761,
990, 50, 1762,
991, 51, 1763,
992, 52, 1764,
993, 53, 1765,
994, 54, 1766,
995, 55, 1767,
996, 56, 1768,
997, 57, 1769,
998, 58, 1770,
999, 59, 1771,
1000, 60, 1772,
1001, 61, 1773,
1002, 62, 1774,
1003, 63, 1775,
1004, 64, 1776,
1005, 65, 1777,
1006, 66, 1778,
1007, 67, 1779,
1008, 68, 1780,
1009, 69, 1781,
1010, 70, 1782,
1011, 71, 1783,
1012, 72, 1784,
1013, 73, 1785,
1014, 74, 1786,
1015, 75, 1787,
1016, 76, 1788,
1017, 77, 1789,
1018, 78, 1790,
1019, 79, 1791,
1020, 80, 1792,
1021, 81, 1793,
1022, 82, 1794,
1023, 83, 1795,
1024, 415, 915,
1025, 416, 916,
1026, 417, 917,
1027, 418, 918,
1028, 419, 919,
1029, 420, 920,
1030, 421, 921,
1031, 422, 922,
1032, 423, 923,
1033, 424, 924,
1034, 425, 925,
1035, 426, 926,
1036, 427, 927,
1037, 428, 928,
1038, 429, 929,
1039, 430, 930,
1040, 431, 931,
1041, 432, 932,
1042, 433, 933,
1043, 434, 934,
1044, 435, 935,
1045, 436, 936,
1046, 437, 937,
1047, 438, 938,
1048, 439, 939,
1049, 440, 940,
1050, 441, 941,
1051, 442, 942,
1052, 443, 943,
1053, 444, 944,
1054, 445, 945,
1055, 446, 946,
1056, 447, 947,
1057, 448, 948,
1058, 449, 949,
1059, 450, 950,
1060, 451, 951,
1061, 452, 952,
1062, 453, 953,
1063, 454, 954,
1064, 455, 955,
1065, 456, 956,
1066, 457, 957,
1067, 458, 958,
1068, 459, 959,
1069, 460, 960,
1070, 461, 961,
1071, 462, 962,
1072, 463, 963,
1073, 464, 964,
1074, 465, 965,
1075, 466, 966,
1076, 467, 967,
1077, 468, 968,
1078, 469, 969,
1079, 470, 970,
1080, 471, 971,
1081, 472, 972,
1082, 473, 973,
1083, 474, 974,
1084, 475, 975,
1085, 476, 976,
1086, 477, 977,
1087, 478, 978,
1088, 479, 979,
1089, 480, 980,
1090, 481, 981,
1091, 482, 982,
1092, 483, 983,
1093, 484, 984,
1094, 485, 985,
1095, 486, 986,
1096, 487, 987,
1097, 488, 988,
1098, 489, 989,
1099, 490, 990,
1100, 491, 991,
1101, 492, 992,
1102, 493, 993,
1103, 494, 994,
1104, 495, 995,
1105, 496, 996,
1106, 497, 997,
1107, 498, 998,
1108, 499, 999,
1109, 500, 1000,
1110, 501, 1001,
1111, 502, 1002,
1112, 503, 1003,
1113, 504, 1004,
1114, 505, 1005,
1115, 506, 1006,
1116, 507, 1007,
1117, 508, 1008,
1118, 509, 1009,
1119, 510, 1010,
1120, 511, 1011,
1121, 0, 1012,
1122, 1, 1013,
1123, 2, 1014,
1124, 3, 1015,
1125, 4, 1016,
1126, 5, 1017,
1127, 6, 1018,
1128, 7, 1019,
1129, 8, 1020,
1130, 9, 1021,
1131, 10, 1022,
1132, 11, 1023,
1133, 12, 512,
1134, 13, 513,
1135, 14, 514,
1136, 15, 515,
1137, 16, 516,
1138, 17, 517,
1139, 18, 518,
1140, 19, 519,
1141, 20, 520,
1142, 21, 521,
1143, 22, 522,
1144, 23, 523,
1145, 24, 524,
1146, 25, 525,
1147, 26, 526,
1148, 27, 527,
1149, 28, 528,
1150, 29, 529,
1151, 30, 530,
1152, 31, 531,
1153, 32, 532,
1154, 33, 533,
1155, 34, 534,
1156, 35, 535,
1157, 36, 536,
1158, 37, 537,
1159, 38, 538,
1160, 39, 539,
1161, 40, 540,
1162, 41, 541,
1163, 42, 542,
1164, 43, 543,
1165, 44, 544,
1166, 45, 545,
1167, 46, 546,
1168, 47, 547,
1169, 48, 548,
1170, 49, 549,
1171, 50, 550,
1172, 51, 551,
1173, 52, 552,
1174, 53, 553,
1175, 54, 554,
1176, 55, 555,
1177, 56, 556,
1178, 57, 557,
1179, 58, 558,
1180, 59, 559,
1181, 60, 560,
1182, 61, 561,
1183, 62, 562,
1184, 63, 563,
1185, 64, 564,
1186, 65, 565,
1187, 66, 566,
1188, 67, 567,
1189, 68, 568,
1190, 69, 569,
1191, 70, 570,
1192, 71, 571,
1193, 72, 572,
1194, 73, 573,
1195, 74, 574,
1196, 75, 575,
1197, 76, 576,
1198, 77, 577,
1199, 78, 578,
1200, 79, 579,
1201, 80, 580,
1202, 81, 581,
1203, 82, 582,
1204, 83, 583,
1205, 84, 584,
1206, 85, 585,
1207, 86, 586,
1208, 87, 587,
1209, 88, 588,
1210, 89, 589,
1211, 90, 590,
1212, 91, 591,
1213, 92, 592,
1214, 93, 593,
1215, 94, 594,
1216, 95, 595,
1217, 96, 596,
1218, 97, 597,
1219, 98, 598,
1220, 99, 599,
1221, 100, 600,
1222, 101, 601,
1223, 102, 602,
1224, 103, 603,
1225, 104, 604,
1226, 105, 605,
1227, 106, 606,
1228, 107, 607,
1229, 108, 608,
1230, 109, 609,
1231, 110, 610,
1232, 111, 611,
1233, 112, 612,
1234, 113, 613,
1235, 114, 614,
1236, 115, 615,
1237, 116, 616,
1238, 117, 617,
1239, 118, 618,
1240, 119, 619,
1241, 120, 620,
1242, 121, 621,
1243, 122, 622,
1244, 123, 623,
1245, 124, 624,
1246, 125, 625,
1247, 126, 626,
1248, 127, 627,
1249, 128, 628,
1250, 129, 629,
1251, 130, 630,
1252, 131, 631,
1253, 132, 632,
1254, 133, 633,
1255, 134, 634,
1256, 135, 635,
1257, 136, 636,
1258, 137, 637,
1259, 138, 638,
1260, 139, 639,
1261, 140, 640,
1262, 141, 641,
1263, 142, 642,
1264, 143, 643,
1265, 144, 644,
1266, 145, 645,
1267, 146, 646,
1268, 147, 647,
1269, 148, 648,
1270, 149, 649,
1271, 150, 650,
1272, 151, 651,
1273, 152, 652,
1274, 153, 653,
1275, 154, 654,
1276, 155, 655,
1277, 156, 656,
1278, 157, 657,
1279, 158, 658,
1280, 159, 659,
1281, 160, 660,
1282, 161, 661,
1283, 162, 662,
1284, 163, 663,
1285, 164, 664,
1286, 165, 665,
1287, 166, 666,
1288, 167, 667,
1289, 168, 668,
1290, 169, 669,
1291, 170, 670,
1292, 171, 671,
1293, 172, 672,
1294, 173, 673,
1295, 174, 674,
1296, 175, 675,
1297, 176, 676,
1298, 177, 677,
1299, 178, 678,
1300, 179, 679,
1301, 180, 680,
1302, 181, 681,
1303, 182, 682,
1304, 183, 683,
1305, 184, 684,
1306, 185, 685,
1307, 186, 686,
1308, 187, 687,
1309, 188, 688,
1310, 189, 689,
1311, 190, 690,
1312, 191, 691,
1313, 192, 692,
1314, 193, 693,
1315, 194, 694,
1316, 195, 695,
1317, 196, 696,
1318, 197, 697,
1319, 198, 698,
1320, 199, 699,
1321, 200, 700,
1322, 201, 701,
1323, 202, 702,
1324, 203, 703,
1325, 204, 704,
1326, 205, 705,
1327, 206, 706,
1328, 207, 707,
1329, 208, 708,
1330, 209, 709,
1331, 210, 710,
1332, 211, 711,
1333, 212, 712,
1334, 213, 713,
1335, 214, 714,
1336, 215, 715,
1337, 216, 716,
1338, 217, 717,
1339, 218, 718,
1340, 219, 719,
1341, 220, 720,
1342, 221, 721,
1343, 222, 722,
1344, 223, 723,
1345, 224, 724,
1346, 225, 725,
1347, 226, 726,
1348, 227, 727,
1349, 228, 728,
1350, 229, 729,
1351, 230, 730,
1352, 231, 731,
1353, 232, 732,
1354, 233, 733,
1355, 234, 734,
1356, 235, 735,
1357, 236, 736,
1358, 237, 737,
1359, 238, 738,
1360, 239, 739,
1361, 240, 740,
1362, 241, 741,
1363, 242, 742,
1364, 243, 743,
1365, 244, 744,
1366, 245, 745,
1367, 246, 746,
1368, 247, 747,
1369, 248, 748,
1370, 249, 749,
1371, 250, 750,
1372, 251, 751,
1373, 252, 752,
1374, 253, 753,
1375, 254, 754,
1376, 255, 755,
1377, 256, 756,
1378, 257, 757,
1379, 258, 758,
1380, 259, 759,
1381, 260, 760,
1382, 261, 761,
1383, 262, 762,
1384, 263, 763,
1385, 264, 764,
1386, 265, 765,
1387, 266, 766,
1388, 267, 767,
1389, 268, 768,
1390, 269, 769,
1391, 270, 770,
1392, 271, 771,
1393, 272, 772,
1394, 273, 773,
1395, 274, 774,
1396, 275, 775,
1397, 276, 776,
1398, 277, 777,
1399, 278, 778,
1400, 279, 779,
1401, 280, 780,
1402, 281, 781,
1403, 282, 782,
1404, 283, 783,
1405, 284, 784,
1406, 285, 785,
1407, 286, 786,
1408, 287, 787,
1409, 288, 788,
1410, 289, 789,
1411, 290, 790,
1412, 291, 791,
1413, 292, 792,
1414, 293, 793,
1415, 294, 794,
1416, 295, 795,
1417, 296, 796,
1418, 297, 797,
1419, 298, 798,
1420, 299, 799,
1421, 300, 800,
1422, 301, 801,
1423, 302, 802,
1424, 303, 803,
1425, 304, 804,
1426, 305, 805,
1427, 306, 806,
1428, 307, 807,
1429, 308, 808,
1430, 309, 809,
1431, 310, 810,
1432, 311, 811,
1433, 312, 812,
1434, 313, 813,
1435, 314, 814,
1436, 315, 815,
1437, 316, 816,
1438, 317, 817,
1439, 318, 818,
1440, 319, 819,
1441, 320, 820,
1442, 321, 821,
1443, 322, 822,
1444, 323, 823,
1445, 324, 824,
1446, 325, 825,
1447, 326, 826,
1448, 327, 827,
1449, 328, 828,
1450, 329, 829,
1451, 330, 830,
1452, 331, 831,
1453, 332, 832,
1454, 333, 833,
1455, 334, 834,
1456, 335, 835,
1457, 336, 836,
1458, 337, 837,
1459, 338, 838,
1460, 339, 839,
1461, 340, 840,
1462, 341, 841,
1463, 342, 842,
1464, 343, 843,
1465, 344, 844,
1466, 345, 845,
1467, 346, 846,
1468, 347, 847,
1469, 348, 848,
1470, 349, 849,
1471, 350, 850,
1472, 351, 851,
1473, 352, 852,
1474, 353, 853,
1475, 354, 854,
1476, 355, 855,
1477, 356, 856,
1478, 357, 857,
1479, 358, 858,
1480, 359, 859,
1481, 360, 860,
1482, 361, 861,
1483, 362, 862,
1484, 363, 863,
1485, 364, 864,
1486, 365, 865,
1487, 366, 866,
1488, 367, 867,
1489, 368, 868,
1490, 369, 869,
1491, 370, 870,
1492, 371, 871,
1493, 372, 872,
1494, 373, 873,
1495, 374, 874,
1496, 375, 875,
1497, 376, 876,
1498, 377, 877,
1499, 378, 878,
1500, 379, 879,
1501, 380, 880,
1502, 381, 881,
1503, 382, 882,
1504, 383, 883,
1505, 384, 884,
1506, 385, 885,
1507, 386, 886,
1508, 387, 887,
1509, 388, 888,
1510, 389, 889,
1511, 390, 890,
1512, 391, 891,
1513, 392, 892,
1514, 393, 893,
1515, 394, 894,
1516, 395, 895,
1517, 396, 896,
1518, 397, 897,
1519, 398, 898,
1520, 399, 899,
1521, 400, 900,
1522, 401, 901,
1523, 402, 902,
1524, 403, 903,
1525, 404, 904,
1526, 405, 905,
1527, 406, 906,
1528, 407, 907,
1529, 408, 908,
1530, 409, 909,
1531, 410, 910,
1532, 411, 911,
1533, 412, 912,
1534, 413, 913,
1535, 414, 914,
1536, 560, 1031,
1537, 561, 1032,
1538, 562, 1033,
1539, 563, 1034,
1540, 564, 1035,
1541, 565, 1036,
1542, 566, 1037,
1543, 567, 1038,
1544, 568, 1039,
1545, 569, 1040,
1546, 570, 1041,
1547, 571, 1042,
1548, 572, 1043,
1549, 573, 1044,
1550, 574, 1045,
1551, 575, 1046,
1552, 576, 1047,
1553, 577, 1048,
1554, 578, 1049,
1555, 579, 1050,
1556, 580, 1051,
1557, 581, 1052,
1558, 582, 1053,
1559, 583, 1054,
1560, 584, 1055,
1561, 585, 1056,
1562, 586, 1057,
1563, 587, 1058,
1564, 588, 1059,
1565, 589, 1060,
1566, 590, 1061,
1567, 591, 1062,
1568, 592, 1063,
1569, 593, 1064,
1570, 594, 1065,
1571, 595, 1066,
1572, 596, 1067,
1573, 597, 1068,
1574, 598, 1069,
1575, 599, 1070,
1576, 600, 1071,
1577, 601, 1072,
1578, 602, 1073,
1579, 603, 1074,
1580, 604, 1075,
1581, 605, 1076,
1582, 606, 1077,
1583, 607, 1078,
1584, 608, 1079,
1585, 609, 1080,
1586, 610, 1081,
1587, 611, 1082,
1588, 612, 1083,
1589, 613, 1084,
1590, 614, 1085,
1591, 615, 1086,
1592, 616, 1087,
1593, 617, 1088,
1594, 618, 1089,
1595, 619, 1090,
1596, 620, 1091,
1597, 621, 1092,
1598, 622, 1093,
1599, 623, 1094,
1600, 624, 1095,
1601, 625, 1096,
1602, 626, 1097,
1603, 627, 1098,
1604, 628, 1099,
1605, 629, 1100,
1606, 630, 1101,
1607, 631, 1102,
1608, 632, 1103,
1609, 633, 1104,
1610, 634, 1105,
1611, 635, 1106,
1612, 636, 1107,
1613, 637, 1108,
1614, 638, 1109,
1615, 639, 1110,
1616, 640, 1111,
1617, 641, 1112,
1618, 642, 1113,
1619, 643, 1114,
1620, 644, 1115,
1621, 645, 1116,
1622, 646, 1117,
1623, 647, 1118,
1624, 648, 1119,
1625, 649, 1120,
1626, 650, 1121,
1627, 651, 1122,
1628, 652, 1123,
1629, 653, 1124,
1630, 654, 1125,
1631, 655, 1126,
1632, 656, 1127,
1633, 657, 1128,
1634, 658, 1129,
1635, 659, 1130,
1636, 660, 1131,
1637, 661, 1132,
1638, 662, 1133,
1639, 663, 1134,
1640, 664, 1135,
1641, 665, 1136,
1642, 666, 1137,
1643, 667, 1138,
1644, 668, 1139,
1645, 669, 1140,
1646, 670, 1141,
1647, 671, 1142,
1648, 672, 1143,
1649, 673, 1144,
1650, 674, 1145,
1651, 675, 1146,
1652, 676, 1147,
1653, 677, 1148,
1654, 678, 1149,
1655, 679, 1150,
1656, 680, 1151,
1657, 681, 1152,
1658, 682, 1153,
1659, 683, 1154,
1660, 684, 1155,
1661, 685, 1156,
1662, 686, 1157,
1663, 687, 1158,
1664, 688, 1159,
1665, 689, 1160,
1666, 690, 1161,
1667, 691, 1162,
1668, 692, 1163,
1669, 693, 1164,
1670, 694, 1165,
1671, 695, 1166,
1672, 696, 1167,
1673, 697, 1168,
1674, 698, 1169,
1675, 699, 1170,
1676, 700, 1171,
1677, 701, 1172,
1678, 702, 1173,
1679, 703, 1174,
1680, 704, 1175,
1681, 705, 1176,
1682, 706, 1177,
1683, 707, 1178,
1684, 708, 1179,
1685, 709, 1180,
1686, 710, 1181,
1687, 711, 1182,
1688, 712, 1183,
1689, 713, 1184,
1690, 714, 1185,
1691, 715, 1186,
1692, 716, 1187,
1693, 717, 1188,
1694, 718, 1189,
1695, 719, 1190,
1696, 720, 1191,
1697, 721, 1192,
1698, 722, 1193,
1699, 723, 1194,
1700, 724, 1195,
1701, 725, 1196,
1702, 726, 1197,
1703, 727, 1198,
1704, 728, 1199,
1705, 729, 1200,
1706, 730, 1201,
1707, 731, 1202,
1708, 732, 1203,
1709, 733, 1204,
1710, 734, 1205,
1711, 735, 1206,
1712, 736, 1207,
1713, 737, 1208,
1714, 738, 1209,
1715, 739, 1210,
1716, 740, 1211,
1717, 741, 1212,
1718, 742, 1213,
1719, 743, 1214,
1720, 744, 1215,
1721, 745, 1216,
1722, 746, 1217,
1723, 747, 1218,
1724, 748, 1219,
1725, 749, 1220,
1726, 750, 1221,
1727, 751, 1222,
1728, 752, 1223,
1729, 753, 1224,
1730, 754, 1225,
1731, 755, 1226,
1732, 756, 1227,
1733, 757, 1228,
1734, 758, 1229,
1735, 759, 1230,
1736, 760, 1231,
1737, 761, 1232,
1738, 762, 1233,
1739, 763, 1234,
1740, 764, 1235,
1741, 765, 1236,
1742, 766, 1237,
1743, 767, 1238,
1744, 768, 1239,
1745, 769, 1240,
1746, 770, 1241,
1747, 771, 1242,
1748, 772, 1243,
1749, 773, 1244,
1750, 774, 1245,
1751, 775, 1246,
1752, 776, 1247,
1753, 777, 1248,
1754, 778, 1249,
1755, 779, 1250,
1756, 780, 1251,
1757, 781, 1252,
1758, 782, 1253,
1759, 783, 1254,
1760, 784, 1255,
1761, 785, 1256,
1762, 786, 1257,
1763, 787, 1258,
1764, 788, 1259,
1765, 789, 1260,
1766, 790, 1261,
1767, 791, 1262,
1768, 792, 1263,
1769, 793, 1264,
1770, 794, 1265,
1771, 795, 1266,
1772, 796, 1267,
1773, 797, 1268,
1774, 798, 1269,
1775, 799, 1270,
1776, 800, 1271,
1777, 801, 1272,
1778, 802, 1273,
1779, 803, 1274,
1780, 804, 1275,
1781, 805, 1276,
1782, 806, 1277,
1783, 807, 1278,
1784, 808, 1279,
1785, 809, 1280,
1786, 810, 1281,
1787, 811, 1282,
1788, 812, 1283,
1789, 813, 1284,
1790, 814, 1285,
1791, 815, 1286,
1792, 816, 1287,
1793, 817, 1288,
1794, 818, 1289,
1795, 819, 1290,
1796, 820, 1291,
1797, 821, 1292,
1798, 822, 1293,
1799, 823, 1294,
1800, 824, 1295,
1801, 825, 1296,
1802, 826, 1297,
1803, 827, 1298,
1804, 828, 1299,
1805, 829, 1300,
1806, 830, 1301,
1807, 831, 1302,
1808, 832, 1303,
1809, 833, 1304,
1810, 834, 1305,
1811, 835, 1306,
1812, 836, 1307,
1813, 837, 1308,
1814, 838, 1309,
1815, 839, 1310,
1816, 840, 1311,
1817, 841, 1312,
1818, 842, 1313,
1819, 843, 1314,
1820, 844, 1315,
1821, 845, 1316,
1822, 846, 1317,
1823, 847, 1318,
1824, 848, 1319,
1825, 849, 1320,
1826, 850, 1321,
1827, 851, 1322,
1828, 852, 1323,
1829, 853, 1324,
1830, 854, 1325,
1831, 855, 1326,
1832, 856, 1327,
1833, 857, 1328,
1834, 858, 1329,
1835, 859, 1330,
1836, 860, 1331,
1837, 861, 1332,
1838, 862, 1333,
1839, 863, 1334,
1840, 864, 1335,
1841, 865, 1336,
1842, 866, 1337,
1843, 867, 1338,
1844, 868, 1339,
1845, 869, 1340,
1846, 870, 1341,
1847, 871, 1342,
1848, 872, 1343,
1849, 873, 1344,
1850, 874, 1345,
1851, 875, 1346,
1852, 876, 1347,
1853, 877, 1348,
1854, 878, 1349,
1855, 879, 1350,
1856, 880, 1351,
1857, 881, 1352,
1858, 882, 1353,
1859, 883, 1354,
1860, 884, 1355,
1861, 885, 1356,
1862, 886, 1357,
1863, 887, 1358,
1864, 888, 1359,
1865, 889, 1360,
1866, 890, 1361,
1867, 891, 1362,
1868, 892, 1363,
1869, 893, 1364,
1870, 894, 1365,
1871, 895, 1366,
1872, 896, 1367,
1873, 897, 1368,
1874, 898, 1369,
1875, 899, 1370,
1876, 900, 1371,
1877, 901, 1372,
1878, 902, 1373,
1879, 903, 1374,
1880, 904, 1375,
1881, 905, 1376,
1882, 906, 1377,
1883, 907, 1378,
1884, 908, 1379,
1885, 909, 1380,
1886, 910, 1381,
1887, 911, 1382,
1888, 912, 1383,
1889, 913, 1384,
1890, 914, 1385,
1891, 915, 1386,
1892, 916, 1387,
1893, 917, 1388,
1894, 918, 1389,
1895, 919, 1390,
1896, 920, 1391,
1897, 921, 1392,
1898, 922, 1393,
1899, 923, 1394,
1900, 924, 1395,
1901, 925, 1396,
1902, 926, 1397,
1903, 927, 1398,
1904, 928, 1399,
1905, 929, 1400,
1906, 930, 1401,
1907, 931, 1402,
1908, 932, 1403,
1909, 933, 1404,
1910, 934, 1405,
1911, 935, 1406,
1912, 936, 1407,
1913, 937, 1408,
1914, 938, 1409,
1915, 939, 1410,
1916, 940, 1411,
1917, 941, 1412,
1918, 942, 1413,
1919, 943, 1414,
1920, 944, 1415,
1921, 945, 1416,
1922, 946, 1417,
1923, 947, 1418,
1924, 948, 1419,
1925, 949, 1420,
1926, 950, 1421,
1927, 951, 1422,
1928, 952, 1423,
1929, 953, 1424,
1930, 954, 1425,
1931, 955, 1426,
1932, 956, 1427,
1933, 957, 1428,
1934, 958, 1429,
1935, 959, 1430,
1936, 960, 1431,
1937, 961, 1432,
1938, 962, 1433,
1939, 963, 1434,
1940, 964, 1435,
1941, 965, 1436,
1942, 966, 1437,
1943, 967, 1438,
1944, 968, 1439,
1945, 969, 1440,
1946, 970, 1441,
1947, 971, 1442,
1948, 972, 1443,
1949, 973, 1444,
1950, 974, 1445,
1951, 975, 1446,
1952, 976, 1447,
1953, 977, 1448,
1954, 978, 1449,
1955, 979, 1450,
1956, 980, 1451,
1957, 981, 1452,
1958, 982, 1453,
1959, 983, 1454,
1960, 984, 1455,
1961, 985, 1456,
1962, 986, 1457,
1963, 987, 1458,
1964, 988, 1459,
1965, 989, 1460,
1966, 990, 1461,
1967, 991, 1462,
1968, 992, 1463,
1969, 993, 1464,
1970, 994, 1465,
1971, 995, 1466,
1972, 996, 1467,
1973, 997, 1468,
1974, 998, 1469,
1975, 999, 1470,
1976, 1000, 1471,
1977, 1001, 1472,
1978, 1002, 1473,
1979, 1003, 1474,
1980, 1004, 1475,
1981, 1005, 1476,
1982, 1006, 1477,
1983, 1007, 1478,
1984, 1008, 1479,
1985, 1009, 1480,
1986, 1010, 1481,
1987, 1011, 1482,
1988, 1012, 1483,
1989, 1013, 1484,
1990, 1014, 1485,
1991, 1015, 1486,
1992, 1016, 1487,
1993, 1017, 1488,
1994, 1018, 1489,
1995, 1019, 1490,
1996, 1020, 1491,
1997, 1021, 1492,
1998, 1022, 1493,
1999, 1023, 1494,
2000, 512, 1495,
2001, 513, 1496,
2002, 514, 1497,
2003, 515, 1498,
2004, 516, 1499,
2005, 517, 1500,
2006, 518, 1501,
2007, 519, 1502,
2008, 520, 1503,
2009, 521, 1504,
2010, 522, 1505,
2011, 523, 1506,
2012, 524, 1507,
2013, 525, 1508,
2014, 526, 1509,
2015, 527, 1510,
2016, 528, 1511,
2017, 529, 1512,
2018, 530, 1513,
2019, 531, 1514,
2020, 532, 1515,
2021, 533, 1516,
2022, 534, 1517,
2023, 535, 1518,
2024, 536, 1519,
2025, 537, 1520,
2026, 538, 1521,
2027, 539, 1522,
2028, 540, 1523,
2029, 541, 1524,
2030, 542, 1525,
2031, 543, 1526,
2032, 544, 1527,
2033, 545, 1528,
2034, 546, 1529,
2035, 547, 1530,
2036, 548, 1531,
2037, 549, 1532,
2038, 550, 1533,
2039, 551, 1534,
2040, 552, 1535,
2041, 553, 1024,
2042, 554, 1025,
2043, 555, 1026,
2044, 556, 1027,
2045, 557, 1028,
2046, 558, 1029,
2047, 559, 1030
 };
#pragma line 268 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_1_2_2_trichk.h" 1
vars_3_12 varinx6A_4096_b[] = {
126, 750, 1505,
127, 751, 1506,
128, 752, 1507,
129, 753, 1508,
130, 754, 1509,
131, 755, 1510,
132, 756, 1511,
133, 757, 1512,
134, 758, 1513,
135, 759, 1514,
136, 760, 1515,
137, 761, 1516,
138, 762, 1517,
139, 763, 1518,
140, 764, 1519,
141, 765, 1520,
142, 766, 1521,
143, 767, 1522,
144, 768, 1523,
145, 769, 1524,
146, 770, 1525,
147, 771, 1526,
148, 772, 1527,
149, 773, 1528,
150, 774, 1529,
151, 775, 1530,
152, 776, 1531,
153, 777, 1532,
154, 778, 1533,
155, 779, 1534,
156, 780, 1535,
157, 781, 1024,
158, 782, 1025,
159, 783, 1026,
160, 784, 1027,
161, 785, 1028,
162, 786, 1029,
163, 787, 1030,
164, 788, 1031,
165, 789, 1032,
166, 790, 1033,
167, 791, 1034,
168, 792, 1035,
169, 793, 1036,
170, 794, 1037,
171, 795, 1038,
172, 796, 1039,
173, 797, 1040,
174, 798, 1041,
175, 799, 1042,
176, 800, 1043,
177, 801, 1044,
178, 802, 1045,
179, 803, 1046,
180, 804, 1047,
181, 805, 1048,
182, 806, 1049,
183, 807, 1050,
184, 808, 1051,
185, 809, 1052,
186, 810, 1053,
187, 811, 1054,
188, 812, 1055,
189, 813, 1056,
190, 814, 1057,
191, 815, 1058,
192, 816, 1059,
193, 817, 1060,
194, 818, 1061,
195, 819, 1062,
196, 820, 1063,
197, 821, 1064,
198, 822, 1065,
199, 823, 1066,
200, 824, 1067,
201, 825, 1068,
202, 826, 1069,
203, 827, 1070,
204, 828, 1071,
205, 829, 1072,
206, 830, 1073,
207, 831, 1074,
208, 832, 1075,
209, 833, 1076,
210, 834, 1077,
211, 835, 1078,
212, 836, 1079,
213, 837, 1080,
214, 838, 1081,
215, 839, 1082,
216, 840, 1083,
217, 841, 1084,
218, 842, 1085,
219, 843, 1086,
220, 844, 1087,
221, 845, 1088,
222, 846, 1089,
223, 847, 1090,
224, 848, 1091,
225, 849, 1092,
226, 850, 1093,
227, 851, 1094,
228, 852, 1095,
229, 853, 1096,
230, 854, 1097,
231, 855, 1098,
232, 856, 1099,
233, 857, 1100,
234, 858, 1101,
235, 859, 1102,
236, 860, 1103,
237, 861, 1104,
238, 862, 1105,
239, 863, 1106,
240, 864, 1107,
241, 865, 1108,
242, 866, 1109,
243, 867, 1110,
244, 868, 1111,
245, 869, 1112,
246, 870, 1113,
247, 871, 1114,
248, 872, 1115,
249, 873, 1116,
250, 874, 1117,
251, 875, 1118,
252, 876, 1119,
253, 877, 1120,
254, 878, 1121,
255, 879, 1122,
256, 880, 1123,
257, 881, 1124,
258, 882, 1125,
259, 883, 1126,
260, 884, 1127,
261, 885, 1128,
262, 886, 1129,
263, 887, 1130,
264, 888, 1131,
265, 889, 1132,
266, 890, 1133,
267, 891, 1134,
268, 892, 1135,
269, 893, 1136,
270, 894, 1137,
271, 895, 1138,
272, 896, 1139,
273, 897, 1140,
274, 898, 1141,
275, 899, 1142,
276, 900, 1143,
277, 901, 1144,
278, 902, 1145,
279, 903, 1146,
280, 904, 1147,
281, 905, 1148,
282, 906, 1149,
283, 907, 1150,
284, 908, 1151,
285, 909, 1152,
286, 910, 1153,
287, 911, 1154,
288, 912, 1155,
289, 913, 1156,
290, 914, 1157,
291, 915, 1158,
292, 916, 1159,
293, 917, 1160,
294, 918, 1161,
295, 919, 1162,
296, 920, 1163,
297, 921, 1164,
298, 922, 1165,
299, 923, 1166,
300, 924, 1167,
301, 925, 1168,
302, 926, 1169,
303, 927, 1170,
304, 928, 1171,
305, 929, 1172,
306, 930, 1173,
307, 931, 1174,
308, 932, 1175,
309, 933, 1176,
310, 934, 1177,
311, 935, 1178,
312, 936, 1179,
313, 937, 1180,
314, 938, 1181,
315, 939, 1182,
316, 940, 1183,
317, 941, 1184,
318, 942, 1185,
319, 943, 1186,
320, 944, 1187,
321, 945, 1188,
322, 946, 1189,
323, 947, 1190,
324, 948, 1191,
325, 949, 1192,
326, 950, 1193,
327, 951, 1194,
328, 952, 1195,
329, 953, 1196,
330, 954, 1197,
331, 955, 1198,
332, 956, 1199,
333, 957, 1200,
334, 958, 1201,
335, 959, 1202,
336, 960, 1203,
337, 961, 1204,
338, 962, 1205,
339, 963, 1206,
340, 964, 1207,
341, 965, 1208,
342, 966, 1209,
343, 967, 1210,
344, 968, 1211,
345, 969, 1212,
346, 970, 1213,
347, 971, 1214,
348, 972, 1215,
349, 973, 1216,
350, 974, 1217,
351, 975, 1218,
352, 976, 1219,
353, 977, 1220,
354, 978, 1221,
355, 979, 1222,
356, 980, 1223,
357, 981, 1224,
358, 982, 1225,
359, 983, 1226,
360, 984, 1227,
361, 985, 1228,
362, 986, 1229,
363, 987, 1230,
364, 988, 1231,
365, 989, 1232,
366, 990, 1233,
367, 991, 1234,
368, 992, 1235,
369, 993, 1236,
370, 994, 1237,
371, 995, 1238,
372, 996, 1239,
373, 997, 1240,
374, 998, 1241,
375, 999, 1242,
376, 1000, 1243,
377, 1001, 1244,
378, 1002, 1245,
379, 1003, 1246,
380, 1004, 1247,
381, 1005, 1248,
382, 1006, 1249,
383, 1007, 1250,
384, 1008, 1251,
385, 1009, 1252,
386, 1010, 1253,
387, 1011, 1254,
388, 1012, 1255,
389, 1013, 1256,
390, 1014, 1257,
391, 1015, 1258,
392, 1016, 1259,
393, 1017, 1260,
394, 1018, 1261,
395, 1019, 1262,
396, 1020, 1263,
397, 1021, 1264,
398, 1022, 1265,
399, 1023, 1266,
400, 512, 1267,
401, 513, 1268,
402, 514, 1269,
403, 515, 1270,
404, 516, 1271,
405, 517, 1272,
406, 518, 1273,
407, 519, 1274,
408, 520, 1275,
409, 521, 1276,
410, 522, 1277,
411, 523, 1278,
412, 524, 1279,
413, 525, 1280,
414, 526, 1281,
415, 527, 1282,
416, 528, 1283,
417, 529, 1284,
418, 530, 1285,
419, 531, 1286,
420, 532, 1287,
421, 533, 1288,
422, 534, 1289,
423, 535, 1290,
424, 536, 1291,
425, 537, 1292,
426, 538, 1293,
427, 539, 1294,
428, 540, 1295,
429, 541, 1296,
430, 542, 1297,
431, 543, 1298,
432, 544, 1299,
433, 545, 1300,
434, 546, 1301,
435, 547, 1302,
436, 548, 1303,
437, 549, 1304,
438, 550, 1305,
439, 551, 1306,
440, 552, 1307,
441, 553, 1308,
442, 554, 1309,
443, 555, 1310,
444, 556, 1311,
445, 557, 1312,
446, 558, 1313,
447, 559, 1314,
448, 560, 1315,
449, 561, 1316,
450, 562, 1317,
451, 563, 1318,
452, 564, 1319,
453, 565, 1320,
454, 566, 1321,
455, 567, 1322,
456, 568, 1323,
457, 569, 1324,
458, 570, 1325,
459, 571, 1326,
460, 572, 1327,
461, 573, 1328,
462, 574, 1329,
463, 575, 1330,
464, 576, 1331,
465, 577, 1332,
466, 578, 1333,
467, 579, 1334,
468, 580, 1335,
469, 581, 1336,
470, 582, 1337,
471, 583, 1338,
472, 584, 1339,
473, 585, 1340,
474, 586, 1341,
475, 587, 1342,
476, 588, 1343,
477, 589, 1344,
478, 590, 1345,
479, 591, 1346,
480, 592, 1347,
481, 593, 1348,
482, 594, 1349,
483, 595, 1350,
484, 596, 1351,
485, 597, 1352,
486, 598, 1353,
487, 599, 1354,
488, 600, 1355,
489, 601, 1356,
490, 602, 1357,
491, 603, 1358,
492, 604, 1359,
493, 605, 1360,
494, 606, 1361,
495, 607, 1362,
496, 608, 1363,
497, 609, 1364,
498, 610, 1365,
499, 611, 1366,
500, 612, 1367,
501, 613, 1368,
502, 614, 1369,
503, 615, 1370,
504, 616, 1371,
505, 617, 1372,
506, 618, 1373,
507, 619, 1374,
508, 620, 1375,
509, 621, 1376,
510, 622, 1377,
511, 623, 1378,
0, 624, 1379,
1, 625, 1380,
2, 626, 1381,
3, 627, 1382,
4, 628, 1383,
5, 629, 1384,
6, 630, 1385,
7, 631, 1386,
8, 632, 1387,
9, 633, 1388,
10, 634, 1389,
11, 635, 1390,
12, 636, 1391,
13, 637, 1392,
14, 638, 1393,
15, 639, 1394,
16, 640, 1395,
17, 641, 1396,
18, 642, 1397,
19, 643, 1398,
20, 644, 1399,
21, 645, 1400,
22, 646, 1401,
23, 647, 1402,
24, 648, 1403,
25, 649, 1404,
26, 650, 1405,
27, 651, 1406,
28, 652, 1407,
29, 653, 1408,
30, 654, 1409,
31, 655, 1410,
32, 656, 1411,
33, 657, 1412,
34, 658, 1413,
35, 659, 1414,
36, 660, 1415,
37, 661, 1416,
38, 662, 1417,
39, 663, 1418,
40, 664, 1419,
41, 665, 1420,
42, 666, 1421,
43, 667, 1422,
44, 668, 1423,
45, 669, 1424,
46, 670, 1425,
47, 671, 1426,
48, 672, 1427,
49, 673, 1428,
50, 674, 1429,
51, 675, 1430,
52, 676, 1431,
53, 677, 1432,
54, 678, 1433,
55, 679, 1434,
56, 680, 1435,
57, 681, 1436,
58, 682, 1437,
59, 683, 1438,
60, 684, 1439,
61, 685, 1440,
62, 686, 1441,
63, 687, 1442,
64, 688, 1443,
65, 689, 1444,
66, 690, 1445,
67, 691, 1446,
68, 692, 1447,
69, 693, 1448,
70, 694, 1449,
71, 695, 1450,
72, 696, 1451,
73, 697, 1452,
74, 698, 1453,
75, 699, 1454,
76, 700, 1455,
77, 701, 1456,
78, 702, 1457,
79, 703, 1458,
80, 704, 1459,
81, 705, 1460,
82, 706, 1461,
83, 707, 1462,
84, 708, 1463,
85, 709, 1464,
86, 710, 1465,
87, 711, 1466,
88, 712, 1467,
89, 713, 1468,
90, 714, 1469,
91, 715, 1470,
92, 716, 1471,
93, 717, 1472,
94, 718, 1473,
95, 719, 1474,
96, 720, 1475,
97, 721, 1476,
98, 722, 1477,
99, 723, 1478,
100, 724, 1479,
101, 725, 1480,
102, 726, 1481,
103, 727, 1482,
104, 728, 1483,
105, 729, 1484,
106, 730, 1485,
107, 731, 1486,
108, 732, 1487,
109, 733, 1488,
110, 734, 1489,
111, 735, 1490,
112, 736, 1491,
113, 737, 1492,
114, 738, 1493,
115, 739, 1494,
116, 740, 1495,
117, 741, 1496,
118, 742, 1497,
119, 743, 1498,
120, 744, 1499,
121, 745, 1500,
122, 746, 1501,
123, 747, 1502,
124, 748, 1503,
125, 749, 1504,
887, 1460, 1886,
888, 1461, 1887,
889, 1462, 1888,
890, 1463, 1889,
891, 1464, 1890,
892, 1465, 1891,
893, 1466, 1892,
894, 1467, 1893,
895, 1468, 1894,
896, 1469, 1895,
897, 1470, 1896,
898, 1471, 1897,
899, 1472, 1898,
900, 1473, 1899,
901, 1474, 1900,
902, 1475, 1901,
903, 1476, 1902,
904, 1477, 1903,
905, 1478, 1904,
906, 1479, 1905,
907, 1480, 1906,
908, 1481, 1907,
909, 1482, 1908,
910, 1483, 1909,
911, 1484, 1910,
912, 1485, 1911,
913, 1486, 1912,
914, 1487, 1913,
915, 1488, 1914,
916, 1489, 1915,
917, 1490, 1916,
918, 1491, 1917,
919, 1492, 1918,
920, 1493, 1919,
921, 1494, 1920,
922, 1495, 1921,
923, 1496, 1922,
924, 1497, 1923,
925, 1498, 1924,
926, 1499, 1925,
927, 1500, 1926,
928, 1501, 1927,
929, 1502, 1928,
930, 1503, 1929,
931, 1504, 1930,
932, 1505, 1931,
933, 1506, 1932,
934, 1507, 1933,
935, 1508, 1934,
936, 1509, 1935,
937, 1510, 1936,
938, 1511, 1937,
939, 1512, 1938,
940, 1513, 1939,
941, 1514, 1940,
942, 1515, 1941,
943, 1516, 1942,
944, 1517, 1943,
945, 1518, 1944,
946, 1519, 1945,
947, 1520, 1946,
948, 1521, 1947,
949, 1522, 1948,
950, 1523, 1949,
951, 1524, 1950,
952, 1525, 1951,
953, 1526, 1952,
954, 1527, 1953,
955, 1528, 1954,
956, 1529, 1955,
957, 1530, 1956,
958, 1531, 1957,
959, 1532, 1958,
960, 1533, 1959,
961, 1534, 1960,
962, 1535, 1961,
963, 1024, 1962,
964, 1025, 1963,
965, 1026, 1964,
966, 1027, 1965,
967, 1028, 1966,
968, 1029, 1967,
969, 1030, 1968,
970, 1031, 1969,
971, 1032, 1970,
972, 1033, 1971,
973, 1034, 1972,
974, 1035, 1973,
975, 1036, 1974,
976, 1037, 1975,
977, 1038, 1976,
978, 1039, 1977,
979, 1040, 1978,
980, 1041, 1979,
981, 1042, 1980,
982, 1043, 1981,
983, 1044, 1982,
984, 1045, 1983,
985, 1046, 1984,
986, 1047, 1985,
987, 1048, 1986,
988, 1049, 1987,
989, 1050, 1988,
990, 1051, 1989,
991, 1052, 1990,
992, 1053, 1991,
993, 1054, 1992,
994, 1055, 1993,
995, 1056, 1994,
996, 1057, 1995,
997, 1058, 1996,
998, 1059, 1997,
999, 1060, 1998,
1000, 1061, 1999,
1001, 1062, 2000,
1002, 1063, 2001,
1003, 1064, 2002,
1004, 1065, 2003,
1005, 1066, 2004,
1006, 1067, 2005,
1007, 1068, 2006,
1008, 1069, 2007,
1009, 1070, 2008,
1010, 1071, 2009,
1011, 1072, 2010,
1012, 1073, 2011,
1013, 1074, 2012,
1014, 1075, 2013,
1015, 1076, 2014,
1016, 1077, 2015,
1017, 1078, 2016,
1018, 1079, 2017,
1019, 1080, 2018,
1020, 1081, 2019,
1021, 1082, 2020,
1022, 1083, 2021,
1023, 1084, 2022,
512, 1085, 2023,
513, 1086, 2024,
514, 1087, 2025,
515, 1088, 2026,
516, 1089, 2027,
517, 1090, 2028,
518, 1091, 2029,
519, 1092, 2030,
520, 1093, 2031,
521, 1094, 2032,
522, 1095, 2033,
523, 1096, 2034,
524, 1097, 2035,
525, 1098, 2036,
526, 1099, 2037,
527, 1100, 2038,
528, 1101, 2039,
529, 1102, 2040,
530, 1103, 2041,
531, 1104, 2042,
532, 1105, 2043,
533, 1106, 2044,
534, 1107, 2045,
535, 1108, 2046,
536, 1109, 2047,
537, 1110, 1536,
538, 1111, 1537,
539, 1112, 1538,
540, 1113, 1539,
541, 1114, 1540,
542, 1115, 1541,
543, 1116, 1542,
544, 1117, 1543,
545, 1118, 1544,
546, 1119, 1545,
547, 1120, 1546,
548, 1121, 1547,
549, 1122, 1548,
550, 1123, 1549,
551, 1124, 1550,
552, 1125, 1551,
553, 1126, 1552,
554, 1127, 1553,
555, 1128, 1554,
556, 1129, 1555,
557, 1130, 1556,
558, 1131, 1557,
559, 1132, 1558,
560, 1133, 1559,
561, 1134, 1560,
562, 1135, 1561,
563, 1136, 1562,
564, 1137, 1563,
565, 1138, 1564,
566, 1139, 1565,
567, 1140, 1566,
568, 1141, 1567,
569, 1142, 1568,
570, 1143, 1569,
571, 1144, 1570,
572, 1145, 1571,
573, 1146, 1572,
574, 1147, 1573,
575, 1148, 1574,
576, 1149, 1575,
577, 1150, 1576,
578, 1151, 1577,
579, 1152, 1578,
580, 1153, 1579,
581, 1154, 1580,
582, 1155, 1581,
583, 1156, 1582,
584, 1157, 1583,
585, 1158, 1584,
586, 1159, 1585,
587, 1160, 1586,
588, 1161, 1587,
589, 1162, 1588,
590, 1163, 1589,
591, 1164, 1590,
592, 1165, 1591,
593, 1166, 1592,
594, 1167, 1593,
595, 1168, 1594,
596, 1169, 1595,
597, 1170, 1596,
598, 1171, 1597,
599, 1172, 1598,
600, 1173, 1599,
601, 1174, 1600,
602, 1175, 1601,
603, 1176, 1602,
604, 1177, 1603,
605, 1178, 1604,
606, 1179, 1605,
607, 1180, 1606,
608, 1181, 1607,
609, 1182, 1608,
610, 1183, 1609,
611, 1184, 1610,
612, 1185, 1611,
613, 1186, 1612,
614, 1187, 1613,
615, 1188, 1614,
616, 1189, 1615,
617, 1190, 1616,
618, 1191, 1617,
619, 1192, 1618,
620, 1193, 1619,
621, 1194, 1620,
622, 1195, 1621,
623, 1196, 1622,
624, 1197, 1623,
625, 1198, 1624,
626, 1199, 1625,
627, 1200, 1626,
628, 1201, 1627,
629, 1202, 1628,
630, 1203, 1629,
631, 1204, 1630,
632, 1205, 1631,
633, 1206, 1632,
634, 1207, 1633,
635, 1208, 1634,
636, 1209, 1635,
637, 1210, 1636,
638, 1211, 1637,
639, 1212, 1638,
640, 1213, 1639,
641, 1214, 1640,
642, 1215, 1641,
643, 1216, 1642,
644, 1217, 1643,
645, 1218, 1644,
646, 1219, 1645,
647, 1220, 1646,
648, 1221, 1647,
649, 1222, 1648,
650, 1223, 1649,
651, 1224, 1650,
652, 1225, 1651,
653, 1226, 1652,
654, 1227, 1653,
655, 1228, 1654,
656, 1229, 1655,
657, 1230, 1656,
658, 1231, 1657,
659, 1232, 1658,
660, 1233, 1659,
661, 1234, 1660,
662, 1235, 1661,
663, 1236, 1662,
664, 1237, 1663,
665, 1238, 1664,
666, 1239, 1665,
667, 1240, 1666,
668, 1241, 1667,
669, 1242, 1668,
670, 1243, 1669,
671, 1244, 1670,
672, 1245, 1671,
673, 1246, 1672,
674, 1247, 1673,
675, 1248, 1674,
676, 1249, 1675,
677, 1250, 1676,
678, 1251, 1677,
679, 1252, 1678,
680, 1253, 1679,
681, 1254, 1680,
682, 1255, 1681,
683, 1256, 1682,
684, 1257, 1683,
685, 1258, 1684,
686, 1259, 1685,
687, 1260, 1686,
688, 1261, 1687,
689, 1262, 1688,
690, 1263, 1689,
691, 1264, 1690,
692, 1265, 1691,
693, 1266, 1692,
694, 1267, 1693,
695, 1268, 1694,
696, 1269, 1695,
697, 1270, 1696,
698, 1271, 1697,
699, 1272, 1698,
700, 1273, 1699,
701, 1274, 1700,
702, 1275, 1701,
703, 1276, 1702,
704, 1277, 1703,
705, 1278, 1704,
706, 1279, 1705,
707, 1280, 1706,
708, 1281, 1707,
709, 1282, 1708,
710, 1283, 1709,
711, 1284, 1710,
712, 1285, 1711,
713, 1286, 1712,
714, 1287, 1713,
715, 1288, 1714,
716, 1289, 1715,
717, 1290, 1716,
718, 1291, 1717,
719, 1292, 1718,
720, 1293, 1719,
721, 1294, 1720,
722, 1295, 1721,
723, 1296, 1722,
724, 1297, 1723,
725, 1298, 1724,
726, 1299, 1725,
727, 1300, 1726,
728, 1301, 1727,
729, 1302, 1728,
730, 1303, 1729,
731, 1304, 1730,
732, 1305, 1731,
733, 1306, 1732,
734, 1307, 1733,
735, 1308, 1734,
736, 1309, 1735,
737, 1310, 1736,
738, 1311, 1737,
739, 1312, 1738,
740, 1313, 1739,
741, 1314, 1740,
742, 1315, 1741,
743, 1316, 1742,
744, 1317, 1743,
745, 1318, 1744,
746, 1319, 1745,
747, 1320, 1746,
748, 1321, 1747,
749, 1322, 1748,
750, 1323, 1749,
751, 1324, 1750,
752, 1325, 1751,
753, 1326, 1752,
754, 1327, 1753,
755, 1328, 1754,
756, 1329, 1755,
757, 1330, 1756,
758, 1331, 1757,
759, 1332, 1758,
760, 1333, 1759,
761, 1334, 1760,
762, 1335, 1761,
763, 1336, 1762,
764, 1337, 1763,
765, 1338, 1764,
766, 1339, 1765,
767, 1340, 1766,
768, 1341, 1767,
769, 1342, 1768,
770, 1343, 1769,
771, 1344, 1770,
772, 1345, 1771,
773, 1346, 1772,
774, 1347, 1773,
775, 1348, 1774,
776, 1349, 1775,
777, 1350, 1776,
778, 1351, 1777,
779, 1352, 1778,
780, 1353, 1779,
781, 1354, 1780,
782, 1355, 1781,
783, 1356, 1782,
784, 1357, 1783,
785, 1358, 1784,
786, 1359, 1785,
787, 1360, 1786,
788, 1361, 1787,
789, 1362, 1788,
790, 1363, 1789,
791, 1364, 1790,
792, 1365, 1791,
793, 1366, 1792,
794, 1367, 1793,
795, 1368, 1794,
796, 1369, 1795,
797, 1370, 1796,
798, 1371, 1797,
799, 1372, 1798,
800, 1373, 1799,
801, 1374, 1800,
802, 1375, 1801,
803, 1376, 1802,
804, 1377, 1803,
805, 1378, 1804,
806, 1379, 1805,
807, 1380, 1806,
808, 1381, 1807,
809, 1382, 1808,
810, 1383, 1809,
811, 1384, 1810,
812, 1385, 1811,
813, 1386, 1812,
814, 1387, 1813,
815, 1388, 1814,
816, 1389, 1815,
817, 1390, 1816,
818, 1391, 1817,
819, 1392, 1818,
820, 1393, 1819,
821, 1394, 1820,
822, 1395, 1821,
823, 1396, 1822,
824, 1397, 1823,
825, 1398, 1824,
826, 1399, 1825,
827, 1400, 1826,
828, 1401, 1827,
829, 1402, 1828,
830, 1403, 1829,
831, 1404, 1830,
832, 1405, 1831,
833, 1406, 1832,
834, 1407, 1833,
835, 1408, 1834,
836, 1409, 1835,
837, 1410, 1836,
838, 1411, 1837,
839, 1412, 1838,
840, 1413, 1839,
841, 1414, 1840,
842, 1415, 1841,
843, 1416, 1842,
844, 1417, 1843,
845, 1418, 1844,
846, 1419, 1845,
847, 1420, 1846,
848, 1421, 1847,
849, 1422, 1848,
850, 1423, 1849,
851, 1424, 1850,
852, 1425, 1851,
853, 1426, 1852,
854, 1427, 1853,
855, 1428, 1854,
856, 1429, 1855,
857, 1430, 1856,
858, 1431, 1857,
859, 1432, 1858,
860, 1433, 1859,
861, 1434, 1860,
862, 1435, 1861,
863, 1436, 1862,
864, 1437, 1863,
865, 1438, 1864,
866, 1439, 1865,
867, 1440, 1866,
868, 1441, 1867,
869, 1442, 1868,
870, 1443, 1869,
871, 1444, 1870,
872, 1445, 1871,
873, 1446, 1872,
874, 1447, 1873,
875, 1448, 1874,
876, 1449, 1875,
877, 1450, 1876,
878, 1451, 1877,
879, 1452, 1878,
880, 1453, 1879,
881, 1454, 1880,
882, 1455, 1881,
883, 1456, 1882,
884, 1457, 1883,
885, 1458, 1884,
886, 1459, 1885,
263, 1243, 1552,
264, 1244, 1553,
265, 1245, 1554,
266, 1246, 1555,
267, 1247, 1556,
268, 1248, 1557,
269, 1249, 1558,
270, 1250, 1559,
271, 1251, 1560,
272, 1252, 1561,
273, 1253, 1562,
274, 1254, 1563,
275, 1255, 1564,
276, 1256, 1565,
277, 1257, 1566,
278, 1258, 1567,
279, 1259, 1568,
280, 1260, 1569,
281, 1261, 1570,
282, 1262, 1571,
283, 1263, 1572,
284, 1264, 1573,
285, 1265, 1574,
286, 1266, 1575,
287, 1267, 1576,
288, 1268, 1577,
289, 1269, 1578,
290, 1270, 1579,
291, 1271, 1580,
292, 1272, 1581,
293, 1273, 1582,
294, 1274, 1583,
295, 1275, 1584,
296, 1276, 1585,
297, 1277, 1586,
298, 1278, 1587,
299, 1279, 1588,
300, 1280, 1589,
301, 1281, 1590,
302, 1282, 1591,
303, 1283, 1592,
304, 1284, 1593,
305, 1285, 1594,
306, 1286, 1595,
307, 1287, 1596,
308, 1288, 1597,
309, 1289, 1598,
310, 1290, 1599,
311, 1291, 1600,
312, 1292, 1601,
313, 1293, 1602,
314, 1294, 1603,
315, 1295, 1604,
316, 1296, 1605,
317, 1297, 1606,
318, 1298, 1607,
319, 1299, 1608,
320, 1300, 1609,
321, 1301, 1610,
322, 1302, 1611,
323, 1303, 1612,
324, 1304, 1613,
325, 1305, 1614,
326, 1306, 1615,
327, 1307, 1616,
328, 1308, 1617,
329, 1309, 1618,
330, 1310, 1619,
331, 1311, 1620,
332, 1312, 1621,
333, 1313, 1622,
334, 1314, 1623,
335, 1315, 1624,
336, 1316, 1625,
337, 1317, 1626,
338, 1318, 1627,
339, 1319, 1628,
340, 1320, 1629,
341, 1321, 1630,
342, 1322, 1631,
343, 1323, 1632,
344, 1324, 1633,
345, 1325, 1634,
346, 1326, 1635,
347, 1327, 1636,
348, 1328, 1637,
349, 1329, 1638,
350, 1330, 1639,
351, 1331, 1640,
352, 1332, 1641,
353, 1333, 1642,
354, 1334, 1643,
355, 1335, 1644,
356, 1336, 1645,
357, 1337, 1646,
358, 1338, 1647,
359, 1339, 1648,
360, 1340, 1649,
361, 1341, 1650,
362, 1342, 1651,
363, 1343, 1652,
364, 1344, 1653,
365, 1345, 1654,
366, 1346, 1655,
367, 1347, 1656,
368, 1348, 1657,
369, 1349, 1658,
370, 1350, 1659,
371, 1351, 1660,
372, 1352, 1661,
373, 1353, 1662,
374, 1354, 1663,
375, 1355, 1664,
376, 1356, 1665,
377, 1357, 1666,
378, 1358, 1667,
379, 1359, 1668,
380, 1360, 1669,
381, 1361, 1670,
382, 1362, 1671,
383, 1363, 1672,
384, 1364, 1673,
385, 1365, 1674,
386, 1366, 1675,
387, 1367, 1676,
388, 1368, 1677,
389, 1369, 1678,
390, 1370, 1679,
391, 1371, 1680,
392, 1372, 1681,
393, 1373, 1682,
394, 1374, 1683,
395, 1375, 1684,
396, 1376, 1685,
397, 1377, 1686,
398, 1378, 1687,
399, 1379, 1688,
400, 1380, 1689,
401, 1381, 1690,
402, 1382, 1691,
403, 1383, 1692,
404, 1384, 1693,
405, 1385, 1694,
406, 1386, 1695,
407, 1387, 1696,
408, 1388, 1697,
409, 1389, 1698,
410, 1390, 1699,
411, 1391, 1700,
412, 1392, 1701,
413, 1393, 1702,
414, 1394, 1703,
415, 1395, 1704,
416, 1396, 1705,
417, 1397, 1706,
418, 1398, 1707,
419, 1399, 1708,
420, 1400, 1709,
421, 1401, 1710,
422, 1402, 1711,
423, 1403, 1712,
424, 1404, 1713,
425, 1405, 1714,
426, 1406, 1715,
427, 1407, 1716,
428, 1408, 1717,
429, 1409, 1718,
430, 1410, 1719,
431, 1411, 1720,
432, 1412, 1721,
433, 1413, 1722,
434, 1414, 1723,
435, 1415, 1724,
436, 1416, 1725,
437, 1417, 1726,
438, 1418, 1727,
439, 1419, 1728,
440, 1420, 1729,
441, 1421, 1730,
442, 1422, 1731,
443, 1423, 1732,
444, 1424, 1733,
445, 1425, 1734,
446, 1426, 1735,
447, 1427, 1736,
448, 1428, 1737,
449, 1429, 1738,
450, 1430, 1739,
451, 1431, 1740,
452, 1432, 1741,
453, 1433, 1742,
454, 1434, 1743,
455, 1435, 1744,
456, 1436, 1745,
457, 1437, 1746,
458, 1438, 1747,
459, 1439, 1748,
460, 1440, 1749,
461, 1441, 1750,
462, 1442, 1751,
463, 1443, 1752,
464, 1444, 1753,
465, 1445, 1754,
466, 1446, 1755,
467, 1447, 1756,
468, 1448, 1757,
469, 1449, 1758,
470, 1450, 1759,
471, 1451, 1760,
472, 1452, 1761,
473, 1453, 1762,
474, 1454, 1763,
475, 1455, 1764,
476, 1456, 1765,
477, 1457, 1766,
478, 1458, 1767,
479, 1459, 1768,
480, 1460, 1769,
481, 1461, 1770,
482, 1462, 1771,
483, 1463, 1772,
484, 1464, 1773,
485, 1465, 1774,
486, 1466, 1775,
487, 1467, 1776,
488, 1468, 1777,
489, 1469, 1778,
490, 1470, 1779,
491, 1471, 1780,
492, 1472, 1781,
493, 1473, 1782,
494, 1474, 1783,
495, 1475, 1784,
496, 1476, 1785,
497, 1477, 1786,
498, 1478, 1787,
499, 1479, 1788,
500, 1480, 1789,
501, 1481, 1790,
502, 1482, 1791,
503, 1483, 1792,
504, 1484, 1793,
505, 1485, 1794,
506, 1486, 1795,
507, 1487, 1796,
508, 1488, 1797,
509, 1489, 1798,
510, 1490, 1799,
511, 1491, 1800,
0, 1492, 1801,
1, 1493, 1802,
2, 1494, 1803,
3, 1495, 1804,
4, 1496, 1805,
5, 1497, 1806,
6, 1498, 1807,
7, 1499, 1808,
8, 1500, 1809,
9, 1501, 1810,
10, 1502, 1811,
11, 1503, 1812,
12, 1504, 1813,
13, 1505, 1814,
14, 1506, 1815,
15, 1507, 1816,
16, 1508, 1817,
17, 1509, 1818,
18, 1510, 1819,
19, 1511, 1820,
20, 1512, 1821,
21, 1513, 1822,
22, 1514, 1823,
23, 1515, 1824,
24, 1516, 1825,
25, 1517, 1826,
26, 1518, 1827,
27, 1519, 1828,
28, 1520, 1829,
29, 1521, 1830,
30, 1522, 1831,
31, 1523, 1832,
32, 1524, 1833,
33, 1525, 1834,
34, 1526, 1835,
35, 1527, 1836,
36, 1528, 1837,
37, 1529, 1838,
38, 1530, 1839,
39, 1531, 1840,
40, 1532, 1841,
41, 1533, 1842,
42, 1534, 1843,
43, 1535, 1844,
44, 1024, 1845,
45, 1025, 1846,
46, 1026, 1847,
47, 1027, 1848,
48, 1028, 1849,
49, 1029, 1850,
50, 1030, 1851,
51, 1031, 1852,
52, 1032, 1853,
53, 1033, 1854,
54, 1034, 1855,
55, 1035, 1856,
56, 1036, 1857,
57, 1037, 1858,
58, 1038, 1859,
59, 1039, 1860,
60, 1040, 1861,
61, 1041, 1862,
62, 1042, 1863,
63, 1043, 1864,
64, 1044, 1865,
65, 1045, 1866,
66, 1046, 1867,
67, 1047, 1868,
68, 1048, 1869,
69, 1049, 1870,
70, 1050, 1871,
71, 1051, 1872,
72, 1052, 1873,
73, 1053, 1874,
74, 1054, 1875,
75, 1055, 1876,
76, 1056, 1877,
77, 1057, 1878,
78, 1058, 1879,
79, 1059, 1880,
80, 1060, 1881,
81, 1061, 1882,
82, 1062, 1883,
83, 1063, 1884,
84, 1064, 1885,
85, 1065, 1886,
86, 1066, 1887,
87, 1067, 1888,
88, 1068, 1889,
89, 1069, 1890,
90, 1070, 1891,
91, 1071, 1892,
92, 1072, 1893,
93, 1073, 1894,
94, 1074, 1895,
95, 1075, 1896,
96, 1076, 1897,
97, 1077, 1898,
98, 1078, 1899,
99, 1079, 1900,
100, 1080, 1901,
101, 1081, 1902,
102, 1082, 1903,
103, 1083, 1904,
104, 1084, 1905,
105, 1085, 1906,
106, 1086, 1907,
107, 1087, 1908,
108, 1088, 1909,
109, 1089, 1910,
110, 1090, 1911,
111, 1091, 1912,
112, 1092, 1913,
113, 1093, 1914,
114, 1094, 1915,
115, 1095, 1916,
116, 1096, 1917,
117, 1097, 1918,
118, 1098, 1919,
119, 1099, 1920,
120, 1100, 1921,
121, 1101, 1922,
122, 1102, 1923,
123, 1103, 1924,
124, 1104, 1925,
125, 1105, 1926,
126, 1106, 1927,
127, 1107, 1928,
128, 1108, 1929,
129, 1109, 1930,
130, 1110, 1931,
131, 1111, 1932,
132, 1112, 1933,
133, 1113, 1934,
134, 1114, 1935,
135, 1115, 1936,
136, 1116, 1937,
137, 1117, 1938,
138, 1118, 1939,
139, 1119, 1940,
140, 1120, 1941,
141, 1121, 1942,
142, 1122, 1943,
143, 1123, 1944,
144, 1124, 1945,
145, 1125, 1946,
146, 1126, 1947,
147, 1127, 1948,
148, 1128, 1949,
149, 1129, 1950,
150, 1130, 1951,
151, 1131, 1952,
152, 1132, 1953,
153, 1133, 1954,
154, 1134, 1955,
155, 1135, 1956,
156, 1136, 1957,
157, 1137, 1958,
158, 1138, 1959,
159, 1139, 1960,
160, 1140, 1961,
161, 1141, 1962,
162, 1142, 1963,
163, 1143, 1964,
164, 1144, 1965,
165, 1145, 1966,
166, 1146, 1967,
167, 1147, 1968,
168, 1148, 1969,
169, 1149, 1970,
170, 1150, 1971,
171, 1151, 1972,
172, 1152, 1973,
173, 1153, 1974,
174, 1154, 1975,
175, 1155, 1976,
176, 1156, 1977,
177, 1157, 1978,
178, 1158, 1979,
179, 1159, 1980,
180, 1160, 1981,
181, 1161, 1982,
182, 1162, 1983,
183, 1163, 1984,
184, 1164, 1985,
185, 1165, 1986,
186, 1166, 1987,
187, 1167, 1988,
188, 1168, 1989,
189, 1169, 1990,
190, 1170, 1991,
191, 1171, 1992,
192, 1172, 1993,
193, 1173, 1994,
194, 1174, 1995,
195, 1175, 1996,
196, 1176, 1997,
197, 1177, 1998,
198, 1178, 1999,
199, 1179, 2000,
200, 1180, 2001,
201, 1181, 2002,
202, 1182, 2003,
203, 1183, 2004,
204, 1184, 2005,
205, 1185, 2006,
206, 1186, 2007,
207, 1187, 2008,
208, 1188, 2009,
209, 1189, 2010,
210, 1190, 2011,
211, 1191, 2012,
212, 1192, 2013,
213, 1193, 2014,
214, 1194, 2015,
215, 1195, 2016,
216, 1196, 2017,
217, 1197, 2018,
218, 1198, 2019,
219, 1199, 2020,
220, 1200, 2021,
221, 1201, 2022,
222, 1202, 2023,
223, 1203, 2024,
224, 1204, 2025,
225, 1205, 2026,
226, 1206, 2027,
227, 1207, 2028,
228, 1208, 2029,
229, 1209, 2030,
230, 1210, 2031,
231, 1211, 2032,
232, 1212, 2033,
233, 1213, 2034,
234, 1214, 2035,
235, 1215, 2036,
236, 1216, 2037,
237, 1217, 2038,
238, 1218, 2039,
239, 1219, 2040,
240, 1220, 2041,
241, 1221, 2042,
242, 1222, 2043,
243, 1223, 2044,
244, 1224, 2045,
245, 1225, 2046,
246, 1226, 2047,
247, 1227, 1536,
248, 1228, 1537,
249, 1229, 1538,
250, 1230, 1539,
251, 1231, 1540,
252, 1232, 1541,
253, 1233, 1542,
254, 1234, 1543,
255, 1235, 1544,
256, 1236, 1545,
257, 1237, 1546,
258, 1238, 1547,
259, 1239, 1548,
260, 1240, 1549,
261, 1241, 1550,
262, 1242, 1551,
503, 900, 1848,
504, 901, 1849,
505, 902, 1850,
506, 903, 1851,
507, 904, 1852,
508, 905, 1853,
509, 906, 1854,
510, 907, 1855,
511, 908, 1856,
0, 909, 1857,
1, 910, 1858,
2, 911, 1859,
3, 912, 1860,
4, 913, 1861,
5, 914, 1862,
6, 915, 1863,
7, 916, 1864,
8, 917, 1865,
9, 918, 1866,
10, 919, 1867,
11, 920, 1868,
12, 921, 1869,
13, 922, 1870,
14, 923, 1871,
15, 924, 1872,
16, 925, 1873,
17, 926, 1874,
18, 927, 1875,
19, 928, 1876,
20, 929, 1877,
21, 930, 1878,
22, 931, 1879,
23, 932, 1880,
24, 933, 1881,
25, 934, 1882,
26, 935, 1883,
27, 936, 1884,
28, 937, 1885,
29, 938, 1886,
30, 939, 1887,
31, 940, 1888,
32, 941, 1889,
33, 942, 1890,
34, 943, 1891,
35, 944, 1892,
36, 945, 1893,
37, 946, 1894,
38, 947, 1895,
39, 948, 1896,
40, 949, 1897,
41, 950, 1898,
42, 951, 1899,
43, 952, 1900,
44, 953, 1901,
45, 954, 1902,
46, 955, 1903,
47, 956, 1904,
48, 957, 1905,
49, 958, 1906,
50, 959, 1907,
51, 960, 1908,
52, 961, 1909,
53, 962, 1910,
54, 963, 1911,
55, 964, 1912,
56, 965, 1913,
57, 966, 1914,
58, 967, 1915,
59, 968, 1916,
60, 969, 1917,
61, 970, 1918,
62, 971, 1919,
63, 972, 1920,
64, 973, 1921,
65, 974, 1922,
66, 975, 1923,
67, 976, 1924,
68, 977, 1925,
69, 978, 1926,
70, 979, 1927,
71, 980, 1928,
72, 981, 1929,
73, 982, 1930,
74, 983, 1931,
75, 984, 1932,
76, 985, 1933,
77, 986, 1934,
78, 987, 1935,
79, 988, 1936,
80, 989, 1937,
81, 990, 1938,
82, 991, 1939,
83, 992, 1940,
84, 993, 1941,
85, 994, 1942,
86, 995, 1943,
87, 996, 1944,
88, 997, 1945,
89, 998, 1946,
90, 999, 1947,
91, 1000, 1948,
92, 1001, 1949,
93, 1002, 1950,
94, 1003, 1951,
95, 1004, 1952,
96, 1005, 1953,
97, 1006, 1954,
98, 1007, 1955,
99, 1008, 1956,
100, 1009, 1957,
101, 1010, 1958,
102, 1011, 1959,
103, 1012, 1960,
104, 1013, 1961,
105, 1014, 1962,
106, 1015, 1963,
107, 1016, 1964,
108, 1017, 1965,
109, 1018, 1966,
110, 1019, 1967,
111, 1020, 1968,
112, 1021, 1969,
113, 1022, 1970,
114, 1023, 1971,
115, 512, 1972,
116, 513, 1973,
117, 514, 1974,
118, 515, 1975,
119, 516, 1976,
120, 517, 1977,
121, 518, 1978,
122, 519, 1979,
123, 520, 1980,
124, 521, 1981,
125, 522, 1982,
126, 523, 1983,
127, 524, 1984,
128, 525, 1985,
129, 526, 1986,
130, 527, 1987,
131, 528, 1988,
132, 529, 1989,
133, 530, 1990,
134, 531, 1991,
135, 532, 1992,
136, 533, 1993,
137, 534, 1994,
138, 535, 1995,
139, 536, 1996,
140, 537, 1997,
141, 538, 1998,
142, 539, 1999,
143, 540, 2000,
144, 541, 2001,
145, 542, 2002,
146, 543, 2003,
147, 544, 2004,
148, 545, 2005,
149, 546, 2006,
150, 547, 2007,
151, 548, 2008,
152, 549, 2009,
153, 550, 2010,
154, 551, 2011,
155, 552, 2012,
156, 553, 2013,
157, 554, 2014,
158, 555, 2015,
159, 556, 2016,
160, 557, 2017,
161, 558, 2018,
162, 559, 2019,
163, 560, 2020,
164, 561, 2021,
165, 562, 2022,
166, 563, 2023,
167, 564, 2024,
168, 565, 2025,
169, 566, 2026,
170, 567, 2027,
171, 568, 2028,
172, 569, 2029,
173, 570, 2030,
174, 571, 2031,
175, 572, 2032,
176, 573, 2033,
177, 574, 2034,
178, 575, 2035,
179, 576, 2036,
180, 577, 2037,
181, 578, 2038,
182, 579, 2039,
183, 580, 2040,
184, 581, 2041,
185, 582, 2042,
186, 583, 2043,
187, 584, 2044,
188, 585, 2045,
189, 586, 2046,
190, 587, 2047,
191, 588, 1536,
192, 589, 1537,
193, 590, 1538,
194, 591, 1539,
195, 592, 1540,
196, 593, 1541,
197, 594, 1542,
198, 595, 1543,
199, 596, 1544,
200, 597, 1545,
201, 598, 1546,
202, 599, 1547,
203, 600, 1548,
204, 601, 1549,
205, 602, 1550,
206, 603, 1551,
207, 604, 1552,
208, 605, 1553,
209, 606, 1554,
210, 607, 1555,
211, 608, 1556,
212, 609, 1557,
213, 610, 1558,
214, 611, 1559,
215, 612, 1560,
216, 613, 1561,
217, 614, 1562,
218, 615, 1563,
219, 616, 1564,
220, 617, 1565,
221, 618, 1566,
222, 619, 1567,
223, 620, 1568,
224, 621, 1569,
225, 622, 1570,
226, 623, 1571,
227, 624, 1572,
228, 625, 1573,
229, 626, 1574,
230, 627, 1575,
231, 628, 1576,
232, 629, 1577,
233, 630, 1578,
234, 631, 1579,
235, 632, 1580,
236, 633, 1581,
237, 634, 1582,
238, 635, 1583,
239, 636, 1584,
240, 637, 1585,
241, 638, 1586,
242, 639, 1587,
243, 640, 1588,
244, 641, 1589,
245, 642, 1590,
246, 643, 1591,
247, 644, 1592,
248, 645, 1593,
249, 646, 1594,
250, 647, 1595,
251, 648, 1596,
252, 649, 1597,
253, 650, 1598,
254, 651, 1599,
255, 652, 1600,
256, 653, 1601,
257, 654, 1602,
258, 655, 1603,
259, 656, 1604,
260, 657, 1605,
261, 658, 1606,
262, 659, 1607,
263, 660, 1608,
264, 661, 1609,
265, 662, 1610,
266, 663, 1611,
267, 664, 1612,
268, 665, 1613,
269, 666, 1614,
270, 667, 1615,
271, 668, 1616,
272, 669, 1617,
273, 670, 1618,
274, 671, 1619,
275, 672, 1620,
276, 673, 1621,
277, 674, 1622,
278, 675, 1623,
279, 676, 1624,
280, 677, 1625,
281, 678, 1626,
282, 679, 1627,
283, 680, 1628,
284, 681, 1629,
285, 682, 1630,
286, 683, 1631,
287, 684, 1632,
288, 685, 1633,
289, 686, 1634,
290, 687, 1635,
291, 688, 1636,
292, 689, 1637,
293, 690, 1638,
294, 691, 1639,
295, 692, 1640,
296, 693, 1641,
297, 694, 1642,
298, 695, 1643,
299, 696, 1644,
300, 697, 1645,
301, 698, 1646,
302, 699, 1647,
303, 700, 1648,
304, 701, 1649,
305, 702, 1650,
306, 703, 1651,
307, 704, 1652,
308, 705, 1653,
309, 706, 1654,
310, 707, 1655,
311, 708, 1656,
312, 709, 1657,
313, 710, 1658,
314, 711, 1659,
315, 712, 1660,
316, 713, 1661,
317, 714, 1662,
318, 715, 1663,
319, 716, 1664,
320, 717, 1665,
321, 718, 1666,
322, 719, 1667,
323, 720, 1668,
324, 721, 1669,
325, 722, 1670,
326, 723, 1671,
327, 724, 1672,
328, 725, 1673,
329, 726, 1674,
330, 727, 1675,
331, 728, 1676,
332, 729, 1677,
333, 730, 1678,
334, 731, 1679,
335, 732, 1680,
336, 733, 1681,
337, 734, 1682,
338, 735, 1683,
339, 736, 1684,
340, 737, 1685,
341, 738, 1686,
342, 739, 1687,
343, 740, 1688,
344, 741, 1689,
345, 742, 1690,
346, 743, 1691,
347, 744, 1692,
348, 745, 1693,
349, 746, 1694,
350, 747, 1695,
351, 748, 1696,
352, 749, 1697,
353, 750, 1698,
354, 751, 1699,
355, 752, 1700,
356, 753, 1701,
357, 754, 1702,
358, 755, 1703,
359, 756, 1704,
360, 757, 1705,
361, 758, 1706,
362, 759, 1707,
363, 760, 1708,
364, 761, 1709,
365, 762, 1710,
366, 763, 1711,
367, 764, 1712,
368, 765, 1713,
369, 766, 1714,
370, 767, 1715,
371, 768, 1716,
372, 769, 1717,
373, 770, 1718,
374, 771, 1719,
375, 772, 1720,
376, 773, 1721,
377, 774, 1722,
378, 775, 1723,
379, 776, 1724,
380, 777, 1725,
381, 778, 1726,
382, 779, 1727,
383, 780, 1728,
384, 781, 1729,
385, 782, 1730,
386, 783, 1731,
387, 784, 1732,
388, 785, 1733,
389, 786, 1734,
390, 787, 1735,
391, 788, 1736,
392, 789, 1737,
393, 790, 1738,
394, 791, 1739,
395, 792, 1740,
396, 793, 1741,
397, 794, 1742,
398, 795, 1743,
399, 796, 1744,
400, 797, 1745,
401, 798, 1746,
402, 799, 1747,
403, 800, 1748,
404, 801, 1749,
405, 802, 1750,
406, 803, 1751,
407, 804, 1752,
408, 805, 1753,
409, 806, 1754,
410, 807, 1755,
411, 808, 1756,
412, 809, 1757,
413, 810, 1758,
414, 811, 1759,
415, 812, 1760,
416, 813, 1761,
417, 814, 1762,
418, 815, 1763,
419, 816, 1764,
420, 817, 1765,
421, 818, 1766,
422, 819, 1767,
423, 820, 1768,
424, 821, 1769,
425, 822, 1770,
426, 823, 1771,
427, 824, 1772,
428, 825, 1773,
429, 826, 1774,
430, 827, 1775,
431, 828, 1776,
432, 829, 1777,
433, 830, 1778,
434, 831, 1779,
435, 832, 1780,
436, 833, 1781,
437, 834, 1782,
438, 835, 1783,
439, 836, 1784,
440, 837, 1785,
441, 838, 1786,
442, 839, 1787,
443, 840, 1788,
444, 841, 1789,
445, 842, 1790,
446, 843, 1791,
447, 844, 1792,
448, 845, 1793,
449, 846, 1794,
450, 847, 1795,
451, 848, 1796,
452, 849, 1797,
453, 850, 1798,
454, 851, 1799,
455, 852, 1800,
456, 853, 1801,
457, 854, 1802,
458, 855, 1803,
459, 856, 1804,
460, 857, 1805,
461, 858, 1806,
462, 859, 1807,
463, 860, 1808,
464, 861, 1809,
465, 862, 1810,
466, 863, 1811,
467, 864, 1812,
468, 865, 1813,
469, 866, 1814,
470, 867, 1815,
471, 868, 1816,
472, 869, 1817,
473, 870, 1818,
474, 871, 1819,
475, 872, 1820,
476, 873, 1821,
477, 874, 1822,
478, 875, 1823,
479, 876, 1824,
480, 877, 1825,
481, 878, 1826,
482, 879, 1827,
483, 880, 1828,
484, 881, 1829,
485, 882, 1830,
486, 883, 1831,
487, 884, 1832,
488, 885, 1833,
489, 886, 1834,
490, 887, 1835,
491, 888, 1836,
492, 889, 1837,
493, 890, 1838,
494, 891, 1839,
495, 892, 1840,
496, 893, 1841,
497, 894, 1842,
498, 895, 1843,
499, 896, 1844,
500, 897, 1845,
501, 898, 1846,
502, 899, 1847
 };
vars_3_12 varinx6B_4096_b[] = {
59, 737, 0,
60, 738, 1,
61, 739, 2,
62, 740, 3,
63, 741, 4,
64, 742, 5,
65, 743, 6,
66, 744, 7,
67, 745, 8,
68, 746, 9,
69, 747, 10,
70, 748, 11,
71, 749, 12,
72, 750, 13,
73, 751, 14,
74, 752, 15,
75, 753, 16,
76, 754, 17,
77, 755, 18,
78, 756, 19,
79, 757, 20,
80, 758, 21,
81, 759, 22,
82, 760, 23,
83, 761, 24,
84, 762, 25,
85, 763, 26,
86, 764, 27,
87, 765, 28,
88, 766, 29,
89, 767, 30,
90, 768, 31,
91, 769, 32,
92, 770, 33,
93, 771, 34,
94, 772, 35,
95, 773, 36,
96, 774, 37,
97, 775, 38,
98, 776, 39,
99, 777, 40,
100, 778, 41,
101, 779, 42,
102, 780, 43,
103, 781, 44,
104, 782, 45,
105, 783, 46,
106, 784, 47,
107, 785, 48,
108, 786, 49,
109, 787, 50,
110, 788, 51,
111, 789, 52,
112, 790, 53,
113, 791, 54,
114, 792, 55,
115, 793, 56,
116, 794, 57,
117, 795, 58,
118, 796, 59,
119, 797, 60,
120, 798, 61,
121, 799, 62,
122, 800, 63,
123, 801, 64,
124, 802, 65,
125, 803, 66,
126, 804, 67,
127, 805, 68,
128, 806, 69,
129, 807, 70,
130, 808, 71,
131, 809, 72,
132, 810, 73,
133, 811, 74,
134, 812, 75,
135, 813, 76,
136, 814, 77,
137, 815, 78,
138, 816, 79,
139, 817, 80,
140, 818, 81,
141, 819, 82,
142, 820, 83,
143, 821, 84,
144, 822, 85,
145, 823, 86,
146, 824, 87,
147, 825, 88,
148, 826, 89,
149, 827, 90,
150, 828, 91,
151, 829, 92,
152, 830, 93,
153, 831, 94,
154, 832, 95,
155, 833, 96,
156, 834, 97,
157, 835, 98,
158, 836, 99,
159, 837, 100,
160, 838, 101,
161, 839, 102,
162, 840, 103,
163, 841, 104,
164, 842, 105,
165, 843, 106,
166, 844, 107,
167, 845, 108,
168, 846, 109,
169, 847, 110,
170, 848, 111,
171, 849, 112,
172, 850, 113,
173, 851, 114,
174, 852, 115,
175, 853, 116,
176, 854, 117,
177, 855, 118,
178, 856, 119,
179, 857, 120,
180, 858, 121,
181, 859, 122,
182, 860, 123,
183, 861, 124,
184, 862, 125,
185, 863, 126,
186, 864, 127,
187, 865, 128,
188, 866, 129,
189, 867, 130,
190, 868, 131,
191, 869, 132,
192, 870, 133,
193, 871, 134,
194, 872, 135,
195, 873, 136,
196, 874, 137,
197, 875, 138,
198, 876, 139,
199, 877, 140,
200, 878, 141,
201, 879, 142,
202, 880, 143,
203, 881, 144,
204, 882, 145,
205, 883, 146,
206, 884, 147,
207, 885, 148,
208, 886, 149,
209, 887, 150,
210, 888, 151,
211, 889, 152,
212, 890, 153,
213, 891, 154,
214, 892, 155,
215, 893, 156,
216, 894, 157,
217, 895, 158,
218, 896, 159,
219, 897, 160,
220, 898, 161,
221, 899, 162,
222, 900, 163,
223, 901, 164,
224, 902, 165,
225, 903, 166,
226, 904, 167,
227, 905, 168,
228, 906, 169,
229, 907, 170,
230, 908, 171,
231, 909, 172,
232, 910, 173,
233, 911, 174,
234, 912, 175,
235, 913, 176,
236, 914, 177,
237, 915, 178,
238, 916, 179,
239, 917, 180,
240, 918, 181,
241, 919, 182,
242, 920, 183,
243, 921, 184,
244, 922, 185,
245, 923, 186,
246, 924, 187,
247, 925, 188,
248, 926, 189,
249, 927, 190,
250, 928, 191,
251, 929, 192,
252, 930, 193,
253, 931, 194,
254, 932, 195,
255, 933, 196,
256, 934, 197,
257, 935, 198,
258, 936, 199,
259, 937, 200,
260, 938, 201,
261, 939, 202,
262, 940, 203,
263, 941, 204,
264, 942, 205,
265, 943, 206,
266, 944, 207,
267, 945, 208,
268, 946, 209,
269, 947, 210,
270, 948, 211,
271, 949, 212,
272, 950, 213,
273, 951, 214,
274, 952, 215,
275, 953, 216,
276, 954, 217,
277, 955, 218,
278, 956, 219,
279, 957, 220,
280, 958, 221,
281, 959, 222,
282, 960, 223,
283, 961, 224,
284, 962, 225,
285, 963, 226,
286, 964, 227,
287, 965, 228,
288, 966, 229,
289, 967, 230,
290, 968, 231,
291, 969, 232,
292, 970, 233,
293, 971, 234,
294, 972, 235,
295, 973, 236,
296, 974, 237,
297, 975, 238,
298, 976, 239,
299, 977, 240,
300, 978, 241,
301, 979, 242,
302, 980, 243,
303, 981, 244,
304, 982, 245,
305, 983, 246,
306, 984, 247,
307, 985, 248,
308, 986, 249,
309, 987, 250,
310, 988, 251,
311, 989, 252,
312, 990, 253,
313, 991, 254,
314, 992, 255,
315, 993, 256,
316, 994, 257,
317, 995, 258,
318, 996, 259,
319, 997, 260,
320, 998, 261,
321, 999, 262,
322, 1000, 263,
323, 1001, 264,
324, 1002, 265,
325, 1003, 266,
326, 1004, 267,
327, 1005, 268,
328, 1006, 269,
329, 1007, 270,
330, 1008, 271,
331, 1009, 272,
332, 1010, 273,
333, 1011, 274,
334, 1012, 275,
335, 1013, 276,
336, 1014, 277,
337, 1015, 278,
338, 1016, 279,
339, 1017, 280,
340, 1018, 281,
341, 1019, 282,
342, 1020, 283,
343, 1021, 284,
344, 1022, 285,
345, 1023, 286,
346, 512, 287,
347, 513, 288,
348, 514, 289,
349, 515, 290,
350, 516, 291,
351, 517, 292,
352, 518, 293,
353, 519, 294,
354, 520, 295,
355, 521, 296,
356, 522, 297,
357, 523, 298,
358, 524, 299,
359, 525, 300,
360, 526, 301,
361, 527, 302,
362, 528, 303,
363, 529, 304,
364, 530, 305,
365, 531, 306,
366, 532, 307,
367, 533, 308,
368, 534, 309,
369, 535, 310,
370, 536, 311,
371, 537, 312,
372, 538, 313,
373, 539, 314,
374, 540, 315,
375, 541, 316,
376, 542, 317,
377, 543, 318,
378, 544, 319,
379, 545, 320,
380, 546, 321,
381, 547, 322,
382, 548, 323,
383, 549, 324,
384, 550, 325,
385, 551, 326,
386, 552, 327,
387, 553, 328,
388, 554, 329,
389, 555, 330,
390, 556, 331,
391, 557, 332,
392, 558, 333,
393, 559, 334,
394, 560, 335,
395, 561, 336,
396, 562, 337,
397, 563, 338,
398, 564, 339,
399, 565, 340,
400, 566, 341,
401, 567, 342,
402, 568, 343,
403, 569, 344,
404, 570, 345,
405, 571, 346,
406, 572, 347,
407, 573, 348,
408, 574, 349,
409, 575, 350,
410, 576, 351,
411, 577, 352,
412, 578, 353,
413, 579, 354,
414, 580, 355,
415, 581, 356,
416, 582, 357,
417, 583, 358,
418, 584, 359,
419, 585, 360,
420, 586, 361,
421, 587, 362,
422, 588, 363,
423, 589, 364,
424, 590, 365,
425, 591, 366,
426, 592, 367,
427, 593, 368,
428, 594, 369,
429, 595, 370,
430, 596, 371,
431, 597, 372,
432, 598, 373,
433, 599, 374,
434, 600, 375,
435, 601, 376,
436, 602, 377,
437, 603, 378,
438, 604, 379,
439, 605, 380,
440, 606, 381,
441, 607, 382,
442, 608, 383,
443, 609, 384,
444, 610, 385,
445, 611, 386,
446, 612, 387,
447, 613, 388,
448, 614, 389,
449, 615, 390,
450, 616, 391,
451, 617, 392,
452, 618, 393,
453, 619, 394,
454, 620, 395,
455, 621, 396,
456, 622, 397,
457, 623, 398,
458, 624, 399,
459, 625, 400,
460, 626, 401,
461, 627, 402,
462, 628, 403,
463, 629, 404,
464, 630, 405,
465, 631, 406,
466, 632, 407,
467, 633, 408,
468, 634, 409,
469, 635, 410,
470, 636, 411,
471, 637, 412,
472, 638, 413,
473, 639, 414,
474, 640, 415,
475, 641, 416,
476, 642, 417,
477, 643, 418,
478, 644, 419,
479, 645, 420,
480, 646, 421,
481, 647, 422,
482, 648, 423,
483, 649, 424,
484, 650, 425,
485, 651, 426,
486, 652, 427,
487, 653, 428,
488, 654, 429,
489, 655, 430,
490, 656, 431,
491, 657, 432,
492, 658, 433,
493, 659, 434,
494, 660, 435,
495, 661, 436,
496, 662, 437,
497, 663, 438,
498, 664, 439,
499, 665, 440,
500, 666, 441,
501, 667, 442,
502, 668, 443,
503, 669, 444,
504, 670, 445,
505, 671, 446,
506, 672, 447,
507, 673, 448,
508, 674, 449,
509, 675, 450,
510, 676, 451,
511, 677, 452,
0, 678, 453,
1, 679, 454,
2, 680, 455,
3, 681, 456,
4, 682, 457,
5, 683, 458,
6, 684, 459,
7, 685, 460,
8, 686, 461,
9, 687, 462,
10, 688, 463,
11, 689, 464,
12, 690, 465,
13, 691, 466,
14, 692, 467,
15, 693, 468,
16, 694, 469,
17, 695, 470,
18, 696, 471,
19, 697, 472,
20, 698, 473,
21, 699, 474,
22, 700, 475,
23, 701, 476,
24, 702, 477,
25, 703, 478,
26, 704, 479,
27, 705, 480,
28, 706, 481,
29, 707, 482,
30, 708, 483,
31, 709, 484,
32, 710, 485,
33, 711, 486,
34, 712, 487,
35, 713, 488,
36, 714, 489,
37, 715, 490,
38, 716, 491,
39, 717, 492,
40, 718, 493,
41, 719, 494,
42, 720, 495,
43, 721, 496,
44, 722, 497,
45, 723, 498,
46, 724, 499,
47, 725, 500,
48, 726, 501,
49, 727, 502,
50, 728, 503,
51, 729, 504,
52, 730, 505,
53, 731, 506,
54, 732, 507,
55, 733, 508,
56, 734, 509,
57, 735, 510,
58, 736, 511,
830, 1406, 512,
831, 1407, 513,
832, 1408, 514,
833, 1409, 515,
834, 1410, 516,
835, 1411, 517,
836, 1412, 518,
837, 1413, 519,
838, 1414, 520,
839, 1415, 521,
840, 1416, 522,
841, 1417, 523,
842, 1418, 524,
843, 1419, 525,
844, 1420, 526,
845, 1421, 527,
846, 1422, 528,
847, 1423, 529,
848, 1424, 530,
849, 1425, 531,
850, 1426, 532,
851, 1427, 533,
852, 1428, 534,
853, 1429, 535,
854, 1430, 536,
855, 1431, 537,
856, 1432, 538,
857, 1433, 539,
858, 1434, 540,
859, 1435, 541,
860, 1436, 542,
861, 1437, 543,
862, 1438, 544,
863, 1439, 545,
864, 1440, 546,
865, 1441, 547,
866, 1442, 548,
867, 1443, 549,
868, 1444, 550,
869, 1445, 551,
870, 1446, 552,
871, 1447, 553,
872, 1448, 554,
873, 1449, 555,
874, 1450, 556,
875, 1451, 557,
876, 1452, 558,
877, 1453, 559,
878, 1454, 560,
879, 1455, 561,
880, 1456, 562,
881, 1457, 563,
882, 1458, 564,
883, 1459, 565,
884, 1460, 566,
885, 1461, 567,
886, 1462, 568,
887, 1463, 569,
888, 1464, 570,
889, 1465, 571,
890, 1466, 572,
891, 1467, 573,
892, 1468, 574,
893, 1469, 575,
894, 1470, 576,
895, 1471, 577,
896, 1472, 578,
897, 1473, 579,
898, 1474, 580,
899, 1475, 581,
900, 1476, 582,
901, 1477, 583,
902, 1478, 584,
903, 1479, 585,
904, 1480, 586,
905, 1481, 587,
906, 1482, 588,
907, 1483, 589,
908, 1484, 590,
909, 1485, 591,
910, 1486, 592,
911, 1487, 593,
912, 1488, 594,
913, 1489, 595,
914, 1490, 596,
915, 1491, 597,
916, 1492, 598,
917, 1493, 599,
918, 1494, 600,
919, 1495, 601,
920, 1496, 602,
921, 1497, 603,
922, 1498, 604,
923, 1499, 605,
924, 1500, 606,
925, 1501, 607,
926, 1502, 608,
927, 1503, 609,
928, 1504, 610,
929, 1505, 611,
930, 1506, 612,
931, 1507, 613,
932, 1508, 614,
933, 1509, 615,
934, 1510, 616,
935, 1511, 617,
936, 1512, 618,
937, 1513, 619,
938, 1514, 620,
939, 1515, 621,
940, 1516, 622,
941, 1517, 623,
942, 1518, 624,
943, 1519, 625,
944, 1520, 626,
945, 1521, 627,
946, 1522, 628,
947, 1523, 629,
948, 1524, 630,
949, 1525, 631,
950, 1526, 632,
951, 1527, 633,
952, 1528, 634,
953, 1529, 635,
954, 1530, 636,
955, 1531, 637,
956, 1532, 638,
957, 1533, 639,
958, 1534, 640,
959, 1535, 641,
960, 1024, 642,
961, 1025, 643,
962, 1026, 644,
963, 1027, 645,
964, 1028, 646,
965, 1029, 647,
966, 1030, 648,
967, 1031, 649,
968, 1032, 650,
969, 1033, 651,
970, 1034, 652,
971, 1035, 653,
972, 1036, 654,
973, 1037, 655,
974, 1038, 656,
975, 1039, 657,
976, 1040, 658,
977, 1041, 659,
978, 1042, 660,
979, 1043, 661,
980, 1044, 662,
981, 1045, 663,
982, 1046, 664,
983, 1047, 665,
984, 1048, 666,
985, 1049, 667,
986, 1050, 668,
987, 1051, 669,
988, 1052, 670,
989, 1053, 671,
990, 1054, 672,
991, 1055, 673,
992, 1056, 674,
993, 1057, 675,
994, 1058, 676,
995, 1059, 677,
996, 1060, 678,
997, 1061, 679,
998, 1062, 680,
999, 1063, 681,
1000, 1064, 682,
1001, 1065, 683,
1002, 1066, 684,
1003, 1067, 685,
1004, 1068, 686,
1005, 1069, 687,
1006, 1070, 688,
1007, 1071, 689,
1008, 1072, 690,
1009, 1073, 691,
1010, 1074, 692,
1011, 1075, 693,
1012, 1076, 694,
1013, 1077, 695,
1014, 1078, 696,
1015, 1079, 697,
1016, 1080, 698,
1017, 1081, 699,
1018, 1082, 700,
1019, 1083, 701,
1020, 1084, 702,
1021, 1085, 703,
1022, 1086, 704,
1023, 1087, 705,
512, 1088, 706,
513, 1089, 707,
514, 1090, 708,
515, 1091, 709,
516, 1092, 710,
517, 1093, 711,
518, 1094, 712,
519, 1095, 713,
520, 1096, 714,
521, 1097, 715,
522, 1098, 716,
523, 1099, 717,
524, 1100, 718,
525, 1101, 719,
526, 1102, 720,
527, 1103, 721,
528, 1104, 722,
529, 1105, 723,
530, 1106, 724,
531, 1107, 725,
532, 1108, 726,
533, 1109, 727,
534, 1110, 728,
535, 1111, 729,
536, 1112, 730,
537, 1113, 731,
538, 1114, 732,
539, 1115, 733,
540, 1116, 734,
541, 1117, 735,
542, 1118, 736,
543, 1119, 737,
544, 1120, 738,
545, 1121, 739,
546, 1122, 740,
547, 1123, 741,
548, 1124, 742,
549, 1125, 743,
550, 1126, 744,
551, 1127, 745,
552, 1128, 746,
553, 1129, 747,
554, 1130, 748,
555, 1131, 749,
556, 1132, 750,
557, 1133, 751,
558, 1134, 752,
559, 1135, 753,
560, 1136, 754,
561, 1137, 755,
562, 1138, 756,
563, 1139, 757,
564, 1140, 758,
565, 1141, 759,
566, 1142, 760,
567, 1143, 761,
568, 1144, 762,
569, 1145, 763,
570, 1146, 764,
571, 1147, 765,
572, 1148, 766,
573, 1149, 767,
574, 1150, 768,
575, 1151, 769,
576, 1152, 770,
577, 1153, 771,
578, 1154, 772,
579, 1155, 773,
580, 1156, 774,
581, 1157, 775,
582, 1158, 776,
583, 1159, 777,
584, 1160, 778,
585, 1161, 779,
586, 1162, 780,
587, 1163, 781,
588, 1164, 782,
589, 1165, 783,
590, 1166, 784,
591, 1167, 785,
592, 1168, 786,
593, 1169, 787,
594, 1170, 788,
595, 1171, 789,
596, 1172, 790,
597, 1173, 791,
598, 1174, 792,
599, 1175, 793,
600, 1176, 794,
601, 1177, 795,
602, 1178, 796,
603, 1179, 797,
604, 1180, 798,
605, 1181, 799,
606, 1182, 800,
607, 1183, 801,
608, 1184, 802,
609, 1185, 803,
610, 1186, 804,
611, 1187, 805,
612, 1188, 806,
613, 1189, 807,
614, 1190, 808,
615, 1191, 809,
616, 1192, 810,
617, 1193, 811,
618, 1194, 812,
619, 1195, 813,
620, 1196, 814,
621, 1197, 815,
622, 1198, 816,
623, 1199, 817,
624, 1200, 818,
625, 1201, 819,
626, 1202, 820,
627, 1203, 821,
628, 1204, 822,
629, 1205, 823,
630, 1206, 824,
631, 1207, 825,
632, 1208, 826,
633, 1209, 827,
634, 1210, 828,
635, 1211, 829,
636, 1212, 830,
637, 1213, 831,
638, 1214, 832,
639, 1215, 833,
640, 1216, 834,
641, 1217, 835,
642, 1218, 836,
643, 1219, 837,
644, 1220, 838,
645, 1221, 839,
646, 1222, 840,
647, 1223, 841,
648, 1224, 842,
649, 1225, 843,
650, 1226, 844,
651, 1227, 845,
652, 1228, 846,
653, 1229, 847,
654, 1230, 848,
655, 1231, 849,
656, 1232, 850,
657, 1233, 851,
658, 1234, 852,
659, 1235, 853,
660, 1236, 854,
661, 1237, 855,
662, 1238, 856,
663, 1239, 857,
664, 1240, 858,
665, 1241, 859,
666, 1242, 860,
667, 1243, 861,
668, 1244, 862,
669, 1245, 863,
670, 1246, 864,
671, 1247, 865,
672, 1248, 866,
673, 1249, 867,
674, 1250, 868,
675, 1251, 869,
676, 1252, 870,
677, 1253, 871,
678, 1254, 872,
679, 1255, 873,
680, 1256, 874,
681, 1257, 875,
682, 1258, 876,
683, 1259, 877,
684, 1260, 878,
685, 1261, 879,
686, 1262, 880,
687, 1263, 881,
688, 1264, 882,
689, 1265, 883,
690, 1266, 884,
691, 1267, 885,
692, 1268, 886,
693, 1269, 887,
694, 1270, 888,
695, 1271, 889,
696, 1272, 890,
697, 1273, 891,
698, 1274, 892,
699, 1275, 893,
700, 1276, 894,
701, 1277, 895,
702, 1278, 896,
703, 1279, 897,
704, 1280, 898,
705, 1281, 899,
706, 1282, 900,
707, 1283, 901,
708, 1284, 902,
709, 1285, 903,
710, 1286, 904,
711, 1287, 905,
712, 1288, 906,
713, 1289, 907,
714, 1290, 908,
715, 1291, 909,
716, 1292, 910,
717, 1293, 911,
718, 1294, 912,
719, 1295, 913,
720, 1296, 914,
721, 1297, 915,
722, 1298, 916,
723, 1299, 917,
724, 1300, 918,
725, 1301, 919,
726, 1302, 920,
727, 1303, 921,
728, 1304, 922,
729, 1305, 923,
730, 1306, 924,
731, 1307, 925,
732, 1308, 926,
733, 1309, 927,
734, 1310, 928,
735, 1311, 929,
736, 1312, 930,
737, 1313, 931,
738, 1314, 932,
739, 1315, 933,
740, 1316, 934,
741, 1317, 935,
742, 1318, 936,
743, 1319, 937,
744, 1320, 938,
745, 1321, 939,
746, 1322, 940,
747, 1323, 941,
748, 1324, 942,
749, 1325, 943,
750, 1326, 944,
751, 1327, 945,
752, 1328, 946,
753, 1329, 947,
754, 1330, 948,
755, 1331, 949,
756, 1332, 950,
757, 1333, 951,
758, 1334, 952,
759, 1335, 953,
760, 1336, 954,
761, 1337, 955,
762, 1338, 956,
763, 1339, 957,
764, 1340, 958,
765, 1341, 959,
766, 1342, 960,
767, 1343, 961,
768, 1344, 962,
769, 1345, 963,
770, 1346, 964,
771, 1347, 965,
772, 1348, 966,
773, 1349, 967,
774, 1350, 968,
775, 1351, 969,
776, 1352, 970,
777, 1353, 971,
778, 1354, 972,
779, 1355, 973,
780, 1356, 974,
781, 1357, 975,
782, 1358, 976,
783, 1359, 977,
784, 1360, 978,
785, 1361, 979,
786, 1362, 980,
787, 1363, 981,
788, 1364, 982,
789, 1365, 983,
790, 1366, 984,
791, 1367, 985,
792, 1368, 986,
793, 1369, 987,
794, 1370, 988,
795, 1371, 989,
796, 1372, 990,
797, 1373, 991,
798, 1374, 992,
799, 1375, 993,
800, 1376, 994,
801, 1377, 995,
802, 1378, 996,
803, 1379, 997,
804, 1380, 998,
805, 1381, 999,
806, 1382, 1000,
807, 1383, 1001,
808, 1384, 1002,
809, 1385, 1003,
810, 1386, 1004,
811, 1387, 1005,
812, 1388, 1006,
813, 1389, 1007,
814, 1390, 1008,
815, 1391, 1009,
816, 1392, 1010,
817, 1393, 1011,
818, 1394, 1012,
819, 1395, 1013,
820, 1396, 1014,
821, 1397, 1015,
822, 1398, 1016,
823, 1399, 1017,
824, 1400, 1018,
825, 1401, 1019,
826, 1402, 1020,
827, 1403, 1021,
828, 1404, 1022,
829, 1405, 1023,
1208, 1815, 1024,
1209, 1816, 1025,
1210, 1817, 1026,
1211, 1818, 1027,
1212, 1819, 1028,
1213, 1820, 1029,
1214, 1821, 1030,
1215, 1822, 1031,
1216, 1823, 1032,
1217, 1824, 1033,
1218, 1825, 1034,
1219, 1826, 1035,
1220, 1827, 1036,
1221, 1828, 1037,
1222, 1829, 1038,
1223, 1830, 1039,
1224, 1831, 1040,
1225, 1832, 1041,
1226, 1833, 1042,
1227, 1834, 1043,
1228, 1835, 1044,
1229, 1836, 1045,
1230, 1837, 1046,
1231, 1838, 1047,
1232, 1839, 1048,
1233, 1840, 1049,
1234, 1841, 1050,
1235, 1842, 1051,
1236, 1843, 1052,
1237, 1844, 1053,
1238, 1845, 1054,
1239, 1846, 1055,
1240, 1847, 1056,
1241, 1848, 1057,
1242, 1849, 1058,
1243, 1850, 1059,
1244, 1851, 1060,
1245, 1852, 1061,
1246, 1853, 1062,
1247, 1854, 1063,
1248, 1855, 1064,
1249, 1856, 1065,
1250, 1857, 1066,
1251, 1858, 1067,
1252, 1859, 1068,
1253, 1860, 1069,
1254, 1861, 1070,
1255, 1862, 1071,
1256, 1863, 1072,
1257, 1864, 1073,
1258, 1865, 1074,
1259, 1866, 1075,
1260, 1867, 1076,
1261, 1868, 1077,
1262, 1869, 1078,
1263, 1870, 1079,
1264, 1871, 1080,
1265, 1872, 1081,
1266, 1873, 1082,
1267, 1874, 1083,
1268, 1875, 1084,
1269, 1876, 1085,
1270, 1877, 1086,
1271, 1878, 1087,
1272, 1879, 1088,
1273, 1880, 1089,
1274, 1881, 1090,
1275, 1882, 1091,
1276, 1883, 1092,
1277, 1884, 1093,
1278, 1885, 1094,
1279, 1886, 1095,
1280, 1887, 1096,
1281, 1888, 1097,
1282, 1889, 1098,
1283, 1890, 1099,
1284, 1891, 1100,
1285, 1892, 1101,
1286, 1893, 1102,
1287, 1894, 1103,
1288, 1895, 1104,
1289, 1896, 1105,
1290, 1897, 1106,
1291, 1898, 1107,
1292, 1899, 1108,
1293, 1900, 1109,
1294, 1901, 1110,
1295, 1902, 1111,
1296, 1903, 1112,
1297, 1904, 1113,
1298, 1905, 1114,
1299, 1906, 1115,
1300, 1907, 1116,
1301, 1908, 1117,
1302, 1909, 1118,
1303, 1910, 1119,
1304, 1911, 1120,
1305, 1912, 1121,
1306, 1913, 1122,
1307, 1914, 1123,
1308, 1915, 1124,
1309, 1916, 1125,
1310, 1917, 1126,
1311, 1918, 1127,
1312, 1919, 1128,
1313, 1920, 1129,
1314, 1921, 1130,
1315, 1922, 1131,
1316, 1923, 1132,
1317, 1924, 1133,
1318, 1925, 1134,
1319, 1926, 1135,
1320, 1927, 1136,
1321, 1928, 1137,
1322, 1929, 1138,
1323, 1930, 1139,
1324, 1931, 1140,
1325, 1932, 1141,
1326, 1933, 1142,
1327, 1934, 1143,
1328, 1935, 1144,
1329, 1936, 1145,
1330, 1937, 1146,
1331, 1938, 1147,
1332, 1939, 1148,
1333, 1940, 1149,
1334, 1941, 1150,
1335, 1942, 1151,
1336, 1943, 1152,
1337, 1944, 1153,
1338, 1945, 1154,
1339, 1946, 1155,
1340, 1947, 1156,
1341, 1948, 1157,
1342, 1949, 1158,
1343, 1950, 1159,
1344, 1951, 1160,
1345, 1952, 1161,
1346, 1953, 1162,
1347, 1954, 1163,
1348, 1955, 1164,
1349, 1956, 1165,
1350, 1957, 1166,
1351, 1958, 1167,
1352, 1959, 1168,
1353, 1960, 1169,
1354, 1961, 1170,
1355, 1962, 1171,
1356, 1963, 1172,
1357, 1964, 1173,
1358, 1965, 1174,
1359, 1966, 1175,
1360, 1967, 1176,
1361, 1968, 1177,
1362, 1969, 1178,
1363, 1970, 1179,
1364, 1971, 1180,
1365, 1972, 1181,
1366, 1973, 1182,
1367, 1974, 1183,
1368, 1975, 1184,
1369, 1976, 1185,
1370, 1977, 1186,
1371, 1978, 1187,
1372, 1979, 1188,
1373, 1980, 1189,
1374, 1981, 1190,
1375, 1982, 1191,
1376, 1983, 1192,
1377, 1984, 1193,
1378, 1985, 1194,
1379, 1986, 1195,
1380, 1987, 1196,
1381, 1988, 1197,
1382, 1989, 1198,
1383, 1990, 1199,
1384, 1991, 1200,
1385, 1992, 1201,
1386, 1993, 1202,
1387, 1994, 1203,
1388, 1995, 1204,
1389, 1996, 1205,
1390, 1997, 1206,
1391, 1998, 1207,
1392, 1999, 1208,
1393, 2000, 1209,
1394, 2001, 1210,
1395, 2002, 1211,
1396, 2003, 1212,
1397, 2004, 1213,
1398, 2005, 1214,
1399, 2006, 1215,
1400, 2007, 1216,
1401, 2008, 1217,
1402, 2009, 1218,
1403, 2010, 1219,
1404, 2011, 1220,
1405, 2012, 1221,
1406, 2013, 1222,
1407, 2014, 1223,
1408, 2015, 1224,
1409, 2016, 1225,
1410, 2017, 1226,
1411, 2018, 1227,
1412, 2019, 1228,
1413, 2020, 1229,
1414, 2021, 1230,
1415, 2022, 1231,
1416, 2023, 1232,
1417, 2024, 1233,
1418, 2025, 1234,
1419, 2026, 1235,
1420, 2027, 1236,
1421, 2028, 1237,
1422, 2029, 1238,
1423, 2030, 1239,
1424, 2031, 1240,
1425, 2032, 1241,
1426, 2033, 1242,
1427, 2034, 1243,
1428, 2035, 1244,
1429, 2036, 1245,
1430, 2037, 1246,
1431, 2038, 1247,
1432, 2039, 1248,
1433, 2040, 1249,
1434, 2041, 1250,
1435, 2042, 1251,
1436, 2043, 1252,
1437, 2044, 1253,
1438, 2045, 1254,
1439, 2046, 1255,
1440, 2047, 1256,
1441, 1536, 1257,
1442, 1537, 1258,
1443, 1538, 1259,
1444, 1539, 1260,
1445, 1540, 1261,
1446, 1541, 1262,
1447, 1542, 1263,
1448, 1543, 1264,
1449, 1544, 1265,
1450, 1545, 1266,
1451, 1546, 1267,
1452, 1547, 1268,
1453, 1548, 1269,
1454, 1549, 1270,
1455, 1550, 1271,
1456, 1551, 1272,
1457, 1552, 1273,
1458, 1553, 1274,
1459, 1554, 1275,
1460, 1555, 1276,
1461, 1556, 1277,
1462, 1557, 1278,
1463, 1558, 1279,
1464, 1559, 1280,
1465, 1560, 1281,
1466, 1561, 1282,
1467, 1562, 1283,
1468, 1563, 1284,
1469, 1564, 1285,
1470, 1565, 1286,
1471, 1566, 1287,
1472, 1567, 1288,
1473, 1568, 1289,
1474, 1569, 1290,
1475, 1570, 1291,
1476, 1571, 1292,
1477, 1572, 1293,
1478, 1573, 1294,
1479, 1574, 1295,
1480, 1575, 1296,
1481, 1576, 1297,
1482, 1577, 1298,
1483, 1578, 1299,
1484, 1579, 1300,
1485, 1580, 1301,
1486, 1581, 1302,
1487, 1582, 1303,
1488, 1583, 1304,
1489, 1584, 1305,
1490, 1585, 1306,
1491, 1586, 1307,
1492, 1587, 1308,
1493, 1588, 1309,
1494, 1589, 1310,
1495, 1590, 1311,
1496, 1591, 1312,
1497, 1592, 1313,
1498, 1593, 1314,
1499, 1594, 1315,
1500, 1595, 1316,
1501, 1596, 1317,
1502, 1597, 1318,
1503, 1598, 1319,
1504, 1599, 1320,
1505, 1600, 1321,
1506, 1601, 1322,
1507, 1602, 1323,
1508, 1603, 1324,
1509, 1604, 1325,
1510, 1605, 1326,
1511, 1606, 1327,
1512, 1607, 1328,
1513, 1608, 1329,
1514, 1609, 1330,
1515, 1610, 1331,
1516, 1611, 1332,
1517, 1612, 1333,
1518, 1613, 1334,
1519, 1614, 1335,
1520, 1615, 1336,
1521, 1616, 1337,
1522, 1617, 1338,
1523, 1618, 1339,
1524, 1619, 1340,
1525, 1620, 1341,
1526, 1621, 1342,
1527, 1622, 1343,
1528, 1623, 1344,
1529, 1624, 1345,
1530, 1625, 1346,
1531, 1626, 1347,
1532, 1627, 1348,
1533, 1628, 1349,
1534, 1629, 1350,
1535, 1630, 1351,
1024, 1631, 1352,
1025, 1632, 1353,
1026, 1633, 1354,
1027, 1634, 1355,
1028, 1635, 1356,
1029, 1636, 1357,
1030, 1637, 1358,
1031, 1638, 1359,
1032, 1639, 1360,
1033, 1640, 1361,
1034, 1641, 1362,
1035, 1642, 1363,
1036, 1643, 1364,
1037, 1644, 1365,
1038, 1645, 1366,
1039, 1646, 1367,
1040, 1647, 1368,
1041, 1648, 1369,
1042, 1649, 1370,
1043, 1650, 1371,
1044, 1651, 1372,
1045, 1652, 1373,
1046, 1653, 1374,
1047, 1654, 1375,
1048, 1655, 1376,
1049, 1656, 1377,
1050, 1657, 1378,
1051, 1658, 1379,
1052, 1659, 1380,
1053, 1660, 1381,
1054, 1661, 1382,
1055, 1662, 1383,
1056, 1663, 1384,
1057, 1664, 1385,
1058, 1665, 1386,
1059, 1666, 1387,
1060, 1667, 1388,
1061, 1668, 1389,
1062, 1669, 1390,
1063, 1670, 1391,
1064, 1671, 1392,
1065, 1672, 1393,
1066, 1673, 1394,
1067, 1674, 1395,
1068, 1675, 1396,
1069, 1676, 1397,
1070, 1677, 1398,
1071, 1678, 1399,
1072, 1679, 1400,
1073, 1680, 1401,
1074, 1681, 1402,
1075, 1682, 1403,
1076, 1683, 1404,
1077, 1684, 1405,
1078, 1685, 1406,
1079, 1686, 1407,
1080, 1687, 1408,
1081, 1688, 1409,
1082, 1689, 1410,
1083, 1690, 1411,
1084, 1691, 1412,
1085, 1692, 1413,
1086, 1693, 1414,
1087, 1694, 1415,
1088, 1695, 1416,
1089, 1696, 1417,
1090, 1697, 1418,
1091, 1698, 1419,
1092, 1699, 1420,
1093, 1700, 1421,
1094, 1701, 1422,
1095, 1702, 1423,
1096, 1703, 1424,
1097, 1704, 1425,
1098, 1705, 1426,
1099, 1706, 1427,
1100, 1707, 1428,
1101, 1708, 1429,
1102, 1709, 1430,
1103, 1710, 1431,
1104, 1711, 1432,
1105, 1712, 1433,
1106, 1713, 1434,
1107, 1714, 1435,
1108, 1715, 1436,
1109, 1716, 1437,
1110, 1717, 1438,
1111, 1718, 1439,
1112, 1719, 1440,
1113, 1720, 1441,
1114, 1721, 1442,
1115, 1722, 1443,
1116, 1723, 1444,
1117, 1724, 1445,
1118, 1725, 1446,
1119, 1726, 1447,
1120, 1727, 1448,
1121, 1728, 1449,
1122, 1729, 1450,
1123, 1730, 1451,
1124, 1731, 1452,
1125, 1732, 1453,
1126, 1733, 1454,
1127, 1734, 1455,
1128, 1735, 1456,
1129, 1736, 1457,
1130, 1737, 1458,
1131, 1738, 1459,
1132, 1739, 1460,
1133, 1740, 1461,
1134, 1741, 1462,
1135, 1742, 1463,
1136, 1743, 1464,
1137, 1744, 1465,
1138, 1745, 1466,
1139, 1746, 1467,
1140, 1747, 1468,
1141, 1748, 1469,
1142, 1749, 1470,
1143, 1750, 1471,
1144, 1751, 1472,
1145, 1752, 1473,
1146, 1753, 1474,
1147, 1754, 1475,
1148, 1755, 1476,
1149, 1756, 1477,
1150, 1757, 1478,
1151, 1758, 1479,
1152, 1759, 1480,
1153, 1760, 1481,
1154, 1761, 1482,
1155, 1762, 1483,
1156, 1763, 1484,
1157, 1764, 1485,
1158, 1765, 1486,
1159, 1766, 1487,
1160, 1767, 1488,
1161, 1768, 1489,
1162, 1769, 1490,
1163, 1770, 1491,
1164, 1771, 1492,
1165, 1772, 1493,
1166, 1773, 1494,
1167, 1774, 1495,
1168, 1775, 1496,
1169, 1776, 1497,
1170, 1777, 1498,
1171, 1778, 1499,
1172, 1779, 1500,
1173, 1780, 1501,
1174, 1781, 1502,
1175, 1782, 1503,
1176, 1783, 1504,
1177, 1784, 1505,
1178, 1785, 1506,
1179, 1786, 1507,
1180, 1787, 1508,
1181, 1788, 1509,
1182, 1789, 1510,
1183, 1790, 1511,
1184, 1791, 1512,
1185, 1792, 1513,
1186, 1793, 1514,
1187, 1794, 1515,
1188, 1795, 1516,
1189, 1796, 1517,
1190, 1797, 1518,
1191, 1798, 1519,
1192, 1799, 1520,
1193, 1800, 1521,
1194, 1801, 1522,
1195, 1802, 1523,
1196, 1803, 1524,
1197, 1804, 1525,
1198, 1805, 1526,
1199, 1806, 1527,
1200, 1807, 1528,
1201, 1808, 1529,
1202, 1809, 1530,
1203, 1810, 1531,
1204, 1811, 1532,
1205, 1812, 1533,
1206, 1813, 1534,
1207, 1814, 1535,
328, 1721, 1536,
329, 1722, 1537,
330, 1723, 1538,
331, 1724, 1539,
332, 1725, 1540,
333, 1726, 1541,
334, 1727, 1542,
335, 1728, 1543,
336, 1729, 1544,
337, 1730, 1545,
338, 1731, 1546,
339, 1732, 1547,
340, 1733, 1548,
341, 1734, 1549,
342, 1735, 1550,
343, 1736, 1551,
344, 1737, 1552,
345, 1738, 1553,
346, 1739, 1554,
347, 1740, 1555,
348, 1741, 1556,
349, 1742, 1557,
350, 1743, 1558,
351, 1744, 1559,
352, 1745, 1560,
353, 1746, 1561,
354, 1747, 1562,
355, 1748, 1563,
356, 1749, 1564,
357, 1750, 1565,
358, 1751, 1566,
359, 1752, 1567,
360, 1753, 1568,
361, 1754, 1569,
362, 1755, 1570,
363, 1756, 1571,
364, 1757, 1572,
365, 1758, 1573,
366, 1759, 1574,
367, 1760, 1575,
368, 1761, 1576,
369, 1762, 1577,
370, 1763, 1578,
371, 1764, 1579,
372, 1765, 1580,
373, 1766, 1581,
374, 1767, 1582,
375, 1768, 1583,
376, 1769, 1584,
377, 1770, 1585,
378, 1771, 1586,
379, 1772, 1587,
380, 1773, 1588,
381, 1774, 1589,
382, 1775, 1590,
383, 1776, 1591,
384, 1777, 1592,
385, 1778, 1593,
386, 1779, 1594,
387, 1780, 1595,
388, 1781, 1596,
389, 1782, 1597,
390, 1783, 1598,
391, 1784, 1599,
392, 1785, 1600,
393, 1786, 1601,
394, 1787, 1602,
395, 1788, 1603,
396, 1789, 1604,
397, 1790, 1605,
398, 1791, 1606,
399, 1792, 1607,
400, 1793, 1608,
401, 1794, 1609,
402, 1795, 1610,
403, 1796, 1611,
404, 1797, 1612,
405, 1798, 1613,
406, 1799, 1614,
407, 1800, 1615,
408, 1801, 1616,
409, 1802, 1617,
410, 1803, 1618,
411, 1804, 1619,
412, 1805, 1620,
413, 1806, 1621,
414, 1807, 1622,
415, 1808, 1623,
416, 1809, 1624,
417, 1810, 1625,
418, 1811, 1626,
419, 1812, 1627,
420, 1813, 1628,
421, 1814, 1629,
422, 1815, 1630,
423, 1816, 1631,
424, 1817, 1632,
425, 1818, 1633,
426, 1819, 1634,
427, 1820, 1635,
428, 1821, 1636,
429, 1822, 1637,
430, 1823, 1638,
431, 1824, 1639,
432, 1825, 1640,
433, 1826, 1641,
434, 1827, 1642,
435, 1828, 1643,
436, 1829, 1644,
437, 1830, 1645,
438, 1831, 1646,
439, 1832, 1647,
440, 1833, 1648,
441, 1834, 1649,
442, 1835, 1650,
443, 1836, 1651,
444, 1837, 1652,
445, 1838, 1653,
446, 1839, 1654,
447, 1840, 1655,
448, 1841, 1656,
449, 1842, 1657,
450, 1843, 1658,
451, 1844, 1659,
452, 1845, 1660,
453, 1846, 1661,
454, 1847, 1662,
455, 1848, 1663,
456, 1849, 1664,
457, 1850, 1665,
458, 1851, 1666,
459, 1852, 1667,
460, 1853, 1668,
461, 1854, 1669,
462, 1855, 1670,
463, 1856, 1671,
464, 1857, 1672,
465, 1858, 1673,
466, 1859, 1674,
467, 1860, 1675,
468, 1861, 1676,
469, 1862, 1677,
470, 1863, 1678,
471, 1864, 1679,
472, 1865, 1680,
473, 1866, 1681,
474, 1867, 1682,
475, 1868, 1683,
476, 1869, 1684,
477, 1870, 1685,
478, 1871, 1686,
479, 1872, 1687,
480, 1873, 1688,
481, 1874, 1689,
482, 1875, 1690,
483, 1876, 1691,
484, 1877, 1692,
485, 1878, 1693,
486, 1879, 1694,
487, 1880, 1695,
488, 1881, 1696,
489, 1882, 1697,
490, 1883, 1698,
491, 1884, 1699,
492, 1885, 1700,
493, 1886, 1701,
494, 1887, 1702,
495, 1888, 1703,
496, 1889, 1704,
497, 1890, 1705,
498, 1891, 1706,
499, 1892, 1707,
500, 1893, 1708,
501, 1894, 1709,
502, 1895, 1710,
503, 1896, 1711,
504, 1897, 1712,
505, 1898, 1713,
506, 1899, 1714,
507, 1900, 1715,
508, 1901, 1716,
509, 1902, 1717,
510, 1903, 1718,
511, 1904, 1719,
0, 1905, 1720,
1, 1906, 1721,
2, 1907, 1722,
3, 1908, 1723,
4, 1909, 1724,
5, 1910, 1725,
6, 1911, 1726,
7, 1912, 1727,
8, 1913, 1728,
9, 1914, 1729,
10, 1915, 1730,
11, 1916, 1731,
12, 1917, 1732,
13, 1918, 1733,
14, 1919, 1734,
15, 1920, 1735,
16, 1921, 1736,
17, 1922, 1737,
18, 1923, 1738,
19, 1924, 1739,
20, 1925, 1740,
21, 1926, 1741,
22, 1927, 1742,
23, 1928, 1743,
24, 1929, 1744,
25, 1930, 1745,
26, 1931, 1746,
27, 1932, 1747,
28, 1933, 1748,
29, 1934, 1749,
30, 1935, 1750,
31, 1936, 1751,
32, 1937, 1752,
33, 1938, 1753,
34, 1939, 1754,
35, 1940, 1755,
36, 1941, 1756,
37, 1942, 1757,
38, 1943, 1758,
39, 1944, 1759,
40, 1945, 1760,
41, 1946, 1761,
42, 1947, 1762,
43, 1948, 1763,
44, 1949, 1764,
45, 1950, 1765,
46, 1951, 1766,
47, 1952, 1767,
48, 1953, 1768,
49, 1954, 1769,
50, 1955, 1770,
51, 1956, 1771,
52, 1957, 1772,
53, 1958, 1773,
54, 1959, 1774,
55, 1960, 1775,
56, 1961, 1776,
57, 1962, 1777,
58, 1963, 1778,
59, 1964, 1779,
60, 1965, 1780,
61, 1966, 1781,
62, 1967, 1782,
63, 1968, 1783,
64, 1969, 1784,
65, 1970, 1785,
66, 1971, 1786,
67, 1972, 1787,
68, 1973, 1788,
69, 1974, 1789,
70, 1975, 1790,
71, 1976, 1791,
72, 1977, 1792,
73, 1978, 1793,
74, 1979, 1794,
75, 1980, 1795,
76, 1981, 1796,
77, 1982, 1797,
78, 1983, 1798,
79, 1984, 1799,
80, 1985, 1800,
81, 1986, 1801,
82, 1987, 1802,
83, 1988, 1803,
84, 1989, 1804,
85, 1990, 1805,
86, 1991, 1806,
87, 1992, 1807,
88, 1993, 1808,
89, 1994, 1809,
90, 1995, 1810,
91, 1996, 1811,
92, 1997, 1812,
93, 1998, 1813,
94, 1999, 1814,
95, 2000, 1815,
96, 2001, 1816,
97, 2002, 1817,
98, 2003, 1818,
99, 2004, 1819,
100, 2005, 1820,
101, 2006, 1821,
102, 2007, 1822,
103, 2008, 1823,
104, 2009, 1824,
105, 2010, 1825,
106, 2011, 1826,
107, 2012, 1827,
108, 2013, 1828,
109, 2014, 1829,
110, 2015, 1830,
111, 2016, 1831,
112, 2017, 1832,
113, 2018, 1833,
114, 2019, 1834,
115, 2020, 1835,
116, 2021, 1836,
117, 2022, 1837,
118, 2023, 1838,
119, 2024, 1839,
120, 2025, 1840,
121, 2026, 1841,
122, 2027, 1842,
123, 2028, 1843,
124, 2029, 1844,
125, 2030, 1845,
126, 2031, 1846,
127, 2032, 1847,
128, 2033, 1848,
129, 2034, 1849,
130, 2035, 1850,
131, 2036, 1851,
132, 2037, 1852,
133, 2038, 1853,
134, 2039, 1854,
135, 2040, 1855,
136, 2041, 1856,
137, 2042, 1857,
138, 2043, 1858,
139, 2044, 1859,
140, 2045, 1860,
141, 2046, 1861,
142, 2047, 1862,
143, 1536, 1863,
144, 1537, 1864,
145, 1538, 1865,
146, 1539, 1866,
147, 1540, 1867,
148, 1541, 1868,
149, 1542, 1869,
150, 1543, 1870,
151, 1544, 1871,
152, 1545, 1872,
153, 1546, 1873,
154, 1547, 1874,
155, 1548, 1875,
156, 1549, 1876,
157, 1550, 1877,
158, 1551, 1878,
159, 1552, 1879,
160, 1553, 1880,
161, 1554, 1881,
162, 1555, 1882,
163, 1556, 1883,
164, 1557, 1884,
165, 1558, 1885,
166, 1559, 1886,
167, 1560, 1887,
168, 1561, 1888,
169, 1562, 1889,
170, 1563, 1890,
171, 1564, 1891,
172, 1565, 1892,
173, 1566, 1893,
174, 1567, 1894,
175, 1568, 1895,
176, 1569, 1896,
177, 1570, 1897,
178, 1571, 1898,
179, 1572, 1899,
180, 1573, 1900,
181, 1574, 1901,
182, 1575, 1902,
183, 1576, 1903,
184, 1577, 1904,
185, 1578, 1905,
186, 1579, 1906,
187, 1580, 1907,
188, 1581, 1908,
189, 1582, 1909,
190, 1583, 1910,
191, 1584, 1911,
192, 1585, 1912,
193, 1586, 1913,
194, 1587, 1914,
195, 1588, 1915,
196, 1589, 1916,
197, 1590, 1917,
198, 1591, 1918,
199, 1592, 1919,
200, 1593, 1920,
201, 1594, 1921,
202, 1595, 1922,
203, 1596, 1923,
204, 1597, 1924,
205, 1598, 1925,
206, 1599, 1926,
207, 1600, 1927,
208, 1601, 1928,
209, 1602, 1929,
210, 1603, 1930,
211, 1604, 1931,
212, 1605, 1932,
213, 1606, 1933,
214, 1607, 1934,
215, 1608, 1935,
216, 1609, 1936,
217, 1610, 1937,
218, 1611, 1938,
219, 1612, 1939,
220, 1613, 1940,
221, 1614, 1941,
222, 1615, 1942,
223, 1616, 1943,
224, 1617, 1944,
225, 1618, 1945,
226, 1619, 1946,
227, 1620, 1947,
228, 1621, 1948,
229, 1622, 1949,
230, 1623, 1950,
231, 1624, 1951,
232, 1625, 1952,
233, 1626, 1953,
234, 1627, 1954,
235, 1628, 1955,
236, 1629, 1956,
237, 1630, 1957,
238, 1631, 1958,
239, 1632, 1959,
240, 1633, 1960,
241, 1634, 1961,
242, 1635, 1962,
243, 1636, 1963,
244, 1637, 1964,
245, 1638, 1965,
246, 1639, 1966,
247, 1640, 1967,
248, 1641, 1968,
249, 1642, 1969,
250, 1643, 1970,
251, 1644, 1971,
252, 1645, 1972,
253, 1646, 1973,
254, 1647, 1974,
255, 1648, 1975,
256, 1649, 1976,
257, 1650, 1977,
258, 1651, 1978,
259, 1652, 1979,
260, 1653, 1980,
261, 1654, 1981,
262, 1655, 1982,
263, 1656, 1983,
264, 1657, 1984,
265, 1658, 1985,
266, 1659, 1986,
267, 1660, 1987,
268, 1661, 1988,
269, 1662, 1989,
270, 1663, 1990,
271, 1664, 1991,
272, 1665, 1992,
273, 1666, 1993,
274, 1667, 1994,
275, 1668, 1995,
276, 1669, 1996,
277, 1670, 1997,
278, 1671, 1998,
279, 1672, 1999,
280, 1673, 2000,
281, 1674, 2001,
282, 1675, 2002,
283, 1676, 2003,
284, 1677, 2004,
285, 1678, 2005,
286, 1679, 2006,
287, 1680, 2007,
288, 1681, 2008,
289, 1682, 2009,
290, 1683, 2010,
291, 1684, 2011,
292, 1685, 2012,
293, 1686, 2013,
294, 1687, 2014,
295, 1688, 2015,
296, 1689, 2016,
297, 1690, 2017,
298, 1691, 2018,
299, 1692, 2019,
300, 1693, 2020,
301, 1694, 2021,
302, 1695, 2022,
303, 1696, 2023,
304, 1697, 2024,
305, 1698, 2025,
306, 1699, 2026,
307, 1700, 2027,
308, 1701, 2028,
309, 1702, 2029,
310, 1703, 2030,
311, 1704, 2031,
312, 1705, 2032,
313, 1706, 2033,
314, 1707, 2034,
315, 1708, 2035,
316, 1709, 2036,
317, 1710, 2037,
318, 1711, 2038,
319, 1712, 2039,
320, 1713, 2040,
321, 1714, 2041,
322, 1715, 2042,
323, 1716, 2043,
324, 1717, 2044,
325, 1718, 2045,
326, 1719, 2046,
327, 1720, 2047
 };
#pragma line 269 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_1_2_trichk.h" 1
#pragma empty_line
vars_3_12 varinx3_4096_12[] = {
0, 0, 1644,
1, 1, 1645,
2, 2, 1646,
3, 3, 1647,
4, 4, 1648,
5, 5, 1649,
6, 6, 1650,
7, 7, 1651,
8, 8, 1652,
9, 9, 1653,
10, 10, 1654,
11, 11, 1655,
12, 12, 1656,
13, 13, 1657,
14, 14, 1658,
15, 15, 1659,
16, 16, 1660,
17, 17, 1661,
18, 18, 1662,
19, 19, 1663,
20, 20, 1664,
21, 21, 1665,
22, 22, 1666,
23, 23, 1667,
24, 24, 1668,
25, 25, 1669,
26, 26, 1670,
27, 27, 1671,
28, 28, 1672,
29, 29, 1673,
30, 30, 1674,
31, 31, 1675,
32, 32, 1676,
33, 33, 1677,
34, 34, 1678,
35, 35, 1679,
36, 36, 1680,
37, 37, 1681,
38, 38, 1682,
39, 39, 1683,
40, 40, 1684,
41, 41, 1685,
42, 42, 1686,
43, 43, 1687,
44, 44, 1688,
45, 45, 1689,
46, 46, 1690,
47, 47, 1691,
48, 48, 1692,
49, 49, 1693,
50, 50, 1694,
51, 51, 1695,
52, 52, 1696,
53, 53, 1697,
54, 54, 1698,
55, 55, 1699,
56, 56, 1700,
57, 57, 1701,
58, 58, 1702,
59, 59, 1703,
60, 60, 1704,
61, 61, 1705,
62, 62, 1706,
63, 63, 1707,
64, 64, 1708,
65, 65, 1709,
66, 66, 1710,
67, 67, 1711,
68, 68, 1712,
69, 69, 1713,
70, 70, 1714,
71, 71, 1715,
72, 72, 1716,
73, 73, 1717,
74, 74, 1718,
75, 75, 1719,
76, 76, 1720,
77, 77, 1721,
78, 78, 1722,
79, 79, 1723,
80, 80, 1724,
81, 81, 1725,
82, 82, 1726,
83, 83, 1727,
84, 84, 1728,
85, 85, 1729,
86, 86, 1730,
87, 87, 1731,
88, 88, 1732,
89, 89, 1733,
90, 90, 1734,
91, 91, 1735,
92, 92, 1736,
93, 93, 1737,
94, 94, 1738,
95, 95, 1739,
96, 96, 1740,
97, 97, 1741,
98, 98, 1742,
99, 99, 1743,
100, 100, 1744,
101, 101, 1745,
102, 102, 1746,
103, 103, 1747,
104, 104, 1748,
105, 105, 1749,
106, 106, 1750,
107, 107, 1751,
108, 108, 1752,
109, 109, 1753,
110, 110, 1754,
111, 111, 1755,
112, 112, 1756,
113, 113, 1757,
114, 114, 1758,
115, 115, 1759,
116, 116, 1760,
117, 117, 1761,
118, 118, 1762,
119, 119, 1763,
120, 120, 1764,
121, 121, 1765,
122, 122, 1766,
123, 123, 1767,
124, 124, 1768,
125, 125, 1769,
126, 126, 1770,
127, 127, 1771,
128, 128, 1772,
129, 129, 1773,
130, 130, 1774,
131, 131, 1775,
132, 132, 1776,
133, 133, 1777,
134, 134, 1778,
135, 135, 1779,
136, 136, 1780,
137, 137, 1781,
138, 138, 1782,
139, 139, 1783,
140, 140, 1784,
141, 141, 1785,
142, 142, 1786,
143, 143, 1787,
144, 144, 1788,
145, 145, 1789,
146, 146, 1790,
147, 147, 1791,
148, 148, 1792,
149, 149, 1793,
150, 150, 1794,
151, 151, 1795,
152, 152, 1796,
153, 153, 1797,
154, 154, 1798,
155, 155, 1799,
156, 156, 1800,
157, 157, 1801,
158, 158, 1802,
159, 159, 1803,
160, 160, 1804,
161, 161, 1805,
162, 162, 1806,
163, 163, 1807,
164, 164, 1808,
165, 165, 1809,
166, 166, 1810,
167, 167, 1811,
168, 168, 1812,
169, 169, 1813,
170, 170, 1814,
171, 171, 1815,
172, 172, 1816,
173, 173, 1817,
174, 174, 1818,
175, 175, 1819,
176, 176, 1820,
177, 177, 1821,
178, 178, 1822,
179, 179, 1823,
180, 180, 1824,
181, 181, 1825,
182, 182, 1826,
183, 183, 1827,
184, 184, 1828,
185, 185, 1829,
186, 186, 1830,
187, 187, 1831,
188, 188, 1832,
189, 189, 1833,
190, 190, 1834,
191, 191, 1835,
192, 192, 1836,
193, 193, 1837,
194, 194, 1838,
195, 195, 1839,
196, 196, 1840,
197, 197, 1841,
198, 198, 1842,
199, 199, 1843,
200, 200, 1844,
201, 201, 1845,
202, 202, 1846,
203, 203, 1847,
204, 204, 1848,
205, 205, 1849,
206, 206, 1850,
207, 207, 1851,
208, 208, 1852,
209, 209, 1853,
210, 210, 1854,
211, 211, 1855,
212, 212, 1856,
213, 213, 1857,
214, 214, 1858,
215, 215, 1859,
216, 216, 1860,
217, 217, 1861,
218, 218, 1862,
219, 219, 1863,
220, 220, 1864,
221, 221, 1865,
222, 222, 1866,
223, 223, 1867,
224, 224, 1868,
225, 225, 1869,
226, 226, 1870,
227, 227, 1871,
228, 228, 1872,
229, 229, 1873,
230, 230, 1874,
231, 231, 1875,
232, 232, 1876,
233, 233, 1877,
234, 234, 1878,
235, 235, 1879,
236, 236, 1880,
237, 237, 1881,
238, 238, 1882,
239, 239, 1883,
240, 240, 1884,
241, 241, 1885,
242, 242, 1886,
243, 243, 1887,
244, 244, 1888,
245, 245, 1889,
246, 246, 1890,
247, 247, 1891,
248, 248, 1892,
249, 249, 1893,
250, 250, 1894,
251, 251, 1895,
252, 252, 1896,
253, 253, 1897,
254, 254, 1898,
255, 255, 1899,
256, 256, 1900,
257, 257, 1901,
258, 258, 1902,
259, 259, 1903,
260, 260, 1904,
261, 261, 1905,
262, 262, 1906,
263, 263, 1907,
264, 264, 1908,
265, 265, 1909,
266, 266, 1910,
267, 267, 1911,
268, 268, 1912,
269, 269, 1913,
270, 270, 1914,
271, 271, 1915,
272, 272, 1916,
273, 273, 1917,
274, 274, 1918,
275, 275, 1919,
276, 276, 1920,
277, 277, 1921,
278, 278, 1922,
279, 279, 1923,
280, 280, 1924,
281, 281, 1925,
282, 282, 1926,
283, 283, 1927,
284, 284, 1928,
285, 285, 1929,
286, 286, 1930,
287, 287, 1931,
288, 288, 1932,
289, 289, 1933,
290, 290, 1934,
291, 291, 1935,
292, 292, 1936,
293, 293, 1937,
294, 294, 1938,
295, 295, 1939,
296, 296, 1940,
297, 297, 1941,
298, 298, 1942,
299, 299, 1943,
300, 300, 1944,
301, 301, 1945,
302, 302, 1946,
303, 303, 1947,
304, 304, 1948,
305, 305, 1949,
306, 306, 1950,
307, 307, 1951,
308, 308, 1952,
309, 309, 1953,
310, 310, 1954,
311, 311, 1955,
312, 312, 1956,
313, 313, 1957,
314, 314, 1958,
315, 315, 1959,
316, 316, 1960,
317, 317, 1961,
318, 318, 1962,
319, 319, 1963,
320, 320, 1964,
321, 321, 1965,
322, 322, 1966,
323, 323, 1967,
324, 324, 1968,
325, 325, 1969,
326, 326, 1970,
327, 327, 1971,
328, 328, 1972,
329, 329, 1973,
330, 330, 1974,
331, 331, 1975,
332, 332, 1976,
333, 333, 1977,
334, 334, 1978,
335, 335, 1979,
336, 336, 1980,
337, 337, 1981,
338, 338, 1982,
339, 339, 1983,
340, 340, 1984,
341, 341, 1985,
342, 342, 1986,
343, 343, 1987,
344, 344, 1988,
345, 345, 1989,
346, 346, 1990,
347, 347, 1991,
348, 348, 1992,
349, 349, 1993,
350, 350, 1994,
351, 351, 1995,
352, 352, 1996,
353, 353, 1997,
354, 354, 1998,
355, 355, 1999,
356, 356, 2000,
357, 357, 2001,
358, 358, 2002,
359, 359, 2003,
360, 360, 2004,
361, 361, 2005,
362, 362, 2006,
363, 363, 2007,
364, 364, 2008,
365, 365, 2009,
366, 366, 2010,
367, 367, 2011,
368, 368, 2012,
369, 369, 2013,
370, 370, 2014,
371, 371, 2015,
372, 372, 2016,
373, 373, 2017,
374, 374, 2018,
375, 375, 2019,
376, 376, 2020,
377, 377, 2021,
378, 378, 2022,
379, 379, 2023,
380, 380, 2024,
381, 381, 2025,
382, 382, 2026,
383, 383, 2027,
384, 384, 2028,
385, 385, 2029,
386, 386, 2030,
387, 387, 2031,
388, 388, 2032,
389, 389, 2033,
390, 390, 2034,
391, 391, 2035,
392, 392, 2036,
393, 393, 2037,
394, 394, 2038,
395, 395, 2039,
396, 396, 2040,
397, 397, 2041,
398, 398, 2042,
399, 399, 2043,
400, 400, 2044,
401, 401, 2045,
402, 402, 2046,
403, 403, 2047,
404, 404, 1536,
405, 405, 1537,
406, 406, 1538,
407, 407, 1539,
408, 408, 1540,
409, 409, 1541,
410, 410, 1542,
411, 411, 1543,
412, 412, 1544,
413, 413, 1545,
414, 414, 1546,
415, 415, 1547,
416, 416, 1548,
417, 417, 1549,
418, 418, 1550,
419, 419, 1551,
420, 420, 1552,
421, 421, 1553,
422, 422, 1554,
423, 423, 1555,
424, 424, 1556,
425, 425, 1557,
426, 426, 1558,
427, 427, 1559,
428, 428, 1560,
429, 429, 1561,
430, 430, 1562,
431, 431, 1563,
432, 432, 1564,
433, 433, 1565,
434, 434, 1566,
435, 435, 1567,
436, 436, 1568,
437, 437, 1569,
438, 438, 1570,
439, 439, 1571,
440, 440, 1572,
441, 441, 1573,
442, 442, 1574,
443, 443, 1575,
444, 444, 1576,
445, 445, 1577,
446, 446, 1578,
447, 447, 1579,
448, 448, 1580,
449, 449, 1581,
450, 450, 1582,
451, 451, 1583,
452, 452, 1584,
453, 453, 1585,
454, 454, 1586,
455, 455, 1587,
456, 456, 1588,
457, 457, 1589,
458, 458, 1590,
459, 459, 1591,
460, 460, 1592,
461, 461, 1593,
462, 462, 1594,
463, 463, 1595,
464, 464, 1596,
465, 465, 1597,
466, 466, 1598,
467, 467, 1599,
468, 468, 1600,
469, 469, 1601,
470, 470, 1602,
471, 471, 1603,
472, 472, 1604,
473, 473, 1605,
474, 474, 1606,
475, 475, 1607,
476, 476, 1608,
477, 477, 1609,
478, 478, 1610,
479, 479, 1611,
480, 480, 1612,
481, 481, 1613,
482, 482, 1614,
483, 483, 1615,
484, 484, 1616,
485, 485, 1617,
486, 486, 1618,
487, 487, 1619,
488, 488, 1620,
489, 489, 1621,
490, 490, 1622,
491, 491, 1623,
492, 492, 1624,
493, 493, 1625,
494, 494, 1626,
495, 495, 1627,
496, 496, 1628,
497, 497, 1629,
498, 498, 1630,
499, 499, 1631,
500, 500, 1632,
501, 501, 1633,
502, 502, 1634,
503, 503, 1635,
504, 504, 1636,
505, 505, 1637,
506, 506, 1638,
507, 507, 1639,
508, 508, 1640,
509, 509, 1641,
510, 510, 1642,
511, 511, 1643,
512, 0, 512,
513, 1, 513,
514, 2, 514,
515, 3, 515,
516, 4, 516,
517, 5, 517,
518, 6, 518,
519, 7, 519,
520, 8, 520,
521, 9, 521,
522, 10, 522,
523, 11, 523,
524, 12, 524,
525, 13, 525,
526, 14, 526,
527, 15, 527,
528, 16, 528,
529, 17, 529,
530, 18, 530,
531, 19, 531,
532, 20, 532,
533, 21, 533,
534, 22, 534,
535, 23, 535,
536, 24, 536,
537, 25, 537,
538, 26, 538,
539, 27, 539,
540, 28, 540,
541, 29, 541,
542, 30, 542,
543, 31, 543,
544, 32, 544,
545, 33, 545,
546, 34, 546,
547, 35, 547,
548, 36, 548,
549, 37, 549,
550, 38, 550,
551, 39, 551,
552, 40, 552,
553, 41, 553,
554, 42, 554,
555, 43, 555,
556, 44, 556,
557, 45, 557,
558, 46, 558,
559, 47, 559,
560, 48, 560,
561, 49, 561,
562, 50, 562,
563, 51, 563,
564, 52, 564,
565, 53, 565,
566, 54, 566,
567, 55, 567,
568, 56, 568,
569, 57, 569,
570, 58, 570,
571, 59, 571,
572, 60, 572,
573, 61, 573,
574, 62, 574,
575, 63, 575,
576, 64, 576,
577, 65, 577,
578, 66, 578,
579, 67, 579,
580, 68, 580,
581, 69, 581,
582, 70, 582,
583, 71, 583,
584, 72, 584,
585, 73, 585,
586, 74, 586,
587, 75, 587,
588, 76, 588,
589, 77, 589,
590, 78, 590,
591, 79, 591,
592, 80, 592,
593, 81, 593,
594, 82, 594,
595, 83, 595,
596, 84, 596,
597, 85, 597,
598, 86, 598,
599, 87, 599,
600, 88, 600,
601, 89, 601,
602, 90, 602,
603, 91, 603,
604, 92, 604,
605, 93, 605,
606, 94, 606,
607, 95, 607,
608, 96, 608,
609, 97, 609,
610, 98, 610,
611, 99, 611,
612, 100, 612,
613, 101, 613,
614, 102, 614,
615, 103, 615,
616, 104, 616,
617, 105, 617,
618, 106, 618,
619, 107, 619,
620, 108, 620,
621, 109, 621,
622, 110, 622,
623, 111, 623,
624, 112, 624,
625, 113, 625,
626, 114, 626,
627, 115, 627,
628, 116, 628,
629, 117, 629,
630, 118, 630,
631, 119, 631,
632, 120, 632,
633, 121, 633,
634, 122, 634,
635, 123, 635,
636, 124, 636,
637, 125, 637,
638, 126, 638,
639, 127, 639,
640, 128, 640,
641, 129, 641,
642, 130, 642,
643, 131, 643,
644, 132, 644,
645, 133, 645,
646, 134, 646,
647, 135, 647,
648, 136, 648,
649, 137, 649,
650, 138, 650,
651, 139, 651,
652, 140, 652,
653, 141, 653,
654, 142, 654,
655, 143, 655,
656, 144, 656,
657, 145, 657,
658, 146, 658,
659, 147, 659,
660, 148, 660,
661, 149, 661,
662, 150, 662,
663, 151, 663,
664, 152, 664,
665, 153, 665,
666, 154, 666,
667, 155, 667,
668, 156, 668,
669, 157, 669,
670, 158, 670,
671, 159, 671,
672, 160, 672,
673, 161, 673,
674, 162, 674,
675, 163, 675,
676, 164, 676,
677, 165, 677,
678, 166, 678,
679, 167, 679,
680, 168, 680,
681, 169, 681,
682, 170, 682,
683, 171, 683,
684, 172, 684,
685, 173, 685,
686, 174, 686,
687, 175, 687,
688, 176, 688,
689, 177, 689,
690, 178, 690,
691, 179, 691,
692, 180, 692,
693, 181, 693,
694, 182, 694,
695, 183, 695,
696, 184, 696,
697, 185, 697,
698, 186, 698,
699, 187, 699,
700, 188, 700,
701, 189, 701,
702, 190, 702,
703, 191, 703,
704, 192, 704,
705, 193, 705,
706, 194, 706,
707, 195, 707,
708, 196, 708,
709, 197, 709,
710, 198, 710,
711, 199, 711,
712, 200, 712,
713, 201, 713,
714, 202, 714,
715, 203, 715,
716, 204, 716,
717, 205, 717,
718, 206, 718,
719, 207, 719,
720, 208, 720,
721, 209, 721,
722, 210, 722,
723, 211, 723,
724, 212, 724,
725, 213, 725,
726, 214, 726,
727, 215, 727,
728, 216, 728,
729, 217, 729,
730, 218, 730,
731, 219, 731,
732, 220, 732,
733, 221, 733,
734, 222, 734,
735, 223, 735,
736, 224, 736,
737, 225, 737,
738, 226, 738,
739, 227, 739,
740, 228, 740,
741, 229, 741,
742, 230, 742,
743, 231, 743,
744, 232, 744,
745, 233, 745,
746, 234, 746,
747, 235, 747,
748, 236, 748,
749, 237, 749,
750, 238, 750,
751, 239, 751,
752, 240, 752,
753, 241, 753,
754, 242, 754,
755, 243, 755,
756, 244, 756,
757, 245, 757,
758, 246, 758,
759, 247, 759,
760, 248, 760,
761, 249, 761,
762, 250, 762,
763, 251, 763,
764, 252, 764,
765, 253, 765,
766, 254, 766,
767, 255, 767,
768, 256, 768,
769, 257, 769,
770, 258, 770,
771, 259, 771,
772, 260, 772,
773, 261, 773,
774, 262, 774,
775, 263, 775,
776, 264, 776,
777, 265, 777,
778, 266, 778,
779, 267, 779,
780, 268, 780,
781, 269, 781,
782, 270, 782,
783, 271, 783,
784, 272, 784,
785, 273, 785,
786, 274, 786,
787, 275, 787,
788, 276, 788,
789, 277, 789,
790, 278, 790,
791, 279, 791,
792, 280, 792,
793, 281, 793,
794, 282, 794,
795, 283, 795,
796, 284, 796,
797, 285, 797,
798, 286, 798,
799, 287, 799,
800, 288, 800,
801, 289, 801,
802, 290, 802,
803, 291, 803,
804, 292, 804,
805, 293, 805,
806, 294, 806,
807, 295, 807,
808, 296, 808,
809, 297, 809,
810, 298, 810,
811, 299, 811,
812, 300, 812,
813, 301, 813,
814, 302, 814,
815, 303, 815,
816, 304, 816,
817, 305, 817,
818, 306, 818,
819, 307, 819,
820, 308, 820,
821, 309, 821,
822, 310, 822,
823, 311, 823,
824, 312, 824,
825, 313, 825,
826, 314, 826,
827, 315, 827,
828, 316, 828,
829, 317, 829,
830, 318, 830,
831, 319, 831,
832, 320, 832,
833, 321, 833,
834, 322, 834,
835, 323, 835,
836, 324, 836,
837, 325, 837,
838, 326, 838,
839, 327, 839,
840, 328, 840,
841, 329, 841,
842, 330, 842,
843, 331, 843,
844, 332, 844,
845, 333, 845,
846, 334, 846,
847, 335, 847,
848, 336, 848,
849, 337, 849,
850, 338, 850,
851, 339, 851,
852, 340, 852,
853, 341, 853,
854, 342, 854,
855, 343, 855,
856, 344, 856,
857, 345, 857,
858, 346, 858,
859, 347, 859,
860, 348, 860,
861, 349, 861,
862, 350, 862,
863, 351, 863,
864, 352, 864,
865, 353, 865,
866, 354, 866,
867, 355, 867,
868, 356, 868,
869, 357, 869,
870, 358, 870,
871, 359, 871,
872, 360, 872,
873, 361, 873,
874, 362, 874,
875, 363, 875,
876, 364, 876,
877, 365, 877,
878, 366, 878,
879, 367, 879,
880, 368, 880,
881, 369, 881,
882, 370, 882,
883, 371, 883,
884, 372, 884,
885, 373, 885,
886, 374, 886,
887, 375, 887,
888, 376, 888,
889, 377, 889,
890, 378, 890,
891, 379, 891,
892, 380, 892,
893, 381, 893,
894, 382, 894,
895, 383, 895,
896, 384, 896,
897, 385, 897,
898, 386, 898,
899, 387, 899,
900, 388, 900,
901, 389, 901,
902, 390, 902,
903, 391, 903,
904, 392, 904,
905, 393, 905,
906, 394, 906,
907, 395, 907,
908, 396, 908,
909, 397, 909,
910, 398, 910,
911, 399, 911,
912, 400, 912,
913, 401, 913,
914, 402, 914,
915, 403, 915,
916, 404, 916,
917, 405, 917,
918, 406, 918,
919, 407, 919,
920, 408, 920,
921, 409, 921,
922, 410, 922,
923, 411, 923,
924, 412, 924,
925, 413, 925,
926, 414, 926,
927, 415, 927,
928, 416, 928,
929, 417, 929,
930, 418, 930,
931, 419, 931,
932, 420, 932,
933, 421, 933,
934, 422, 934,
935, 423, 935,
936, 424, 936,
937, 425, 937,
938, 426, 938,
939, 427, 939,
940, 428, 940,
941, 429, 941,
942, 430, 942,
943, 431, 943,
944, 432, 944,
945, 433, 945,
946, 434, 946,
947, 435, 947,
948, 436, 948,
949, 437, 949,
950, 438, 950,
951, 439, 951,
952, 440, 952,
953, 441, 953,
954, 442, 954,
955, 443, 955,
956, 444, 956,
957, 445, 957,
958, 446, 958,
959, 447, 959,
960, 448, 960,
961, 449, 961,
962, 450, 962,
963, 451, 963,
964, 452, 964,
965, 453, 965,
966, 454, 966,
967, 455, 967,
968, 456, 968,
969, 457, 969,
970, 458, 970,
971, 459, 971,
972, 460, 972,
973, 461, 973,
974, 462, 974,
975, 463, 975,
976, 464, 976,
977, 465, 977,
978, 466, 978,
979, 467, 979,
980, 468, 980,
981, 469, 981,
982, 470, 982,
983, 471, 983,
984, 472, 984,
985, 473, 985,
986, 474, 986,
987, 475, 987,
988, 476, 988,
989, 477, 989,
990, 478, 990,
991, 479, 991,
992, 480, 992,
993, 481, 993,
994, 482, 994,
995, 483, 995,
996, 484, 996,
997, 485, 997,
998, 486, 998,
999, 487, 999,
1000, 488, 1000,
1001, 489, 1001,
1002, 490, 1002,
1003, 491, 1003,
1004, 492, 1004,
1005, 493, 1005,
1006, 494, 1006,
1007, 495, 1007,
1008, 496, 1008,
1009, 497, 1009,
1010, 498, 1010,
1011, 499, 1011,
1012, 500, 1012,
1013, 501, 1013,
1014, 502, 1014,
1015, 503, 1015,
1016, 504, 1016,
1017, 505, 1017,
1018, 506, 1018,
1019, 507, 1019,
1020, 508, 1020,
1021, 509, 1021,
1022, 510, 1022,
1023, 511, 1023,
1024, 512, 1024,
1025, 513, 1025,
1026, 514, 1026,
1027, 515, 1027,
1028, 516, 1028,
1029, 517, 1029,
1030, 518, 1030,
1031, 519, 1031,
1032, 520, 1032,
1033, 521, 1033,
1034, 522, 1034,
1035, 523, 1035,
1036, 524, 1036,
1037, 525, 1037,
1038, 526, 1038,
1039, 527, 1039,
1040, 528, 1040,
1041, 529, 1041,
1042, 530, 1042,
1043, 531, 1043,
1044, 532, 1044,
1045, 533, 1045,
1046, 534, 1046,
1047, 535, 1047,
1048, 536, 1048,
1049, 537, 1049,
1050, 538, 1050,
1051, 539, 1051,
1052, 540, 1052,
1053, 541, 1053,
1054, 542, 1054,
1055, 543, 1055,
1056, 544, 1056,
1057, 545, 1057,
1058, 546, 1058,
1059, 547, 1059,
1060, 548, 1060,
1061, 549, 1061,
1062, 550, 1062,
1063, 551, 1063,
1064, 552, 1064,
1065, 553, 1065,
1066, 554, 1066,
1067, 555, 1067,
1068, 556, 1068,
1069, 557, 1069,
1070, 558, 1070,
1071, 559, 1071,
1072, 560, 1072,
1073, 561, 1073,
1074, 562, 1074,
1075, 563, 1075,
1076, 564, 1076,
1077, 565, 1077,
1078, 566, 1078,
1079, 567, 1079,
1080, 568, 1080,
1081, 569, 1081,
1082, 570, 1082,
1083, 571, 1083,
1084, 572, 1084,
1085, 573, 1085,
1086, 574, 1086,
1087, 575, 1087,
1088, 576, 1088,
1089, 577, 1089,
1090, 578, 1090,
1091, 579, 1091,
1092, 580, 1092,
1093, 581, 1093,
1094, 582, 1094,
1095, 583, 1095,
1096, 584, 1096,
1097, 585, 1097,
1098, 586, 1098,
1099, 587, 1099,
1100, 588, 1100,
1101, 589, 1101,
1102, 590, 1102,
1103, 591, 1103,
1104, 592, 1104,
1105, 593, 1105,
1106, 594, 1106,
1107, 595, 1107,
1108, 596, 1108,
1109, 597, 1109,
1110, 598, 1110,
1111, 599, 1111,
1112, 600, 1112,
1113, 601, 1113,
1114, 602, 1114,
1115, 603, 1115,
1116, 604, 1116,
1117, 605, 1117,
1118, 606, 1118,
1119, 607, 1119,
1120, 608, 1120,
1121, 609, 1121,
1122, 610, 1122,
1123, 611, 1123,
1124, 612, 1124,
1125, 613, 1125,
1126, 614, 1126,
1127, 615, 1127,
1128, 616, 1128,
1129, 617, 1129,
1130, 618, 1130,
1131, 619, 1131,
1132, 620, 1132,
1133, 621, 1133,
1134, 622, 1134,
1135, 623, 1135,
1136, 624, 1136,
1137, 625, 1137,
1138, 626, 1138,
1139, 627, 1139,
1140, 628, 1140,
1141, 629, 1141,
1142, 630, 1142,
1143, 631, 1143,
1144, 632, 1144,
1145, 633, 1145,
1146, 634, 1146,
1147, 635, 1147,
1148, 636, 1148,
1149, 637, 1149,
1150, 638, 1150,
1151, 639, 1151,
1152, 640, 1152,
1153, 641, 1153,
1154, 642, 1154,
1155, 643, 1155,
1156, 644, 1156,
1157, 645, 1157,
1158, 646, 1158,
1159, 647, 1159,
1160, 648, 1160,
1161, 649, 1161,
1162, 650, 1162,
1163, 651, 1163,
1164, 652, 1164,
1165, 653, 1165,
1166, 654, 1166,
1167, 655, 1167,
1168, 656, 1168,
1169, 657, 1169,
1170, 658, 1170,
1171, 659, 1171,
1172, 660, 1172,
1173, 661, 1173,
1174, 662, 1174,
1175, 663, 1175,
1176, 664, 1176,
1177, 665, 1177,
1178, 666, 1178,
1179, 667, 1179,
1180, 668, 1180,
1181, 669, 1181,
1182, 670, 1182,
1183, 671, 1183,
1184, 672, 1184,
1185, 673, 1185,
1186, 674, 1186,
1187, 675, 1187,
1188, 676, 1188,
1189, 677, 1189,
1190, 678, 1190,
1191, 679, 1191,
1192, 680, 1192,
1193, 681, 1193,
1194, 682, 1194,
1195, 683, 1195,
1196, 684, 1196,
1197, 685, 1197,
1198, 686, 1198,
1199, 687, 1199,
1200, 688, 1200,
1201, 689, 1201,
1202, 690, 1202,
1203, 691, 1203,
1204, 692, 1204,
1205, 693, 1205,
1206, 694, 1206,
1207, 695, 1207,
1208, 696, 1208,
1209, 697, 1209,
1210, 698, 1210,
1211, 699, 1211,
1212, 700, 1212,
1213, 701, 1213,
1214, 702, 1214,
1215, 703, 1215,
1216, 704, 1216,
1217, 705, 1217,
1218, 706, 1218,
1219, 707, 1219,
1220, 708, 1220,
1221, 709, 1221,
1222, 710, 1222,
1223, 711, 1223,
1224, 712, 1224,
1225, 713, 1225,
1226, 714, 1226,
1227, 715, 1227,
1228, 716, 1228,
1229, 717, 1229,
1230, 718, 1230,
1231, 719, 1231,
1232, 720, 1232,
1233, 721, 1233,
1234, 722, 1234,
1235, 723, 1235,
1236, 724, 1236,
1237, 725, 1237,
1238, 726, 1238,
1239, 727, 1239,
1240, 728, 1240,
1241, 729, 1241,
1242, 730, 1242,
1243, 731, 1243,
1244, 732, 1244,
1245, 733, 1245,
1246, 734, 1246,
1247, 735, 1247,
1248, 736, 1248,
1249, 737, 1249,
1250, 738, 1250,
1251, 739, 1251,
1252, 740, 1252,
1253, 741, 1253,
1254, 742, 1254,
1255, 743, 1255,
1256, 744, 1256,
1257, 745, 1257,
1258, 746, 1258,
1259, 747, 1259,
1260, 748, 1260,
1261, 749, 1261,
1262, 750, 1262,
1263, 751, 1263,
1264, 752, 1264,
1265, 753, 1265,
1266, 754, 1266,
1267, 755, 1267,
1268, 756, 1268,
1269, 757, 1269,
1270, 758, 1270,
1271, 759, 1271,
1272, 760, 1272,
1273, 761, 1273,
1274, 762, 1274,
1275, 763, 1275,
1276, 764, 1276,
1277, 765, 1277,
1278, 766, 1278,
1279, 767, 1279,
1280, 768, 1280,
1281, 769, 1281,
1282, 770, 1282,
1283, 771, 1283,
1284, 772, 1284,
1285, 773, 1285,
1286, 774, 1286,
1287, 775, 1287,
1288, 776, 1288,
1289, 777, 1289,
1290, 778, 1290,
1291, 779, 1291,
1292, 780, 1292,
1293, 781, 1293,
1294, 782, 1294,
1295, 783, 1295,
1296, 784, 1296,
1297, 785, 1297,
1298, 786, 1298,
1299, 787, 1299,
1300, 788, 1300,
1301, 789, 1301,
1302, 790, 1302,
1303, 791, 1303,
1304, 792, 1304,
1305, 793, 1305,
1306, 794, 1306,
1307, 795, 1307,
1308, 796, 1308,
1309, 797, 1309,
1310, 798, 1310,
1311, 799, 1311,
1312, 800, 1312,
1313, 801, 1313,
1314, 802, 1314,
1315, 803, 1315,
1316, 804, 1316,
1317, 805, 1317,
1318, 806, 1318,
1319, 807, 1319,
1320, 808, 1320,
1321, 809, 1321,
1322, 810, 1322,
1323, 811, 1323,
1324, 812, 1324,
1325, 813, 1325,
1326, 814, 1326,
1327, 815, 1327,
1328, 816, 1328,
1329, 817, 1329,
1330, 818, 1330,
1331, 819, 1331,
1332, 820, 1332,
1333, 821, 1333,
1334, 822, 1334,
1335, 823, 1335,
1336, 824, 1336,
1337, 825, 1337,
1338, 826, 1338,
1339, 827, 1339,
1340, 828, 1340,
1341, 829, 1341,
1342, 830, 1342,
1343, 831, 1343,
1344, 832, 1344,
1345, 833, 1345,
1346, 834, 1346,
1347, 835, 1347,
1348, 836, 1348,
1349, 837, 1349,
1350, 838, 1350,
1351, 839, 1351,
1352, 840, 1352,
1353, 841, 1353,
1354, 842, 1354,
1355, 843, 1355,
1356, 844, 1356,
1357, 845, 1357,
1358, 846, 1358,
1359, 847, 1359,
1360, 848, 1360,
1361, 849, 1361,
1362, 850, 1362,
1363, 851, 1363,
1364, 852, 1364,
1365, 853, 1365,
1366, 854, 1366,
1367, 855, 1367,
1368, 856, 1368,
1369, 857, 1369,
1370, 858, 1370,
1371, 859, 1371,
1372, 860, 1372,
1373, 861, 1373,
1374, 862, 1374,
1375, 863, 1375,
1376, 864, 1376,
1377, 865, 1377,
1378, 866, 1378,
1379, 867, 1379,
1380, 868, 1380,
1381, 869, 1381,
1382, 870, 1382,
1383, 871, 1383,
1384, 872, 1384,
1385, 873, 1385,
1386, 874, 1386,
1387, 875, 1387,
1388, 876, 1388,
1389, 877, 1389,
1390, 878, 1390,
1391, 879, 1391,
1392, 880, 1392,
1393, 881, 1393,
1394, 882, 1394,
1395, 883, 1395,
1396, 884, 1396,
1397, 885, 1397,
1398, 886, 1398,
1399, 887, 1399,
1400, 888, 1400,
1401, 889, 1401,
1402, 890, 1402,
1403, 891, 1403,
1404, 892, 1404,
1405, 893, 1405,
1406, 894, 1406,
1407, 895, 1407,
1408, 896, 1408,
1409, 897, 1409,
1410, 898, 1410,
1411, 899, 1411,
1412, 900, 1412,
1413, 901, 1413,
1414, 902, 1414,
1415, 903, 1415,
1416, 904, 1416,
1417, 905, 1417,
1418, 906, 1418,
1419, 907, 1419,
1420, 908, 1420,
1421, 909, 1421,
1422, 910, 1422,
1423, 911, 1423,
1424, 912, 1424,
1425, 913, 1425,
1426, 914, 1426,
1427, 915, 1427,
1428, 916, 1428,
1429, 917, 1429,
1430, 918, 1430,
1431, 919, 1431,
1432, 920, 1432,
1433, 921, 1433,
1434, 922, 1434,
1435, 923, 1435,
1436, 924, 1436,
1437, 925, 1437,
1438, 926, 1438,
1439, 927, 1439,
1440, 928, 1440,
1441, 929, 1441,
1442, 930, 1442,
1443, 931, 1443,
1444, 932, 1444,
1445, 933, 1445,
1446, 934, 1446,
1447, 935, 1447,
1448, 936, 1448,
1449, 937, 1449,
1450, 938, 1450,
1451, 939, 1451,
1452, 940, 1452,
1453, 941, 1453,
1454, 942, 1454,
1455, 943, 1455,
1456, 944, 1456,
1457, 945, 1457,
1458, 946, 1458,
1459, 947, 1459,
1460, 948, 1460,
1461, 949, 1461,
1462, 950, 1462,
1463, 951, 1463,
1464, 952, 1464,
1465, 953, 1465,
1466, 954, 1466,
1467, 955, 1467,
1468, 956, 1468,
1469, 957, 1469,
1470, 958, 1470,
1471, 959, 1471,
1472, 960, 1472,
1473, 961, 1473,
1474, 962, 1474,
1475, 963, 1475,
1476, 964, 1476,
1477, 965, 1477,
1478, 966, 1478,
1479, 967, 1479,
1480, 968, 1480,
1481, 969, 1481,
1482, 970, 1482,
1483, 971, 1483,
1484, 972, 1484,
1485, 973, 1485,
1486, 974, 1486,
1487, 975, 1487,
1488, 976, 1488,
1489, 977, 1489,
1490, 978, 1490,
1491, 979, 1491,
1492, 980, 1492,
1493, 981, 1493,
1494, 982, 1494,
1495, 983, 1495,
1496, 984, 1496,
1497, 985, 1497,
1498, 986, 1498,
1499, 987, 1499,
1500, 988, 1500,
1501, 989, 1501,
1502, 990, 1502,
1503, 991, 1503,
1504, 992, 1504,
1505, 993, 1505,
1506, 994, 1506,
1507, 995, 1507,
1508, 996, 1508,
1509, 997, 1509,
1510, 998, 1510,
1511, 999, 1511,
1512, 1000, 1512,
1513, 1001, 1513,
1514, 1002, 1514,
1515, 1003, 1515,
1516, 1004, 1516,
1517, 1005, 1517,
1518, 1006, 1518,
1519, 1007, 1519,
1520, 1008, 1520,
1521, 1009, 1521,
1522, 1010, 1522,
1523, 1011, 1523,
1524, 1012, 1524,
1525, 1013, 1525,
1526, 1014, 1526,
1527, 1015, 1527,
1528, 1016, 1528,
1529, 1017, 1529,
1530, 1018, 1530,
1531, 1019, 1531,
1532, 1020, 1532,
1533, 1021, 1533,
1534, 1022, 1534,
1535, 1023, 1535,
1536, 1024, 1536,
1537, 1025, 1537,
1538, 1026, 1538,
1539, 1027, 1539,
1540, 1028, 1540,
1541, 1029, 1541,
1542, 1030, 1542,
1543, 1031, 1543,
1544, 1032, 1544,
1545, 1033, 1545,
1546, 1034, 1546,
1547, 1035, 1547,
1548, 1036, 1548,
1549, 1037, 1549,
1550, 1038, 1550,
1551, 1039, 1551,
1552, 1040, 1552,
1553, 1041, 1553,
1554, 1042, 1554,
1555, 1043, 1555,
1556, 1044, 1556,
1557, 1045, 1557,
1558, 1046, 1558,
1559, 1047, 1559,
1560, 1048, 1560,
1561, 1049, 1561,
1562, 1050, 1562,
1563, 1051, 1563,
1564, 1052, 1564,
1565, 1053, 1565,
1566, 1054, 1566,
1567, 1055, 1567,
1568, 1056, 1568,
1569, 1057, 1569,
1570, 1058, 1570,
1571, 1059, 1571,
1572, 1060, 1572,
1573, 1061, 1573,
1574, 1062, 1574,
1575, 1063, 1575,
1576, 1064, 1576,
1577, 1065, 1577,
1578, 1066, 1578,
1579, 1067, 1579,
1580, 1068, 1580,
1581, 1069, 1581,
1582, 1070, 1582,
1583, 1071, 1583,
1584, 1072, 1584,
1585, 1073, 1585,
1586, 1074, 1586,
1587, 1075, 1587,
1588, 1076, 1588,
1589, 1077, 1589,
1590, 1078, 1590,
1591, 1079, 1591,
1592, 1080, 1592,
1593, 1081, 1593,
1594, 1082, 1594,
1595, 1083, 1595,
1596, 1084, 1596,
1597, 1085, 1597,
1598, 1086, 1598,
1599, 1087, 1599,
1600, 1088, 1600,
1601, 1089, 1601,
1602, 1090, 1602,
1603, 1091, 1603,
1604, 1092, 1604,
1605, 1093, 1605,
1606, 1094, 1606,
1607, 1095, 1607,
1608, 1096, 1608,
1609, 1097, 1609,
1610, 1098, 1610,
1611, 1099, 1611,
1612, 1100, 1612,
1613, 1101, 1613,
1614, 1102, 1614,
1615, 1103, 1615,
1616, 1104, 1616,
1617, 1105, 1617,
1618, 1106, 1618,
1619, 1107, 1619,
1620, 1108, 1620,
1621, 1109, 1621,
1622, 1110, 1622,
1623, 1111, 1623,
1624, 1112, 1624,
1625, 1113, 1625,
1626, 1114, 1626,
1627, 1115, 1627,
1628, 1116, 1628,
1629, 1117, 1629,
1630, 1118, 1630,
1631, 1119, 1631,
1632, 1120, 1632,
1633, 1121, 1633,
1634, 1122, 1634,
1635, 1123, 1635,
1636, 1124, 1636,
1637, 1125, 1637,
1638, 1126, 1638,
1639, 1127, 1639,
1640, 1128, 1640,
1641, 1129, 1641,
1642, 1130, 1642,
1643, 1131, 1643,
1644, 1132, 1644,
1645, 1133, 1645,
1646, 1134, 1646,
1647, 1135, 1647,
1648, 1136, 1648,
1649, 1137, 1649,
1650, 1138, 1650,
1651, 1139, 1651,
1652, 1140, 1652,
1653, 1141, 1653,
1654, 1142, 1654,
1655, 1143, 1655,
1656, 1144, 1656,
1657, 1145, 1657,
1658, 1146, 1658,
1659, 1147, 1659,
1660, 1148, 1660,
1661, 1149, 1661,
1662, 1150, 1662,
1663, 1151, 1663,
1664, 1152, 1664,
1665, 1153, 1665,
1666, 1154, 1666,
1667, 1155, 1667,
1668, 1156, 1668,
1669, 1157, 1669,
1670, 1158, 1670,
1671, 1159, 1671,
1672, 1160, 1672,
1673, 1161, 1673,
1674, 1162, 1674,
1675, 1163, 1675,
1676, 1164, 1676,
1677, 1165, 1677,
1678, 1166, 1678,
1679, 1167, 1679,
1680, 1168, 1680,
1681, 1169, 1681,
1682, 1170, 1682,
1683, 1171, 1683,
1684, 1172, 1684,
1685, 1173, 1685,
1686, 1174, 1686,
1687, 1175, 1687,
1688, 1176, 1688,
1689, 1177, 1689,
1690, 1178, 1690,
1691, 1179, 1691,
1692, 1180, 1692,
1693, 1181, 1693,
1694, 1182, 1694,
1695, 1183, 1695,
1696, 1184, 1696,
1697, 1185, 1697,
1698, 1186, 1698,
1699, 1187, 1699,
1700, 1188, 1700,
1701, 1189, 1701,
1702, 1190, 1702,
1703, 1191, 1703,
1704, 1192, 1704,
1705, 1193, 1705,
1706, 1194, 1706,
1707, 1195, 1707,
1708, 1196, 1708,
1709, 1197, 1709,
1710, 1198, 1710,
1711, 1199, 1711,
1712, 1200, 1712,
1713, 1201, 1713,
1714, 1202, 1714,
1715, 1203, 1715,
1716, 1204, 1716,
1717, 1205, 1717,
1718, 1206, 1718,
1719, 1207, 1719,
1720, 1208, 1720,
1721, 1209, 1721,
1722, 1210, 1722,
1723, 1211, 1723,
1724, 1212, 1724,
1725, 1213, 1725,
1726, 1214, 1726,
1727, 1215, 1727,
1728, 1216, 1728,
1729, 1217, 1729,
1730, 1218, 1730,
1731, 1219, 1731,
1732, 1220, 1732,
1733, 1221, 1733,
1734, 1222, 1734,
1735, 1223, 1735,
1736, 1224, 1736,
1737, 1225, 1737,
1738, 1226, 1738,
1739, 1227, 1739,
1740, 1228, 1740,
1741, 1229, 1741,
1742, 1230, 1742,
1743, 1231, 1743,
1744, 1232, 1744,
1745, 1233, 1745,
1746, 1234, 1746,
1747, 1235, 1747,
1748, 1236, 1748,
1749, 1237, 1749,
1750, 1238, 1750,
1751, 1239, 1751,
1752, 1240, 1752,
1753, 1241, 1753,
1754, 1242, 1754,
1755, 1243, 1755,
1756, 1244, 1756,
1757, 1245, 1757,
1758, 1246, 1758,
1759, 1247, 1759,
1760, 1248, 1760,
1761, 1249, 1761,
1762, 1250, 1762,
1763, 1251, 1763,
1764, 1252, 1764,
1765, 1253, 1765,
1766, 1254, 1766,
1767, 1255, 1767,
1768, 1256, 1768,
1769, 1257, 1769,
1770, 1258, 1770,
1771, 1259, 1771,
1772, 1260, 1772,
1773, 1261, 1773,
1774, 1262, 1774,
1775, 1263, 1775,
1776, 1264, 1776,
1777, 1265, 1777,
1778, 1266, 1778,
1779, 1267, 1779,
1780, 1268, 1780,
1781, 1269, 1781,
1782, 1270, 1782,
1783, 1271, 1783,
1784, 1272, 1784,
1785, 1273, 1785,
1786, 1274, 1786,
1787, 1275, 1787,
1788, 1276, 1788,
1789, 1277, 1789,
1790, 1278, 1790,
1791, 1279, 1791,
1792, 1280, 1792,
1793, 1281, 1793,
1794, 1282, 1794,
1795, 1283, 1795,
1796, 1284, 1796,
1797, 1285, 1797,
1798, 1286, 1798,
1799, 1287, 1799,
1800, 1288, 1800,
1801, 1289, 1801,
1802, 1290, 1802,
1803, 1291, 1803,
1804, 1292, 1804,
1805, 1293, 1805,
1806, 1294, 1806,
1807, 1295, 1807,
1808, 1296, 1808,
1809, 1297, 1809,
1810, 1298, 1810,
1811, 1299, 1811,
1812, 1300, 1812,
1813, 1301, 1813,
1814, 1302, 1814,
1815, 1303, 1815,
1816, 1304, 1816,
1817, 1305, 1817,
1818, 1306, 1818,
1819, 1307, 1819,
1820, 1308, 1820,
1821, 1309, 1821,
1822, 1310, 1822,
1823, 1311, 1823,
1824, 1312, 1824,
1825, 1313, 1825,
1826, 1314, 1826,
1827, 1315, 1827,
1828, 1316, 1828,
1829, 1317, 1829,
1830, 1318, 1830,
1831, 1319, 1831,
1832, 1320, 1832,
1833, 1321, 1833,
1834, 1322, 1834,
1835, 1323, 1835,
1836, 1324, 1836,
1837, 1325, 1837,
1838, 1326, 1838,
1839, 1327, 1839,
1840, 1328, 1840,
1841, 1329, 1841,
1842, 1330, 1842,
1843, 1331, 1843,
1844, 1332, 1844,
1845, 1333, 1845,
1846, 1334, 1846,
1847, 1335, 1847,
1848, 1336, 1848,
1849, 1337, 1849,
1850, 1338, 1850,
1851, 1339, 1851,
1852, 1340, 1852,
1853, 1341, 1853,
1854, 1342, 1854,
1855, 1343, 1855,
1856, 1344, 1856,
1857, 1345, 1857,
1858, 1346, 1858,
1859, 1347, 1859,
1860, 1348, 1860,
1861, 1349, 1861,
1862, 1350, 1862,
1863, 1351, 1863,
1864, 1352, 1864,
1865, 1353, 1865,
1866, 1354, 1866,
1867, 1355, 1867,
1868, 1356, 1868,
1869, 1357, 1869,
1870, 1358, 1870,
1871, 1359, 1871,
1872, 1360, 1872,
1873, 1361, 1873,
1874, 1362, 1874,
1875, 1363, 1875,
1876, 1364, 1876,
1877, 1365, 1877,
1878, 1366, 1878,
1879, 1367, 1879,
1880, 1368, 1880,
1881, 1369, 1881,
1882, 1370, 1882,
1883, 1371, 1883,
1884, 1372, 1884,
1885, 1373, 1885,
1886, 1374, 1886,
1887, 1375, 1887,
1888, 1376, 1888,
1889, 1377, 1889,
1890, 1378, 1890,
1891, 1379, 1891,
1892, 1380, 1892,
1893, 1381, 1893,
1894, 1382, 1894,
1895, 1383, 1895,
1896, 1384, 1896,
1897, 1385, 1897,
1898, 1386, 1898,
1899, 1387, 1899,
1900, 1388, 1900,
1901, 1389, 1901,
1902, 1390, 1902,
1903, 1391, 1903,
1904, 1392, 1904,
1905, 1393, 1905,
1906, 1394, 1906,
1907, 1395, 1907,
1908, 1396, 1908,
1909, 1397, 1909,
1910, 1398, 1910,
1911, 1399, 1911,
1912, 1400, 1912,
1913, 1401, 1913,
1914, 1402, 1914,
1915, 1403, 1915,
1916, 1404, 1916,
1917, 1405, 1917,
1918, 1406, 1918,
1919, 1407, 1919,
1920, 1408, 1920,
1921, 1409, 1921,
1922, 1410, 1922,
1923, 1411, 1923,
1924, 1412, 1924,
1925, 1413, 1925,
1926, 1414, 1926,
1927, 1415, 1927,
1928, 1416, 1928,
1929, 1417, 1929,
1930, 1418, 1930,
1931, 1419, 1931,
1932, 1420, 1932,
1933, 1421, 1933,
1934, 1422, 1934,
1935, 1423, 1935,
1936, 1424, 1936,
1937, 1425, 1937,
1938, 1426, 1938,
1939, 1427, 1939,
1940, 1428, 1940,
1941, 1429, 1941,
1942, 1430, 1942,
1943, 1431, 1943,
1944, 1432, 1944,
1945, 1433, 1945,
1946, 1434, 1946,
1947, 1435, 1947,
1948, 1436, 1948,
1949, 1437, 1949,
1950, 1438, 1950,
1951, 1439, 1951,
1952, 1440, 1952,
1953, 1441, 1953,
1954, 1442, 1954,
1955, 1443, 1955,
1956, 1444, 1956,
1957, 1445, 1957,
1958, 1446, 1958,
1959, 1447, 1959,
1960, 1448, 1960,
1961, 1449, 1961,
1962, 1450, 1962,
1963, 1451, 1963,
1964, 1452, 1964,
1965, 1453, 1965,
1966, 1454, 1966,
1967, 1455, 1967,
1968, 1456, 1968,
1969, 1457, 1969,
1970, 1458, 1970,
1971, 1459, 1971,
1972, 1460, 1972,
1973, 1461, 1973,
1974, 1462, 1974,
1975, 1463, 1975,
1976, 1464, 1976,
1977, 1465, 1977,
1978, 1466, 1978,
1979, 1467, 1979,
1980, 1468, 1980,
1981, 1469, 1981,
1982, 1470, 1982,
1983, 1471, 1983,
1984, 1472, 1984,
1985, 1473, 1985,
1986, 1474, 1986,
1987, 1475, 1987,
1988, 1476, 1988,
1989, 1477, 1989,
1990, 1478, 1990,
1991, 1479, 1991,
1992, 1480, 1992,
1993, 1481, 1993,
1994, 1482, 1994,
1995, 1483, 1995,
1996, 1484, 1996,
1997, 1485, 1997,
1998, 1486, 1998,
1999, 1487, 1999,
2000, 1488, 2000,
2001, 1489, 2001,
2002, 1490, 2002,
2003, 1491, 2003,
2004, 1492, 2004,
2005, 1493, 2005,
2006, 1494, 2006,
2007, 1495, 2007,
2008, 1496, 2008,
2009, 1497, 2009,
2010, 1498, 2010,
2011, 1499, 2011,
2012, 1500, 2012,
2013, 1501, 2013,
2014, 1502, 2014,
2015, 1503, 2015,
2016, 1504, 2016,
2017, 1505, 2017,
2018, 1506, 2018,
2019, 1507, 2019,
2020, 1508, 2020,
2021, 1509, 2021,
2022, 1510, 2022,
2023, 1511, 2023,
2024, 1512, 2024,
2025, 1513, 2025,
2026, 1514, 2026,
2027, 1515, 2027,
2028, 1516, 2028,
2029, 1517, 2029,
2030, 1518, 2030,
2031, 1519, 2031,
2032, 1520, 2032,
2033, 1521, 2033,
2034, 1522, 2034,
2035, 1523, 2035,
2036, 1524, 2036,
2037, 1525, 2037,
2038, 1526, 2038,
2039, 1527, 2039,
2040, 1528, 2040,
2041, 1529, 2041,
2042, 1530, 2042,
2043, 1531, 2043,
2044, 1532, 2044,
2045, 1533, 2045,
2046, 1534, 2046,
2047, 1535, 2047
 };
#pragma line 270 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_2_3_1_trichk.h" 1
vars_3_23 varinx10A_1024_a[] = {
27, 94, 171,
28, 95, 172,
29, 96, 173,
30, 97, 174,
31, 98, 175,
32, 99, 176,
33, 100, 177,
34, 101, 178,
35, 102, 179,
36, 103, 180,
37, 104, 181,
38, 105, 182,
39, 106, 183,
40, 107, 184,
41, 108, 185,
42, 109, 186,
43, 110, 187,
44, 111, 188,
45, 112, 189,
46, 113, 190,
47, 114, 191,
48, 115, 128,
49, 116, 129,
50, 117, 130,
51, 118, 131,
52, 119, 132,
53, 120, 133,
54, 121, 134,
55, 122, 135,
56, 123, 136,
57, 124, 137,
58, 125, 138,
59, 126, 139,
60, 127, 140,
61, 64, 141,
62, 65, 142,
63, 66, 143,
0, 67, 144,
1, 68, 145,
2, 69, 146,
3, 70, 147,
4, 71, 148,
5, 72, 149,
6, 73, 150,
7, 74, 151,
8, 75, 152,
9, 76, 153,
10, 77, 154,
11, 78, 155,
12, 79, 156,
13, 80, 157,
14, 81, 158,
15, 82, 159,
16, 83, 160,
17, 84, 161,
18, 85, 162,
19, 86, 163,
20, 87, 164,
21, 88, 165,
22, 89, 166,
23, 90, 167,
24, 91, 168,
25, 92, 169,
26, 93, 170,
103, 142, 214,
104, 143, 215,
105, 144, 216,
106, 145, 217,
107, 146, 218,
108, 147, 219,
109, 148, 220,
110, 149, 221,
111, 150, 222,
112, 151, 223,
113, 152, 224,
114, 153, 225,
115, 154, 226,
116, 155, 227,
117, 156, 228,
118, 157, 229,
119, 158, 230,
120, 159, 231,
121, 160, 232,
122, 161, 233,
123, 162, 234,
124, 163, 235,
125, 164, 236,
126, 165, 237,
127, 166, 238,
64, 167, 239,
65, 168, 240,
66, 169, 241,
67, 170, 242,
68, 171, 243,
69, 172, 244,
70, 173, 245,
71, 174, 246,
72, 175, 247,
73, 176, 248,
74, 177, 249,
75, 178, 250,
76, 179, 251,
77, 180, 252,
78, 181, 253,
79, 182, 254,
80, 183, 255,
81, 184, 192,
82, 185, 193,
83, 186, 194,
84, 187, 195,
85, 188, 196,
86, 189, 197,
87, 190, 198,
88, 191, 199,
89, 128, 200,
90, 129, 201,
91, 130, 202,
92, 131, 203,
93, 132, 204,
94, 133, 205,
95, 134, 206,
96, 135, 207,
97, 136, 208,
98, 137, 209,
99, 138, 210,
100, 139, 211,
101, 140, 212,
102, 141, 213,
36, 137, 241,
37, 138, 242,
38, 139, 243,
39, 140, 244,
40, 141, 245,
41, 142, 246,
42, 143, 247,
43, 144, 248,
44, 145, 249,
45, 146, 250,
46, 147, 251,
47, 148, 252,
48, 149, 253,
49, 150, 254,
50, 151, 255,
51, 152, 192,
52, 153, 193,
53, 154, 194,
54, 155, 195,
55, 156, 196,
56, 157, 197,
57, 158, 198,
58, 159, 199,
59, 160, 200,
60, 161, 201,
61, 162, 202,
62, 163, 203,
63, 164, 204,
0, 165, 205,
1, 166, 206,
2, 167, 207,
3, 168, 208,
4, 169, 209,
5, 170, 210,
6, 171, 211,
7, 172, 212,
8, 173, 213,
9, 174, 214,
10, 175, 215,
11, 176, 216,
12, 177, 217,
13, 178, 218,
14, 179, 219,
15, 180, 220,
16, 181, 221,
17, 182, 222,
18, 183, 223,
19, 184, 224,
20, 185, 225,
21, 186, 226,
22, 187, 227,
23, 188, 228,
24, 189, 229,
25, 190, 230,
26, 191, 231,
27, 128, 232,
28, 129, 233,
29, 130, 234,
30, 131, 235,
31, 132, 236,
32, 133, 237,
33, 134, 238,
34, 135, 239,
35, 136, 240,
30, 117, 194,
31, 118, 195,
32, 119, 196,
33, 120, 197,
34, 121, 198,
35, 122, 199,
36, 123, 200,
37, 124, 201,
38, 125, 202,
39, 126, 203,
40, 127, 204,
41, 64, 205,
42, 65, 206,
43, 66, 207,
44, 67, 208,
45, 68, 209,
46, 69, 210,
47, 70, 211,
48, 71, 212,
49, 72, 213,
50, 73, 214,
51, 74, 215,
52, 75, 216,
53, 76, 217,
54, 77, 218,
55, 78, 219,
56, 79, 220,
57, 80, 221,
58, 81, 222,
59, 82, 223,
60, 83, 224,
61, 84, 225,
62, 85, 226,
63, 86, 227,
0, 87, 228,
1, 88, 229,
2, 89, 230,
3, 90, 231,
4, 91, 232,
5, 92, 233,
6, 93, 234,
7, 94, 235,
8, 95, 236,
9, 96, 237,
10, 97, 238,
11, 98, 239,
12, 99, 240,
13, 100, 241,
14, 101, 242,
15, 102, 243,
16, 103, 244,
17, 104, 245,
18, 105, 246,
19, 106, 247,
20, 107, 248,
21, 108, 249,
22, 109, 250,
23, 110, 251,
24, 111, 252,
25, 112, 253,
26, 113, 254,
27, 114, 255,
28, 115, 192,
29, 116, 193};
#pragma empty_line
vars_3_23 varinx10B_1024_a[] = {
0, 14, 174,
1, 15, 175,
2, 16, 176,
3, 17, 177,
4, 18, 178,
5, 19, 179,
6, 20, 180,
7, 21, 181,
8, 22, 182,
9, 23, 183,
10, 24, 184,
11, 25, 185,
12, 26, 186,
13, 27, 187,
14, 28, 188,
15, 29, 189,
16, 30, 190,
17, 31, 191,
18, 32, 128,
19, 33, 129,
20, 34, 130,
21, 35, 131,
22, 36, 132,
23, 37, 133,
24, 38, 134,
25, 39, 135,
26, 40, 136,
27, 41, 137,
28, 42, 138,
29, 43, 139,
30, 44, 140,
31, 45, 141,
32, 46, 142,
33, 47, 143,
34, 48, 144,
35, 49, 145,
36, 50, 146,
37, 51, 147,
38, 52, 148,
39, 53, 149,
40, 54, 150,
41, 55, 151,
42, 56, 152,
43, 57, 153,
44, 58, 154,
45, 59, 155,
46, 60, 156,
47, 61, 157,
48, 62, 158,
49, 63, 159,
50, 0, 160,
51, 1, 161,
52, 2, 162,
53, 3, 163,
54, 4, 164,
55, 5, 165,
56, 6, 166,
57, 7, 167,
58, 8, 168,
59, 9, 169,
60, 10, 170,
61, 11, 171,
62, 12, 172,
63, 13, 173,
64, 55, 79,
65, 56, 80,
66, 57, 81,
67, 58, 82,
68, 59, 83,
69, 60, 84,
70, 61, 85,
71, 62, 86,
72, 63, 87,
73, 0, 88,
74, 1, 89,
75, 2, 90,
76, 3, 91,
77, 4, 92,
78, 5, 93,
79, 6, 94,
80, 7, 95,
81, 8, 96,
82, 9, 97,
83, 10, 98,
84, 11, 99,
85, 12, 100,
86, 13, 101,
87, 14, 102,
88, 15, 103,
89, 16, 104,
90, 17, 105,
91, 18, 106,
92, 19, 107,
93, 20, 108,
94, 21, 109,
95, 22, 110,
96, 23, 111,
97, 24, 112,
98, 25, 113,
99, 26, 114,
100, 27, 115,
101, 28, 116,
102, 29, 117,
103, 30, 118,
104, 31, 119,
105, 32, 120,
106, 33, 121,
107, 34, 122,
108, 35, 123,
109, 36, 124,
110, 37, 125,
111, 38, 126,
112, 39, 127,
113, 40, 64,
114, 41, 65,
115, 42, 66,
116, 43, 67,
117, 44, 68,
118, 45, 69,
119, 46, 70,
120, 47, 71,
121, 48, 72,
122, 49, 73,
123, 50, 74,
124, 51, 75,
125, 52, 76,
126, 53, 77,
127, 54, 78,
128, 11, 82,
129, 12, 83,
130, 13, 84,
131, 14, 85,
132, 15, 86,
133, 16, 87,
134, 17, 88,
135, 18, 89,
136, 19, 90,
137, 20, 91,
138, 21, 92,
139, 22, 93,
140, 23, 94,
141, 24, 95,
142, 25, 96,
143, 26, 97,
144, 27, 98,
145, 28, 99,
146, 29, 100,
147, 30, 101,
148, 31, 102,
149, 32, 103,
150, 33, 104,
151, 34, 105,
152, 35, 106,
153, 36, 107,
154, 37, 108,
155, 38, 109,
156, 39, 110,
157, 40, 111,
158, 41, 112,
159, 42, 113,
160, 43, 114,
161, 44, 115,
162, 45, 116,
163, 46, 117,
164, 47, 118,
165, 48, 119,
166, 49, 120,
167, 50, 121,
168, 51, 122,
169, 52, 123,
170, 53, 124,
171, 54, 125,
172, 55, 126,
173, 56, 127,
174, 57, 64,
175, 58, 65,
176, 59, 66,
177, 60, 67,
178, 61, 68,
179, 62, 69,
180, 63, 70,
181, 0, 71,
182, 1, 72,
183, 2, 73,
184, 3, 74,
185, 4, 75,
186, 5, 76,
187, 6, 77,
188, 7, 78,
189, 8, 79,
190, 9, 80,
191, 10, 81,
192, 93, 165,
193, 94, 166,
194, 95, 167,
195, 96, 168,
196, 97, 169,
197, 98, 170,
198, 99, 171,
199, 100, 172,
200, 101, 173,
201, 102, 174,
202, 103, 175,
203, 104, 176,
204, 105, 177,
205, 106, 178,
206, 107, 179,
207, 108, 180,
208, 109, 181,
209, 110, 182,
210, 111, 183,
211, 112, 184,
212, 113, 185,
213, 114, 186,
214, 115, 187,
215, 116, 188,
216, 117, 189,
217, 118, 190,
218, 119, 191,
219, 120, 128,
220, 121, 129,
221, 122, 130,
222, 123, 131,
223, 124, 132,
224, 125, 133,
225, 126, 134,
226, 127, 135,
227, 64, 136,
228, 65, 137,
229, 66, 138,
230, 67, 139,
231, 68, 140,
232, 69, 141,
233, 70, 142,
234, 71, 143,
235, 72, 144,
236, 73, 145,
237, 74, 146,
238, 75, 147,
239, 76, 148,
240, 77, 149,
241, 78, 150,
242, 79, 151,
243, 80, 152,
244, 81, 153,
245, 82, 154,
246, 83, 155,
247, 84, 156,
248, 85, 157,
249, 86, 158,
250, 87, 159,
251, 88, 160,
252, 89, 161,
253, 90, 162,
254, 91, 163,
255, 92, 164
 };
#pragma line 272 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_2_3_2_trichk.h" 1
vars_3_23 varinx10A_1024_b[] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127,
128, 128, 128,
129, 129, 129,
130, 130, 130,
131, 131, 131,
132, 132, 132,
133, 133, 133,
134, 134, 134,
135, 135, 135,
136, 136, 136,
137, 137, 137,
138, 138, 138,
139, 139, 139,
140, 140, 140,
141, 141, 141,
142, 142, 142,
143, 143, 143,
144, 144, 144,
145, 145, 145,
146, 146, 146,
147, 147, 147,
148, 148, 148,
149, 149, 149,
150, 150, 150,
151, 151, 151,
152, 152, 152,
153, 153, 153,
154, 154, 154,
155, 155, 155,
156, 156, 156,
157, 157, 157,
158, 158, 158,
159, 159, 159,
160, 160, 160,
161, 161, 161,
162, 162, 162,
163, 163, 163,
164, 164, 164,
165, 165, 165,
166, 166, 166,
167, 167, 167,
168, 168, 168,
169, 169, 169,
170, 170, 170,
171, 171, 171,
172, 172, 172,
173, 173, 173,
174, 174, 174,
175, 175, 175,
176, 176, 176,
177, 177, 177,
178, 178, 178,
179, 179, 179,
180, 180, 180,
181, 181, 181,
182, 182, 182,
183, 183, 183,
184, 184, 184,
185, 185, 185,
186, 186, 186,
187, 187, 187,
188, 188, 188,
189, 189, 189,
190, 190, 190,
191, 191, 191,
192, 192, 192,
193, 193, 193,
194, 194, 194,
195, 195, 195,
196, 196, 196,
197, 197, 197,
198, 198, 198,
199, 199, 199,
200, 200, 200,
201, 201, 201,
202, 202, 202,
203, 203, 203,
204, 204, 204,
205, 205, 205,
206, 206, 206,
207, 207, 207,
208, 208, 208,
209, 209, 209,
210, 210, 210,
211, 211, 211,
212, 212, 212,
213, 213, 213,
214, 214, 214,
215, 215, 215,
216, 216, 216,
217, 217, 217,
218, 218, 218,
219, 219, 219,
220, 220, 220,
221, 221, 221,
222, 222, 222,
223, 223, 223,
224, 224, 224,
225, 225, 225,
226, 226, 226,
227, 227, 227,
228, 228, 228,
229, 229, 229,
230, 230, 230,
231, 231, 231,
232, 232, 232,
233, 233, 233,
234, 234, 234,
235, 235, 235,
236, 236, 236,
237, 237, 237,
238, 238, 238,
239, 239, 239,
240, 240, 240,
241, 241, 241,
242, 242, 242,
243, 243, 243,
244, 244, 244,
245, 245, 245,
246, 246, 246,
247, 247, 247,
248, 248, 248,
249, 249, 249,
250, 250, 250,
251, 251, 251,
252, 252, 252,
253, 253, 253,
254, 254, 254,
255, 255, 255};
#pragma empty_line
vars_3_23 varinx10B_1024_b[] = {
254, 0, 139,
255, 1, 140,
192, 2, 141,
193, 3, 142,
194, 4, 143,
195, 5, 144,
196, 6, 145,
197, 7, 146,
198, 8, 147,
199, 9, 148,
200, 10, 149,
201, 11, 150,
202, 12, 151,
203, 13, 152,
204, 14, 153,
205, 15, 154,
206, 16, 155,
207, 17, 156,
208, 18, 157,
209, 19, 158,
210, 20, 159,
211, 21, 160,
212, 22, 161,
213, 23, 162,
214, 24, 163,
215, 25, 164,
216, 26, 165,
217, 27, 166,
218, 28, 167,
219, 29, 168,
220, 30, 169,
221, 31, 170,
222, 32, 171,
223, 33, 172,
224, 34, 173,
225, 35, 174,
226, 36, 175,
227, 37, 176,
228, 38, 177,
229, 39, 178,
230, 40, 179,
231, 41, 180,
232, 42, 181,
233, 43, 182,
234, 44, 183,
235, 45, 184,
236, 46, 185,
237, 47, 186,
238, 48, 187,
239, 49, 188,
240, 50, 189,
241, 51, 190,
242, 52, 191,
243, 53, 128,
244, 54, 129,
245, 55, 130,
246, 56, 131,
247, 57, 132,
248, 58, 133,
249, 59, 134,
250, 60, 135,
251, 61, 136,
252, 62, 137,
253, 63, 138,
240, 64, 29,
241, 65, 30,
242, 66, 31,
243, 67, 32,
244, 68, 33,
245, 69, 34,
246, 70, 35,
247, 71, 36,
248, 72, 37,
249, 73, 38,
250, 74, 39,
251, 75, 40,
252, 76, 41,
253, 77, 42,
254, 78, 43,
255, 79, 44,
192, 80, 45,
193, 81, 46,
194, 82, 47,
195, 83, 48,
196, 84, 49,
197, 85, 50,
198, 86, 51,
199, 87, 52,
200, 88, 53,
201, 89, 54,
202, 90, 55,
203, 91, 56,
204, 92, 57,
205, 93, 58,
206, 94, 59,
207, 95, 60,
208, 96, 61,
209, 97, 62,
210, 98, 63,
211, 99, 0,
212, 100, 1,
213, 101, 2,
214, 102, 3,
215, 103, 4,
216, 104, 5,
217, 105, 6,
218, 106, 7,
219, 107, 8,
220, 108, 9,
221, 109, 10,
222, 110, 11,
223, 111, 12,
224, 112, 13,
225, 113, 14,
226, 114, 15,
227, 115, 16,
228, 116, 17,
229, 117, 18,
230, 118, 19,
231, 119, 20,
232, 120, 21,
233, 121, 22,
234, 122, 23,
235, 123, 24,
236, 124, 25,
237, 125, 26,
238, 126, 27,
239, 127, 28,
138, 128, 48,
139, 129, 49,
140, 130, 50,
141, 131, 51,
142, 132, 52,
143, 133, 53,
144, 134, 54,
145, 135, 55,
146, 136, 56,
147, 137, 57,
148, 138, 58,
149, 139, 59,
150, 140, 60,
151, 141, 61,
152, 142, 62,
153, 143, 63,
154, 144, 0,
155, 145, 1,
156, 146, 2,
157, 147, 3,
158, 148, 4,
159, 149, 5,
160, 150, 6,
161, 151, 7,
162, 152, 8,
163, 153, 9,
164, 154, 10,
165, 155, 11,
166, 156, 12,
167, 157, 13,
168, 158, 14,
169, 159, 15,
170, 160, 16,
171, 161, 17,
172, 162, 18,
173, 163, 19,
174, 164, 20,
175, 165, 21,
176, 166, 22,
177, 167, 23,
178, 168, 24,
179, 169, 25,
180, 170, 26,
181, 171, 27,
182, 172, 28,
183, 173, 29,
184, 174, 30,
185, 175, 31,
186, 176, 32,
187, 177, 33,
188, 178, 34,
189, 179, 35,
190, 180, 36,
191, 181, 37,
128, 182, 38,
129, 183, 39,
130, 184, 40,
131, 185, 41,
132, 186, 42,
133, 187, 43,
134, 188, 44,
135, 189, 45,
136, 190, 46,
137, 191, 47,
215, 192, 79,
216, 193, 80,
217, 194, 81,
218, 195, 82,
219, 196, 83,
220, 197, 84,
221, 198, 85,
222, 199, 86,
223, 200, 87,
224, 201, 88,
225, 202, 89,
226, 203, 90,
227, 204, 91,
228, 205, 92,
229, 206, 93,
230, 207, 94,
231, 208, 95,
232, 209, 96,
233, 210, 97,
234, 211, 98,
235, 212, 99,
236, 213, 100,
237, 214, 101,
238, 215, 102,
239, 216, 103,
240, 217, 104,
241, 218, 105,
242, 219, 106,
243, 220, 107,
244, 221, 108,
245, 222, 109,
246, 223, 110,
247, 224, 111,
248, 225, 112,
249, 226, 113,
250, 227, 114,
251, 228, 115,
252, 229, 116,
253, 230, 117,
254, 231, 118,
255, 232, 119,
192, 233, 120,
193, 234, 121,
194, 235, 122,
195, 236, 123,
196, 237, 124,
197, 238, 125,
198, 239, 126,
199, 240, 127,
200, 241, 64,
201, 242, 65,
202, 243, 66,
203, 244, 67,
204, 245, 68,
205, 246, 69,
206, 247, 70,
207, 248, 71,
208, 249, 72,
209, 250, 73,
210, 251, 74,
211, 252, 75,
212, 253, 76,
213, 254, 77,
214, 255, 78
 };
#pragma line 273 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_2_3_3_trichk.h" 1
vars_3_23 varinx10A_1024_c[] = {
0, 18, 116,
1, 19, 117,
2, 20, 118,
3, 21, 119,
4, 22, 120,
5, 23, 121,
6, 24, 122,
7, 25, 123,
8, 26, 124,
9, 27, 125,
10, 28, 126,
11, 29, 127,
12, 30, 64,
13, 31, 65,
14, 32, 66,
15, 33, 67,
16, 34, 68,
17, 35, 69,
18, 36, 70,
19, 37, 71,
20, 38, 72,
21, 39, 73,
22, 40, 74,
23, 41, 75,
24, 42, 76,
25, 43, 77,
26, 44, 78,
27, 45, 79,
28, 46, 80,
29, 47, 81,
30, 48, 82,
31, 49, 83,
32, 50, 84,
33, 51, 85,
34, 52, 86,
35, 53, 87,
36, 54, 88,
37, 55, 89,
38, 56, 90,
39, 57, 91,
40, 58, 92,
41, 59, 93,
42, 60, 94,
43, 61, 95,
44, 62, 96,
45, 63, 97,
46, 0, 98,
47, 1, 99,
48, 2, 100,
49, 3, 101,
50, 4, 102,
51, 5, 103,
52, 6, 104,
53, 7, 105,
54, 8, 106,
55, 9, 107,
56, 10, 108,
57, 11, 109,
58, 12, 110,
59, 13, 111,
60, 14, 112,
61, 15, 113,
62, 16, 114,
63, 17, 115,
64, 96, 149,
65, 97, 150,
66, 98, 151,
67, 99, 152,
68, 100, 153,
69, 101, 154,
70, 102, 155,
71, 103, 156,
72, 104, 157,
73, 105, 158,
74, 106, 159,
75, 107, 160,
76, 108, 161,
77, 109, 162,
78, 110, 163,
79, 111, 164,
80, 112, 165,
81, 113, 166,
82, 114, 167,
83, 115, 168,
84, 116, 169,
85, 117, 170,
86, 118, 171,
87, 119, 172,
88, 120, 173,
89, 121, 174,
90, 122, 175,
91, 123, 176,
92, 124, 177,
93, 125, 178,
94, 126, 179,
95, 127, 180,
96, 64, 181,
97, 65, 182,
98, 66, 183,
99, 67, 184,
100, 68, 185,
101, 69, 186,
102, 70, 187,
103, 71, 188,
104, 72, 189,
105, 73, 190,
106, 74, 191,
107, 75, 128,
108, 76, 129,
109, 77, 130,
110, 78, 131,
111, 79, 132,
112, 80, 133,
113, 81, 134,
114, 82, 135,
115, 83, 136,
116, 84, 137,
117, 85, 138,
118, 86, 139,
119, 87, 140,
120, 88, 141,
121, 89, 142,
122, 90, 143,
123, 91, 144,
124, 92, 145,
125, 93, 146,
126, 94, 147,
127, 95, 148,
128, 27, 174,
129, 28, 175,
130, 29, 176,
131, 30, 177,
132, 31, 178,
133, 32, 179,
134, 33, 180,
135, 34, 181,
136, 35, 182,
137, 36, 183,
138, 37, 184,
139, 38, 185,
140, 39, 186,
141, 40, 187,
142, 41, 188,
143, 42, 189,
144, 43, 190,
145, 44, 191,
146, 45, 128,
147, 46, 129,
148, 47, 130,
149, 48, 131,
150, 49, 132,
151, 50, 133,
152, 51, 134,
153, 52, 135,
154, 53, 136,
155, 54, 137,
156, 55, 138,
157, 56, 139,
158, 57, 140,
159, 58, 141,
160, 59, 142,
161, 60, 143,
162, 61, 144,
163, 62, 145,
164, 63, 146,
165, 0, 147,
166, 1, 148,
167, 2, 149,
168, 3, 150,
169, 4, 151,
170, 5, 152,
171, 6, 153,
172, 7, 154,
173, 8, 155,
174, 9, 156,
175, 10, 157,
176, 11, 158,
177, 12, 159,
178, 13, 160,
179, 14, 161,
180, 15, 162,
181, 16, 163,
182, 17, 164,
183, 18, 165,
184, 19, 166,
185, 20, 167,
186, 21, 168,
187, 22, 169,
188, 23, 170,
189, 24, 171,
190, 25, 172,
191, 26, 173,
192, 51, 76,
193, 52, 77,
194, 53, 78,
195, 54, 79,
196, 55, 80,
197, 56, 81,
198, 57, 82,
199, 58, 83,
200, 59, 84,
201, 60, 85,
202, 61, 86,
203, 62, 87,
204, 63, 88,
205, 0, 89,
206, 1, 90,
207, 2, 91,
208, 3, 92,
209, 4, 93,
210, 5, 94,
211, 6, 95,
212, 7, 96,
213, 8, 97,
214, 9, 98,
215, 10, 99,
216, 11, 100,
217, 12, 101,
218, 13, 102,
219, 14, 103,
220, 15, 104,
221, 16, 105,
222, 17, 106,
223, 18, 107,
224, 19, 108,
225, 20, 109,
226, 21, 110,
227, 22, 111,
228, 23, 112,
229, 24, 113,
230, 25, 114,
231, 26, 115,
232, 27, 116,
233, 28, 117,
234, 29, 118,
235, 30, 119,
236, 31, 120,
237, 32, 121,
238, 33, 122,
239, 34, 123,
240, 35, 124,
241, 36, 125,
242, 37, 126,
243, 38, 127,
244, 39, 64,
245, 40, 65,
246, 41, 66,
247, 42, 67,
248, 43, 68,
249, 44, 69,
250, 45, 70,
251, 46, 71,
252, 47, 72,
253, 48, 73,
254, 49, 74,
255, 50, 75};
#pragma empty_line
vars_3_23 varinx10B_1024_c[] = {
199, 22, 89,
200, 23, 90,
201, 24, 91,
202, 25, 92,
203, 26, 93,
204, 27, 94,
205, 28, 95,
206, 29, 96,
207, 30, 97,
208, 31, 98,
209, 32, 99,
210, 33, 100,
211, 34, 101,
212, 35, 102,
213, 36, 103,
214, 37, 104,
215, 38, 105,
216, 39, 106,
217, 40, 107,
218, 41, 108,
219, 42, 109,
220, 43, 110,
221, 44, 111,
222, 45, 112,
223, 46, 113,
224, 47, 114,
225, 48, 115,
226, 49, 116,
227, 50, 117,
228, 51, 118,
229, 52, 119,
230, 53, 120,
231, 54, 121,
232, 55, 122,
233, 56, 123,
234, 57, 124,
235, 58, 125,
236, 59, 126,
237, 60, 127,
238, 61, 64,
239, 62, 65,
240, 63, 66,
241, 0, 67,
242, 1, 68,
243, 2, 69,
244, 3, 70,
245, 4, 71,
246, 5, 72,
247, 6, 73,
248, 7, 74,
249, 8, 75,
250, 9, 76,
251, 10, 77,
252, 11, 78,
253, 12, 79,
254, 13, 80,
255, 14, 81,
192, 15, 82,
193, 16, 83,
194, 17, 84,
195, 18, 85,
196, 19, 86,
197, 20, 87,
198, 21, 88,
222, 108, 157,
223, 109, 158,
224, 110, 159,
225, 111, 160,
226, 112, 161,
227, 113, 162,
228, 114, 163,
229, 115, 164,
230, 116, 165,
231, 117, 166,
232, 118, 167,
233, 119, 168,
234, 120, 169,
235, 121, 170,
236, 122, 171,
237, 123, 172,
238, 124, 173,
239, 125, 174,
240, 126, 175,
241, 127, 176,
242, 64, 177,
243, 65, 178,
244, 66, 179,
245, 67, 180,
246, 68, 181,
247, 69, 182,
248, 70, 183,
249, 71, 184,
250, 72, 185,
251, 73, 186,
252, 74, 187,
253, 75, 188,
254, 76, 189,
255, 77, 190,
192, 78, 191,
193, 79, 128,
194, 80, 129,
195, 81, 130,
196, 82, 131,
197, 83, 132,
198, 84, 133,
199, 85, 134,
200, 86, 135,
201, 87, 136,
202, 88, 137,
203, 89, 138,
204, 90, 139,
205, 91, 140,
206, 92, 141,
207, 93, 142,
208, 94, 143,
209, 95, 144,
210, 96, 145,
211, 97, 146,
212, 98, 147,
213, 99, 148,
214, 100, 149,
215, 101, 150,
216, 102, 151,
217, 103, 152,
218, 104, 153,
219, 105, 154,
220, 106, 155,
221, 107, 156,
101, 169, 205,
102, 170, 206,
103, 171, 207,
104, 172, 208,
105, 173, 209,
106, 174, 210,
107, 175, 211,
108, 176, 212,
109, 177, 213,
110, 178, 214,
111, 179, 215,
112, 180, 216,
113, 181, 217,
114, 182, 218,
115, 183, 219,
116, 184, 220,
117, 185, 221,
118, 186, 222,
119, 187, 223,
120, 188, 224,
121, 189, 225,
122, 190, 226,
123, 191, 227,
124, 128, 228,
125, 129, 229,
126, 130, 230,
127, 131, 231,
64, 132, 232,
65, 133, 233,
66, 134, 234,
67, 135, 235,
68, 136, 236,
69, 137, 237,
70, 138, 238,
71, 139, 239,
72, 140, 240,
73, 141, 241,
74, 142, 242,
75, 143, 243,
76, 144, 244,
77, 145, 245,
78, 146, 246,
79, 147, 247,
80, 148, 248,
81, 149, 249,
82, 150, 250,
83, 151, 251,
84, 152, 252,
85, 153, 253,
86, 154, 254,
87, 155, 255,
88, 156, 192,
89, 157, 193,
90, 158, 194,
91, 159, 195,
92, 160, 196,
93, 161, 197,
94, 162, 198,
95, 163, 199,
96, 164, 200,
97, 165, 201,
98, 166, 202,
99, 167, 203,
100, 168, 204,
140, 7, 196,
141, 8, 197,
142, 9, 198,
143, 10, 199,
144, 11, 200,
145, 12, 201,
146, 13, 202,
147, 14, 203,
148, 15, 204,
149, 16, 205,
150, 17, 206,
151, 18, 207,
152, 19, 208,
153, 20, 209,
154, 21, 210,
155, 22, 211,
156, 23, 212,
157, 24, 213,
158, 25, 214,
159, 26, 215,
160, 27, 216,
161, 28, 217,
162, 29, 218,
163, 30, 219,
164, 31, 220,
165, 32, 221,
166, 33, 222,
167, 34, 223,
168, 35, 224,
169, 36, 225,
170, 37, 226,
171, 38, 227,
172, 39, 228,
173, 40, 229,
174, 41, 230,
175, 42, 231,
176, 43, 232,
177, 44, 233,
178, 45, 234,
179, 46, 235,
180, 47, 236,
181, 48, 237,
182, 49, 238,
183, 50, 239,
184, 51, 240,
185, 52, 241,
186, 53, 242,
187, 54, 243,
188, 55, 244,
189, 56, 245,
190, 57, 246,
191, 58, 247,
128, 59, 248,
129, 60, 249,
130, 61, 250,
131, 62, 251,
132, 63, 252,
133, 0, 253,
134, 1, 254,
135, 2, 255,
136, 3, 192,
137, 4, 193,
138, 5, 194,
139, 6, 195
 };
#pragma line 274 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_2_3_4_trichk.h" 1
int11 varinx10A_1024_d[] = {
151,
152,
153,
154,
155,
156,
157,
158,
159,
160,
161,
162,
163,
164,
165,
166,
167,
168,
169,
170,
171,
172,
173,
174,
175,
176,
177,
178,
179,
180,
181,
182,
183,
184,
185,
186,
187,
188,
189,
190,
191,
128,
129,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
228,
229,
230,
231,
232,
233,
234,
235,
236,
237,
238,
239,
240,
241,
242,
243,
244,
245,
246,
247,
248,
249,
250,
251,
252,
253,
254,
255,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
209,
210,
211,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
237,
238,
239,
240,
241,
242,
243,
244,
245,
246,
247,
248,
249,
250,
251,
252,
253,
254,
255,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
209,
210,
211,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235,
236,
236,
237,
238,
239,
240,
241,
242,
243,
244,
245,
246,
247,
248,
249,
250,
251,
252,
253,
254,
255,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
209,
210,
211,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235};
#pragma empty_line
int11 varinx10B_1024_d[] = {
0,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
21,
22,
23,
24,
25,
26,
27,
28,
29,
30,
31,
32,
33,
34,
35,
36,
37,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
64,
65,
66,
67,
68,
69,
70,
71,
72,
73,
74,
75,
76,
77,
78,
79,
80,
81,
82,
83,
84,
85,
86,
87,
88,
89,
90,
91,
92,
93,
94,
95,
96,
97,
98,
99,
100,
101,
102,
103,
104,
105,
106,
107,
108,
109,
110,
111,
112,
113,
114,
115,
116,
117,
118,
119,
120,
121,
122,
123,
124,
125,
126,
127,
128,
129,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
151,
152,
153,
154,
155,
156,
157,
158,
159,
160,
161,
162,
163,
164,
165,
166,
167,
168,
169,
170,
171,
172,
173,
174,
175,
176,
177,
178,
179,
180,
181,
182,
183,
184,
185,
186,
187,
188,
189,
190,
191,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
209,
210,
211,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235,
236,
237,
238,
239,
240,
241,
242,
243,
244,
245,
246,
247,
248,
249,
250,
251,
252,
253,
254,
255
 };
#pragma line 275 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_2_3_trichk.h" 1
#pragma empty_line
vars_3_23 varinx3_1024_23[] = {
0, 0, 251,
1, 1, 252,
2, 2, 253,
3, 3, 254,
4, 4, 255,
5, 5, 192,
6, 6, 193,
7, 7, 194,
8, 8, 195,
9, 9, 196,
10, 10, 197,
11, 11, 198,
12, 12, 199,
13, 13, 200,
14, 14, 201,
15, 15, 202,
16, 16, 203,
17, 17, 204,
18, 18, 205,
19, 19, 206,
20, 20, 207,
21, 21, 208,
22, 22, 209,
23, 23, 210,
24, 24, 211,
25, 25, 212,
26, 26, 213,
27, 27, 214,
28, 28, 215,
29, 29, 216,
30, 30, 217,
31, 31, 218,
32, 32, 219,
33, 33, 220,
34, 34, 221,
35, 35, 222,
36, 36, 223,
37, 37, 224,
38, 38, 225,
39, 39, 226,
40, 40, 227,
41, 41, 228,
42, 42, 229,
43, 43, 230,
44, 44, 231,
45, 45, 232,
46, 46, 233,
47, 47, 234,
48, 48, 235,
49, 49, 236,
50, 50, 237,
51, 51, 238,
52, 52, 239,
53, 53, 240,
54, 54, 241,
55, 55, 242,
56, 56, 243,
57, 57, 244,
58, 58, 245,
59, 59, 246,
60, 60, 247,
61, 61, 248,
62, 62, 249,
63, 63, 250,
64, 0, 64,
65, 1, 65,
66, 2, 66,
67, 3, 67,
68, 4, 68,
69, 5, 69,
70, 6, 70,
71, 7, 71,
72, 8, 72,
73, 9, 73,
74, 10, 74,
75, 11, 75,
76, 12, 76,
77, 13, 77,
78, 14, 78,
79, 15, 79,
80, 16, 80,
81, 17, 81,
82, 18, 82,
83, 19, 83,
84, 20, 84,
85, 21, 85,
86, 22, 86,
87, 23, 87,
88, 24, 88,
89, 25, 89,
90, 26, 90,
91, 27, 91,
92, 28, 92,
93, 29, 93,
94, 30, 94,
95, 31, 95,
96, 32, 96,
97, 33, 97,
98, 34, 98,
99, 35, 99,
100, 36, 100,
101, 37, 101,
102, 38, 102,
103, 39, 103,
104, 40, 104,
105, 41, 105,
106, 42, 106,
107, 43, 107,
108, 44, 108,
109, 45, 109,
110, 46, 110,
111, 47, 111,
112, 48, 112,
113, 49, 113,
114, 50, 114,
115, 51, 115,
116, 52, 116,
117, 53, 117,
118, 54, 118,
119, 55, 119,
120, 56, 120,
121, 57, 121,
122, 58, 122,
123, 59, 123,
124, 60, 124,
125, 61, 125,
126, 62, 126,
127, 63, 127,
128, 64, 128,
129, 65, 129,
130, 66, 130,
131, 67, 131,
132, 68, 132,
133, 69, 133,
134, 70, 134,
135, 71, 135,
136, 72, 136,
137, 73, 137,
138, 74, 138,
139, 75, 139,
140, 76, 140,
141, 77, 141,
142, 78, 142,
143, 79, 143,
144, 80, 144,
145, 81, 145,
146, 82, 146,
147, 83, 147,
148, 84, 148,
149, 85, 149,
150, 86, 150,
151, 87, 151,
152, 88, 152,
153, 89, 153,
154, 90, 154,
155, 91, 155,
156, 92, 156,
157, 93, 157,
158, 94, 158,
159, 95, 159,
160, 96, 160,
161, 97, 161,
162, 98, 162,
163, 99, 163,
164, 100, 164,
165, 101, 165,
166, 102, 166,
167, 103, 167,
168, 104, 168,
169, 105, 169,
170, 106, 170,
171, 107, 171,
172, 108, 172,
173, 109, 173,
174, 110, 174,
175, 111, 175,
176, 112, 176,
177, 113, 177,
178, 114, 178,
179, 115, 179,
180, 116, 180,
181, 117, 181,
182, 118, 182,
183, 119, 183,
184, 120, 184,
185, 121, 185,
186, 122, 186,
187, 123, 187,
188, 124, 188,
189, 125, 189,
190, 126, 190,
191, 127, 191,
192, 128, 192,
193, 129, 193,
194, 130, 194,
195, 131, 195,
196, 132, 196,
197, 133, 197,
198, 134, 198,
199, 135, 199,
200, 136, 200,
201, 137, 201,
202, 138, 202,
203, 139, 203,
204, 140, 204,
205, 141, 205,
206, 142, 206,
207, 143, 207,
208, 144, 208,
209, 145, 209,
210, 146, 210,
211, 147, 211,
212, 148, 212,
213, 149, 213,
214, 150, 214,
215, 151, 215,
216, 152, 216,
217, 153, 217,
218, 154, 218,
219, 155, 219,
220, 156, 220,
221, 157, 221,
222, 158, 222,
223, 159, 223,
224, 160, 224,
225, 161, 225,
226, 162, 226,
227, 163, 227,
228, 164, 228,
229, 165, 229,
230, 166, 230,
231, 167, 231,
232, 168, 232,
233, 169, 233,
234, 170, 234,
235, 171, 235,
236, 172, 236,
237, 173, 237,
238, 174, 238,
239, 175, 239,
240, 176, 240,
241, 177, 241,
242, 178, 242,
243, 179, 243,
244, 180, 244,
245, 181, 245,
246, 182, 246,
247, 183, 247,
248, 184, 248,
249, 185, 249,
250, 186, 250,
251, 187, 251,
252, 188, 252,
253, 189, 253,
254, 190, 254,
255, 191, 255
 };
#pragma line 276 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_2_3_1_trichk.h" 1
vars_3_23 varinx10A_4096_a[] = {
248, 268, 623,
249, 269, 624,
250, 270, 625,
251, 271, 626,
252, 272, 627,
253, 273, 628,
254, 274, 629,
255, 275, 630,
0, 276, 631,
1, 277, 632,
2, 278, 633,
3, 279, 634,
4, 280, 635,
5, 281, 636,
6, 282, 637,
7, 283, 638,
8, 284, 639,
9, 285, 640,
10, 286, 641,
11, 287, 642,
12, 288, 643,
13, 289, 644,
14, 290, 645,
15, 291, 646,
16, 292, 647,
17, 293, 648,
18, 294, 649,
19, 295, 650,
20, 296, 651,
21, 297, 652,
22, 298, 653,
23, 299, 654,
24, 300, 655,
25, 301, 656,
26, 302, 657,
27, 303, 658,
28, 304, 659,
29, 305, 660,
30, 306, 661,
31, 307, 662,
32, 308, 663,
33, 309, 664,
34, 310, 665,
35, 311, 666,
36, 312, 667,
37, 313, 668,
38, 314, 669,
39, 315, 670,
40, 316, 671,
41, 317, 672,
42, 318, 673,
43, 319, 674,
44, 320, 675,
45, 321, 676,
46, 322, 677,
47, 323, 678,
48, 324, 679,
49, 325, 680,
50, 326, 681,
51, 327, 682,
52, 328, 683,
53, 329, 684,
54, 330, 685,
55, 331, 686,
56, 332, 687,
57, 333, 688,
58, 334, 689,
59, 335, 690,
60, 336, 691,
61, 337, 692,
62, 338, 693,
63, 339, 694,
64, 340, 695,
65, 341, 696,
66, 342, 697,
67, 343, 698,
68, 344, 699,
69, 345, 700,
70, 346, 701,
71, 347, 702,
72, 348, 703,
73, 349, 704,
74, 350, 705,
75, 351, 706,
76, 352, 707,
77, 353, 708,
78, 354, 709,
79, 355, 710,
80, 356, 711,
81, 357, 712,
82, 358, 713,
83, 359, 714,
84, 360, 715,
85, 361, 716,
86, 362, 717,
87, 363, 718,
88, 364, 719,
89, 365, 720,
90, 366, 721,
91, 367, 722,
92, 368, 723,
93, 369, 724,
94, 370, 725,
95, 371, 726,
96, 372, 727,
97, 373, 728,
98, 374, 729,
99, 375, 730,
100, 376, 731,
101, 377, 732,
102, 378, 733,
103, 379, 734,
104, 380, 735,
105, 381, 736,
106, 382, 737,
107, 383, 738,
108, 384, 739,
109, 385, 740,
110, 386, 741,
111, 387, 742,
112, 388, 743,
113, 389, 744,
114, 390, 745,
115, 391, 746,
116, 392, 747,
117, 393, 748,
118, 394, 749,
119, 395, 750,
120, 396, 751,
121, 397, 752,
122, 398, 753,
123, 399, 754,
124, 400, 755,
125, 401, 756,
126, 402, 757,
127, 403, 758,
128, 404, 759,
129, 405, 760,
130, 406, 761,
131, 407, 762,
132, 408, 763,
133, 409, 764,
134, 410, 765,
135, 411, 766,
136, 412, 767,
137, 413, 512,
138, 414, 513,
139, 415, 514,
140, 416, 515,
141, 417, 516,
142, 418, 517,
143, 419, 518,
144, 420, 519,
145, 421, 520,
146, 422, 521,
147, 423, 522,
148, 424, 523,
149, 425, 524,
150, 426, 525,
151, 427, 526,
152, 428, 527,
153, 429, 528,
154, 430, 529,
155, 431, 530,
156, 432, 531,
157, 433, 532,
158, 434, 533,
159, 435, 534,
160, 436, 535,
161, 437, 536,
162, 438, 537,
163, 439, 538,
164, 440, 539,
165, 441, 540,
166, 442, 541,
167, 443, 542,
168, 444, 543,
169, 445, 544,
170, 446, 545,
171, 447, 546,
172, 448, 547,
173, 449, 548,
174, 450, 549,
175, 451, 550,
176, 452, 551,
177, 453, 552,
178, 454, 553,
179, 455, 554,
180, 456, 555,
181, 457, 556,
182, 458, 557,
183, 459, 558,
184, 460, 559,
185, 461, 560,
186, 462, 561,
187, 463, 562,
188, 464, 563,
189, 465, 564,
190, 466, 565,
191, 467, 566,
192, 468, 567,
193, 469, 568,
194, 470, 569,
195, 471, 570,
196, 472, 571,
197, 473, 572,
198, 474, 573,
199, 475, 574,
200, 476, 575,
201, 477, 576,
202, 478, 577,
203, 479, 578,
204, 480, 579,
205, 481, 580,
206, 482, 581,
207, 483, 582,
208, 484, 583,
209, 485, 584,
210, 486, 585,
211, 487, 586,
212, 488, 587,
213, 489, 588,
214, 490, 589,
215, 491, 590,
216, 492, 591,
217, 493, 592,
218, 494, 593,
219, 495, 594,
220, 496, 595,
221, 497, 596,
222, 498, 597,
223, 499, 598,
224, 500, 599,
225, 501, 600,
226, 502, 601,
227, 503, 602,
228, 504, 603,
229, 505, 604,
230, 506, 605,
231, 507, 606,
232, 508, 607,
233, 509, 608,
234, 510, 609,
235, 511, 610,
236, 256, 611,
237, 257, 612,
238, 258, 613,
239, 259, 614,
240, 260, 615,
241, 261, 616,
242, 262, 617,
243, 263, 618,
244, 264, 619,
245, 265, 620,
246, 266, 621,
247, 267, 622,
311, 524, 995,
312, 525, 996,
313, 526, 997,
314, 527, 998,
315, 528, 999,
316, 529, 1000,
317, 530, 1001,
318, 531, 1002,
319, 532, 1003,
320, 533, 1004,
321, 534, 1005,
322, 535, 1006,
323, 536, 1007,
324, 537, 1008,
325, 538, 1009,
326, 539, 1010,
327, 540, 1011,
328, 541, 1012,
329, 542, 1013,
330, 543, 1014,
331, 544, 1015,
332, 545, 1016,
333, 546, 1017,
334, 547, 1018,
335, 548, 1019,
336, 549, 1020,
337, 550, 1021,
338, 551, 1022,
339, 552, 1023,
340, 553, 768,
341, 554, 769,
342, 555, 770,
343, 556, 771,
344, 557, 772,
345, 558, 773,
346, 559, 774,
347, 560, 775,
348, 561, 776,
349, 562, 777,
350, 563, 778,
351, 564, 779,
352, 565, 780,
353, 566, 781,
354, 567, 782,
355, 568, 783,
356, 569, 784,
357, 570, 785,
358, 571, 786,
359, 572, 787,
360, 573, 788,
361, 574, 789,
362, 575, 790,
363, 576, 791,
364, 577, 792,
365, 578, 793,
366, 579, 794,
367, 580, 795,
368, 581, 796,
369, 582, 797,
370, 583, 798,
371, 584, 799,
372, 585, 800,
373, 586, 801,
374, 587, 802,
375, 588, 803,
376, 589, 804,
377, 590, 805,
378, 591, 806,
379, 592, 807,
380, 593, 808,
381, 594, 809,
382, 595, 810,
383, 596, 811,
384, 597, 812,
385, 598, 813,
386, 599, 814,
387, 600, 815,
388, 601, 816,
389, 602, 817,
390, 603, 818,
391, 604, 819,
392, 605, 820,
393, 606, 821,
394, 607, 822,
395, 608, 823,
396, 609, 824,
397, 610, 825,
398, 611, 826,
399, 612, 827,
400, 613, 828,
401, 614, 829,
402, 615, 830,
403, 616, 831,
404, 617, 832,
405, 618, 833,
406, 619, 834,
407, 620, 835,
408, 621, 836,
409, 622, 837,
410, 623, 838,
411, 624, 839,
412, 625, 840,
413, 626, 841,
414, 627, 842,
415, 628, 843,
416, 629, 844,
417, 630, 845,
418, 631, 846,
419, 632, 847,
420, 633, 848,
421, 634, 849,
422, 635, 850,
423, 636, 851,
424, 637, 852,
425, 638, 853,
426, 639, 854,
427, 640, 855,
428, 641, 856,
429, 642, 857,
430, 643, 858,
431, 644, 859,
432, 645, 860,
433, 646, 861,
434, 647, 862,
435, 648, 863,
436, 649, 864,
437, 650, 865,
438, 651, 866,
439, 652, 867,
440, 653, 868,
441, 654, 869,
442, 655, 870,
443, 656, 871,
444, 657, 872,
445, 658, 873,
446, 659, 874,
447, 660, 875,
448, 661, 876,
449, 662, 877,
450, 663, 878,
451, 664, 879,
452, 665, 880,
453, 666, 881,
454, 667, 882,
455, 668, 883,
456, 669, 884,
457, 670, 885,
458, 671, 886,
459, 672, 887,
460, 673, 888,
461, 674, 889,
462, 675, 890,
463, 676, 891,
464, 677, 892,
465, 678, 893,
466, 679, 894,
467, 680, 895,
468, 681, 896,
469, 682, 897,
470, 683, 898,
471, 684, 899,
472, 685, 900,
473, 686, 901,
474, 687, 902,
475, 688, 903,
476, 689, 904,
477, 690, 905,
478, 691, 906,
479, 692, 907,
480, 693, 908,
481, 694, 909,
482, 695, 910,
483, 696, 911,
484, 697, 912,
485, 698, 913,
486, 699, 914,
487, 700, 915,
488, 701, 916,
489, 702, 917,
490, 703, 918,
491, 704, 919,
492, 705, 920,
493, 706, 921,
494, 707, 922,
495, 708, 923,
496, 709, 924,
497, 710, 925,
498, 711, 926,
499, 712, 927,
500, 713, 928,
501, 714, 929,
502, 715, 930,
503, 716, 931,
504, 717, 932,
505, 718, 933,
506, 719, 934,
507, 720, 935,
508, 721, 936,
509, 722, 937,
510, 723, 938,
511, 724, 939,
256, 725, 940,
257, 726, 941,
258, 727, 942,
259, 728, 943,
260, 729, 944,
261, 730, 945,
262, 731, 946,
263, 732, 947,
264, 733, 948,
265, 734, 949,
266, 735, 950,
267, 736, 951,
268, 737, 952,
269, 738, 953,
270, 739, 954,
271, 740, 955,
272, 741, 956,
273, 742, 957,
274, 743, 958,
275, 744, 959,
276, 745, 960,
277, 746, 961,
278, 747, 962,
279, 748, 963,
280, 749, 964,
281, 750, 965,
282, 751, 966,
283, 752, 967,
284, 753, 968,
285, 754, 969,
286, 755, 970,
287, 756, 971,
288, 757, 972,
289, 758, 973,
290, 759, 974,
291, 760, 975,
292, 761, 976,
293, 762, 977,
294, 763, 978,
295, 764, 979,
296, 765, 980,
297, 766, 981,
298, 767, 982,
299, 512, 983,
300, 513, 984,
301, 514, 985,
302, 515, 986,
303, 516, 987,
304, 517, 988,
305, 518, 989,
306, 519, 990,
307, 520, 991,
308, 521, 992,
309, 522, 993,
310, 523, 994,
23, 659, 822,
24, 660, 823,
25, 661, 824,
26, 662, 825,
27, 663, 826,
28, 664, 827,
29, 665, 828,
30, 666, 829,
31, 667, 830,
32, 668, 831,
33, 669, 832,
34, 670, 833,
35, 671, 834,
36, 672, 835,
37, 673, 836,
38, 674, 837,
39, 675, 838,
40, 676, 839,
41, 677, 840,
42, 678, 841,
43, 679, 842,
44, 680, 843,
45, 681, 844,
46, 682, 845,
47, 683, 846,
48, 684, 847,
49, 685, 848,
50, 686, 849,
51, 687, 850,
52, 688, 851,
53, 689, 852,
54, 690, 853,
55, 691, 854,
56, 692, 855,
57, 693, 856,
58, 694, 857,
59, 695, 858,
60, 696, 859,
61, 697, 860,
62, 698, 861,
63, 699, 862,
64, 700, 863,
65, 701, 864,
66, 702, 865,
67, 703, 866,
68, 704, 867,
69, 705, 868,
70, 706, 869,
71, 707, 870,
72, 708, 871,
73, 709, 872,
74, 710, 873,
75, 711, 874,
76, 712, 875,
77, 713, 876,
78, 714, 877,
79, 715, 878,
80, 716, 879,
81, 717, 880,
82, 718, 881,
83, 719, 882,
84, 720, 883,
85, 721, 884,
86, 722, 885,
87, 723, 886,
88, 724, 887,
89, 725, 888,
90, 726, 889,
91, 727, 890,
92, 728, 891,
93, 729, 892,
94, 730, 893,
95, 731, 894,
96, 732, 895,
97, 733, 896,
98, 734, 897,
99, 735, 898,
100, 736, 899,
101, 737, 900,
102, 738, 901,
103, 739, 902,
104, 740, 903,
105, 741, 904,
106, 742, 905,
107, 743, 906,
108, 744, 907,
109, 745, 908,
110, 746, 909,
111, 747, 910,
112, 748, 911,
113, 749, 912,
114, 750, 913,
115, 751, 914,
116, 752, 915,
117, 753, 916,
118, 754, 917,
119, 755, 918,
120, 756, 919,
121, 757, 920,
122, 758, 921,
123, 759, 922,
124, 760, 923,
125, 761, 924,
126, 762, 925,
127, 763, 926,
128, 764, 927,
129, 765, 928,
130, 766, 929,
131, 767, 930,
132, 512, 931,
133, 513, 932,
134, 514, 933,
135, 515, 934,
136, 516, 935,
137, 517, 936,
138, 518, 937,
139, 519, 938,
140, 520, 939,
141, 521, 940,
142, 522, 941,
143, 523, 942,
144, 524, 943,
145, 525, 944,
146, 526, 945,
147, 527, 946,
148, 528, 947,
149, 529, 948,
150, 530, 949,
151, 531, 950,
152, 532, 951,
153, 533, 952,
154, 534, 953,
155, 535, 954,
156, 536, 955,
157, 537, 956,
158, 538, 957,
159, 539, 958,
160, 540, 959,
161, 541, 960,
162, 542, 961,
163, 543, 962,
164, 544, 963,
165, 545, 964,
166, 546, 965,
167, 547, 966,
168, 548, 967,
169, 549, 968,
170, 550, 969,
171, 551, 970,
172, 552, 971,
173, 553, 972,
174, 554, 973,
175, 555, 974,
176, 556, 975,
177, 557, 976,
178, 558, 977,
179, 559, 978,
180, 560, 979,
181, 561, 980,
182, 562, 981,
183, 563, 982,
184, 564, 983,
185, 565, 984,
186, 566, 985,
187, 567, 986,
188, 568, 987,
189, 569, 988,
190, 570, 989,
191, 571, 990,
192, 572, 991,
193, 573, 992,
194, 574, 993,
195, 575, 994,
196, 576, 995,
197, 577, 996,
198, 578, 997,
199, 579, 998,
200, 580, 999,
201, 581, 1000,
202, 582, 1001,
203, 583, 1002,
204, 584, 1003,
205, 585, 1004,
206, 586, 1005,
207, 587, 1006,
208, 588, 1007,
209, 589, 1008,
210, 590, 1009,
211, 591, 1010,
212, 592, 1011,
213, 593, 1012,
214, 594, 1013,
215, 595, 1014,
216, 596, 1015,
217, 597, 1016,
218, 598, 1017,
219, 599, 1018,
220, 600, 1019,
221, 601, 1020,
222, 602, 1021,
223, 603, 1022,
224, 604, 1023,
225, 605, 768,
226, 606, 769,
227, 607, 770,
228, 608, 771,
229, 609, 772,
230, 610, 773,
231, 611, 774,
232, 612, 775,
233, 613, 776,
234, 614, 777,
235, 615, 778,
236, 616, 779,
237, 617, 780,
238, 618, 781,
239, 619, 782,
240, 620, 783,
241, 621, 784,
242, 622, 785,
243, 623, 786,
244, 624, 787,
245, 625, 788,
246, 626, 789,
247, 627, 790,
248, 628, 791,
249, 629, 792,
250, 630, 793,
251, 631, 794,
252, 632, 795,
253, 633, 796,
254, 634, 797,
255, 635, 798,
0, 636, 799,
1, 637, 800,
2, 638, 801,
3, 639, 802,
4, 640, 803,
5, 641, 804,
6, 642, 805,
7, 643, 806,
8, 644, 807,
9, 645, 808,
10, 646, 809,
11, 647, 810,
12, 648, 811,
13, 649, 812,
14, 650, 813,
15, 651, 814,
16, 652, 815,
17, 653, 816,
18, 654, 817,
19, 655, 818,
20, 656, 819,
21, 657, 820,
22, 658, 821,
99, 361, 901,
100, 362, 902,
101, 363, 903,
102, 364, 904,
103, 365, 905,
104, 366, 906,
105, 367, 907,
106, 368, 908,
107, 369, 909,
108, 370, 910,
109, 371, 911,
110, 372, 912,
111, 373, 913,
112, 374, 914,
113, 375, 915,
114, 376, 916,
115, 377, 917,
116, 378, 918,
117, 379, 919,
118, 380, 920,
119, 381, 921,
120, 382, 922,
121, 383, 923,
122, 384, 924,
123, 385, 925,
124, 386, 926,
125, 387, 927,
126, 388, 928,
127, 389, 929,
128, 390, 930,
129, 391, 931,
130, 392, 932,
131, 393, 933,
132, 394, 934,
133, 395, 935,
134, 396, 936,
135, 397, 937,
136, 398, 938,
137, 399, 939,
138, 400, 940,
139, 401, 941,
140, 402, 942,
141, 403, 943,
142, 404, 944,
143, 405, 945,
144, 406, 946,
145, 407, 947,
146, 408, 948,
147, 409, 949,
148, 410, 950,
149, 411, 951,
150, 412, 952,
151, 413, 953,
152, 414, 954,
153, 415, 955,
154, 416, 956,
155, 417, 957,
156, 418, 958,
157, 419, 959,
158, 420, 960,
159, 421, 961,
160, 422, 962,
161, 423, 963,
162, 424, 964,
163, 425, 965,
164, 426, 966,
165, 427, 967,
166, 428, 968,
167, 429, 969,
168, 430, 970,
169, 431, 971,
170, 432, 972,
171, 433, 973,
172, 434, 974,
173, 435, 975,
174, 436, 976,
175, 437, 977,
176, 438, 978,
177, 439, 979,
178, 440, 980,
179, 441, 981,
180, 442, 982,
181, 443, 983,
182, 444, 984,
183, 445, 985,
184, 446, 986,
185, 447, 987,
186, 448, 988,
187, 449, 989,
188, 450, 990,
189, 451, 991,
190, 452, 992,
191, 453, 993,
192, 454, 994,
193, 455, 995,
194, 456, 996,
195, 457, 997,
196, 458, 998,
197, 459, 999,
198, 460, 1000,
199, 461, 1001,
200, 462, 1002,
201, 463, 1003,
202, 464, 1004,
203, 465, 1005,
204, 466, 1006,
205, 467, 1007,
206, 468, 1008,
207, 469, 1009,
208, 470, 1010,
209, 471, 1011,
210, 472, 1012,
211, 473, 1013,
212, 474, 1014,
213, 475, 1015,
214, 476, 1016,
215, 477, 1017,
216, 478, 1018,
217, 479, 1019,
218, 480, 1020,
219, 481, 1021,
220, 482, 1022,
221, 483, 1023,
222, 484, 768,
223, 485, 769,
224, 486, 770,
225, 487, 771,
226, 488, 772,
227, 489, 773,
228, 490, 774,
229, 491, 775,
230, 492, 776,
231, 493, 777,
232, 494, 778,
233, 495, 779,
234, 496, 780,
235, 497, 781,
236, 498, 782,
237, 499, 783,
238, 500, 784,
239, 501, 785,
240, 502, 786,
241, 503, 787,
242, 504, 788,
243, 505, 789,
244, 506, 790,
245, 507, 791,
246, 508, 792,
247, 509, 793,
248, 510, 794,
249, 511, 795,
250, 256, 796,
251, 257, 797,
252, 258, 798,
253, 259, 799,
254, 260, 800,
255, 261, 801,
0, 262, 802,
1, 263, 803,
2, 264, 804,
3, 265, 805,
4, 266, 806,
5, 267, 807,
6, 268, 808,
7, 269, 809,
8, 270, 810,
9, 271, 811,
10, 272, 812,
11, 273, 813,
12, 274, 814,
13, 275, 815,
14, 276, 816,
15, 277, 817,
16, 278, 818,
17, 279, 819,
18, 280, 820,
19, 281, 821,
20, 282, 822,
21, 283, 823,
22, 284, 824,
23, 285, 825,
24, 286, 826,
25, 287, 827,
26, 288, 828,
27, 289, 829,
28, 290, 830,
29, 291, 831,
30, 292, 832,
31, 293, 833,
32, 294, 834,
33, 295, 835,
34, 296, 836,
35, 297, 837,
36, 298, 838,
37, 299, 839,
38, 300, 840,
39, 301, 841,
40, 302, 842,
41, 303, 843,
42, 304, 844,
43, 305, 845,
44, 306, 846,
45, 307, 847,
46, 308, 848,
47, 309, 849,
48, 310, 850,
49, 311, 851,
50, 312, 852,
51, 313, 853,
52, 314, 854,
53, 315, 855,
54, 316, 856,
55, 317, 857,
56, 318, 858,
57, 319, 859,
58, 320, 860,
59, 321, 861,
60, 322, 862,
61, 323, 863,
62, 324, 864,
63, 325, 865,
64, 326, 866,
65, 327, 867,
66, 328, 868,
67, 329, 869,
68, 330, 870,
69, 331, 871,
70, 332, 872,
71, 333, 873,
72, 334, 874,
73, 335, 875,
74, 336, 876,
75, 337, 877,
76, 338, 878,
77, 339, 879,
78, 340, 880,
79, 341, 881,
80, 342, 882,
81, 343, 883,
82, 344, 884,
83, 345, 885,
84, 346, 886,
85, 347, 887,
86, 348, 888,
87, 349, 889,
88, 350, 890,
89, 351, 891,
90, 352, 892,
91, 353, 893,
92, 354, 894,
93, 355, 895,
94, 356, 896,
95, 357, 897,
96, 358, 898,
97, 359, 899,
98, 360, 900 };
#pragma empty_line
vars_3_23 varinx10B_4096_a[] = {
0, 66, 685,
1, 67, 686,
2, 68, 687,
3, 69, 688,
4, 70, 689,
5, 71, 690,
6, 72, 691,
7, 73, 692,
8, 74, 693,
9, 75, 694,
10, 76, 695,
11, 77, 696,
12, 78, 697,
13, 79, 698,
14, 80, 699,
15, 81, 700,
16, 82, 701,
17, 83, 702,
18, 84, 703,
19, 85, 704,
20, 86, 705,
21, 87, 706,
22, 88, 707,
23, 89, 708,
24, 90, 709,
25, 91, 710,
26, 92, 711,
27, 93, 712,
28, 94, 713,
29, 95, 714,
30, 96, 715,
31, 97, 716,
32, 98, 717,
33, 99, 718,
34, 100, 719,
35, 101, 720,
36, 102, 721,
37, 103, 722,
38, 104, 723,
39, 105, 724,
40, 106, 725,
41, 107, 726,
42, 108, 727,
43, 109, 728,
44, 110, 729,
45, 111, 730,
46, 112, 731,
47, 113, 732,
48, 114, 733,
49, 115, 734,
50, 116, 735,
51, 117, 736,
52, 118, 737,
53, 119, 738,
54, 120, 739,
55, 121, 740,
56, 122, 741,
57, 123, 742,
58, 124, 743,
59, 125, 744,
60, 126, 745,
61, 127, 746,
62, 128, 747,
63, 129, 748,
64, 130, 749,
65, 131, 750,
66, 132, 751,
67, 133, 752,
68, 134, 753,
69, 135, 754,
70, 136, 755,
71, 137, 756,
72, 138, 757,
73, 139, 758,
74, 140, 759,
75, 141, 760,
76, 142, 761,
77, 143, 762,
78, 144, 763,
79, 145, 764,
80, 146, 765,
81, 147, 766,
82, 148, 767,
83, 149, 512,
84, 150, 513,
85, 151, 514,
86, 152, 515,
87, 153, 516,
88, 154, 517,
89, 155, 518,
90, 156, 519,
91, 157, 520,
92, 158, 521,
93, 159, 522,
94, 160, 523,
95, 161, 524,
96, 162, 525,
97, 163, 526,
98, 164, 527,
99, 165, 528,
100, 166, 529,
101, 167, 530,
102, 168, 531,
103, 169, 532,
104, 170, 533,
105, 171, 534,
106, 172, 535,
107, 173, 536,
108, 174, 537,
109, 175, 538,
110, 176, 539,
111, 177, 540,
112, 178, 541,
113, 179, 542,
114, 180, 543,
115, 181, 544,
116, 182, 545,
117, 183, 546,
118, 184, 547,
119, 185, 548,
120, 186, 549,
121, 187, 550,
122, 188, 551,
123, 189, 552,
124, 190, 553,
125, 191, 554,
126, 192, 555,
127, 193, 556,
128, 194, 557,
129, 195, 558,
130, 196, 559,
131, 197, 560,
132, 198, 561,
133, 199, 562,
134, 200, 563,
135, 201, 564,
136, 202, 565,
137, 203, 566,
138, 204, 567,
139, 205, 568,
140, 206, 569,
141, 207, 570,
142, 208, 571,
143, 209, 572,
144, 210, 573,
145, 211, 574,
146, 212, 575,
147, 213, 576,
148, 214, 577,
149, 215, 578,
150, 216, 579,
151, 217, 580,
152, 218, 581,
153, 219, 582,
154, 220, 583,
155, 221, 584,
156, 222, 585,
157, 223, 586,
158, 224, 587,
159, 225, 588,
160, 226, 589,
161, 227, 590,
162, 228, 591,
163, 229, 592,
164, 230, 593,
165, 231, 594,
166, 232, 595,
167, 233, 596,
168, 234, 597,
169, 235, 598,
170, 236, 599,
171, 237, 600,
172, 238, 601,
173, 239, 602,
174, 240, 603,
175, 241, 604,
176, 242, 605,
177, 243, 606,
178, 244, 607,
179, 245, 608,
180, 246, 609,
181, 247, 610,
182, 248, 611,
183, 249, 612,
184, 250, 613,
185, 251, 614,
186, 252, 615,
187, 253, 616,
188, 254, 617,
189, 255, 618,
190, 0, 619,
191, 1, 620,
192, 2, 621,
193, 3, 622,
194, 4, 623,
195, 5, 624,
196, 6, 625,
197, 7, 626,
198, 8, 627,
199, 9, 628,
200, 10, 629,
201, 11, 630,
202, 12, 631,
203, 13, 632,
204, 14, 633,
205, 15, 634,
206, 16, 635,
207, 17, 636,
208, 18, 637,
209, 19, 638,
210, 20, 639,
211, 21, 640,
212, 22, 641,
213, 23, 642,
214, 24, 643,
215, 25, 644,
216, 26, 645,
217, 27, 646,
218, 28, 647,
219, 29, 648,
220, 30, 649,
221, 31, 650,
222, 32, 651,
223, 33, 652,
224, 34, 653,
225, 35, 654,
226, 36, 655,
227, 37, 656,
228, 38, 657,
229, 39, 658,
230, 40, 659,
231, 41, 660,
232, 42, 661,
233, 43, 662,
234, 44, 663,
235, 45, 664,
236, 46, 665,
237, 47, 666,
238, 48, 667,
239, 49, 668,
240, 50, 669,
241, 51, 670,
242, 52, 671,
243, 53, 672,
244, 54, 673,
245, 55, 674,
246, 56, 675,
247, 57, 676,
248, 58, 677,
249, 59, 678,
250, 60, 679,
251, 61, 680,
252, 62, 681,
253, 63, 682,
254, 64, 683,
255, 65, 684,
256, 243, 298,
257, 244, 299,
258, 245, 300,
259, 246, 301,
260, 247, 302,
261, 248, 303,
262, 249, 304,
263, 250, 305,
264, 251, 306,
265, 252, 307,
266, 253, 308,
267, 254, 309,
268, 255, 310,
269, 0, 311,
270, 1, 312,
271, 2, 313,
272, 3, 314,
273, 4, 315,
274, 5, 316,
275, 6, 317,
276, 7, 318,
277, 8, 319,
278, 9, 320,
279, 10, 321,
280, 11, 322,
281, 12, 323,
282, 13, 324,
283, 14, 325,
284, 15, 326,
285, 16, 327,
286, 17, 328,
287, 18, 329,
288, 19, 330,
289, 20, 331,
290, 21, 332,
291, 22, 333,
292, 23, 334,
293, 24, 335,
294, 25, 336,
295, 26, 337,
296, 27, 338,
297, 28, 339,
298, 29, 340,
299, 30, 341,
300, 31, 342,
301, 32, 343,
302, 33, 344,
303, 34, 345,
304, 35, 346,
305, 36, 347,
306, 37, 348,
307, 38, 349,
308, 39, 350,
309, 40, 351,
310, 41, 352,
311, 42, 353,
312, 43, 354,
313, 44, 355,
314, 45, 356,
315, 46, 357,
316, 47, 358,
317, 48, 359,
318, 49, 360,
319, 50, 361,
320, 51, 362,
321, 52, 363,
322, 53, 364,
323, 54, 365,
324, 55, 366,
325, 56, 367,
326, 57, 368,
327, 58, 369,
328, 59, 370,
329, 60, 371,
330, 61, 372,
331, 62, 373,
332, 63, 374,
333, 64, 375,
334, 65, 376,
335, 66, 377,
336, 67, 378,
337, 68, 379,
338, 69, 380,
339, 70, 381,
340, 71, 382,
341, 72, 383,
342, 73, 384,
343, 74, 385,
344, 75, 386,
345, 76, 387,
346, 77, 388,
347, 78, 389,
348, 79, 390,
349, 80, 391,
350, 81, 392,
351, 82, 393,
352, 83, 394,
353, 84, 395,
354, 85, 396,
355, 86, 397,
356, 87, 398,
357, 88, 399,
358, 89, 400,
359, 90, 401,
360, 91, 402,
361, 92, 403,
362, 93, 404,
363, 94, 405,
364, 95, 406,
365, 96, 407,
366, 97, 408,
367, 98, 409,
368, 99, 410,
369, 100, 411,
370, 101, 412,
371, 102, 413,
372, 103, 414,
373, 104, 415,
374, 105, 416,
375, 106, 417,
376, 107, 418,
377, 108, 419,
378, 109, 420,
379, 110, 421,
380, 111, 422,
381, 112, 423,
382, 113, 424,
383, 114, 425,
384, 115, 426,
385, 116, 427,
386, 117, 428,
387, 118, 429,
388, 119, 430,
389, 120, 431,
390, 121, 432,
391, 122, 433,
392, 123, 434,
393, 124, 435,
394, 125, 436,
395, 126, 437,
396, 127, 438,
397, 128, 439,
398, 129, 440,
399, 130, 441,
400, 131, 442,
401, 132, 443,
402, 133, 444,
403, 134, 445,
404, 135, 446,
405, 136, 447,
406, 137, 448,
407, 138, 449,
408, 139, 450,
409, 140, 451,
410, 141, 452,
411, 142, 453,
412, 143, 454,
413, 144, 455,
414, 145, 456,
415, 146, 457,
416, 147, 458,
417, 148, 459,
418, 149, 460,
419, 150, 461,
420, 151, 462,
421, 152, 463,
422, 153, 464,
423, 154, 465,
424, 155, 466,
425, 156, 467,
426, 157, 468,
427, 158, 469,
428, 159, 470,
429, 160, 471,
430, 161, 472,
431, 162, 473,
432, 163, 474,
433, 164, 475,
434, 165, 476,
435, 166, 477,
436, 167, 478,
437, 168, 479,
438, 169, 480,
439, 170, 481,
440, 171, 482,
441, 172, 483,
442, 173, 484,
443, 174, 485,
444, 175, 486,
445, 176, 487,
446, 177, 488,
447, 178, 489,
448, 179, 490,
449, 180, 491,
450, 181, 492,
451, 182, 493,
452, 183, 494,
453, 184, 495,
454, 185, 496,
455, 186, 497,
456, 187, 498,
457, 188, 499,
458, 189, 500,
459, 190, 501,
460, 191, 502,
461, 192, 503,
462, 193, 504,
463, 194, 505,
464, 195, 506,
465, 196, 507,
466, 197, 508,
467, 198, 509,
468, 199, 510,
469, 200, 511,
470, 201, 256,
471, 202, 257,
472, 203, 258,
473, 204, 259,
474, 205, 260,
475, 206, 261,
476, 207, 262,
477, 208, 263,
478, 209, 264,
479, 210, 265,
480, 211, 266,
481, 212, 267,
482, 213, 268,
483, 214, 269,
484, 215, 270,
485, 216, 271,
486, 217, 272,
487, 218, 273,
488, 219, 274,
489, 220, 275,
490, 221, 276,
491, 222, 277,
492, 223, 278,
493, 224, 279,
494, 225, 280,
495, 226, 281,
496, 227, 282,
497, 228, 283,
498, 229, 284,
499, 230, 285,
500, 231, 286,
501, 232, 287,
502, 233, 288,
503, 234, 289,
504, 235, 290,
505, 236, 291,
506, 237, 292,
507, 238, 293,
508, 239, 294,
509, 240, 295,
510, 241, 296,
511, 242, 297,
512, 20, 453,
513, 21, 454,
514, 22, 455,
515, 23, 456,
516, 24, 457,
517, 25, 458,
518, 26, 459,
519, 27, 460,
520, 28, 461,
521, 29, 462,
522, 30, 463,
523, 31, 464,
524, 32, 465,
525, 33, 466,
526, 34, 467,
527, 35, 468,
528, 36, 469,
529, 37, 470,
530, 38, 471,
531, 39, 472,
532, 40, 473,
533, 41, 474,
534, 42, 475,
535, 43, 476,
536, 44, 477,
537, 45, 478,
538, 46, 479,
539, 47, 480,
540, 48, 481,
541, 49, 482,
542, 50, 483,
543, 51, 484,
544, 52, 485,
545, 53, 486,
546, 54, 487,
547, 55, 488,
548, 56, 489,
549, 57, 490,
550, 58, 491,
551, 59, 492,
552, 60, 493,
553, 61, 494,
554, 62, 495,
555, 63, 496,
556, 64, 497,
557, 65, 498,
558, 66, 499,
559, 67, 500,
560, 68, 501,
561, 69, 502,
562, 70, 503,
563, 71, 504,
564, 72, 505,
565, 73, 506,
566, 74, 507,
567, 75, 508,
568, 76, 509,
569, 77, 510,
570, 78, 511,
571, 79, 256,
572, 80, 257,
573, 81, 258,
574, 82, 259,
575, 83, 260,
576, 84, 261,
577, 85, 262,
578, 86, 263,
579, 87, 264,
580, 88, 265,
581, 89, 266,
582, 90, 267,
583, 91, 268,
584, 92, 269,
585, 93, 270,
586, 94, 271,
587, 95, 272,
588, 96, 273,
589, 97, 274,
590, 98, 275,
591, 99, 276,
592, 100, 277,
593, 101, 278,
594, 102, 279,
595, 103, 280,
596, 104, 281,
597, 105, 282,
598, 106, 283,
599, 107, 284,
600, 108, 285,
601, 109, 286,
602, 110, 287,
603, 111, 288,
604, 112, 289,
605, 113, 290,
606, 114, 291,
607, 115, 292,
608, 116, 293,
609, 117, 294,
610, 118, 295,
611, 119, 296,
612, 120, 297,
613, 121, 298,
614, 122, 299,
615, 123, 300,
616, 124, 301,
617, 125, 302,
618, 126, 303,
619, 127, 304,
620, 128, 305,
621, 129, 306,
622, 130, 307,
623, 131, 308,
624, 132, 309,
625, 133, 310,
626, 134, 311,
627, 135, 312,
628, 136, 313,
629, 137, 314,
630, 138, 315,
631, 139, 316,
632, 140, 317,
633, 141, 318,
634, 142, 319,
635, 143, 320,
636, 144, 321,
637, 145, 322,
638, 146, 323,
639, 147, 324,
640, 148, 325,
641, 149, 326,
642, 150, 327,
643, 151, 328,
644, 152, 329,
645, 153, 330,
646, 154, 331,
647, 155, 332,
648, 156, 333,
649, 157, 334,
650, 158, 335,
651, 159, 336,
652, 160, 337,
653, 161, 338,
654, 162, 339,
655, 163, 340,
656, 164, 341,
657, 165, 342,
658, 166, 343,
659, 167, 344,
660, 168, 345,
661, 169, 346,
662, 170, 347,
663, 171, 348,
664, 172, 349,
665, 173, 350,
666, 174, 351,
667, 175, 352,
668, 176, 353,
669, 177, 354,
670, 178, 355,
671, 179, 356,
672, 180, 357,
673, 181, 358,
674, 182, 359,
675, 183, 360,
676, 184, 361,
677, 185, 362,
678, 186, 363,
679, 187, 364,
680, 188, 365,
681, 189, 366,
682, 190, 367,
683, 191, 368,
684, 192, 369,
685, 193, 370,
686, 194, 371,
687, 195, 372,
688, 196, 373,
689, 197, 374,
690, 198, 375,
691, 199, 376,
692, 200, 377,
693, 201, 378,
694, 202, 379,
695, 203, 380,
696, 204, 381,
697, 205, 382,
698, 206, 383,
699, 207, 384,
700, 208, 385,
701, 209, 386,
702, 210, 387,
703, 211, 388,
704, 212, 389,
705, 213, 390,
706, 214, 391,
707, 215, 392,
708, 216, 393,
709, 217, 394,
710, 218, 395,
711, 219, 396,
712, 220, 397,
713, 221, 398,
714, 222, 399,
715, 223, 400,
716, 224, 401,
717, 225, 402,
718, 226, 403,
719, 227, 404,
720, 228, 405,
721, 229, 406,
722, 230, 407,
723, 231, 408,
724, 232, 409,
725, 233, 410,
726, 234, 411,
727, 235, 412,
728, 236, 413,
729, 237, 414,
730, 238, 415,
731, 239, 416,
732, 240, 417,
733, 241, 418,
734, 242, 419,
735, 243, 420,
736, 244, 421,
737, 245, 422,
738, 246, 423,
739, 247, 424,
740, 248, 425,
741, 249, 426,
742, 250, 427,
743, 251, 428,
744, 252, 429,
745, 253, 430,
746, 254, 431,
747, 255, 432,
748, 0, 433,
749, 1, 434,
750, 2, 435,
751, 3, 436,
752, 4, 437,
753, 5, 438,
754, 6, 439,
755, 7, 440,
756, 8, 441,
757, 9, 442,
758, 10, 443,
759, 11, 444,
760, 12, 445,
761, 13, 446,
762, 14, 447,
763, 15, 448,
764, 16, 449,
765, 17, 450,
766, 18, 451,
767, 19, 452,
768, 353, 603,
769, 354, 604,
770, 355, 605,
771, 356, 606,
772, 357, 607,
773, 358, 608,
774, 359, 609,
775, 360, 610,
776, 361, 611,
777, 362, 612,
778, 363, 613,
779, 364, 614,
780, 365, 615,
781, 366, 616,
782, 367, 617,
783, 368, 618,
784, 369, 619,
785, 370, 620,
786, 371, 621,
787, 372, 622,
788, 373, 623,
789, 374, 624,
790, 375, 625,
791, 376, 626,
792, 377, 627,
793, 378, 628,
794, 379, 629,
795, 380, 630,
796, 381, 631,
797, 382, 632,
798, 383, 633,
799, 384, 634,
800, 385, 635,
801, 386, 636,
802, 387, 637,
803, 388, 638,
804, 389, 639,
805, 390, 640,
806, 391, 641,
807, 392, 642,
808, 393, 643,
809, 394, 644,
810, 395, 645,
811, 396, 646,
812, 397, 647,
813, 398, 648,
814, 399, 649,
815, 400, 650,
816, 401, 651,
817, 402, 652,
818, 403, 653,
819, 404, 654,
820, 405, 655,
821, 406, 656,
822, 407, 657,
823, 408, 658,
824, 409, 659,
825, 410, 660,
826, 411, 661,
827, 412, 662,
828, 413, 663,
829, 414, 664,
830, 415, 665,
831, 416, 666,
832, 417, 667,
833, 418, 668,
834, 419, 669,
835, 420, 670,
836, 421, 671,
837, 422, 672,
838, 423, 673,
839, 424, 674,
840, 425, 675,
841, 426, 676,
842, 427, 677,
843, 428, 678,
844, 429, 679,
845, 430, 680,
846, 431, 681,
847, 432, 682,
848, 433, 683,
849, 434, 684,
850, 435, 685,
851, 436, 686,
852, 437, 687,
853, 438, 688,
854, 439, 689,
855, 440, 690,
856, 441, 691,
857, 442, 692,
858, 443, 693,
859, 444, 694,
860, 445, 695,
861, 446, 696,
862, 447, 697,
863, 448, 698,
864, 449, 699,
865, 450, 700,
866, 451, 701,
867, 452, 702,
868, 453, 703,
869, 454, 704,
870, 455, 705,
871, 456, 706,
872, 457, 707,
873, 458, 708,
874, 459, 709,
875, 460, 710,
876, 461, 711,
877, 462, 712,
878, 463, 713,
879, 464, 714,
880, 465, 715,
881, 466, 716,
882, 467, 717,
883, 468, 718,
884, 469, 719,
885, 470, 720,
886, 471, 721,
887, 472, 722,
888, 473, 723,
889, 474, 724,
890, 475, 725,
891, 476, 726,
892, 477, 727,
893, 478, 728,
894, 479, 729,
895, 480, 730,
896, 481, 731,
897, 482, 732,
898, 483, 733,
899, 484, 734,
900, 485, 735,
901, 486, 736,
902, 487, 737,
903, 488, 738,
904, 489, 739,
905, 490, 740,
906, 491, 741,
907, 492, 742,
908, 493, 743,
909, 494, 744,
910, 495, 745,
911, 496, 746,
912, 497, 747,
913, 498, 748,
914, 499, 749,
915, 500, 750,
916, 501, 751,
917, 502, 752,
918, 503, 753,
919, 504, 754,
920, 505, 755,
921, 506, 756,
922, 507, 757,
923, 508, 758,
924, 509, 759,
925, 510, 760,
926, 511, 761,
927, 256, 762,
928, 257, 763,
929, 258, 764,
930, 259, 765,
931, 260, 766,
932, 261, 767,
933, 262, 512,
934, 263, 513,
935, 264, 514,
936, 265, 515,
937, 266, 516,
938, 267, 517,
939, 268, 518,
940, 269, 519,
941, 270, 520,
942, 271, 521,
943, 272, 522,
944, 273, 523,
945, 274, 524,
946, 275, 525,
947, 276, 526,
948, 277, 527,
949, 278, 528,
950, 279, 529,
951, 280, 530,
952, 281, 531,
953, 282, 532,
954, 283, 533,
955, 284, 534,
956, 285, 535,
957, 286, 536,
958, 287, 537,
959, 288, 538,
960, 289, 539,
961, 290, 540,
962, 291, 541,
963, 292, 542,
964, 293, 543,
965, 294, 544,
966, 295, 545,
967, 296, 546,
968, 297, 547,
969, 298, 548,
970, 299, 549,
971, 300, 550,
972, 301, 551,
973, 302, 552,
974, 303, 553,
975, 304, 554,
976, 305, 555,
977, 306, 556,
978, 307, 557,
979, 308, 558,
980, 309, 559,
981, 310, 560,
982, 311, 561,
983, 312, 562,
984, 313, 563,
985, 314, 564,
986, 315, 565,
987, 316, 566,
988, 317, 567,
989, 318, 568,
990, 319, 569,
991, 320, 570,
992, 321, 571,
993, 322, 572,
994, 323, 573,
995, 324, 574,
996, 325, 575,
997, 326, 576,
998, 327, 577,
999, 328, 578,
1000, 329, 579,
1001, 330, 580,
1002, 331, 581,
1003, 332, 582,
1004, 333, 583,
1005, 334, 584,
1006, 335, 585,
1007, 336, 586,
1008, 337, 587,
1009, 338, 588,
1010, 339, 589,
1011, 340, 590,
1012, 341, 591,
1013, 342, 592,
1014, 343, 593,
1015, 344, 594,
1016, 345, 595,
1017, 346, 596,
1018, 347, 597,
1019, 348, 598,
1020, 349, 599,
1021, 350, 600,
1022, 351, 601,
1023, 352, 602};
#pragma line 278 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_2_3_2_trichk.h" 1
vars_3_23 varinx10A_4096_b[] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127,
128, 128, 128,
129, 129, 129,
130, 130, 130,
131, 131, 131,
132, 132, 132,
133, 133, 133,
134, 134, 134,
135, 135, 135,
136, 136, 136,
137, 137, 137,
138, 138, 138,
139, 139, 139,
140, 140, 140,
141, 141, 141,
142, 142, 142,
143, 143, 143,
144, 144, 144,
145, 145, 145,
146, 146, 146,
147, 147, 147,
148, 148, 148,
149, 149, 149,
150, 150, 150,
151, 151, 151,
152, 152, 152,
153, 153, 153,
154, 154, 154,
155, 155, 155,
156, 156, 156,
157, 157, 157,
158, 158, 158,
159, 159, 159,
160, 160, 160,
161, 161, 161,
162, 162, 162,
163, 163, 163,
164, 164, 164,
165, 165, 165,
166, 166, 166,
167, 167, 167,
168, 168, 168,
169, 169, 169,
170, 170, 170,
171, 171, 171,
172, 172, 172,
173, 173, 173,
174, 174, 174,
175, 175, 175,
176, 176, 176,
177, 177, 177,
178, 178, 178,
179, 179, 179,
180, 180, 180,
181, 181, 181,
182, 182, 182,
183, 183, 183,
184, 184, 184,
185, 185, 185,
186, 186, 186,
187, 187, 187,
188, 188, 188,
189, 189, 189,
190, 190, 190,
191, 191, 191,
192, 192, 192,
193, 193, 193,
194, 194, 194,
195, 195, 195,
196, 196, 196,
197, 197, 197,
198, 198, 198,
199, 199, 199,
200, 200, 200,
201, 201, 201,
202, 202, 202,
203, 203, 203,
204, 204, 204,
205, 205, 205,
206, 206, 206,
207, 207, 207,
208, 208, 208,
209, 209, 209,
210, 210, 210,
211, 211, 211,
212, 212, 212,
213, 213, 213,
214, 214, 214,
215, 215, 215,
216, 216, 216,
217, 217, 217,
218, 218, 218,
219, 219, 219,
220, 220, 220,
221, 221, 221,
222, 222, 222,
223, 223, 223,
224, 224, 224,
225, 225, 225,
226, 226, 226,
227, 227, 227,
228, 228, 228,
229, 229, 229,
230, 230, 230,
231, 231, 231,
232, 232, 232,
233, 233, 233,
234, 234, 234,
235, 235, 235,
236, 236, 236,
237, 237, 237,
238, 238, 238,
239, 239, 239,
240, 240, 240,
241, 241, 241,
242, 242, 242,
243, 243, 243,
244, 244, 244,
245, 245, 245,
246, 246, 246,
247, 247, 247,
248, 248, 248,
249, 249, 249,
250, 250, 250,
251, 251, 251,
252, 252, 252,
253, 253, 253,
254, 254, 254,
255, 255, 255,
256, 256, 256,
257, 257, 257,
258, 258, 258,
259, 259, 259,
260, 260, 260,
261, 261, 261,
262, 262, 262,
263, 263, 263,
264, 264, 264,
265, 265, 265,
266, 266, 266,
267, 267, 267,
268, 268, 268,
269, 269, 269,
270, 270, 270,
271, 271, 271,
272, 272, 272,
273, 273, 273,
274, 274, 274,
275, 275, 275,
276, 276, 276,
277, 277, 277,
278, 278, 278,
279, 279, 279,
280, 280, 280,
281, 281, 281,
282, 282, 282,
283, 283, 283,
284, 284, 284,
285, 285, 285,
286, 286, 286,
287, 287, 287,
288, 288, 288,
289, 289, 289,
290, 290, 290,
291, 291, 291,
292, 292, 292,
293, 293, 293,
294, 294, 294,
295, 295, 295,
296, 296, 296,
297, 297, 297,
298, 298, 298,
299, 299, 299,
300, 300, 300,
301, 301, 301,
302, 302, 302,
303, 303, 303,
304, 304, 304,
305, 305, 305,
306, 306, 306,
307, 307, 307,
308, 308, 308,
309, 309, 309,
310, 310, 310,
311, 311, 311,
312, 312, 312,
313, 313, 313,
314, 314, 314,
315, 315, 315,
316, 316, 316,
317, 317, 317,
318, 318, 318,
319, 319, 319,
320, 320, 320,
321, 321, 321,
322, 322, 322,
323, 323, 323,
324, 324, 324,
325, 325, 325,
326, 326, 326,
327, 327, 327,
328, 328, 328,
329, 329, 329,
330, 330, 330,
331, 331, 331,
332, 332, 332,
333, 333, 333,
334, 334, 334,
335, 335, 335,
336, 336, 336,
337, 337, 337,
338, 338, 338,
339, 339, 339,
340, 340, 340,
341, 341, 341,
342, 342, 342,
343, 343, 343,
344, 344, 344,
345, 345, 345,
346, 346, 346,
347, 347, 347,
348, 348, 348,
349, 349, 349,
350, 350, 350,
351, 351, 351,
352, 352, 352,
353, 353, 353,
354, 354, 354,
355, 355, 355,
356, 356, 356,
357, 357, 357,
358, 358, 358,
359, 359, 359,
360, 360, 360,
361, 361, 361,
362, 362, 362,
363, 363, 363,
364, 364, 364,
365, 365, 365,
366, 366, 366,
367, 367, 367,
368, 368, 368,
369, 369, 369,
370, 370, 370,
371, 371, 371,
372, 372, 372,
373, 373, 373,
374, 374, 374,
375, 375, 375,
376, 376, 376,
377, 377, 377,
378, 378, 378,
379, 379, 379,
380, 380, 380,
381, 381, 381,
382, 382, 382,
383, 383, 383,
384, 384, 384,
385, 385, 385,
386, 386, 386,
387, 387, 387,
388, 388, 388,
389, 389, 389,
390, 390, 390,
391, 391, 391,
392, 392, 392,
393, 393, 393,
394, 394, 394,
395, 395, 395,
396, 396, 396,
397, 397, 397,
398, 398, 398,
399, 399, 399,
400, 400, 400,
401, 401, 401,
402, 402, 402,
403, 403, 403,
404, 404, 404,
405, 405, 405,
406, 406, 406,
407, 407, 407,
408, 408, 408,
409, 409, 409,
410, 410, 410,
411, 411, 411,
412, 412, 412,
413, 413, 413,
414, 414, 414,
415, 415, 415,
416, 416, 416,
417, 417, 417,
418, 418, 418,
419, 419, 419,
420, 420, 420,
421, 421, 421,
422, 422, 422,
423, 423, 423,
424, 424, 424,
425, 425, 425,
426, 426, 426,
427, 427, 427,
428, 428, 428,
429, 429, 429,
430, 430, 430,
431, 431, 431,
432, 432, 432,
433, 433, 433,
434, 434, 434,
435, 435, 435,
436, 436, 436,
437, 437, 437,
438, 438, 438,
439, 439, 439,
440, 440, 440,
441, 441, 441,
442, 442, 442,
443, 443, 443,
444, 444, 444,
445, 445, 445,
446, 446, 446,
447, 447, 447,
448, 448, 448,
449, 449, 449,
450, 450, 450,
451, 451, 451,
452, 452, 452,
453, 453, 453,
454, 454, 454,
455, 455, 455,
456, 456, 456,
457, 457, 457,
458, 458, 458,
459, 459, 459,
460, 460, 460,
461, 461, 461,
462, 462, 462,
463, 463, 463,
464, 464, 464,
465, 465, 465,
466, 466, 466,
467, 467, 467,
468, 468, 468,
469, 469, 469,
470, 470, 470,
471, 471, 471,
472, 472, 472,
473, 473, 473,
474, 474, 474,
475, 475, 475,
476, 476, 476,
477, 477, 477,
478, 478, 478,
479, 479, 479,
480, 480, 480,
481, 481, 481,
482, 482, 482,
483, 483, 483,
484, 484, 484,
485, 485, 485,
486, 486, 486,
487, 487, 487,
488, 488, 488,
489, 489, 489,
490, 490, 490,
491, 491, 491,
492, 492, 492,
493, 493, 493,
494, 494, 494,
495, 495, 495,
496, 496, 496,
497, 497, 497,
498, 498, 498,
499, 499, 499,
500, 500, 500,
501, 501, 501,
502, 502, 502,
503, 503, 503,
504, 504, 504,
505, 505, 505,
506, 506, 506,
507, 507, 507,
508, 508, 508,
509, 509, 509,
510, 510, 510,
511, 511, 511,
512, 512, 512,
513, 513, 513,
514, 514, 514,
515, 515, 515,
516, 516, 516,
517, 517, 517,
518, 518, 518,
519, 519, 519,
520, 520, 520,
521, 521, 521,
522, 522, 522,
523, 523, 523,
524, 524, 524,
525, 525, 525,
526, 526, 526,
527, 527, 527,
528, 528, 528,
529, 529, 529,
530, 530, 530,
531, 531, 531,
532, 532, 532,
533, 533, 533,
534, 534, 534,
535, 535, 535,
536, 536, 536,
537, 537, 537,
538, 538, 538,
539, 539, 539,
540, 540, 540,
541, 541, 541,
542, 542, 542,
543, 543, 543,
544, 544, 544,
545, 545, 545,
546, 546, 546,
547, 547, 547,
548, 548, 548,
549, 549, 549,
550, 550, 550,
551, 551, 551,
552, 552, 552,
553, 553, 553,
554, 554, 554,
555, 555, 555,
556, 556, 556,
557, 557, 557,
558, 558, 558,
559, 559, 559,
560, 560, 560,
561, 561, 561,
562, 562, 562,
563, 563, 563,
564, 564, 564,
565, 565, 565,
566, 566, 566,
567, 567, 567,
568, 568, 568,
569, 569, 569,
570, 570, 570,
571, 571, 571,
572, 572, 572,
573, 573, 573,
574, 574, 574,
575, 575, 575,
576, 576, 576,
577, 577, 577,
578, 578, 578,
579, 579, 579,
580, 580, 580,
581, 581, 581,
582, 582, 582,
583, 583, 583,
584, 584, 584,
585, 585, 585,
586, 586, 586,
587, 587, 587,
588, 588, 588,
589, 589, 589,
590, 590, 590,
591, 591, 591,
592, 592, 592,
593, 593, 593,
594, 594, 594,
595, 595, 595,
596, 596, 596,
597, 597, 597,
598, 598, 598,
599, 599, 599,
600, 600, 600,
601, 601, 601,
602, 602, 602,
603, 603, 603,
604, 604, 604,
605, 605, 605,
606, 606, 606,
607, 607, 607,
608, 608, 608,
609, 609, 609,
610, 610, 610,
611, 611, 611,
612, 612, 612,
613, 613, 613,
614, 614, 614,
615, 615, 615,
616, 616, 616,
617, 617, 617,
618, 618, 618,
619, 619, 619,
620, 620, 620,
621, 621, 621,
622, 622, 622,
623, 623, 623,
624, 624, 624,
625, 625, 625,
626, 626, 626,
627, 627, 627,
628, 628, 628,
629, 629, 629,
630, 630, 630,
631, 631, 631,
632, 632, 632,
633, 633, 633,
634, 634, 634,
635, 635, 635,
636, 636, 636,
637, 637, 637,
638, 638, 638,
639, 639, 639,
640, 640, 640,
641, 641, 641,
642, 642, 642,
643, 643, 643,
644, 644, 644,
645, 645, 645,
646, 646, 646,
647, 647, 647,
648, 648, 648,
649, 649, 649,
650, 650, 650,
651, 651, 651,
652, 652, 652,
653, 653, 653,
654, 654, 654,
655, 655, 655,
656, 656, 656,
657, 657, 657,
658, 658, 658,
659, 659, 659,
660, 660, 660,
661, 661, 661,
662, 662, 662,
663, 663, 663,
664, 664, 664,
665, 665, 665,
666, 666, 666,
667, 667, 667,
668, 668, 668,
669, 669, 669,
670, 670, 670,
671, 671, 671,
672, 672, 672,
673, 673, 673,
674, 674, 674,
675, 675, 675,
676, 676, 676,
677, 677, 677,
678, 678, 678,
679, 679, 679,
680, 680, 680,
681, 681, 681,
682, 682, 682,
683, 683, 683,
684, 684, 684,
685, 685, 685,
686, 686, 686,
687, 687, 687,
688, 688, 688,
689, 689, 689,
690, 690, 690,
691, 691, 691,
692, 692, 692,
693, 693, 693,
694, 694, 694,
695, 695, 695,
696, 696, 696,
697, 697, 697,
698, 698, 698,
699, 699, 699,
700, 700, 700,
701, 701, 701,
702, 702, 702,
703, 703, 703,
704, 704, 704,
705, 705, 705,
706, 706, 706,
707, 707, 707,
708, 708, 708,
709, 709, 709,
710, 710, 710,
711, 711, 711,
712, 712, 712,
713, 713, 713,
714, 714, 714,
715, 715, 715,
716, 716, 716,
717, 717, 717,
718, 718, 718,
719, 719, 719,
720, 720, 720,
721, 721, 721,
722, 722, 722,
723, 723, 723,
724, 724, 724,
725, 725, 725,
726, 726, 726,
727, 727, 727,
728, 728, 728,
729, 729, 729,
730, 730, 730,
731, 731, 731,
732, 732, 732,
733, 733, 733,
734, 734, 734,
735, 735, 735,
736, 736, 736,
737, 737, 737,
738, 738, 738,
739, 739, 739,
740, 740, 740,
741, 741, 741,
742, 742, 742,
743, 743, 743,
744, 744, 744,
745, 745, 745,
746, 746, 746,
747, 747, 747,
748, 748, 748,
749, 749, 749,
750, 750, 750,
751, 751, 751,
752, 752, 752,
753, 753, 753,
754, 754, 754,
755, 755, 755,
756, 756, 756,
757, 757, 757,
758, 758, 758,
759, 759, 759,
760, 760, 760,
761, 761, 761,
762, 762, 762,
763, 763, 763,
764, 764, 764,
765, 765, 765,
766, 766, 766,
767, 767, 767,
768, 768, 768,
769, 769, 769,
770, 770, 770,
771, 771, 771,
772, 772, 772,
773, 773, 773,
774, 774, 774,
775, 775, 775,
776, 776, 776,
777, 777, 777,
778, 778, 778,
779, 779, 779,
780, 780, 780,
781, 781, 781,
782, 782, 782,
783, 783, 783,
784, 784, 784,
785, 785, 785,
786, 786, 786,
787, 787, 787,
788, 788, 788,
789, 789, 789,
790, 790, 790,
791, 791, 791,
792, 792, 792,
793, 793, 793,
794, 794, 794,
795, 795, 795,
796, 796, 796,
797, 797, 797,
798, 798, 798,
799, 799, 799,
800, 800, 800,
801, 801, 801,
802, 802, 802,
803, 803, 803,
804, 804, 804,
805, 805, 805,
806, 806, 806,
807, 807, 807,
808, 808, 808,
809, 809, 809,
810, 810, 810,
811, 811, 811,
812, 812, 812,
813, 813, 813,
814, 814, 814,
815, 815, 815,
816, 816, 816,
817, 817, 817,
818, 818, 818,
819, 819, 819,
820, 820, 820,
821, 821, 821,
822, 822, 822,
823, 823, 823,
824, 824, 824,
825, 825, 825,
826, 826, 826,
827, 827, 827,
828, 828, 828,
829, 829, 829,
830, 830, 830,
831, 831, 831,
832, 832, 832,
833, 833, 833,
834, 834, 834,
835, 835, 835,
836, 836, 836,
837, 837, 837,
838, 838, 838,
839, 839, 839,
840, 840, 840,
841, 841, 841,
842, 842, 842,
843, 843, 843,
844, 844, 844,
845, 845, 845,
846, 846, 846,
847, 847, 847,
848, 848, 848,
849, 849, 849,
850, 850, 850,
851, 851, 851,
852, 852, 852,
853, 853, 853,
854, 854, 854,
855, 855, 855,
856, 856, 856,
857, 857, 857,
858, 858, 858,
859, 859, 859,
860, 860, 860,
861, 861, 861,
862, 862, 862,
863, 863, 863,
864, 864, 864,
865, 865, 865,
866, 866, 866,
867, 867, 867,
868, 868, 868,
869, 869, 869,
870, 870, 870,
871, 871, 871,
872, 872, 872,
873, 873, 873,
874, 874, 874,
875, 875, 875,
876, 876, 876,
877, 877, 877,
878, 878, 878,
879, 879, 879,
880, 880, 880,
881, 881, 881,
882, 882, 882,
883, 883, 883,
884, 884, 884,
885, 885, 885,
886, 886, 886,
887, 887, 887,
888, 888, 888,
889, 889, 889,
890, 890, 890,
891, 891, 891,
892, 892, 892,
893, 893, 893,
894, 894, 894,
895, 895, 895,
896, 896, 896,
897, 897, 897,
898, 898, 898,
899, 899, 899,
900, 900, 900,
901, 901, 901,
902, 902, 902,
903, 903, 903,
904, 904, 904,
905, 905, 905,
906, 906, 906,
907, 907, 907,
908, 908, 908,
909, 909, 909,
910, 910, 910,
911, 911, 911,
912, 912, 912,
913, 913, 913,
914, 914, 914,
915, 915, 915,
916, 916, 916,
917, 917, 917,
918, 918, 918,
919, 919, 919,
920, 920, 920,
921, 921, 921,
922, 922, 922,
923, 923, 923,
924, 924, 924,
925, 925, 925,
926, 926, 926,
927, 927, 927,
928, 928, 928,
929, 929, 929,
930, 930, 930,
931, 931, 931,
932, 932, 932,
933, 933, 933,
934, 934, 934,
935, 935, 935,
936, 936, 936,
937, 937, 937,
938, 938, 938,
939, 939, 939,
940, 940, 940,
941, 941, 941,
942, 942, 942,
943, 943, 943,
944, 944, 944,
945, 945, 945,
946, 946, 946,
947, 947, 947,
948, 948, 948,
949, 949, 949,
950, 950, 950,
951, 951, 951,
952, 952, 952,
953, 953, 953,
954, 954, 954,
955, 955, 955,
956, 956, 956,
957, 957, 957,
958, 958, 958,
959, 959, 959,
960, 960, 960,
961, 961, 961,
962, 962, 962,
963, 963, 963,
964, 964, 964,
965, 965, 965,
966, 966, 966,
967, 967, 967,
968, 968, 968,
969, 969, 969,
970, 970, 970,
971, 971, 971,
972, 972, 972,
973, 973, 973,
974, 974, 974,
975, 975, 975,
976, 976, 976,
977, 977, 977,
978, 978, 978,
979, 979, 979,
980, 980, 980,
981, 981, 981,
982, 982, 982,
983, 983, 983,
984, 984, 984,
985, 985, 985,
986, 986, 986,
987, 987, 987,
988, 988, 988,
989, 989, 989,
990, 990, 990,
991, 991, 991,
992, 992, 992,
993, 993, 993,
994, 994, 994,
995, 995, 995,
996, 996, 996,
997, 997, 997,
998, 998, 998,
999, 999, 999,
1000, 1000, 1000,
1001, 1001, 1001,
1002, 1002, 1002,
1003, 1003, 1003,
1004, 1004, 1004,
1005, 1005, 1005,
1006, 1006, 1006,
1007, 1007, 1007,
1008, 1008, 1008,
1009, 1009, 1009,
1010, 1010, 1010,
1011, 1011, 1011,
1012, 1012, 1012,
1013, 1013, 1013,
1014, 1014, 1014,
1015, 1015, 1015,
1016, 1016, 1016,
1017, 1017, 1017,
1018, 1018, 1018,
1019, 1019, 1019,
1020, 1020, 1020,
1021, 1021, 1021,
1022, 1022, 1022,
1023, 1023, 1023 };
#pragma empty_line
vars_3_23 varinx10B_4096_b[] = {
810, 0, 721,
811, 1, 722,
812, 2, 723,
813, 3, 724,
814, 4, 725,
815, 5, 726,
816, 6, 727,
817, 7, 728,
818, 8, 729,
819, 9, 730,
820, 10, 731,
821, 11, 732,
822, 12, 733,
823, 13, 734,
824, 14, 735,
825, 15, 736,
826, 16, 737,
827, 17, 738,
828, 18, 739,
829, 19, 740,
830, 20, 741,
831, 21, 742,
832, 22, 743,
833, 23, 744,
834, 24, 745,
835, 25, 746,
836, 26, 747,
837, 27, 748,
838, 28, 749,
839, 29, 750,
840, 30, 751,
841, 31, 752,
842, 32, 753,
843, 33, 754,
844, 34, 755,
845, 35, 756,
846, 36, 757,
847, 37, 758,
848, 38, 759,
849, 39, 760,
850, 40, 761,
851, 41, 762,
852, 42, 763,
853, 43, 764,
854, 44, 765,
855, 45, 766,
856, 46, 767,
857, 47, 512,
858, 48, 513,
859, 49, 514,
860, 50, 515,
861, 51, 516,
862, 52, 517,
863, 53, 518,
864, 54, 519,
865, 55, 520,
866, 56, 521,
867, 57, 522,
868, 58, 523,
869, 59, 524,
870, 60, 525,
871, 61, 526,
872, 62, 527,
873, 63, 528,
874, 64, 529,
875, 65, 530,
876, 66, 531,
877, 67, 532,
878, 68, 533,
879, 69, 534,
880, 70, 535,
881, 71, 536,
882, 72, 537,
883, 73, 538,
884, 74, 539,
885, 75, 540,
886, 76, 541,
887, 77, 542,
888, 78, 543,
889, 79, 544,
890, 80, 545,
891, 81, 546,
892, 82, 547,
893, 83, 548,
894, 84, 549,
895, 85, 550,
896, 86, 551,
897, 87, 552,
898, 88, 553,
899, 89, 554,
900, 90, 555,
901, 91, 556,
902, 92, 557,
903, 93, 558,
904, 94, 559,
905, 95, 560,
906, 96, 561,
907, 97, 562,
908, 98, 563,
909, 99, 564,
910, 100, 565,
911, 101, 566,
912, 102, 567,
913, 103, 568,
914, 104, 569,
915, 105, 570,
916, 106, 571,
917, 107, 572,
918, 108, 573,
919, 109, 574,
920, 110, 575,
921, 111, 576,
922, 112, 577,
923, 113, 578,
924, 114, 579,
925, 115, 580,
926, 116, 581,
927, 117, 582,
928, 118, 583,
929, 119, 584,
930, 120, 585,
931, 121, 586,
932, 122, 587,
933, 123, 588,
934, 124, 589,
935, 125, 590,
936, 126, 591,
937, 127, 592,
938, 128, 593,
939, 129, 594,
940, 130, 595,
941, 131, 596,
942, 132, 597,
943, 133, 598,
944, 134, 599,
945, 135, 600,
946, 136, 601,
947, 137, 602,
948, 138, 603,
949, 139, 604,
950, 140, 605,
951, 141, 606,
952, 142, 607,
953, 143, 608,
954, 144, 609,
955, 145, 610,
956, 146, 611,
957, 147, 612,
958, 148, 613,
959, 149, 614,
960, 150, 615,
961, 151, 616,
962, 152, 617,
963, 153, 618,
964, 154, 619,
965, 155, 620,
966, 156, 621,
967, 157, 622,
968, 158, 623,
969, 159, 624,
970, 160, 625,
971, 161, 626,
972, 162, 627,
973, 163, 628,
974, 164, 629,
975, 165, 630,
976, 166, 631,
977, 167, 632,
978, 168, 633,
979, 169, 634,
980, 170, 635,
981, 171, 636,
982, 172, 637,
983, 173, 638,
984, 174, 639,
985, 175, 640,
986, 176, 641,
987, 177, 642,
988, 178, 643,
989, 179, 644,
990, 180, 645,
991, 181, 646,
992, 182, 647,
993, 183, 648,
994, 184, 649,
995, 185, 650,
996, 186, 651,
997, 187, 652,
998, 188, 653,
999, 189, 654,
1000, 190, 655,
1001, 191, 656,
1002, 192, 657,
1003, 193, 658,
1004, 194, 659,
1005, 195, 660,
1006, 196, 661,
1007, 197, 662,
1008, 198, 663,
1009, 199, 664,
1010, 200, 665,
1011, 201, 666,
1012, 202, 667,
1013, 203, 668,
1014, 204, 669,
1015, 205, 670,
1016, 206, 671,
1017, 207, 672,
1018, 208, 673,
1019, 209, 674,
1020, 210, 675,
1021, 211, 676,
1022, 212, 677,
1023, 213, 678,
768, 214, 679,
769, 215, 680,
770, 216, 681,
771, 217, 682,
772, 218, 683,
773, 219, 684,
774, 220, 685,
775, 221, 686,
776, 222, 687,
777, 223, 688,
778, 224, 689,
779, 225, 690,
780, 226, 691,
781, 227, 692,
782, 228, 693,
783, 229, 694,
784, 230, 695,
785, 231, 696,
786, 232, 697,
787, 233, 698,
788, 234, 699,
789, 235, 700,
790, 236, 701,
791, 237, 702,
792, 238, 703,
793, 239, 704,
794, 240, 705,
795, 241, 706,
796, 242, 707,
797, 243, 708,
798, 244, 709,
799, 245, 710,
800, 246, 711,
801, 247, 712,
802, 248, 713,
803, 249, 714,
804, 250, 715,
805, 251, 716,
806, 252, 717,
807, 253, 718,
808, 254, 719,
809, 255, 720,
820, 256, 141,
821, 257, 142,
822, 258, 143,
823, 259, 144,
824, 260, 145,
825, 261, 146,
826, 262, 147,
827, 263, 148,
828, 264, 149,
829, 265, 150,
830, 266, 151,
831, 267, 152,
832, 268, 153,
833, 269, 154,
834, 270, 155,
835, 271, 156,
836, 272, 157,
837, 273, 158,
838, 274, 159,
839, 275, 160,
840, 276, 161,
841, 277, 162,
842, 278, 163,
843, 279, 164,
844, 280, 165,
845, 281, 166,
846, 282, 167,
847, 283, 168,
848, 284, 169,
849, 285, 170,
850, 286, 171,
851, 287, 172,
852, 288, 173,
853, 289, 174,
854, 290, 175,
855, 291, 176,
856, 292, 177,
857, 293, 178,
858, 294, 179,
859, 295, 180,
860, 296, 181,
861, 297, 182,
862, 298, 183,
863, 299, 184,
864, 300, 185,
865, 301, 186,
866, 302, 187,
867, 303, 188,
868, 304, 189,
869, 305, 190,
870, 306, 191,
871, 307, 192,
872, 308, 193,
873, 309, 194,
874, 310, 195,
875, 311, 196,
876, 312, 197,
877, 313, 198,
878, 314, 199,
879, 315, 200,
880, 316, 201,
881, 317, 202,
882, 318, 203,
883, 319, 204,
884, 320, 205,
885, 321, 206,
886, 322, 207,
887, 323, 208,
888, 324, 209,
889, 325, 210,
890, 326, 211,
891, 327, 212,
892, 328, 213,
893, 329, 214,
894, 330, 215,
895, 331, 216,
896, 332, 217,
897, 333, 218,
898, 334, 219,
899, 335, 220,
900, 336, 221,
901, 337, 222,
902, 338, 223,
903, 339, 224,
904, 340, 225,
905, 341, 226,
906, 342, 227,
907, 343, 228,
908, 344, 229,
909, 345, 230,
910, 346, 231,
911, 347, 232,
912, 348, 233,
913, 349, 234,
914, 350, 235,
915, 351, 236,
916, 352, 237,
917, 353, 238,
918, 354, 239,
919, 355, 240,
920, 356, 241,
921, 357, 242,
922, 358, 243,
923, 359, 244,
924, 360, 245,
925, 361, 246,
926, 362, 247,
927, 363, 248,
928, 364, 249,
929, 365, 250,
930, 366, 251,
931, 367, 252,
932, 368, 253,
933, 369, 254,
934, 370, 255,
935, 371, 0,
936, 372, 1,
937, 373, 2,
938, 374, 3,
939, 375, 4,
940, 376, 5,
941, 377, 6,
942, 378, 7,
943, 379, 8,
944, 380, 9,
945, 381, 10,
946, 382, 11,
947, 383, 12,
948, 384, 13,
949, 385, 14,
950, 386, 15,
951, 387, 16,
952, 388, 17,
953, 389, 18,
954, 390, 19,
955, 391, 20,
956, 392, 21,
957, 393, 22,
958, 394, 23,
959, 395, 24,
960, 396, 25,
961, 397, 26,
962, 398, 27,
963, 399, 28,
964, 400, 29,
965, 401, 30,
966, 402, 31,
967, 403, 32,
968, 404, 33,
969, 405, 34,
970, 406, 35,
971, 407, 36,
972, 408, 37,
973, 409, 38,
974, 410, 39,
975, 411, 40,
976, 412, 41,
977, 413, 42,
978, 414, 43,
979, 415, 44,
980, 416, 45,
981, 417, 46,
982, 418, 47,
983, 419, 48,
984, 420, 49,
985, 421, 50,
986, 422, 51,
987, 423, 52,
988, 424, 53,
989, 425, 54,
990, 426, 55,
991, 427, 56,
992, 428, 57,
993, 429, 58,
994, 430, 59,
995, 431, 60,
996, 432, 61,
997, 433, 62,
998, 434, 63,
999, 435, 64,
1000, 436, 65,
1001, 437, 66,
1002, 438, 67,
1003, 439, 68,
1004, 440, 69,
1005, 441, 70,
1006, 442, 71,
1007, 443, 72,
1008, 444, 73,
1009, 445, 74,
1010, 446, 75,
1011, 447, 76,
1012, 448, 77,
1013, 449, 78,
1014, 450, 79,
1015, 451, 80,
1016, 452, 81,
1017, 453, 82,
1018, 454, 83,
1019, 455, 84,
1020, 456, 85,
1021, 457, 86,
1022, 458, 87,
1023, 459, 88,
768, 460, 89,
769, 461, 90,
770, 462, 91,
771, 463, 92,
772, 464, 93,
773, 465, 94,
774, 466, 95,
775, 467, 96,
776, 468, 97,
777, 469, 98,
778, 470, 99,
779, 471, 100,
780, 472, 101,
781, 473, 102,
782, 474, 103,
783, 475, 104,
784, 476, 105,
785, 477, 106,
786, 478, 107,
787, 479, 108,
788, 480, 109,
789, 481, 110,
790, 482, 111,
791, 483, 112,
792, 484, 113,
793, 485, 114,
794, 486, 115,
795, 487, 116,
796, 488, 117,
797, 489, 118,
798, 490, 119,
799, 491, 120,
800, 492, 121,
801, 493, 122,
802, 494, 123,
803, 495, 124,
804, 496, 125,
805, 497, 126,
806, 498, 127,
807, 499, 128,
808, 500, 129,
809, 501, 130,
810, 502, 131,
811, 503, 132,
812, 504, 133,
813, 505, 134,
814, 506, 135,
815, 507, 136,
816, 508, 137,
817, 509, 138,
818, 510, 139,
819, 511, 140,
605, 512, 84,
606, 513, 85,
607, 514, 86,
608, 515, 87,
609, 516, 88,
610, 517, 89,
611, 518, 90,
612, 519, 91,
613, 520, 92,
614, 521, 93,
615, 522, 94,
616, 523, 95,
617, 524, 96,
618, 525, 97,
619, 526, 98,
620, 527, 99,
621, 528, 100,
622, 529, 101,
623, 530, 102,
624, 531, 103,
625, 532, 104,
626, 533, 105,
627, 534, 106,
628, 535, 107,
629, 536, 108,
630, 537, 109,
631, 538, 110,
632, 539, 111,
633, 540, 112,
634, 541, 113,
635, 542, 114,
636, 543, 115,
637, 544, 116,
638, 545, 117,
639, 546, 118,
640, 547, 119,
641, 548, 120,
642, 549, 121,
643, 550, 122,
644, 551, 123,
645, 552, 124,
646, 553, 125,
647, 554, 126,
648, 555, 127,
649, 556, 128,
650, 557, 129,
651, 558, 130,
652, 559, 131,
653, 560, 132,
654, 561, 133,
655, 562, 134,
656, 563, 135,
657, 564, 136,
658, 565, 137,
659, 566, 138,
660, 567, 139,
661, 568, 140,
662, 569, 141,
663, 570, 142,
664, 571, 143,
665, 572, 144,
666, 573, 145,
667, 574, 146,
668, 575, 147,
669, 576, 148,
670, 577, 149,
671, 578, 150,
672, 579, 151,
673, 580, 152,
674, 581, 153,
675, 582, 154,
676, 583, 155,
677, 584, 156,
678, 585, 157,
679, 586, 158,
680, 587, 159,
681, 588, 160,
682, 589, 161,
683, 590, 162,
684, 591, 163,
685, 592, 164,
686, 593, 165,
687, 594, 166,
688, 595, 167,
689, 596, 168,
690, 597, 169,
691, 598, 170,
692, 599, 171,
693, 600, 172,
694, 601, 173,
695, 602, 174,
696, 603, 175,
697, 604, 176,
698, 605, 177,
699, 606, 178,
700, 607, 179,
701, 608, 180,
702, 609, 181,
703, 610, 182,
704, 611, 183,
705, 612, 184,
706, 613, 185,
707, 614, 186,
708, 615, 187,
709, 616, 188,
710, 617, 189,
711, 618, 190,
712, 619, 191,
713, 620, 192,
714, 621, 193,
715, 622, 194,
716, 623, 195,
717, 624, 196,
718, 625, 197,
719, 626, 198,
720, 627, 199,
721, 628, 200,
722, 629, 201,
723, 630, 202,
724, 631, 203,
725, 632, 204,
726, 633, 205,
727, 634, 206,
728, 635, 207,
729, 636, 208,
730, 637, 209,
731, 638, 210,
732, 639, 211,
733, 640, 212,
734, 641, 213,
735, 642, 214,
736, 643, 215,
737, 644, 216,
738, 645, 217,
739, 646, 218,
740, 647, 219,
741, 648, 220,
742, 649, 221,
743, 650, 222,
744, 651, 223,
745, 652, 224,
746, 653, 225,
747, 654, 226,
748, 655, 227,
749, 656, 228,
750, 657, 229,
751, 658, 230,
752, 659, 231,
753, 660, 232,
754, 661, 233,
755, 662, 234,
756, 663, 235,
757, 664, 236,
758, 665, 237,
759, 666, 238,
760, 667, 239,
761, 668, 240,
762, 669, 241,
763, 670, 242,
764, 671, 243,
765, 672, 244,
766, 673, 245,
767, 674, 246,
512, 675, 247,
513, 676, 248,
514, 677, 249,
515, 678, 250,
516, 679, 251,
517, 680, 252,
518, 681, 253,
519, 682, 254,
520, 683, 255,
521, 684, 0,
522, 685, 1,
523, 686, 2,
524, 687, 3,
525, 688, 4,
526, 689, 5,
527, 690, 6,
528, 691, 7,
529, 692, 8,
530, 693, 9,
531, 694, 10,
532, 695, 11,
533, 696, 12,
534, 697, 13,
535, 698, 14,
536, 699, 15,
537, 700, 16,
538, 701, 17,
539, 702, 18,
540, 703, 19,
541, 704, 20,
542, 705, 21,
543, 706, 22,
544, 707, 23,
545, 708, 24,
546, 709, 25,
547, 710, 26,
548, 711, 27,
549, 712, 28,
550, 713, 29,
551, 714, 30,
552, 715, 31,
553, 716, 32,
554, 717, 33,
555, 718, 34,
556, 719, 35,
557, 720, 36,
558, 721, 37,
559, 722, 38,
560, 723, 39,
561, 724, 40,
562, 725, 41,
563, 726, 42,
564, 727, 43,
565, 728, 44,
566, 729, 45,
567, 730, 46,
568, 731, 47,
569, 732, 48,
570, 733, 49,
571, 734, 50,
572, 735, 51,
573, 736, 52,
574, 737, 53,
575, 738, 54,
576, 739, 55,
577, 740, 56,
578, 741, 57,
579, 742, 58,
580, 743, 59,
581, 744, 60,
582, 745, 61,
583, 746, 62,
584, 747, 63,
585, 748, 64,
586, 749, 65,
587, 750, 66,
588, 751, 67,
589, 752, 68,
590, 753, 69,
591, 754, 70,
592, 755, 71,
593, 756, 72,
594, 757, 73,
595, 758, 74,
596, 759, 75,
597, 760, 76,
598, 761, 77,
599, 762, 78,
600, 763, 79,
601, 764, 80,
602, 765, 81,
603, 766, 82,
604, 767, 83,
785, 768, 420,
786, 769, 421,
787, 770, 422,
788, 771, 423,
789, 772, 424,
790, 773, 425,
791, 774, 426,
792, 775, 427,
793, 776, 428,
794, 777, 429,
795, 778, 430,
796, 779, 431,
797, 780, 432,
798, 781, 433,
799, 782, 434,
800, 783, 435,
801, 784, 436,
802, 785, 437,
803, 786, 438,
804, 787, 439,
805, 788, 440,
806, 789, 441,
807, 790, 442,
808, 791, 443,
809, 792, 444,
810, 793, 445,
811, 794, 446,
812, 795, 447,
813, 796, 448,
814, 797, 449,
815, 798, 450,
816, 799, 451,
817, 800, 452,
818, 801, 453,
819, 802, 454,
820, 803, 455,
821, 804, 456,
822, 805, 457,
823, 806, 458,
824, 807, 459,
825, 808, 460,
826, 809, 461,
827, 810, 462,
828, 811, 463,
829, 812, 464,
830, 813, 465,
831, 814, 466,
832, 815, 467,
833, 816, 468,
834, 817, 469,
835, 818, 470,
836, 819, 471,
837, 820, 472,
838, 821, 473,
839, 822, 474,
840, 823, 475,
841, 824, 476,
842, 825, 477,
843, 826, 478,
844, 827, 479,
845, 828, 480,
846, 829, 481,
847, 830, 482,
848, 831, 483,
849, 832, 484,
850, 833, 485,
851, 834, 486,
852, 835, 487,
853, 836, 488,
854, 837, 489,
855, 838, 490,
856, 839, 491,
857, 840, 492,
858, 841, 493,
859, 842, 494,
860, 843, 495,
861, 844, 496,
862, 845, 497,
863, 846, 498,
864, 847, 499,
865, 848, 500,
866, 849, 501,
867, 850, 502,
868, 851, 503,
869, 852, 504,
870, 853, 505,
871, 854, 506,
872, 855, 507,
873, 856, 508,
874, 857, 509,
875, 858, 510,
876, 859, 511,
877, 860, 256,
878, 861, 257,
879, 862, 258,
880, 863, 259,
881, 864, 260,
882, 865, 261,
883, 866, 262,
884, 867, 263,
885, 868, 264,
886, 869, 265,
887, 870, 266,
888, 871, 267,
889, 872, 268,
890, 873, 269,
891, 874, 270,
892, 875, 271,
893, 876, 272,
894, 877, 273,
895, 878, 274,
896, 879, 275,
897, 880, 276,
898, 881, 277,
899, 882, 278,
900, 883, 279,
901, 884, 280,
902, 885, 281,
903, 886, 282,
904, 887, 283,
905, 888, 284,
906, 889, 285,
907, 890, 286,
908, 891, 287,
909, 892, 288,
910, 893, 289,
911, 894, 290,
912, 895, 291,
913, 896, 292,
914, 897, 293,
915, 898, 294,
916, 899, 295,
917, 900, 296,
918, 901, 297,
919, 902, 298,
920, 903, 299,
921, 904, 300,
922, 905, 301,
923, 906, 302,
924, 907, 303,
925, 908, 304,
926, 909, 305,
927, 910, 306,
928, 911, 307,
929, 912, 308,
930, 913, 309,
931, 914, 310,
932, 915, 311,
933, 916, 312,
934, 917, 313,
935, 918, 314,
936, 919, 315,
937, 920, 316,
938, 921, 317,
939, 922, 318,
940, 923, 319,
941, 924, 320,
942, 925, 321,
943, 926, 322,
944, 927, 323,
945, 928, 324,
946, 929, 325,
947, 930, 326,
948, 931, 327,
949, 932, 328,
950, 933, 329,
951, 934, 330,
952, 935, 331,
953, 936, 332,
954, 937, 333,
955, 938, 334,
956, 939, 335,
957, 940, 336,
958, 941, 337,
959, 942, 338,
960, 943, 339,
961, 944, 340,
962, 945, 341,
963, 946, 342,
964, 947, 343,
965, 948, 344,
966, 949, 345,
967, 950, 346,
968, 951, 347,
969, 952, 348,
970, 953, 349,
971, 954, 350,
972, 955, 351,
973, 956, 352,
974, 957, 353,
975, 958, 354,
976, 959, 355,
977, 960, 356,
978, 961, 357,
979, 962, 358,
980, 963, 359,
981, 964, 360,
982, 965, 361,
983, 966, 362,
984, 967, 363,
985, 968, 364,
986, 969, 365,
987, 970, 366,
988, 971, 367,
989, 972, 368,
990, 973, 369,
991, 974, 370,
992, 975, 371,
993, 976, 372,
994, 977, 373,
995, 978, 374,
996, 979, 375,
997, 980, 376,
998, 981, 377,
999, 982, 378,
1000, 983, 379,
1001, 984, 380,
1002, 985, 381,
1003, 986, 382,
1004, 987, 383,
1005, 988, 384,
1006, 989, 385,
1007, 990, 386,
1008, 991, 387,
1009, 992, 388,
1010, 993, 389,
1011, 994, 390,
1012, 995, 391,
1013, 996, 392,
1014, 997, 393,
1015, 998, 394,
1016, 999, 395,
1017, 1000, 396,
1018, 1001, 397,
1019, 1002, 398,
1020, 1003, 399,
1021, 1004, 400,
1022, 1005, 401,
1023, 1006, 402,
768, 1007, 403,
769, 1008, 404,
770, 1009, 405,
771, 1010, 406,
772, 1011, 407,
773, 1012, 408,
774, 1013, 409,
775, 1014, 410,
776, 1015, 411,
777, 1016, 412,
778, 1017, 413,
779, 1018, 414,
780, 1019, 415,
781, 1020, 416,
782, 1021, 417,
783, 1022, 418,
784, 1023, 419 };
#pragma line 279 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_2_3_3_trichk.h" 1
vars_3_23 varinx10A_4096_c[] = {
0, 241, 441,
1, 242, 442,
2, 243, 443,
3, 244, 444,
4, 245, 445,
5, 246, 446,
6, 247, 447,
7, 248, 448,
8, 249, 449,
9, 250, 450,
10, 251, 451,
11, 252, 452,
12, 253, 453,
13, 254, 454,
14, 255, 455,
15, 0, 456,
16, 1, 457,
17, 2, 458,
18, 3, 459,
19, 4, 460,
20, 5, 461,
21, 6, 462,
22, 7, 463,
23, 8, 464,
24, 9, 465,
25, 10, 466,
26, 11, 467,
27, 12, 468,
28, 13, 469,
29, 14, 470,
30, 15, 471,
31, 16, 472,
32, 17, 473,
33, 18, 474,
34, 19, 475,
35, 20, 476,
36, 21, 477,
37, 22, 478,
38, 23, 479,
39, 24, 480,
40, 25, 481,
41, 26, 482,
42, 27, 483,
43, 28, 484,
44, 29, 485,
45, 30, 486,
46, 31, 487,
47, 32, 488,
48, 33, 489,
49, 34, 490,
50, 35, 491,
51, 36, 492,
52, 37, 493,
53, 38, 494,
54, 39, 495,
55, 40, 496,
56, 41, 497,
57, 42, 498,
58, 43, 499,
59, 44, 500,
60, 45, 501,
61, 46, 502,
62, 47, 503,
63, 48, 504,
64, 49, 505,
65, 50, 506,
66, 51, 507,
67, 52, 508,
68, 53, 509,
69, 54, 510,
70, 55, 511,
71, 56, 256,
72, 57, 257,
73, 58, 258,
74, 59, 259,
75, 60, 260,
76, 61, 261,
77, 62, 262,
78, 63, 263,
79, 64, 264,
80, 65, 265,
81, 66, 266,
82, 67, 267,
83, 68, 268,
84, 69, 269,
85, 70, 270,
86, 71, 271,
87, 72, 272,
88, 73, 273,
89, 74, 274,
90, 75, 275,
91, 76, 276,
92, 77, 277,
93, 78, 278,
94, 79, 279,
95, 80, 280,
96, 81, 281,
97, 82, 282,
98, 83, 283,
99, 84, 284,
100, 85, 285,
101, 86, 286,
102, 87, 287,
103, 88, 288,
104, 89, 289,
105, 90, 290,
106, 91, 291,
107, 92, 292,
108, 93, 293,
109, 94, 294,
110, 95, 295,
111, 96, 296,
112, 97, 297,
113, 98, 298,
114, 99, 299,
115, 100, 300,
116, 101, 301,
117, 102, 302,
118, 103, 303,
119, 104, 304,
120, 105, 305,
121, 106, 306,
122, 107, 307,
123, 108, 308,
124, 109, 309,
125, 110, 310,
126, 111, 311,
127, 112, 312,
128, 113, 313,
129, 114, 314,
130, 115, 315,
131, 116, 316,
132, 117, 317,
133, 118, 318,
134, 119, 319,
135, 120, 320,
136, 121, 321,
137, 122, 322,
138, 123, 323,
139, 124, 324,
140, 125, 325,
141, 126, 326,
142, 127, 327,
143, 128, 328,
144, 129, 329,
145, 130, 330,
146, 131, 331,
147, 132, 332,
148, 133, 333,
149, 134, 334,
150, 135, 335,
151, 136, 336,
152, 137, 337,
153, 138, 338,
154, 139, 339,
155, 140, 340,
156, 141, 341,
157, 142, 342,
158, 143, 343,
159, 144, 344,
160, 145, 345,
161, 146, 346,
162, 147, 347,
163, 148, 348,
164, 149, 349,
165, 150, 350,
166, 151, 351,
167, 152, 352,
168, 153, 353,
169, 154, 354,
170, 155, 355,
171, 156, 356,
172, 157, 357,
173, 158, 358,
174, 159, 359,
175, 160, 360,
176, 161, 361,
177, 162, 362,
178, 163, 363,
179, 164, 364,
180, 165, 365,
181, 166, 366,
182, 167, 367,
183, 168, 368,
184, 169, 369,
185, 170, 370,
186, 171, 371,
187, 172, 372,
188, 173, 373,
189, 174, 374,
190, 175, 375,
191, 176, 376,
192, 177, 377,
193, 178, 378,
194, 179, 379,
195, 180, 380,
196, 181, 381,
197, 182, 382,
198, 183, 383,
199, 184, 384,
200, 185, 385,
201, 186, 386,
202, 187, 387,
203, 188, 388,
204, 189, 389,
205, 190, 390,
206, 191, 391,
207, 192, 392,
208, 193, 393,
209, 194, 394,
210, 195, 395,
211, 196, 396,
212, 197, 397,
213, 198, 398,
214, 199, 399,
215, 200, 400,
216, 201, 401,
217, 202, 402,
218, 203, 403,
219, 204, 404,
220, 205, 405,
221, 206, 406,
222, 207, 407,
223, 208, 408,
224, 209, 409,
225, 210, 410,
226, 211, 411,
227, 212, 412,
228, 213, 413,
229, 214, 414,
230, 215, 415,
231, 216, 416,
232, 217, 417,
233, 218, 418,
234, 219, 419,
235, 220, 420,
236, 221, 421,
237, 222, 422,
238, 223, 423,
239, 224, 424,
240, 225, 425,
241, 226, 426,
242, 227, 427,
243, 228, 428,
244, 229, 429,
245, 230, 430,
246, 231, 431,
247, 232, 432,
248, 233, 433,
249, 234, 434,
250, 235, 435,
251, 236, 436,
252, 237, 437,
253, 238, 438,
254, 239, 439,
255, 240, 440,
256, 438, 761,
257, 439, 762,
258, 440, 763,
259, 441, 764,
260, 442, 765,
261, 443, 766,
262, 444, 767,
263, 445, 512,
264, 446, 513,
265, 447, 514,
266, 448, 515,
267, 449, 516,
268, 450, 517,
269, 451, 518,
270, 452, 519,
271, 453, 520,
272, 454, 521,
273, 455, 522,
274, 456, 523,
275, 457, 524,
276, 458, 525,
277, 459, 526,
278, 460, 527,
279, 461, 528,
280, 462, 529,
281, 463, 530,
282, 464, 531,
283, 465, 532,
284, 466, 533,
285, 467, 534,
286, 468, 535,
287, 469, 536,
288, 470, 537,
289, 471, 538,
290, 472, 539,
291, 473, 540,
292, 474, 541,
293, 475, 542,
294, 476, 543,
295, 477, 544,
296, 478, 545,
297, 479, 546,
298, 480, 547,
299, 481, 548,
300, 482, 549,
301, 483, 550,
302, 484, 551,
303, 485, 552,
304, 486, 553,
305, 487, 554,
306, 488, 555,
307, 489, 556,
308, 490, 557,
309, 491, 558,
310, 492, 559,
311, 493, 560,
312, 494, 561,
313, 495, 562,
314, 496, 563,
315, 497, 564,
316, 498, 565,
317, 499, 566,
318, 500, 567,
319, 501, 568,
320, 502, 569,
321, 503, 570,
322, 504, 571,
323, 505, 572,
324, 506, 573,
325, 507, 574,
326, 508, 575,
327, 509, 576,
328, 510, 577,
329, 511, 578,
330, 256, 579,
331, 257, 580,
332, 258, 581,
333, 259, 582,
334, 260, 583,
335, 261, 584,
336, 262, 585,
337, 263, 586,
338, 264, 587,
339, 265, 588,
340, 266, 589,
341, 267, 590,
342, 268, 591,
343, 269, 592,
344, 270, 593,
345, 271, 594,
346, 272, 595,
347, 273, 596,
348, 274, 597,
349, 275, 598,
350, 276, 599,
351, 277, 600,
352, 278, 601,
353, 279, 602,
354, 280, 603,
355, 281, 604,
356, 282, 605,
357, 283, 606,
358, 284, 607,
359, 285, 608,
360, 286, 609,
361, 287, 610,
362, 288, 611,
363, 289, 612,
364, 290, 613,
365, 291, 614,
366, 292, 615,
367, 293, 616,
368, 294, 617,
369, 295, 618,
370, 296, 619,
371, 297, 620,
372, 298, 621,
373, 299, 622,
374, 300, 623,
375, 301, 624,
376, 302, 625,
377, 303, 626,
378, 304, 627,
379, 305, 628,
380, 306, 629,
381, 307, 630,
382, 308, 631,
383, 309, 632,
384, 310, 633,
385, 311, 634,
386, 312, 635,
387, 313, 636,
388, 314, 637,
389, 315, 638,
390, 316, 639,
391, 317, 640,
392, 318, 641,
393, 319, 642,
394, 320, 643,
395, 321, 644,
396, 322, 645,
397, 323, 646,
398, 324, 647,
399, 325, 648,
400, 326, 649,
401, 327, 650,
402, 328, 651,
403, 329, 652,
404, 330, 653,
405, 331, 654,
406, 332, 655,
407, 333, 656,
408, 334, 657,
409, 335, 658,
410, 336, 659,
411, 337, 660,
412, 338, 661,
413, 339, 662,
414, 340, 663,
415, 341, 664,
416, 342, 665,
417, 343, 666,
418, 344, 667,
419, 345, 668,
420, 346, 669,
421, 347, 670,
422, 348, 671,
423, 349, 672,
424, 350, 673,
425, 351, 674,
426, 352, 675,
427, 353, 676,
428, 354, 677,
429, 355, 678,
430, 356, 679,
431, 357, 680,
432, 358, 681,
433, 359, 682,
434, 360, 683,
435, 361, 684,
436, 362, 685,
437, 363, 686,
438, 364, 687,
439, 365, 688,
440, 366, 689,
441, 367, 690,
442, 368, 691,
443, 369, 692,
444, 370, 693,
445, 371, 694,
446, 372, 695,
447, 373, 696,
448, 374, 697,
449, 375, 698,
450, 376, 699,
451, 377, 700,
452, 378, 701,
453, 379, 702,
454, 380, 703,
455, 381, 704,
456, 382, 705,
457, 383, 706,
458, 384, 707,
459, 385, 708,
460, 386, 709,
461, 387, 710,
462, 388, 711,
463, 389, 712,
464, 390, 713,
465, 391, 714,
466, 392, 715,
467, 393, 716,
468, 394, 717,
469, 395, 718,
470, 396, 719,
471, 397, 720,
472, 398, 721,
473, 399, 722,
474, 400, 723,
475, 401, 724,
476, 402, 725,
477, 403, 726,
478, 404, 727,
479, 405, 728,
480, 406, 729,
481, 407, 730,
482, 408, 731,
483, 409, 732,
484, 410, 733,
485, 411, 734,
486, 412, 735,
487, 413, 736,
488, 414, 737,
489, 415, 738,
490, 416, 739,
491, 417, 740,
492, 418, 741,
493, 419, 742,
494, 420, 743,
495, 421, 744,
496, 422, 745,
497, 423, 746,
498, 424, 747,
499, 425, 748,
500, 426, 749,
501, 427, 750,
502, 428, 751,
503, 429, 752,
504, 430, 753,
505, 431, 754,
506, 432, 755,
507, 433, 756,
508, 434, 757,
509, 435, 758,
510, 436, 759,
511, 437, 760,
512, 214, 547,
513, 215, 548,
514, 216, 549,
515, 217, 550,
516, 218, 551,
517, 219, 552,
518, 220, 553,
519, 221, 554,
520, 222, 555,
521, 223, 556,
522, 224, 557,
523, 225, 558,
524, 226, 559,
525, 227, 560,
526, 228, 561,
527, 229, 562,
528, 230, 563,
529, 231, 564,
530, 232, 565,
531, 233, 566,
532, 234, 567,
533, 235, 568,
534, 236, 569,
535, 237, 570,
536, 238, 571,
537, 239, 572,
538, 240, 573,
539, 241, 574,
540, 242, 575,
541, 243, 576,
542, 244, 577,
543, 245, 578,
544, 246, 579,
545, 247, 580,
546, 248, 581,
547, 249, 582,
548, 250, 583,
549, 251, 584,
550, 252, 585,
551, 253, 586,
552, 254, 587,
553, 255, 588,
554, 0, 589,
555, 1, 590,
556, 2, 591,
557, 3, 592,
558, 4, 593,
559, 5, 594,
560, 6, 595,
561, 7, 596,
562, 8, 597,
563, 9, 598,
564, 10, 599,
565, 11, 600,
566, 12, 601,
567, 13, 602,
568, 14, 603,
569, 15, 604,
570, 16, 605,
571, 17, 606,
572, 18, 607,
573, 19, 608,
574, 20, 609,
575, 21, 610,
576, 22, 611,
577, 23, 612,
578, 24, 613,
579, 25, 614,
580, 26, 615,
581, 27, 616,
582, 28, 617,
583, 29, 618,
584, 30, 619,
585, 31, 620,
586, 32, 621,
587, 33, 622,
588, 34, 623,
589, 35, 624,
590, 36, 625,
591, 37, 626,
592, 38, 627,
593, 39, 628,
594, 40, 629,
595, 41, 630,
596, 42, 631,
597, 43, 632,
598, 44, 633,
599, 45, 634,
600, 46, 635,
601, 47, 636,
602, 48, 637,
603, 49, 638,
604, 50, 639,
605, 51, 640,
606, 52, 641,
607, 53, 642,
608, 54, 643,
609, 55, 644,
610, 56, 645,
611, 57, 646,
612, 58, 647,
613, 59, 648,
614, 60, 649,
615, 61, 650,
616, 62, 651,
617, 63, 652,
618, 64, 653,
619, 65, 654,
620, 66, 655,
621, 67, 656,
622, 68, 657,
623, 69, 658,
624, 70, 659,
625, 71, 660,
626, 72, 661,
627, 73, 662,
628, 74, 663,
629, 75, 664,
630, 76, 665,
631, 77, 666,
632, 78, 667,
633, 79, 668,
634, 80, 669,
635, 81, 670,
636, 82, 671,
637, 83, 672,
638, 84, 673,
639, 85, 674,
640, 86, 675,
641, 87, 676,
642, 88, 677,
643, 89, 678,
644, 90, 679,
645, 91, 680,
646, 92, 681,
647, 93, 682,
648, 94, 683,
649, 95, 684,
650, 96, 685,
651, 97, 686,
652, 98, 687,
653, 99, 688,
654, 100, 689,
655, 101, 690,
656, 102, 691,
657, 103, 692,
658, 104, 693,
659, 105, 694,
660, 106, 695,
661, 107, 696,
662, 108, 697,
663, 109, 698,
664, 110, 699,
665, 111, 700,
666, 112, 701,
667, 113, 702,
668, 114, 703,
669, 115, 704,
670, 116, 705,
671, 117, 706,
672, 118, 707,
673, 119, 708,
674, 120, 709,
675, 121, 710,
676, 122, 711,
677, 123, 712,
678, 124, 713,
679, 125, 714,
680, 126, 715,
681, 127, 716,
682, 128, 717,
683, 129, 718,
684, 130, 719,
685, 131, 720,
686, 132, 721,
687, 133, 722,
688, 134, 723,
689, 135, 724,
690, 136, 725,
691, 137, 726,
692, 138, 727,
693, 139, 728,
694, 140, 729,
695, 141, 730,
696, 142, 731,
697, 143, 732,
698, 144, 733,
699, 145, 734,
700, 146, 735,
701, 147, 736,
702, 148, 737,
703, 149, 738,
704, 150, 739,
705, 151, 740,
706, 152, 741,
707, 153, 742,
708, 154, 743,
709, 155, 744,
710, 156, 745,
711, 157, 746,
712, 158, 747,
713, 159, 748,
714, 160, 749,
715, 161, 750,
716, 162, 751,
717, 163, 752,
718, 164, 753,
719, 165, 754,
720, 166, 755,
721, 167, 756,
722, 168, 757,
723, 169, 758,
724, 170, 759,
725, 171, 760,
726, 172, 761,
727, 173, 762,
728, 174, 763,
729, 175, 764,
730, 176, 765,
731, 177, 766,
732, 178, 767,
733, 179, 512,
734, 180, 513,
735, 181, 514,
736, 182, 515,
737, 183, 516,
738, 184, 517,
739, 185, 518,
740, 186, 519,
741, 187, 520,
742, 188, 521,
743, 189, 522,
744, 190, 523,
745, 191, 524,
746, 192, 525,
747, 193, 526,
748, 194, 527,
749, 195, 528,
750, 196, 529,
751, 197, 530,
752, 198, 531,
753, 199, 532,
754, 200, 533,
755, 201, 534,
756, 202, 535,
757, 203, 536,
758, 204, 537,
759, 205, 538,
760, 206, 539,
761, 207, 540,
762, 208, 541,
763, 209, 542,
764, 210, 543,
765, 211, 544,
766, 212, 545,
767, 213, 546,
768, 7, 287,
769, 8, 288,
770, 9, 289,
771, 10, 290,
772, 11, 291,
773, 12, 292,
774, 13, 293,
775, 14, 294,
776, 15, 295,
777, 16, 296,
778, 17, 297,
779, 18, 298,
780, 19, 299,
781, 20, 300,
782, 21, 301,
783, 22, 302,
784, 23, 303,
785, 24, 304,
786, 25, 305,
787, 26, 306,
788, 27, 307,
789, 28, 308,
790, 29, 309,
791, 30, 310,
792, 31, 311,
793, 32, 312,
794, 33, 313,
795, 34, 314,
796, 35, 315,
797, 36, 316,
798, 37, 317,
799, 38, 318,
800, 39, 319,
801, 40, 320,
802, 41, 321,
803, 42, 322,
804, 43, 323,
805, 44, 324,
806, 45, 325,
807, 46, 326,
808, 47, 327,
809, 48, 328,
810, 49, 329,
811, 50, 330,
812, 51, 331,
813, 52, 332,
814, 53, 333,
815, 54, 334,
816, 55, 335,
817, 56, 336,
818, 57, 337,
819, 58, 338,
820, 59, 339,
821, 60, 340,
822, 61, 341,
823, 62, 342,
824, 63, 343,
825, 64, 344,
826, 65, 345,
827, 66, 346,
828, 67, 347,
829, 68, 348,
830, 69, 349,
831, 70, 350,
832, 71, 351,
833, 72, 352,
834, 73, 353,
835, 74, 354,
836, 75, 355,
837, 76, 356,
838, 77, 357,
839, 78, 358,
840, 79, 359,
841, 80, 360,
842, 81, 361,
843, 82, 362,
844, 83, 363,
845, 84, 364,
846, 85, 365,
847, 86, 366,
848, 87, 367,
849, 88, 368,
850, 89, 369,
851, 90, 370,
852, 91, 371,
853, 92, 372,
854, 93, 373,
855, 94, 374,
856, 95, 375,
857, 96, 376,
858, 97, 377,
859, 98, 378,
860, 99, 379,
861, 100, 380,
862, 101, 381,
863, 102, 382,
864, 103, 383,
865, 104, 384,
866, 105, 385,
867, 106, 386,
868, 107, 387,
869, 108, 388,
870, 109, 389,
871, 110, 390,
872, 111, 391,
873, 112, 392,
874, 113, 393,
875, 114, 394,
876, 115, 395,
877, 116, 396,
878, 117, 397,
879, 118, 398,
880, 119, 399,
881, 120, 400,
882, 121, 401,
883, 122, 402,
884, 123, 403,
885, 124, 404,
886, 125, 405,
887, 126, 406,
888, 127, 407,
889, 128, 408,
890, 129, 409,
891, 130, 410,
892, 131, 411,
893, 132, 412,
894, 133, 413,
895, 134, 414,
896, 135, 415,
897, 136, 416,
898, 137, 417,
899, 138, 418,
900, 139, 419,
901, 140, 420,
902, 141, 421,
903, 142, 422,
904, 143, 423,
905, 144, 424,
906, 145, 425,
907, 146, 426,
908, 147, 427,
909, 148, 428,
910, 149, 429,
911, 150, 430,
912, 151, 431,
913, 152, 432,
914, 153, 433,
915, 154, 434,
916, 155, 435,
917, 156, 436,
918, 157, 437,
919, 158, 438,
920, 159, 439,
921, 160, 440,
922, 161, 441,
923, 162, 442,
924, 163, 443,
925, 164, 444,
926, 165, 445,
927, 166, 446,
928, 167, 447,
929, 168, 448,
930, 169, 449,
931, 170, 450,
932, 171, 451,
933, 172, 452,
934, 173, 453,
935, 174, 454,
936, 175, 455,
937, 176, 456,
938, 177, 457,
939, 178, 458,
940, 179, 459,
941, 180, 460,
942, 181, 461,
943, 182, 462,
944, 183, 463,
945, 184, 464,
946, 185, 465,
947, 186, 466,
948, 187, 467,
949, 188, 468,
950, 189, 469,
951, 190, 470,
952, 191, 471,
953, 192, 472,
954, 193, 473,
955, 194, 474,
956, 195, 475,
957, 196, 476,
958, 197, 477,
959, 198, 478,
960, 199, 479,
961, 200, 480,
962, 201, 481,
963, 202, 482,
964, 203, 483,
965, 204, 484,
966, 205, 485,
967, 206, 486,
968, 207, 487,
969, 208, 488,
970, 209, 489,
971, 210, 490,
972, 211, 491,
973, 212, 492,
974, 213, 493,
975, 214, 494,
976, 215, 495,
977, 216, 496,
978, 217, 497,
979, 218, 498,
980, 219, 499,
981, 220, 500,
982, 221, 501,
983, 222, 502,
984, 223, 503,
985, 224, 504,
986, 225, 505,
987, 226, 506,
988, 227, 507,
989, 228, 508,
990, 229, 509,
991, 230, 510,
992, 231, 511,
993, 232, 256,
994, 233, 257,
995, 234, 258,
996, 235, 259,
997, 236, 260,
998, 237, 261,
999, 238, 262,
1000, 239, 263,
1001, 240, 264,
1002, 241, 265,
1003, 242, 266,
1004, 243, 267,
1005, 244, 268,
1006, 245, 269,
1007, 246, 270,
1008, 247, 271,
1009, 248, 272,
1010, 249, 273,
1011, 250, 274,
1012, 251, 275,
1013, 252, 276,
1014, 253, 277,
1015, 254, 278,
1016, 255, 279,
1017, 0, 280,
1018, 1, 281,
1019, 2, 282,
1020, 3, 283,
1021, 4, 284,
1022, 5, 285,
1023, 6, 286 };
#pragma empty_line
vars_3_23 varinx10B_4096_c[] = {
871, 90, 440,
872, 91, 441,
873, 92, 442,
874, 93, 443,
875, 94, 444,
876, 95, 445,
877, 96, 446,
878, 97, 447,
879, 98, 448,
880, 99, 449,
881, 100, 450,
882, 101, 451,
883, 102, 452,
884, 103, 453,
885, 104, 454,
886, 105, 455,
887, 106, 456,
888, 107, 457,
889, 108, 458,
890, 109, 459,
891, 110, 460,
892, 111, 461,
893, 112, 462,
894, 113, 463,
895, 114, 464,
896, 115, 465,
897, 116, 466,
898, 117, 467,
899, 118, 468,
900, 119, 469,
901, 120, 470,
902, 121, 471,
903, 122, 472,
904, 123, 473,
905, 124, 474,
906, 125, 475,
907, 126, 476,
908, 127, 477,
909, 128, 478,
910, 129, 479,
911, 130, 480,
912, 131, 481,
913, 132, 482,
914, 133, 483,
915, 134, 484,
916, 135, 485,
917, 136, 486,
918, 137, 487,
919, 138, 488,
920, 139, 489,
921, 140, 490,
922, 141, 491,
923, 142, 492,
924, 143, 493,
925, 144, 494,
926, 145, 495,
927, 146, 496,
928, 147, 497,
929, 148, 498,
930, 149, 499,
931, 150, 500,
932, 151, 501,
933, 152, 502,
934, 153, 503,
935, 154, 504,
936, 155, 505,
937, 156, 506,
938, 157, 507,
939, 158, 508,
940, 159, 509,
941, 160, 510,
942, 161, 511,
943, 162, 256,
944, 163, 257,
945, 164, 258,
946, 165, 259,
947, 166, 260,
948, 167, 261,
949, 168, 262,
950, 169, 263,
951, 170, 264,
952, 171, 265,
953, 172, 266,
954, 173, 267,
955, 174, 268,
956, 175, 269,
957, 176, 270,
958, 177, 271,
959, 178, 272,
960, 179, 273,
961, 180, 274,
962, 181, 275,
963, 182, 276,
964, 183, 277,
965, 184, 278,
966, 185, 279,
967, 186, 280,
968, 187, 281,
969, 188, 282,
970, 189, 283,
971, 190, 284,
972, 191, 285,
973, 192, 286,
974, 193, 287,
975, 194, 288,
976, 195, 289,
977, 196, 290,
978, 197, 291,
979, 198, 292,
980, 199, 293,
981, 200, 294,
982, 201, 295,
983, 202, 296,
984, 203, 297,
985, 204, 298,
986, 205, 299,
987, 206, 300,
988, 207, 301,
989, 208, 302,
990, 209, 303,
991, 210, 304,
992, 211, 305,
993, 212, 306,
994, 213, 307,
995, 214, 308,
996, 215, 309,
997, 216, 310,
998, 217, 311,
999, 218, 312,
1000, 219, 313,
1001, 220, 314,
1002, 221, 315,
1003, 222, 316,
1004, 223, 317,
1005, 224, 318,
1006, 225, 319,
1007, 226, 320,
1008, 227, 321,
1009, 228, 322,
1010, 229, 323,
1011, 230, 324,
1012, 231, 325,
1013, 232, 326,
1014, 233, 327,
1015, 234, 328,
1016, 235, 329,
1017, 236, 330,
1018, 237, 331,
1019, 238, 332,
1020, 239, 333,
1021, 240, 334,
1022, 241, 335,
1023, 242, 336,
768, 243, 337,
769, 244, 338,
770, 245, 339,
771, 246, 340,
772, 247, 341,
773, 248, 342,
774, 249, 343,
775, 250, 344,
776, 251, 345,
777, 252, 346,
778, 253, 347,
779, 254, 348,
780, 255, 349,
781, 0, 350,
782, 1, 351,
783, 2, 352,
784, 3, 353,
785, 4, 354,
786, 5, 355,
787, 6, 356,
788, 7, 357,
789, 8, 358,
790, 9, 359,
791, 10, 360,
792, 11, 361,
793, 12, 362,
794, 13, 363,
795, 14, 364,
796, 15, 365,
797, 16, 366,
798, 17, 367,
799, 18, 368,
800, 19, 369,
801, 20, 370,
802, 21, 371,
803, 22, 372,
804, 23, 373,
805, 24, 374,
806, 25, 375,
807, 26, 376,
808, 27, 377,
809, 28, 378,
810, 29, 379,
811, 30, 380,
812, 31, 381,
813, 32, 382,
814, 33, 383,
815, 34, 384,
816, 35, 385,
817, 36, 386,
818, 37, 387,
819, 38, 388,
820, 39, 389,
821, 40, 390,
822, 41, 391,
823, 42, 392,
824, 43, 393,
825, 44, 394,
826, 45, 395,
827, 46, 396,
828, 47, 397,
829, 48, 398,
830, 49, 399,
831, 50, 400,
832, 51, 401,
833, 52, 402,
834, 53, 403,
835, 54, 404,
836, 55, 405,
837, 56, 406,
838, 57, 407,
839, 58, 408,
840, 59, 409,
841, 60, 410,
842, 61, 411,
843, 62, 412,
844, 63, 413,
845, 64, 414,
846, 65, 415,
847, 66, 416,
848, 67, 417,
849, 68, 418,
850, 69, 419,
851, 70, 420,
852, 71, 421,
853, 72, 422,
854, 73, 423,
855, 74, 424,
856, 75, 425,
857, 76, 426,
858, 77, 427,
859, 78, 428,
860, 79, 429,
861, 80, 430,
862, 81, 431,
863, 82, 432,
864, 83, 433,
865, 84, 434,
866, 85, 435,
867, 86, 436,
868, 87, 437,
869, 88, 438,
870, 89, 439,
838, 493, 589,
839, 494, 590,
840, 495, 591,
841, 496, 592,
842, 497, 593,
843, 498, 594,
844, 499, 595,
845, 500, 596,
846, 501, 597,
847, 502, 598,
848, 503, 599,
849, 504, 600,
850, 505, 601,
851, 506, 602,
852, 507, 603,
853, 508, 604,
854, 509, 605,
855, 510, 606,
856, 511, 607,
857, 256, 608,
858, 257, 609,
859, 258, 610,
860, 259, 611,
861, 260, 612,
862, 261, 613,
863, 262, 614,
864, 263, 615,
865, 264, 616,
866, 265, 617,
867, 266, 618,
868, 267, 619,
869, 268, 620,
870, 269, 621,
871, 270, 622,
872, 271, 623,
873, 272, 624,
874, 273, 625,
875, 274, 626,
876, 275, 627,
877, 276, 628,
878, 277, 629,
879, 278, 630,
880, 279, 631,
881, 280, 632,
882, 281, 633,
883, 282, 634,
884, 283, 635,
885, 284, 636,
886, 285, 637,
887, 286, 638,
888, 287, 639,
889, 288, 640,
890, 289, 641,
891, 290, 642,
892, 291, 643,
893, 292, 644,
894, 293, 645,
895, 294, 646,
896, 295, 647,
897, 296, 648,
898, 297, 649,
899, 298, 650,
900, 299, 651,
901, 300, 652,
902, 301, 653,
903, 302, 654,
904, 303, 655,
905, 304, 656,
906, 305, 657,
907, 306, 658,
908, 307, 659,
909, 308, 660,
910, 309, 661,
911, 310, 662,
912, 311, 663,
913, 312, 664,
914, 313, 665,
915, 314, 666,
916, 315, 667,
917, 316, 668,
918, 317, 669,
919, 318, 670,
920, 319, 671,
921, 320, 672,
922, 321, 673,
923, 322, 674,
924, 323, 675,
925, 324, 676,
926, 325, 677,
927, 326, 678,
928, 327, 679,
929, 328, 680,
930, 329, 681,
931, 330, 682,
932, 331, 683,
933, 332, 684,
934, 333, 685,
935, 334, 686,
936, 335, 687,
937, 336, 688,
938, 337, 689,
939, 338, 690,
940, 339, 691,
941, 340, 692,
942, 341, 693,
943, 342, 694,
944, 343, 695,
945, 344, 696,
946, 345, 697,
947, 346, 698,
948, 347, 699,
949, 348, 700,
950, 349, 701,
951, 350, 702,
952, 351, 703,
953, 352, 704,
954, 353, 705,
955, 354, 706,
956, 355, 707,
957, 356, 708,
958, 357, 709,
959, 358, 710,
960, 359, 711,
961, 360, 712,
962, 361, 713,
963, 362, 714,
964, 363, 715,
965, 364, 716,
966, 365, 717,
967, 366, 718,
968, 367, 719,
969, 368, 720,
970, 369, 721,
971, 370, 722,
972, 371, 723,
973, 372, 724,
974, 373, 725,
975, 374, 726,
976, 375, 727,
977, 376, 728,
978, 377, 729,
979, 378, 730,
980, 379, 731,
981, 380, 732,
982, 381, 733,
983, 382, 734,
984, 383, 735,
985, 384, 736,
986, 385, 737,
987, 386, 738,
988, 387, 739,
989, 388, 740,
990, 389, 741,
991, 390, 742,
992, 391, 743,
993, 392, 744,
994, 393, 745,
995, 394, 746,
996, 395, 747,
997, 396, 748,
998, 397, 749,
999, 398, 750,
1000, 399, 751,
1001, 400, 752,
1002, 401, 753,
1003, 402, 754,
1004, 403, 755,
1005, 404, 756,
1006, 405, 757,
1007, 406, 758,
1008, 407, 759,
1009, 408, 760,
1010, 409, 761,
1011, 410, 762,
1012, 411, 763,
1013, 412, 764,
1014, 413, 765,
1015, 414, 766,
1016, 415, 767,
1017, 416, 512,
1018, 417, 513,
1019, 418, 514,
1020, 419, 515,
1021, 420, 516,
1022, 421, 517,
1023, 422, 518,
768, 423, 519,
769, 424, 520,
770, 425, 521,
771, 426, 522,
772, 427, 523,
773, 428, 524,
774, 429, 525,
775, 430, 526,
776, 431, 527,
777, 432, 528,
778, 433, 529,
779, 434, 530,
780, 435, 531,
781, 436, 532,
782, 437, 533,
783, 438, 534,
784, 439, 535,
785, 440, 536,
786, 441, 537,
787, 442, 538,
788, 443, 539,
789, 444, 540,
790, 445, 541,
791, 446, 542,
792, 447, 543,
793, 448, 544,
794, 449, 545,
795, 450, 546,
796, 451, 547,
797, 452, 548,
798, 453, 549,
799, 454, 550,
800, 455, 551,
801, 456, 552,
802, 457, 553,
803, 458, 554,
804, 459, 555,
805, 460, 556,
806, 461, 557,
807, 462, 558,
808, 463, 559,
809, 464, 560,
810, 465, 561,
811, 466, 562,
812, 467, 563,
813, 468, 564,
814, 469, 565,
815, 470, 566,
816, 471, 567,
817, 472, 568,
818, 473, 569,
819, 474, 570,
820, 475, 571,
821, 476, 572,
822, 477, 573,
823, 478, 574,
824, 479, 575,
825, 480, 576,
826, 481, 577,
827, 482, 578,
828, 483, 579,
829, 484, 580,
830, 485, 581,
831, 486, 582,
832, 487, 583,
833, 488, 584,
834, 489, 585,
835, 490, 586,
836, 491, 587,
837, 492, 588,
462, 634, 835,
463, 635, 836,
464, 636, 837,
465, 637, 838,
466, 638, 839,
467, 639, 840,
468, 640, 841,
469, 641, 842,
470, 642, 843,
471, 643, 844,
472, 644, 845,
473, 645, 846,
474, 646, 847,
475, 647, 848,
476, 648, 849,
477, 649, 850,
478, 650, 851,
479, 651, 852,
480, 652, 853,
481, 653, 854,
482, 654, 855,
483, 655, 856,
484, 656, 857,
485, 657, 858,
486, 658, 859,
487, 659, 860,
488, 660, 861,
489, 661, 862,
490, 662, 863,
491, 663, 864,
492, 664, 865,
493, 665, 866,
494, 666, 867,
495, 667, 868,
496, 668, 869,
497, 669, 870,
498, 670, 871,
499, 671, 872,
500, 672, 873,
501, 673, 874,
502, 674, 875,
503, 675, 876,
504, 676, 877,
505, 677, 878,
506, 678, 879,
507, 679, 880,
508, 680, 881,
509, 681, 882,
510, 682, 883,
511, 683, 884,
256, 684, 885,
257, 685, 886,
258, 686, 887,
259, 687, 888,
260, 688, 889,
261, 689, 890,
262, 690, 891,
263, 691, 892,
264, 692, 893,
265, 693, 894,
266, 694, 895,
267, 695, 896,
268, 696, 897,
269, 697, 898,
270, 698, 899,
271, 699, 900,
272, 700, 901,
273, 701, 902,
274, 702, 903,
275, 703, 904,
276, 704, 905,
277, 705, 906,
278, 706, 907,
279, 707, 908,
280, 708, 909,
281, 709, 910,
282, 710, 911,
283, 711, 912,
284, 712, 913,
285, 713, 914,
286, 714, 915,
287, 715, 916,
288, 716, 917,
289, 717, 918,
290, 718, 919,
291, 719, 920,
292, 720, 921,
293, 721, 922,
294, 722, 923,
295, 723, 924,
296, 724, 925,
297, 725, 926,
298, 726, 927,
299, 727, 928,
300, 728, 929,
301, 729, 930,
302, 730, 931,
303, 731, 932,
304, 732, 933,
305, 733, 934,
306, 734, 935,
307, 735, 936,
308, 736, 937,
309, 737, 938,
310, 738, 939,
311, 739, 940,
312, 740, 941,
313, 741, 942,
314, 742, 943,
315, 743, 944,
316, 744, 945,
317, 745, 946,
318, 746, 947,
319, 747, 948,
320, 748, 949,
321, 749, 950,
322, 750, 951,
323, 751, 952,
324, 752, 953,
325, 753, 954,
326, 754, 955,
327, 755, 956,
328, 756, 957,
329, 757, 958,
330, 758, 959,
331, 759, 960,
332, 760, 961,
333, 761, 962,
334, 762, 963,
335, 763, 964,
336, 764, 965,
337, 765, 966,
338, 766, 967,
339, 767, 968,
340, 512, 969,
341, 513, 970,
342, 514, 971,
343, 515, 972,
344, 516, 973,
345, 517, 974,
346, 518, 975,
347, 519, 976,
348, 520, 977,
349, 521, 978,
350, 522, 979,
351, 523, 980,
352, 524, 981,
353, 525, 982,
354, 526, 983,
355, 527, 984,
356, 528, 985,
357, 529, 986,
358, 530, 987,
359, 531, 988,
360, 532, 989,
361, 533, 990,
362, 534, 991,
363, 535, 992,
364, 536, 993,
365, 537, 994,
366, 538, 995,
367, 539, 996,
368, 540, 997,
369, 541, 998,
370, 542, 999,
371, 543, 1000,
372, 544, 1001,
373, 545, 1002,
374, 546, 1003,
375, 547, 1004,
376, 548, 1005,
377, 549, 1006,
378, 550, 1007,
379, 551, 1008,
380, 552, 1009,
381, 553, 1010,
382, 554, 1011,
383, 555, 1012,
384, 556, 1013,
385, 557, 1014,
386, 558, 1015,
387, 559, 1016,
388, 560, 1017,
389, 561, 1018,
390, 562, 1019,
391, 563, 1020,
392, 564, 1021,
393, 565, 1022,
394, 566, 1023,
395, 567, 768,
396, 568, 769,
397, 569, 770,
398, 570, 771,
399, 571, 772,
400, 572, 773,
401, 573, 774,
402, 574, 775,
403, 575, 776,
404, 576, 777,
405, 577, 778,
406, 578, 779,
407, 579, 780,
408, 580, 781,
409, 581, 782,
410, 582, 783,
411, 583, 784,
412, 584, 785,
413, 585, 786,
414, 586, 787,
415, 587, 788,
416, 588, 789,
417, 589, 790,
418, 590, 791,
419, 591, 792,
420, 592, 793,
421, 593, 794,
422, 594, 795,
423, 595, 796,
424, 596, 797,
425, 597, 798,
426, 598, 799,
427, 599, 800,
428, 600, 801,
429, 601, 802,
430, 602, 803,
431, 603, 804,
432, 604, 805,
433, 605, 806,
434, 606, 807,
435, 607, 808,
436, 608, 809,
437, 609, 810,
438, 610, 811,
439, 611, 812,
440, 612, 813,
441, 613, 814,
442, 614, 815,
443, 615, 816,
444, 616, 817,
445, 617, 818,
446, 618, 819,
447, 619, 820,
448, 620, 821,
449, 621, 822,
450, 622, 823,
451, 623, 824,
452, 624, 825,
453, 625, 826,
454, 626, 827,
455, 627, 828,
456, 628, 829,
457, 629, 830,
458, 630, 831,
459, 631, 832,
460, 632, 833,
461, 633, 834,
523, 125, 1005,
524, 126, 1006,
525, 127, 1007,
526, 128, 1008,
527, 129, 1009,
528, 130, 1010,
529, 131, 1011,
530, 132, 1012,
531, 133, 1013,
532, 134, 1014,
533, 135, 1015,
534, 136, 1016,
535, 137, 1017,
536, 138, 1018,
537, 139, 1019,
538, 140, 1020,
539, 141, 1021,
540, 142, 1022,
541, 143, 1023,
542, 144, 768,
543, 145, 769,
544, 146, 770,
545, 147, 771,
546, 148, 772,
547, 149, 773,
548, 150, 774,
549, 151, 775,
550, 152, 776,
551, 153, 777,
552, 154, 778,
553, 155, 779,
554, 156, 780,
555, 157, 781,
556, 158, 782,
557, 159, 783,
558, 160, 784,
559, 161, 785,
560, 162, 786,
561, 163, 787,
562, 164, 788,
563, 165, 789,
564, 166, 790,
565, 167, 791,
566, 168, 792,
567, 169, 793,
568, 170, 794,
569, 171, 795,
570, 172, 796,
571, 173, 797,
572, 174, 798,
573, 175, 799,
574, 176, 800,
575, 177, 801,
576, 178, 802,
577, 179, 803,
578, 180, 804,
579, 181, 805,
580, 182, 806,
581, 183, 807,
582, 184, 808,
583, 185, 809,
584, 186, 810,
585, 187, 811,
586, 188, 812,
587, 189, 813,
588, 190, 814,
589, 191, 815,
590, 192, 816,
591, 193, 817,
592, 194, 818,
593, 195, 819,
594, 196, 820,
595, 197, 821,
596, 198, 822,
597, 199, 823,
598, 200, 824,
599, 201, 825,
600, 202, 826,
601, 203, 827,
602, 204, 828,
603, 205, 829,
604, 206, 830,
605, 207, 831,
606, 208, 832,
607, 209, 833,
608, 210, 834,
609, 211, 835,
610, 212, 836,
611, 213, 837,
612, 214, 838,
613, 215, 839,
614, 216, 840,
615, 217, 841,
616, 218, 842,
617, 219, 843,
618, 220, 844,
619, 221, 845,
620, 222, 846,
621, 223, 847,
622, 224, 848,
623, 225, 849,
624, 226, 850,
625, 227, 851,
626, 228, 852,
627, 229, 853,
628, 230, 854,
629, 231, 855,
630, 232, 856,
631, 233, 857,
632, 234, 858,
633, 235, 859,
634, 236, 860,
635, 237, 861,
636, 238, 862,
637, 239, 863,
638, 240, 864,
639, 241, 865,
640, 242, 866,
641, 243, 867,
642, 244, 868,
643, 245, 869,
644, 246, 870,
645, 247, 871,
646, 248, 872,
647, 249, 873,
648, 250, 874,
649, 251, 875,
650, 252, 876,
651, 253, 877,
652, 254, 878,
653, 255, 879,
654, 0, 880,
655, 1, 881,
656, 2, 882,
657, 3, 883,
658, 4, 884,
659, 5, 885,
660, 6, 886,
661, 7, 887,
662, 8, 888,
663, 9, 889,
664, 10, 890,
665, 11, 891,
666, 12, 892,
667, 13, 893,
668, 14, 894,
669, 15, 895,
670, 16, 896,
671, 17, 897,
672, 18, 898,
673, 19, 899,
674, 20, 900,
675, 21, 901,
676, 22, 902,
677, 23, 903,
678, 24, 904,
679, 25, 905,
680, 26, 906,
681, 27, 907,
682, 28, 908,
683, 29, 909,
684, 30, 910,
685, 31, 911,
686, 32, 912,
687, 33, 913,
688, 34, 914,
689, 35, 915,
690, 36, 916,
691, 37, 917,
692, 38, 918,
693, 39, 919,
694, 40, 920,
695, 41, 921,
696, 42, 922,
697, 43, 923,
698, 44, 924,
699, 45, 925,
700, 46, 926,
701, 47, 927,
702, 48, 928,
703, 49, 929,
704, 50, 930,
705, 51, 931,
706, 52, 932,
707, 53, 933,
708, 54, 934,
709, 55, 935,
710, 56, 936,
711, 57, 937,
712, 58, 938,
713, 59, 939,
714, 60, 940,
715, 61, 941,
716, 62, 942,
717, 63, 943,
718, 64, 944,
719, 65, 945,
720, 66, 946,
721, 67, 947,
722, 68, 948,
723, 69, 949,
724, 70, 950,
725, 71, 951,
726, 72, 952,
727, 73, 953,
728, 74, 954,
729, 75, 955,
730, 76, 956,
731, 77, 957,
732, 78, 958,
733, 79, 959,
734, 80, 960,
735, 81, 961,
736, 82, 962,
737, 83, 963,
738, 84, 964,
739, 85, 965,
740, 86, 966,
741, 87, 967,
742, 88, 968,
743, 89, 969,
744, 90, 970,
745, 91, 971,
746, 92, 972,
747, 93, 973,
748, 94, 974,
749, 95, 975,
750, 96, 976,
751, 97, 977,
752, 98, 978,
753, 99, 979,
754, 100, 980,
755, 101, 981,
756, 102, 982,
757, 103, 983,
758, 104, 984,
759, 105, 985,
760, 106, 986,
761, 107, 987,
762, 108, 988,
763, 109, 989,
764, 110, 990,
765, 111, 991,
766, 112, 992,
767, 113, 993,
512, 114, 994,
513, 115, 995,
514, 116, 996,
515, 117, 997,
516, 118, 998,
517, 119, 999,
518, 120, 1000,
519, 121, 1001,
520, 122, 1002,
521, 123, 1003,
522, 124, 1004 };
#pragma line 280 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_2_3_4_trichk.h" 1
int11 varinx10A_4096_d[] = {
763,
764,
765,
766,
767,
512,
513,
514,
515,
516,
517,
518,
519,
520,
521,
522,
523,
524,
525,
526,
527,
528,
529,
530,
531,
532,
533,
534,
535,
536,
537,
538,
539,
540,
541,
542,
543,
544,
545,
546,
547,
548,
549,
550,
551,
552,
553,
554,
555,
556,
557,
558,
559,
560,
561,
562,
563,
564,
565,
566,
567,
568,
569,
570,
571,
572,
573,
574,
575,
576,
577,
578,
579,
580,
581,
582,
583,
584,
585,
586,
587,
588,
589,
590,
591,
592,
593,
594,
595,
596,
597,
598,
599,
600,
601,
602,
603,
604,
605,
606,
607,
608,
609,
610,
611,
612,
613,
614,
615,
616,
617,
618,
619,
620,
621,
622,
623,
624,
625,
626,
627,
628,
629,
630,
631,
632,
633,
634,
635,
636,
637,
638,
639,
640,
641,
642,
643,
644,
645,
646,
647,
648,
649,
650,
651,
652,
653,
654,
655,
656,
657,
658,
659,
660,
661,
662,
663,
664,
665,
666,
667,
668,
669,
670,
671,
672,
673,
674,
675,
676,
677,
678,
679,
680,
681,
682,
683,
684,
685,
686,
687,
688,
689,
690,
691,
692,
693,
694,
695,
696,
697,
698,
699,
700,
701,
702,
703,
704,
705,
706,
707,
708,
709,
710,
711,
712,
713,
714,
715,
716,
717,
718,
719,
720,
721,
722,
723,
724,
725,
726,
727,
728,
729,
730,
731,
732,
733,
734,
735,
736,
737,
738,
739,
740,
741,
742,
743,
744,
745,
746,
747,
748,
749,
750,
751,
752,
753,
754,
755,
756,
757,
758,
759,
760,
761,
762,
833,
834,
835,
836,
837,
838,
839,
840,
841,
842,
843,
844,
845,
846,
847,
848,
849,
850,
851,
852,
853,
854,
855,
856,
857,
858,
859,
860,
861,
862,
863,
864,
865,
866,
867,
868,
869,
870,
871,
872,
873,
874,
875,
876,
877,
878,
879,
880,
881,
882,
883,
884,
885,
886,
887,
888,
889,
890,
891,
892,
893,
894,
895,
896,
897,
898,
899,
900,
901,
902,
903,
904,
905,
906,
907,
908,
909,
910,
911,
912,
913,
914,
915,
916,
917,
918,
919,
920,
921,
922,
923,
924,
925,
926,
927,
928,
929,
930,
931,
932,
933,
934,
935,
936,
937,
938,
939,
940,
941,
942,
943,
944,
945,
946,
947,
948,
949,
950,
951,
952,
953,
954,
955,
956,
957,
958,
959,
960,
961,
962,
963,
964,
965,
966,
967,
968,
969,
970,
971,
972,
973,
974,
975,
976,
977,
978,
979,
980,
981,
982,
983,
984,
985,
986,
987,
988,
989,
990,
991,
992,
993,
994,
995,
996,
997,
998,
999,
1000,
1001,
1002,
1003,
1004,
1005,
1006,
1007,
1008,
1009,
1010,
1011,
1012,
1013,
1014,
1015,
1016,
1017,
1018,
1019,
1020,
1021,
1022,
1023,
768,
769,
770,
771,
772,
773,
774,
775,
776,
777,
778,
779,
780,
781,
782,
783,
784,
785,
786,
787,
788,
789,
790,
791,
792,
793,
794,
795,
796,
797,
798,
799,
800,
801,
802,
803,
804,
805,
806,
807,
808,
809,
810,
811,
812,
813,
814,
815,
816,
817,
818,
819,
820,
821,
822,
823,
824,
825,
826,
827,
828,
829,
830,
831,
832,
935,
936,
937,
938,
939,
940,
941,
942,
943,
944,
945,
946,
947,
948,
949,
950,
951,
952,
953,
954,
955,
956,
957,
958,
959,
960,
961,
962,
963,
964,
965,
966,
967,
968,
969,
970,
971,
972,
973,
974,
975,
976,
977,
978,
979,
980,
981,
982,
983,
984,
985,
986,
987,
988,
989,
990,
991,
992,
993,
994,
995,
996,
997,
998,
999,
1000,
1001,
1002,
1003,
1004,
1005,
1006,
1007,
1008,
1009,
1010,
1011,
1012,
1013,
1014,
1015,
1016,
1017,
1018,
1019,
1020,
1021,
1022,
1023,
768,
769,
770,
771,
772,
773,
774,
775,
776,
777,
778,
779,
780,
781,
782,
783,
784,
785,
786,
787,
788,
789,
790,
791,
792,
793,
794,
795,
796,
797,
798,
799,
800,
801,
802,
803,
804,
805,
806,
807,
808,
809,
810,
811,
812,
813,
814,
815,
816,
817,
818,
819,
820,
821,
822,
823,
824,
825,
826,
827,
828,
829,
830,
831,
832,
833,
834,
835,
836,
837,
838,
839,
840,
841,
842,
843,
844,
845,
846,
847,
848,
849,
850,
851,
852,
853,
854,
855,
856,
857,
858,
859,
860,
861,
862,
863,
864,
865,
866,
867,
868,
869,
870,
871,
872,
873,
874,
875,
876,
877,
878,
879,
880,
881,
882,
883,
884,
885,
886,
887,
888,
889,
890,
891,
892,
893,
894,
895,
896,
897,
898,
899,
900,
901,
902,
903,
904,
905,
906,
907,
908,
909,
910,
911,
912,
913,
914,
915,
916,
917,
918,
919,
920,
921,
922,
923,
924,
925,
926,
927,
928,
929,
930,
931,
932,
933,
934,
930,
931,
932,
933,
934,
935,
936,
937,
938,
939,
940,
941,
942,
943,
944,
945,
946,
947,
948,
949,
950,
951,
952,
953,
954,
955,
956,
957,
958,
959,
960,
961,
962,
963,
964,
965,
966,
967,
968,
969,
970,
971,
972,
973,
974,
975,
976,
977,
978,
979,
980,
981,
982,
983,
984,
985,
986,
987,
988,
989,
990,
991,
992,
993,
994,
995,
996,
997,
998,
999,
1000,
1001,
1002,
1003,
1004,
1005,
1006,
1007,
1008,
1009,
1010,
1011,
1012,
1013,
1014,
1015,
1016,
1017,
1018,
1019,
1020,
1021,
1022,
1023,
768,
769,
770,
771,
772,
773,
774,
775,
776,
777,
778,
779,
780,
781,
782,
783,
784,
785,
786,
787,
788,
789,
790,
791,
792,
793,
794,
795,
796,
797,
798,
799,
800,
801,
802,
803,
804,
805,
806,
807,
808,
809,
810,
811,
812,
813,
814,
815,
816,
817,
818,
819,
820,
821,
822,
823,
824,
825,
826,
827,
828,
829,
830,
831,
832,
833,
834,
835,
836,
837,
838,
839,
840,
841,
842,
843,
844,
845,
846,
847,
848,
849,
850,
851,
852,
853,
854,
855,
856,
857,
858,
859,
860,
861,
862,
863,
864,
865,
866,
867,
868,
869,
870,
871,
872,
873,
874,
875,
876,
877,
878,
879,
880,
881,
882,
883,
884,
885,
886,
887,
888,
889,
890,
891,
892,
893,
894,
895,
896,
897,
898,
899,
900,
901,
902,
903,
904,
905,
906,
907,
908,
909,
910,
911,
912,
913,
914,
915,
916,
917,
918,
919,
920,
921,
922,
923,
924,
925,
926,
927,
928,
929 };
#pragma empty_line
int11 varinx10B_4096_d[] = {
0,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
21,
22,
23,
24,
25,
26,
27,
28,
29,
30,
31,
32,
33,
34,
35,
36,
37,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
64,
65,
66,
67,
68,
69,
70,
71,
72,
73,
74,
75,
76,
77,
78,
79,
80,
81,
82,
83,
84,
85,
86,
87,
88,
89,
90,
91,
92,
93,
94,
95,
96,
97,
98,
99,
100,
101,
102,
103,
104,
105,
106,
107,
108,
109,
110,
111,
112,
113,
114,
115,
116,
117,
118,
119,
120,
121,
122,
123,
124,
125,
126,
127,
128,
129,
130,
131,
132,
133,
134,
135,
136,
137,
138,
139,
140,
141,
142,
143,
144,
145,
146,
147,
148,
149,
150,
151,
152,
153,
154,
155,
156,
157,
158,
159,
160,
161,
162,
163,
164,
165,
166,
167,
168,
169,
170,
171,
172,
173,
174,
175,
176,
177,
178,
179,
180,
181,
182,
183,
184,
185,
186,
187,
188,
189,
190,
191,
192,
193,
194,
195,
196,
197,
198,
199,
200,
201,
202,
203,
204,
205,
206,
207,
208,
209,
210,
211,
212,
213,
214,
215,
216,
217,
218,
219,
220,
221,
222,
223,
224,
225,
226,
227,
228,
229,
230,
231,
232,
233,
234,
235,
236,
237,
238,
239,
240,
241,
242,
243,
244,
245,
246,
247,
248,
249,
250,
251,
252,
253,
254,
255,
256,
257,
258,
259,
260,
261,
262,
263,
264,
265,
266,
267,
268,
269,
270,
271,
272,
273,
274,
275,
276,
277,
278,
279,
280,
281,
282,
283,
284,
285,
286,
287,
288,
289,
290,
291,
292,
293,
294,
295,
296,
297,
298,
299,
300,
301,
302,
303,
304,
305,
306,
307,
308,
309,
310,
311,
312,
313,
314,
315,
316,
317,
318,
319,
320,
321,
322,
323,
324,
325,
326,
327,
328,
329,
330,
331,
332,
333,
334,
335,
336,
337,
338,
339,
340,
341,
342,
343,
344,
345,
346,
347,
348,
349,
350,
351,
352,
353,
354,
355,
356,
357,
358,
359,
360,
361,
362,
363,
364,
365,
366,
367,
368,
369,
370,
371,
372,
373,
374,
375,
376,
377,
378,
379,
380,
381,
382,
383,
384,
385,
386,
387,
388,
389,
390,
391,
392,
393,
394,
395,
396,
397,
398,
399,
400,
401,
402,
403,
404,
405,
406,
407,
408,
409,
410,
411,
412,
413,
414,
415,
416,
417,
418,
419,
420,
421,
422,
423,
424,
425,
426,
427,
428,
429,
430,
431,
432,
433,
434,
435,
436,
437,
438,
439,
440,
441,
442,
443,
444,
445,
446,
447,
448,
449,
450,
451,
452,
453,
454,
455,
456,
457,
458,
459,
460,
461,
462,
463,
464,
465,
466,
467,
468,
469,
470,
471,
472,
473,
474,
475,
476,
477,
478,
479,
480,
481,
482,
483,
484,
485,
486,
487,
488,
489,
490,
491,
492,
493,
494,
495,
496,
497,
498,
499,
500,
501,
502,
503,
504,
505,
506,
507,
508,
509,
510,
511,
512,
513,
514,
515,
516,
517,
518,
519,
520,
521,
522,
523,
524,
525,
526,
527,
528,
529,
530,
531,
532,
533,
534,
535,
536,
537,
538,
539,
540,
541,
542,
543,
544,
545,
546,
547,
548,
549,
550,
551,
552,
553,
554,
555,
556,
557,
558,
559,
560,
561,
562,
563,
564,
565,
566,
567,
568,
569,
570,
571,
572,
573,
574,
575,
576,
577,
578,
579,
580,
581,
582,
583,
584,
585,
586,
587,
588,
589,
590,
591,
592,
593,
594,
595,
596,
597,
598,
599,
600,
601,
602,
603,
604,
605,
606,
607,
608,
609,
610,
611,
612,
613,
614,
615,
616,
617,
618,
619,
620,
621,
622,
623,
624,
625,
626,
627,
628,
629,
630,
631,
632,
633,
634,
635,
636,
637,
638,
639,
640,
641,
642,
643,
644,
645,
646,
647,
648,
649,
650,
651,
652,
653,
654,
655,
656,
657,
658,
659,
660,
661,
662,
663,
664,
665,
666,
667,
668,
669,
670,
671,
672,
673,
674,
675,
676,
677,
678,
679,
680,
681,
682,
683,
684,
685,
686,
687,
688,
689,
690,
691,
692,
693,
694,
695,
696,
697,
698,
699,
700,
701,
702,
703,
704,
705,
706,
707,
708,
709,
710,
711,
712,
713,
714,
715,
716,
717,
718,
719,
720,
721,
722,
723,
724,
725,
726,
727,
728,
729,
730,
731,
732,
733,
734,
735,
736,
737,
738,
739,
740,
741,
742,
743,
744,
745,
746,
747,
748,
749,
750,
751,
752,
753,
754,
755,
756,
757,
758,
759,
760,
761,
762,
763,
764,
765,
766,
767,
768,
769,
770,
771,
772,
773,
774,
775,
776,
777,
778,
779,
780,
781,
782,
783,
784,
785,
786,
787,
788,
789,
790,
791,
792,
793,
794,
795,
796,
797,
798,
799,
800,
801,
802,
803,
804,
805,
806,
807,
808,
809,
810,
811,
812,
813,
814,
815,
816,
817,
818,
819,
820,
821,
822,
823,
824,
825,
826,
827,
828,
829,
830,
831,
832,
833,
834,
835,
836,
837,
838,
839,
840,
841,
842,
843,
844,
845,
846,
847,
848,
849,
850,
851,
852,
853,
854,
855,
856,
857,
858,
859,
860,
861,
862,
863,
864,
865,
866,
867,
868,
869,
870,
871,
872,
873,
874,
875,
876,
877,
878,
879,
880,
881,
882,
883,
884,
885,
886,
887,
888,
889,
890,
891,
892,
893,
894,
895,
896,
897,
898,
899,
900,
901,
902,
903,
904,
905,
906,
907,
908,
909,
910,
911,
912,
913,
914,
915,
916,
917,
918,
919,
920,
921,
922,
923,
924,
925,
926,
927,
928,
929,
930,
931,
932,
933,
934,
935,
936,
937,
938,
939,
940,
941,
942,
943,
944,
945,
946,
947,
948,
949,
950,
951,
952,
953,
954,
955,
956,
957,
958,
959,
960,
961,
962,
963,
964,
965,
966,
967,
968,
969,
970,
971,
972,
973,
974,
975,
976,
977,
978,
979,
980,
981,
982,
983,
984,
985,
986,
987,
988,
989,
990,
991,
992,
993,
994,
995,
996,
997,
998,
999,
1000,
1001,
1002,
1003,
1004,
1005,
1006,
1007,
1008,
1009,
1010,
1011,
1012,
1013,
1014,
1015,
1016,
1017,
1018,
1019,
1020,
1021,
1022,
1023};
#pragma line 281 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_2_3_trichk.h" 1
#pragma empty_line
vars_3_23 varinx3_4096_23[] = {
0, 0, 928,
1, 1, 929,
2, 2, 930,
3, 3, 931,
4, 4, 932,
5, 5, 933,
6, 6, 934,
7, 7, 935,
8, 8, 936,
9, 9, 937,
10, 10, 938,
11, 11, 939,
12, 12, 940,
13, 13, 941,
14, 14, 942,
15, 15, 943,
16, 16, 944,
17, 17, 945,
18, 18, 946,
19, 19, 947,
20, 20, 948,
21, 21, 949,
22, 22, 950,
23, 23, 951,
24, 24, 952,
25, 25, 953,
26, 26, 954,
27, 27, 955,
28, 28, 956,
29, 29, 957,
30, 30, 958,
31, 31, 959,
32, 32, 960,
33, 33, 961,
34, 34, 962,
35, 35, 963,
36, 36, 964,
37, 37, 965,
38, 38, 966,
39, 39, 967,
40, 40, 968,
41, 41, 969,
42, 42, 970,
43, 43, 971,
44, 44, 972,
45, 45, 973,
46, 46, 974,
47, 47, 975,
48, 48, 976,
49, 49, 977,
50, 50, 978,
51, 51, 979,
52, 52, 980,
53, 53, 981,
54, 54, 982,
55, 55, 983,
56, 56, 984,
57, 57, 985,
58, 58, 986,
59, 59, 987,
60, 60, 988,
61, 61, 989,
62, 62, 990,
63, 63, 991,
64, 64, 992,
65, 65, 993,
66, 66, 994,
67, 67, 995,
68, 68, 996,
69, 69, 997,
70, 70, 998,
71, 71, 999,
72, 72, 1000,
73, 73, 1001,
74, 74, 1002,
75, 75, 1003,
76, 76, 1004,
77, 77, 1005,
78, 78, 1006,
79, 79, 1007,
80, 80, 1008,
81, 81, 1009,
82, 82, 1010,
83, 83, 1011,
84, 84, 1012,
85, 85, 1013,
86, 86, 1014,
87, 87, 1015,
88, 88, 1016,
89, 89, 1017,
90, 90, 1018,
91, 91, 1019,
92, 92, 1020,
93, 93, 1021,
94, 94, 1022,
95, 95, 1023,
96, 96, 768,
97, 97, 769,
98, 98, 770,
99, 99, 771,
100, 100, 772,
101, 101, 773,
102, 102, 774,
103, 103, 775,
104, 104, 776,
105, 105, 777,
106, 106, 778,
107, 107, 779,
108, 108, 780,
109, 109, 781,
110, 110, 782,
111, 111, 783,
112, 112, 784,
113, 113, 785,
114, 114, 786,
115, 115, 787,
116, 116, 788,
117, 117, 789,
118, 118, 790,
119, 119, 791,
120, 120, 792,
121, 121, 793,
122, 122, 794,
123, 123, 795,
124, 124, 796,
125, 125, 797,
126, 126, 798,
127, 127, 799,
128, 128, 800,
129, 129, 801,
130, 130, 802,
131, 131, 803,
132, 132, 804,
133, 133, 805,
134, 134, 806,
135, 135, 807,
136, 136, 808,
137, 137, 809,
138, 138, 810,
139, 139, 811,
140, 140, 812,
141, 141, 813,
142, 142, 814,
143, 143, 815,
144, 144, 816,
145, 145, 817,
146, 146, 818,
147, 147, 819,
148, 148, 820,
149, 149, 821,
150, 150, 822,
151, 151, 823,
152, 152, 824,
153, 153, 825,
154, 154, 826,
155, 155, 827,
156, 156, 828,
157, 157, 829,
158, 158, 830,
159, 159, 831,
160, 160, 832,
161, 161, 833,
162, 162, 834,
163, 163, 835,
164, 164, 836,
165, 165, 837,
166, 166, 838,
167, 167, 839,
168, 168, 840,
169, 169, 841,
170, 170, 842,
171, 171, 843,
172, 172, 844,
173, 173, 845,
174, 174, 846,
175, 175, 847,
176, 176, 848,
177, 177, 849,
178, 178, 850,
179, 179, 851,
180, 180, 852,
181, 181, 853,
182, 182, 854,
183, 183, 855,
184, 184, 856,
185, 185, 857,
186, 186, 858,
187, 187, 859,
188, 188, 860,
189, 189, 861,
190, 190, 862,
191, 191, 863,
192, 192, 864,
193, 193, 865,
194, 194, 866,
195, 195, 867,
196, 196, 868,
197, 197, 869,
198, 198, 870,
199, 199, 871,
200, 200, 872,
201, 201, 873,
202, 202, 874,
203, 203, 875,
204, 204, 876,
205, 205, 877,
206, 206, 878,
207, 207, 879,
208, 208, 880,
209, 209, 881,
210, 210, 882,
211, 211, 883,
212, 212, 884,
213, 213, 885,
214, 214, 886,
215, 215, 887,
216, 216, 888,
217, 217, 889,
218, 218, 890,
219, 219, 891,
220, 220, 892,
221, 221, 893,
222, 222, 894,
223, 223, 895,
224, 224, 896,
225, 225, 897,
226, 226, 898,
227, 227, 899,
228, 228, 900,
229, 229, 901,
230, 230, 902,
231, 231, 903,
232, 232, 904,
233, 233, 905,
234, 234, 906,
235, 235, 907,
236, 236, 908,
237, 237, 909,
238, 238, 910,
239, 239, 911,
240, 240, 912,
241, 241, 913,
242, 242, 914,
243, 243, 915,
244, 244, 916,
245, 245, 917,
246, 246, 918,
247, 247, 919,
248, 248, 920,
249, 249, 921,
250, 250, 922,
251, 251, 923,
252, 252, 924,
253, 253, 925,
254, 254, 926,
255, 255, 927,
256, 0, 256,
257, 1, 257,
258, 2, 258,
259, 3, 259,
260, 4, 260,
261, 5, 261,
262, 6, 262,
263, 7, 263,
264, 8, 264,
265, 9, 265,
266, 10, 266,
267, 11, 267,
268, 12, 268,
269, 13, 269,
270, 14, 270,
271, 15, 271,
272, 16, 272,
273, 17, 273,
274, 18, 274,
275, 19, 275,
276, 20, 276,
277, 21, 277,
278, 22, 278,
279, 23, 279,
280, 24, 280,
281, 25, 281,
282, 26, 282,
283, 27, 283,
284, 28, 284,
285, 29, 285,
286, 30, 286,
287, 31, 287,
288, 32, 288,
289, 33, 289,
290, 34, 290,
291, 35, 291,
292, 36, 292,
293, 37, 293,
294, 38, 294,
295, 39, 295,
296, 40, 296,
297, 41, 297,
298, 42, 298,
299, 43, 299,
300, 44, 300,
301, 45, 301,
302, 46, 302,
303, 47, 303,
304, 48, 304,
305, 49, 305,
306, 50, 306,
307, 51, 307,
308, 52, 308,
309, 53, 309,
310, 54, 310,
311, 55, 311,
312, 56, 312,
313, 57, 313,
314, 58, 314,
315, 59, 315,
316, 60, 316,
317, 61, 317,
318, 62, 318,
319, 63, 319,
320, 64, 320,
321, 65, 321,
322, 66, 322,
323, 67, 323,
324, 68, 324,
325, 69, 325,
326, 70, 326,
327, 71, 327,
328, 72, 328,
329, 73, 329,
330, 74, 330,
331, 75, 331,
332, 76, 332,
333, 77, 333,
334, 78, 334,
335, 79, 335,
336, 80, 336,
337, 81, 337,
338, 82, 338,
339, 83, 339,
340, 84, 340,
341, 85, 341,
342, 86, 342,
343, 87, 343,
344, 88, 344,
345, 89, 345,
346, 90, 346,
347, 91, 347,
348, 92, 348,
349, 93, 349,
350, 94, 350,
351, 95, 351,
352, 96, 352,
353, 97, 353,
354, 98, 354,
355, 99, 355,
356, 100, 356,
357, 101, 357,
358, 102, 358,
359, 103, 359,
360, 104, 360,
361, 105, 361,
362, 106, 362,
363, 107, 363,
364, 108, 364,
365, 109, 365,
366, 110, 366,
367, 111, 367,
368, 112, 368,
369, 113, 369,
370, 114, 370,
371, 115, 371,
372, 116, 372,
373, 117, 373,
374, 118, 374,
375, 119, 375,
376, 120, 376,
377, 121, 377,
378, 122, 378,
379, 123, 379,
380, 124, 380,
381, 125, 381,
382, 126, 382,
383, 127, 383,
384, 128, 384,
385, 129, 385,
386, 130, 386,
387, 131, 387,
388, 132, 388,
389, 133, 389,
390, 134, 390,
391, 135, 391,
392, 136, 392,
393, 137, 393,
394, 138, 394,
395, 139, 395,
396, 140, 396,
397, 141, 397,
398, 142, 398,
399, 143, 399,
400, 144, 400,
401, 145, 401,
402, 146, 402,
403, 147, 403,
404, 148, 404,
405, 149, 405,
406, 150, 406,
407, 151, 407,
408, 152, 408,
409, 153, 409,
410, 154, 410,
411, 155, 411,
412, 156, 412,
413, 157, 413,
414, 158, 414,
415, 159, 415,
416, 160, 416,
417, 161, 417,
418, 162, 418,
419, 163, 419,
420, 164, 420,
421, 165, 421,
422, 166, 422,
423, 167, 423,
424, 168, 424,
425, 169, 425,
426, 170, 426,
427, 171, 427,
428, 172, 428,
429, 173, 429,
430, 174, 430,
431, 175, 431,
432, 176, 432,
433, 177, 433,
434, 178, 434,
435, 179, 435,
436, 180, 436,
437, 181, 437,
438, 182, 438,
439, 183, 439,
440, 184, 440,
441, 185, 441,
442, 186, 442,
443, 187, 443,
444, 188, 444,
445, 189, 445,
446, 190, 446,
447, 191, 447,
448, 192, 448,
449, 193, 449,
450, 194, 450,
451, 195, 451,
452, 196, 452,
453, 197, 453,
454, 198, 454,
455, 199, 455,
456, 200, 456,
457, 201, 457,
458, 202, 458,
459, 203, 459,
460, 204, 460,
461, 205, 461,
462, 206, 462,
463, 207, 463,
464, 208, 464,
465, 209, 465,
466, 210, 466,
467, 211, 467,
468, 212, 468,
469, 213, 469,
470, 214, 470,
471, 215, 471,
472, 216, 472,
473, 217, 473,
474, 218, 474,
475, 219, 475,
476, 220, 476,
477, 221, 477,
478, 222, 478,
479, 223, 479,
480, 224, 480,
481, 225, 481,
482, 226, 482,
483, 227, 483,
484, 228, 484,
485, 229, 485,
486, 230, 486,
487, 231, 487,
488, 232, 488,
489, 233, 489,
490, 234, 490,
491, 235, 491,
492, 236, 492,
493, 237, 493,
494, 238, 494,
495, 239, 495,
496, 240, 496,
497, 241, 497,
498, 242, 498,
499, 243, 499,
500, 244, 500,
501, 245, 501,
502, 246, 502,
503, 247, 503,
504, 248, 504,
505, 249, 505,
506, 250, 506,
507, 251, 507,
508, 252, 508,
509, 253, 509,
510, 254, 510,
511, 255, 511,
512, 256, 512,
513, 257, 513,
514, 258, 514,
515, 259, 515,
516, 260, 516,
517, 261, 517,
518, 262, 518,
519, 263, 519,
520, 264, 520,
521, 265, 521,
522, 266, 522,
523, 267, 523,
524, 268, 524,
525, 269, 525,
526, 270, 526,
527, 271, 527,
528, 272, 528,
529, 273, 529,
530, 274, 530,
531, 275, 531,
532, 276, 532,
533, 277, 533,
534, 278, 534,
535, 279, 535,
536, 280, 536,
537, 281, 537,
538, 282, 538,
539, 283, 539,
540, 284, 540,
541, 285, 541,
542, 286, 542,
543, 287, 543,
544, 288, 544,
545, 289, 545,
546, 290, 546,
547, 291, 547,
548, 292, 548,
549, 293, 549,
550, 294, 550,
551, 295, 551,
552, 296, 552,
553, 297, 553,
554, 298, 554,
555, 299, 555,
556, 300, 556,
557, 301, 557,
558, 302, 558,
559, 303, 559,
560, 304, 560,
561, 305, 561,
562, 306, 562,
563, 307, 563,
564, 308, 564,
565, 309, 565,
566, 310, 566,
567, 311, 567,
568, 312, 568,
569, 313, 569,
570, 314, 570,
571, 315, 571,
572, 316, 572,
573, 317, 573,
574, 318, 574,
575, 319, 575,
576, 320, 576,
577, 321, 577,
578, 322, 578,
579, 323, 579,
580, 324, 580,
581, 325, 581,
582, 326, 582,
583, 327, 583,
584, 328, 584,
585, 329, 585,
586, 330, 586,
587, 331, 587,
588, 332, 588,
589, 333, 589,
590, 334, 590,
591, 335, 591,
592, 336, 592,
593, 337, 593,
594, 338, 594,
595, 339, 595,
596, 340, 596,
597, 341, 597,
598, 342, 598,
599, 343, 599,
600, 344, 600,
601, 345, 601,
602, 346, 602,
603, 347, 603,
604, 348, 604,
605, 349, 605,
606, 350, 606,
607, 351, 607,
608, 352, 608,
609, 353, 609,
610, 354, 610,
611, 355, 611,
612, 356, 612,
613, 357, 613,
614, 358, 614,
615, 359, 615,
616, 360, 616,
617, 361, 617,
618, 362, 618,
619, 363, 619,
620, 364, 620,
621, 365, 621,
622, 366, 622,
623, 367, 623,
624, 368, 624,
625, 369, 625,
626, 370, 626,
627, 371, 627,
628, 372, 628,
629, 373, 629,
630, 374, 630,
631, 375, 631,
632, 376, 632,
633, 377, 633,
634, 378, 634,
635, 379, 635,
636, 380, 636,
637, 381, 637,
638, 382, 638,
639, 383, 639,
640, 384, 640,
641, 385, 641,
642, 386, 642,
643, 387, 643,
644, 388, 644,
645, 389, 645,
646, 390, 646,
647, 391, 647,
648, 392, 648,
649, 393, 649,
650, 394, 650,
651, 395, 651,
652, 396, 652,
653, 397, 653,
654, 398, 654,
655, 399, 655,
656, 400, 656,
657, 401, 657,
658, 402, 658,
659, 403, 659,
660, 404, 660,
661, 405, 661,
662, 406, 662,
663, 407, 663,
664, 408, 664,
665, 409, 665,
666, 410, 666,
667, 411, 667,
668, 412, 668,
669, 413, 669,
670, 414, 670,
671, 415, 671,
672, 416, 672,
673, 417, 673,
674, 418, 674,
675, 419, 675,
676, 420, 676,
677, 421, 677,
678, 422, 678,
679, 423, 679,
680, 424, 680,
681, 425, 681,
682, 426, 682,
683, 427, 683,
684, 428, 684,
685, 429, 685,
686, 430, 686,
687, 431, 687,
688, 432, 688,
689, 433, 689,
690, 434, 690,
691, 435, 691,
692, 436, 692,
693, 437, 693,
694, 438, 694,
695, 439, 695,
696, 440, 696,
697, 441, 697,
698, 442, 698,
699, 443, 699,
700, 444, 700,
701, 445, 701,
702, 446, 702,
703, 447, 703,
704, 448, 704,
705, 449, 705,
706, 450, 706,
707, 451, 707,
708, 452, 708,
709, 453, 709,
710, 454, 710,
711, 455, 711,
712, 456, 712,
713, 457, 713,
714, 458, 714,
715, 459, 715,
716, 460, 716,
717, 461, 717,
718, 462, 718,
719, 463, 719,
720, 464, 720,
721, 465, 721,
722, 466, 722,
723, 467, 723,
724, 468, 724,
725, 469, 725,
726, 470, 726,
727, 471, 727,
728, 472, 728,
729, 473, 729,
730, 474, 730,
731, 475, 731,
732, 476, 732,
733, 477, 733,
734, 478, 734,
735, 479, 735,
736, 480, 736,
737, 481, 737,
738, 482, 738,
739, 483, 739,
740, 484, 740,
741, 485, 741,
742, 486, 742,
743, 487, 743,
744, 488, 744,
745, 489, 745,
746, 490, 746,
747, 491, 747,
748, 492, 748,
749, 493, 749,
750, 494, 750,
751, 495, 751,
752, 496, 752,
753, 497, 753,
754, 498, 754,
755, 499, 755,
756, 500, 756,
757, 501, 757,
758, 502, 758,
759, 503, 759,
760, 504, 760,
761, 505, 761,
762, 506, 762,
763, 507, 763,
764, 508, 764,
765, 509, 765,
766, 510, 766,
767, 511, 767,
768, 512, 768,
769, 513, 769,
770, 514, 770,
771, 515, 771,
772, 516, 772,
773, 517, 773,
774, 518, 774,
775, 519, 775,
776, 520, 776,
777, 521, 777,
778, 522, 778,
779, 523, 779,
780, 524, 780,
781, 525, 781,
782, 526, 782,
783, 527, 783,
784, 528, 784,
785, 529, 785,
786, 530, 786,
787, 531, 787,
788, 532, 788,
789, 533, 789,
790, 534, 790,
791, 535, 791,
792, 536, 792,
793, 537, 793,
794, 538, 794,
795, 539, 795,
796, 540, 796,
797, 541, 797,
798, 542, 798,
799, 543, 799,
800, 544, 800,
801, 545, 801,
802, 546, 802,
803, 547, 803,
804, 548, 804,
805, 549, 805,
806, 550, 806,
807, 551, 807,
808, 552, 808,
809, 553, 809,
810, 554, 810,
811, 555, 811,
812, 556, 812,
813, 557, 813,
814, 558, 814,
815, 559, 815,
816, 560, 816,
817, 561, 817,
818, 562, 818,
819, 563, 819,
820, 564, 820,
821, 565, 821,
822, 566, 822,
823, 567, 823,
824, 568, 824,
825, 569, 825,
826, 570, 826,
827, 571, 827,
828, 572, 828,
829, 573, 829,
830, 574, 830,
831, 575, 831,
832, 576, 832,
833, 577, 833,
834, 578, 834,
835, 579, 835,
836, 580, 836,
837, 581, 837,
838, 582, 838,
839, 583, 839,
840, 584, 840,
841, 585, 841,
842, 586, 842,
843, 587, 843,
844, 588, 844,
845, 589, 845,
846, 590, 846,
847, 591, 847,
848, 592, 848,
849, 593, 849,
850, 594, 850,
851, 595, 851,
852, 596, 852,
853, 597, 853,
854, 598, 854,
855, 599, 855,
856, 600, 856,
857, 601, 857,
858, 602, 858,
859, 603, 859,
860, 604, 860,
861, 605, 861,
862, 606, 862,
863, 607, 863,
864, 608, 864,
865, 609, 865,
866, 610, 866,
867, 611, 867,
868, 612, 868,
869, 613, 869,
870, 614, 870,
871, 615, 871,
872, 616, 872,
873, 617, 873,
874, 618, 874,
875, 619, 875,
876, 620, 876,
877, 621, 877,
878, 622, 878,
879, 623, 879,
880, 624, 880,
881, 625, 881,
882, 626, 882,
883, 627, 883,
884, 628, 884,
885, 629, 885,
886, 630, 886,
887, 631, 887,
888, 632, 888,
889, 633, 889,
890, 634, 890,
891, 635, 891,
892, 636, 892,
893, 637, 893,
894, 638, 894,
895, 639, 895,
896, 640, 896,
897, 641, 897,
898, 642, 898,
899, 643, 899,
900, 644, 900,
901, 645, 901,
902, 646, 902,
903, 647, 903,
904, 648, 904,
905, 649, 905,
906, 650, 906,
907, 651, 907,
908, 652, 908,
909, 653, 909,
910, 654, 910,
911, 655, 911,
912, 656, 912,
913, 657, 913,
914, 658, 914,
915, 659, 915,
916, 660, 916,
917, 661, 917,
918, 662, 918,
919, 663, 919,
920, 664, 920,
921, 665, 921,
922, 666, 922,
923, 667, 923,
924, 668, 924,
925, 669, 925,
926, 670, 926,
927, 671, 927,
928, 672, 928,
929, 673, 929,
930, 674, 930,
931, 675, 931,
932, 676, 932,
933, 677, 933,
934, 678, 934,
935, 679, 935,
936, 680, 936,
937, 681, 937,
938, 682, 938,
939, 683, 939,
940, 684, 940,
941, 685, 941,
942, 686, 942,
943, 687, 943,
944, 688, 944,
945, 689, 945,
946, 690, 946,
947, 691, 947,
948, 692, 948,
949, 693, 949,
950, 694, 950,
951, 695, 951,
952, 696, 952,
953, 697, 953,
954, 698, 954,
955, 699, 955,
956, 700, 956,
957, 701, 957,
958, 702, 958,
959, 703, 959,
960, 704, 960,
961, 705, 961,
962, 706, 962,
963, 707, 963,
964, 708, 964,
965, 709, 965,
966, 710, 966,
967, 711, 967,
968, 712, 968,
969, 713, 969,
970, 714, 970,
971, 715, 971,
972, 716, 972,
973, 717, 973,
974, 718, 974,
975, 719, 975,
976, 720, 976,
977, 721, 977,
978, 722, 978,
979, 723, 979,
980, 724, 980,
981, 725, 981,
982, 726, 982,
983, 727, 983,
984, 728, 984,
985, 729, 985,
986, 730, 986,
987, 731, 987,
988, 732, 988,
989, 733, 989,
990, 734, 990,
991, 735, 991,
992, 736, 992,
993, 737, 993,
994, 738, 994,
995, 739, 995,
996, 740, 996,
997, 741, 997,
998, 742, 998,
999, 743, 999,
1000, 744, 1000,
1001, 745, 1001,
1002, 746, 1002,
1003, 747, 1003,
1004, 748, 1004,
1005, 749, 1005,
1006, 750, 1006,
1007, 751, 1007,
1008, 752, 1008,
1009, 753, 1009,
1010, 754, 1010,
1011, 755, 1011,
1012, 756, 1012,
1013, 757, 1013,
1014, 758, 1014,
1015, 759, 1015,
1016, 760, 1016,
1017, 761, 1017,
1018, 762, 1018,
1019, 763, 1019,
1020, 764, 1020,
1021, 765, 1021,
1022, 766, 1022,
1023, 767, 1023
};
#pragma line 282 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_1_trichk.h" 1
vars_3_45 varinx18A_1024_a[512] = {
4, 51, 71,
5, 52, 72,
6, 53, 73,
7, 54, 74,
8, 55, 75,
9, 56, 76,
10, 57, 77,
11, 58, 78,
12, 59, 79,
13, 60, 80,
14, 61, 81,
15, 62, 82,
16, 63, 83,
17, 32, 84,
18, 33, 85,
19, 34, 86,
20, 35, 87,
21, 36, 88,
22, 37, 89,
23, 38, 90,
24, 39, 91,
25, 40, 92,
26, 41, 93,
27, 42, 94,
28, 43, 95,
29, 44, 64,
30, 45, 65,
31, 46, 66,
0, 47, 67,
1, 48, 68,
2, 49, 69,
3, 50, 70,
34, 69, 107,
35, 70, 108,
36, 71, 109,
37, 72, 110,
38, 73, 111,
39, 74, 112,
40, 75, 113,
41, 76, 114,
42, 77, 115,
43, 78, 116,
44, 79, 117,
45, 80, 118,
46, 81, 119,
47, 82, 120,
48, 83, 121,
49, 84, 122,
50, 85, 123,
51, 86, 124,
52, 87, 125,
53, 88, 126,
54, 89, 127,
55, 90, 96,
56, 91, 97,
57, 92, 98,
58, 93, 99,
59, 94, 100,
60, 95, 101,
61, 64, 102,
62, 65, 103,
63, 66, 104,
32, 67, 105,
33, 68, 106,
11, 66, 107,
12, 67, 108,
13, 68, 109,
14, 69, 110,
15, 70, 111,
16, 71, 112,
17, 72, 113,
18, 73, 114,
19, 74, 115,
20, 75, 116,
21, 76, 117,
22, 77, 118,
23, 78, 119,
24, 79, 120,
25, 80, 121,
26, 81, 122,
27, 82, 123,
28, 83, 124,
29, 84, 125,
30, 85, 126,
31, 86, 127,
0, 87, 96,
1, 88, 97,
2, 89, 98,
3, 90, 99,
4, 91, 100,
5, 92, 101,
6, 93, 102,
7, 94, 103,
8, 95, 104,
9, 64, 105,
10, 65, 106,
18, 63, 116,
19, 32, 117,
20, 33, 118,
21, 34, 119,
22, 35, 120,
23, 36, 121,
24, 37, 122,
25, 38, 123,
26, 39, 124,
27, 40, 125,
28, 41, 126,
29, 42, 127,
30, 43, 96,
31, 44, 97,
0, 45, 98,
1, 46, 99,
2, 47, 100,
3, 48, 101,
4, 49, 102,
5, 50, 103,
6, 51, 104,
7, 52, 105,
8, 53, 106,
9, 54, 107,
10, 55, 108,
11, 56, 109,
12, 57, 110,
13, 58, 111,
14, 59, 112,
15, 60, 113,
16, 61, 114,
17, 62, 115
 };
#pragma empty_line
vars_3_45 varinx18B_1024_a[512] = {
0, 41, 90,
1, 42, 91,
2, 43, 92,
3, 44, 93,
4, 45, 94,
5, 46, 95,
6, 47, 64,
7, 48, 65,
8, 49, 66,
9, 50, 67,
10, 51, 68,
11, 52, 69,
12, 53, 70,
13, 54, 71,
14, 55, 72,
15, 56, 73,
16, 57, 74,
17, 58, 75,
18, 59, 76,
19, 60, 77,
20, 61, 78,
21, 62, 79,
22, 63, 80,
23, 32, 81,
24, 33, 82,
25, 34, 83,
26, 35, 84,
27, 36, 85,
28, 37, 86,
29, 38, 87,
30, 39, 88,
31, 40, 89,
32, 17, 90,
33, 18, 91,
34, 19, 92,
35, 20, 93,
36, 21, 94,
37, 22, 95,
38, 23, 64,
39, 24, 65,
40, 25, 66,
41, 26, 67,
42, 27, 68,
43, 28, 69,
44, 29, 70,
45, 30, 71,
46, 31, 72,
47, 0, 73,
48, 1, 74,
49, 2, 75,
50, 3, 76,
51, 4, 77,
52, 5, 78,
53, 6, 79,
54, 7, 80,
55, 8, 81,
56, 9, 82,
57, 10, 83,
58, 11, 84,
59, 12, 85,
60, 13, 86,
61, 14, 87,
62, 15, 88,
63, 16, 89,
64, 15, 45,
65, 16, 46,
66, 17, 47,
67, 18, 48,
68, 19, 49,
69, 20, 50,
70, 21, 51,
71, 22, 52,
72, 23, 53,
73, 24, 54,
74, 25, 55,
75, 26, 56,
76, 27, 57,
77, 28, 58,
78, 29, 59,
79, 30, 60,
80, 31, 61,
81, 0, 62,
82, 1, 63,
83, 2, 32,
84, 3, 33,
85, 4, 34,
86, 5, 35,
87, 6, 36,
88, 7, 37,
89, 8, 38,
90, 9, 39,
91, 10, 40,
92, 11, 41,
93, 12, 42,
94, 13, 43,
95, 14, 44,
96, 13, 34,
97, 14, 35,
98, 15, 36,
99, 16, 37,
100, 17, 38,
101, 18, 39,
102, 19, 40,
103, 20, 41,
104, 21, 42,
105, 22, 43,
106, 23, 44,
107, 24, 45,
108, 25, 46,
109, 26, 47,
110, 27, 48,
111, 28, 49,
112, 29, 50,
113, 30, 51,
114, 31, 52,
115, 0, 53,
116, 1, 54,
117, 2, 55,
118, 3, 56,
119, 4, 57,
120, 5, 58,
121, 6, 59,
122, 7, 60,
123, 8, 61,
124, 9, 62,
125, 10, 63,
126, 11, 32,
127, 12, 33
 };
#pragma line 285 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_2_trichk.h" 1
vars_3_45 varinx18A_1024_b[512] = {
0, 2, 59,
1, 3, 60,
2, 4, 61,
3, 5, 62,
4, 6, 63,
5, 7, 32,
6, 8, 33,
7, 9, 34,
8, 10, 35,
9, 11, 36,
10, 12, 37,
11, 13, 38,
12, 14, 39,
13, 15, 40,
14, 16, 41,
15, 17, 42,
16, 18, 43,
17, 19, 44,
18, 20, 45,
19, 21, 46,
20, 22, 47,
21, 23, 48,
22, 24, 49,
23, 25, 50,
24, 26, 51,
25, 27, 52,
26, 28, 53,
27, 29, 54,
28, 30, 55,
29, 31, 56,
30, 0, 57,
31, 1, 58,
32, 47, 86,
33, 48, 87,
34, 49, 88,
35, 50, 89,
36, 51, 90,
37, 52, 91,
38, 53, 92,
39, 54, 93,
40, 55, 94,
41, 56, 95,
42, 57, 64,
43, 58, 65,
44, 59, 66,
45, 60, 67,
46, 61, 68,
47, 62, 69,
48, 63, 70,
49, 32, 71,
50, 33, 72,
51, 34, 73,
52, 35, 74,
53, 36, 75,
54, 37, 76,
55, 38, 77,
56, 39, 78,
57, 40, 79,
58, 41, 80,
59, 42, 81,
60, 43, 82,
61, 44, 83,
62, 45, 84,
63, 46, 85,
64, 29, 69,
65, 30, 70,
66, 31, 71,
67, 0, 72,
68, 1, 73,
69, 2, 74,
70, 3, 75,
71, 4, 76,
72, 5, 77,
73, 6, 78,
74, 7, 79,
75, 8, 80,
76, 9, 81,
77, 10, 82,
78, 11, 83,
79, 12, 84,
80, 13, 85,
81, 14, 86,
82, 15, 87,
83, 16, 88,
84, 17, 89,
85, 18, 90,
86, 19, 91,
87, 20, 92,
88, 21, 93,
89, 22, 94,
90, 23, 95,
91, 24, 64,
92, 25, 65,
93, 26, 66,
94, 27, 67,
95, 28, 68,
96, 15, 37,
97, 16, 38,
98, 17, 39,
99, 18, 40,
100, 19, 41,
101, 20, 42,
102, 21, 43,
103, 22, 44,
104, 23, 45,
105, 24, 46,
106, 25, 47,
107, 26, 48,
108, 27, 49,
109, 28, 50,
110, 29, 51,
111, 30, 52,
112, 31, 53,
113, 0, 54,
114, 1, 55,
115, 2, 56,
116, 3, 57,
117, 4, 58,
118, 5, 59,
119, 6, 60,
120, 7, 61,
121, 8, 62,
122, 9, 63,
123, 10, 32,
124, 11, 33,
125, 12, 34,
126, 13, 35,
127, 14, 36
 };
vars_3_45 varinx18B_1024_b[512] = {
113, 0, 7,
114, 1, 8,
115, 2, 9,
116, 3, 10,
117, 4, 11,
118, 5, 12,
119, 6, 13,
120, 7, 14,
121, 8, 15,
122, 9, 16,
123, 10, 17,
124, 11, 18,
125, 12, 19,
126, 13, 20,
127, 14, 21,
96, 15, 22,
97, 16, 23,
98, 17, 24,
99, 18, 25,
100, 19, 26,
101, 20, 27,
102, 21, 28,
103, 22, 29,
104, 23, 30,
105, 24, 31,
106, 25, 0,
107, 26, 1,
108, 27, 2,
109, 28, 3,
110, 29, 4,
111, 30, 5,
112, 31, 6,
105, 32, 35,
106, 33, 36,
107, 34, 37,
108, 35, 38,
109, 36, 39,
110, 37, 40,
111, 38, 41,
112, 39, 42,
113, 40, 43,
114, 41, 44,
115, 42, 45,
116, 43, 46,
117, 44, 47,
118, 45, 48,
119, 46, 49,
120, 47, 50,
121, 48, 51,
122, 49, 52,
123, 50, 53,
124, 51, 54,
125, 52, 55,
126, 53, 56,
127, 54, 57,
96, 55, 58,
97, 56, 59,
98, 57, 60,
99, 58, 61,
100, 59, 62,
101, 60, 63,
102, 61, 32,
103, 62, 33,
104, 63, 34,
99, 64, 8,
100, 65, 9,
101, 66, 10,
102, 67, 11,
103, 68, 12,
104, 69, 13,
105, 70, 14,
106, 71, 15,
107, 72, 16,
108, 73, 17,
109, 74, 18,
110, 75, 19,
111, 76, 20,
112, 77, 21,
113, 78, 22,
114, 79, 23,
115, 80, 24,
116, 81, 25,
117, 82, 26,
118, 83, 27,
119, 84, 28,
120, 85, 29,
121, 86, 30,
122, 87, 31,
123, 88, 0,
124, 89, 1,
125, 90, 2,
126, 91, 3,
127, 92, 4,
96, 93, 5,
97, 94, 6,
98, 95, 7,
82, 96, 17,
83, 97, 18,
84, 98, 19,
85, 99, 20,
86, 100, 21,
87, 101, 22,
88, 102, 23,
89, 103, 24,
90, 104, 25,
91, 105, 26,
92, 106, 27,
93, 107, 28,
94, 108, 29,
95, 109, 30,
64, 110, 31,
65, 111, 0,
66, 112, 1,
67, 113, 2,
68, 114, 3,
69, 115, 4,
70, 116, 5,
71, 117, 6,
72, 118, 7,
73, 119, 8,
74, 120, 9,
75, 121, 10,
76, 122, 11,
77, 123, 12,
78, 124, 13,
79, 125, 14,
80, 126, 15,
81, 127, 16
 };
#pragma line 286 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_3_trichk.h" 1
vars_3_45 varinx18A_1024_c[512] = {
71, 0, 3,
72, 1, 4,
73, 2, 5,
74, 3, 6,
75, 4, 7,
76, 5, 8,
77, 6, 9,
78, 7, 10,
79, 8, 11,
80, 9, 12,
81, 10, 13,
82, 11, 14,
83, 12, 15,
84, 13, 16,
85, 14, 17,
86, 15, 18,
87, 16, 19,
88, 17, 20,
89, 18, 21,
90, 19, 22,
91, 20, 23,
92, 21, 24,
93, 22, 25,
94, 23, 26,
95, 24, 27,
64, 25, 28,
65, 26, 29,
66, 27, 30,
67, 28, 31,
68, 29, 0,
69, 30, 1,
70, 31, 2,
127, 32, 58,
96, 33, 59,
97, 34, 60,
98, 35, 61,
99, 36, 62,
100, 37, 63,
101, 38, 32,
102, 39, 33,
103, 40, 34,
104, 41, 35,
105, 42, 36,
106, 43, 37,
107, 44, 38,
108, 45, 39,
109, 46, 40,
110, 47, 41,
111, 48, 42,
112, 49, 43,
113, 50, 44,
114, 51, 45,
115, 52, 46,
116, 53, 47,
117, 54, 48,
118, 55, 49,
119, 56, 50,
120, 57, 51,
121, 58, 52,
122, 59, 53,
123, 60, 54,
124, 61, 55,
125, 62, 56,
126, 63, 57,
99, 64, 16,
100, 65, 17,
101, 66, 18,
102, 67, 19,
103, 68, 20,
104, 69, 21,
105, 70, 22,
106, 71, 23,
107, 72, 24,
108, 73, 25,
109, 74, 26,
110, 75, 27,
111, 76, 28,
112, 77, 29,
113, 78, 30,
114, 79, 31,
115, 80, 0,
116, 81, 1,
117, 82, 2,
118, 83, 3,
119, 84, 4,
120, 85, 5,
121, 86, 6,
122, 87, 7,
123, 88, 8,
124, 89, 9,
125, 90, 10,
126, 91, 11,
127, 92, 12,
96, 93, 13,
97, 94, 14,
98, 95, 15,
115, 96, 11,
116, 97, 12,
117, 98, 13,
118, 99, 14,
119, 100, 15,
120, 101, 16,
121, 102, 17,
122, 103, 18,
123, 104, 19,
124, 105, 20,
125, 106, 21,
126, 107, 22,
127, 108, 23,
96, 109, 24,
97, 110, 25,
98, 111, 26,
99, 112, 27,
100, 113, 28,
101, 114, 29,
102, 115, 30,
103, 116, 31,
104, 117, 0,
105, 118, 1,
106, 119, 2,
107, 120, 3,
108, 121, 4,
109, 122, 5,
110, 123, 6,
111, 124, 7,
112, 125, 8,
113, 126, 9,
114, 127, 10
 };
vars_3_45 varinx18B_1024_c[512] = {
47, 74, 0,
48, 75, 1,
49, 76, 2,
50, 77, 3,
51, 78, 4,
52, 79, 5,
53, 80, 6,
54, 81, 7,
55, 82, 8,
56, 83, 9,
57, 84, 10,
58, 85, 11,
59, 86, 12,
60, 87, 13,
61, 88, 14,
62, 89, 15,
63, 90, 16,
32, 91, 17,
33, 92, 18,
34, 93, 19,
35, 94, 20,
36, 95, 21,
37, 64, 22,
38, 65, 23,
39, 66, 24,
40, 67, 25,
41, 68, 26,
42, 69, 27,
43, 70, 28,
44, 71, 29,
45, 72, 30,
46, 73, 31,
93, 117, 32,
94, 118, 33,
95, 119, 34,
64, 120, 35,
65, 121, 36,
66, 122, 37,
67, 123, 38,
68, 124, 39,
69, 125, 40,
70, 126, 41,
71, 127, 42,
72, 96, 43,
73, 97, 44,
74, 98, 45,
75, 99, 46,
76, 100, 47,
77, 101, 48,
78, 102, 49,
79, 103, 50,
80, 104, 51,
81, 105, 52,
82, 106, 53,
83, 107, 54,
84, 108, 55,
85, 109, 56,
86, 110, 57,
87, 111, 58,
88, 112, 59,
89, 113, 60,
90, 114, 61,
91, 115, 62,
92, 116, 63,
75, 100, 64,
76, 101, 65,
77, 102, 66,
78, 103, 67,
79, 104, 68,
80, 105, 69,
81, 106, 70,
82, 107, 71,
83, 108, 72,
84, 109, 73,
85, 110, 74,
86, 111, 75,
87, 112, 76,
88, 113, 77,
89, 114, 78,
90, 115, 79,
91, 116, 80,
92, 117, 81,
93, 118, 82,
94, 119, 83,
95, 120, 84,
64, 121, 85,
65, 122, 86,
66, 123, 87,
67, 124, 88,
68, 125, 89,
69, 126, 90,
70, 127, 91,
71, 96, 92,
72, 97, 93,
73, 98, 94,
74, 99, 95,
41, 117, 96,
42, 118, 97,
43, 119, 98,
44, 120, 99,
45, 121, 100,
46, 122, 101,
47, 123, 102,
48, 124, 103,
49, 125, 104,
50, 126, 105,
51, 127, 106,
52, 96, 107,
53, 97, 108,
54, 98, 109,
55, 99, 110,
56, 100, 111,
57, 101, 112,
58, 102, 113,
59, 103, 114,
60, 104, 115,
61, 105, 116,
62, 106, 117,
63, 107, 118,
32, 108, 119,
33, 109, 120,
34, 110, 121,
35, 111, 122,
36, 112, 123,
37, 113, 124,
38, 114, 125,
39, 115, 126,
40, 116, 127
 };
#pragma line 287 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_4_trichk.h" 1
vars_3_45 varinx18A_1024_d[512] = {
54, 67, 0,
55, 68, 1,
56, 69, 2,
57, 70, 3,
58, 71, 4,
59, 72, 5,
60, 73, 6,
61, 74, 7,
62, 75, 8,
63, 76, 9,
32, 77, 10,
33, 78, 11,
34, 79, 12,
35, 80, 13,
36, 81, 14,
37, 82, 15,
38, 83, 16,
39, 84, 17,
40, 85, 18,
41, 86, 19,
42, 87, 20,
43, 88, 21,
44, 89, 22,
45, 90, 23,
46, 91, 24,
47, 92, 25,
48, 93, 26,
49, 94, 27,
50, 95, 28,
51, 64, 29,
52, 65, 30,
53, 66, 31,
88, 100, 32,
89, 101, 33,
90, 102, 34,
91, 103, 35,
92, 104, 36,
93, 105, 37,
94, 106, 38,
95, 107, 39,
64, 108, 40,
65, 109, 41,
66, 110, 42,
67, 111, 43,
68, 112, 44,
69, 113, 45,
70, 114, 46,
71, 115, 47,
72, 116, 48,
73, 117, 49,
74, 118, 50,
75, 119, 51,
76, 120, 52,
77, 121, 53,
78, 122, 54,
79, 123, 55,
80, 124, 56,
81, 125, 57,
82, 126, 58,
83, 127, 59,
84, 96, 60,
85, 97, 61,
86, 98, 62,
87, 99, 63,
71, 111, 64,
72, 112, 65,
73, 113, 66,
74, 114, 67,
75, 115, 68,
76, 116, 69,
77, 117, 70,
78, 118, 71,
79, 119, 72,
80, 120, 73,
81, 121, 74,
82, 122, 75,
83, 123, 76,
84, 124, 77,
85, 125, 78,
86, 126, 79,
87, 127, 80,
88, 96, 81,
89, 97, 82,
90, 98, 83,
91, 99, 84,
92, 100, 85,
93, 101, 86,
94, 102, 87,
95, 103, 88,
64, 104, 89,
65, 105, 90,
66, 106, 91,
67, 107, 92,
68, 108, 93,
69, 109, 94,
70, 110, 95,
49, 100, 96,
50, 101, 97,
51, 102, 98,
52, 103, 99,
53, 104, 100,
54, 105, 101,
55, 106, 102,
56, 107, 103,
57, 108, 104,
58, 109, 105,
59, 110, 106,
60, 111, 107,
61, 112, 108,
62, 113, 109,
63, 114, 110,
32, 115, 111,
33, 116, 112,
34, 117, 113,
35, 118, 114,
36, 119, 115,
37, 120, 116,
38, 121, 117,
39, 122, 118,
40, 123, 119,
41, 124, 120,
42, 125, 121,
43, 126, 122,
44, 127, 123,
45, 96, 124,
46, 97, 125,
47, 98, 126,
48, 99, 127
 };
vars_3_45 varinx18B_1024_d[512] = {
8, 89, 121,
9, 90, 122,
10, 91, 123,
11, 92, 124,
12, 93, 125,
13, 94, 126,
14, 95, 127,
15, 64, 96,
16, 65, 97,
17, 66, 98,
18, 67, 99,
19, 68, 100,
20, 69, 101,
21, 70, 102,
22, 71, 103,
23, 72, 104,
24, 73, 105,
25, 74, 106,
26, 75, 107,
27, 76, 108,
28, 77, 109,
29, 78, 110,
30, 79, 111,
31, 80, 112,
0, 81, 113,
1, 82, 114,
2, 83, 115,
3, 84, 116,
4, 85, 117,
5, 86, 118,
6, 87, 119,
7, 88, 120,
15, 44, 119,
16, 45, 120,
17, 46, 121,
18, 47, 122,
19, 48, 123,
20, 49, 124,
21, 50, 125,
22, 51, 126,
23, 52, 127,
24, 53, 96,
25, 54, 97,
26, 55, 98,
27, 56, 99,
28, 57, 100,
29, 58, 101,
30, 59, 102,
31, 60, 103,
0, 61, 104,
1, 62, 105,
2, 63, 106,
3, 32, 107,
4, 33, 108,
5, 34, 109,
6, 35, 110,
7, 36, 111,
8, 37, 112,
9, 38, 113,
10, 39, 114,
11, 40, 115,
12, 41, 116,
13, 42, 117,
14, 43, 118,
4, 55, 82,
5, 56, 83,
6, 57, 84,
7, 58, 85,
8, 59, 86,
9, 60, 87,
10, 61, 88,
11, 62, 89,
12, 63, 90,
13, 32, 91,
14, 33, 92,
15, 34, 93,
16, 35, 94,
17, 36, 95,
18, 37, 64,
19, 38, 65,
20, 39, 66,
21, 40, 67,
22, 41, 68,
23, 42, 69,
24, 43, 70,
25, 44, 71,
26, 45, 72,
27, 46, 73,
28, 47, 74,
29, 48, 75,
30, 49, 76,
31, 50, 77,
0, 51, 78,
1, 52, 79,
2, 53, 80,
3, 54, 81,
40, 86, 116,
41, 87, 117,
42, 88, 118,
43, 89, 119,
44, 90, 120,
45, 91, 121,
46, 92, 122,
47, 93, 123,
48, 94, 124,
49, 95, 125,
50, 64, 126,
51, 65, 127,
52, 66, 96,
53, 67, 97,
54, 68, 98,
55, 69, 99,
56, 70, 100,
57, 71, 101,
58, 72, 102,
59, 73, 103,
60, 74, 104,
61, 75, 105,
62, 76, 106,
63, 77, 107,
32, 78, 108,
33, 79, 109,
34, 80, 110,
35, 81, 111,
36, 82, 112,
37, 83, 113,
38, 84, 114,
39, 85, 115
 };
#pragma line 288 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_5_trichk.h" 1
vars_3_45 varinx18A_1024_e[512] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127
 };
vars_3_45 varinx18B_1024_e[512] = {
0, 64, 106,
1, 65, 107,
2, 66, 108,
3, 67, 109,
4, 68, 110,
5, 69, 111,
6, 70, 112,
7, 71, 113,
8, 72, 114,
9, 73, 115,
10, 74, 116,
11, 75, 117,
12, 76, 118,
13, 77, 119,
14, 78, 120,
15, 79, 121,
16, 80, 122,
17, 81, 123,
18, 82, 124,
19, 83, 125,
20, 84, 126,
21, 85, 127,
22, 86, 96,
23, 87, 97,
24, 88, 98,
25, 89, 99,
26, 90, 100,
27, 91, 101,
28, 92, 102,
29, 93, 103,
30, 94, 104,
31, 95, 105,
32, 1, 103,
33, 2, 104,
34, 3, 105,
35, 4, 106,
36, 5, 107,
37, 6, 108,
38, 7, 109,
39, 8, 110,
40, 9, 111,
41, 10, 112,
42, 11, 113,
43, 12, 114,
44, 13, 115,
45, 14, 116,
46, 15, 117,
47, 16, 118,
48, 17, 119,
49, 18, 120,
50, 19, 121,
51, 20, 122,
52, 21, 123,
53, 22, 124,
54, 23, 125,
55, 24, 126,
56, 25, 127,
57, 26, 96,
58, 27, 97,
59, 28, 98,
60, 29, 99,
61, 30, 100,
62, 31, 101,
63, 0, 102,
64, 10, 48,
65, 11, 49,
66, 12, 50,
67, 13, 51,
68, 14, 52,
69, 15, 53,
70, 16, 54,
71, 17, 55,
72, 18, 56,
73, 19, 57,
74, 20, 58,
75, 21, 59,
76, 22, 60,
77, 23, 61,
78, 24, 62,
79, 25, 63,
80, 26, 32,
81, 27, 33,
82, 28, 34,
83, 29, 35,
84, 30, 36,
85, 31, 37,
86, 0, 38,
87, 1, 39,
88, 2, 40,
89, 3, 41,
90, 4, 42,
91, 5, 43,
92, 6, 44,
93, 7, 45,
94, 8, 46,
95, 9, 47,
96, 47, 84,
97, 48, 85,
98, 49, 86,
99, 50, 87,
100, 51, 88,
101, 52, 89,
102, 53, 90,
103, 54, 91,
104, 55, 92,
105, 56, 93,
106, 57, 94,
107, 58, 95,
108, 59, 64,
109, 60, 65,
110, 61, 66,
111, 62, 67,
112, 63, 68,
113, 32, 69,
114, 33, 70,
115, 34, 71,
116, 35, 72,
117, 36, 73,
118, 37, 74,
119, 38, 75,
120, 39, 76,
121, 40, 77,
122, 41, 78,
123, 42, 79,
124, 43, 80,
125, 44, 81,
126, 45, 82,
127, 46, 83
 };
#pragma line 289 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_6_trichk.h" 1
vars_3_45 varinx18A_1024_f[512] = {
22, 32, 90,
23, 33, 91,
24, 34, 92,
25, 35, 93,
26, 36, 94,
27, 37, 95,
28, 38, 64,
29, 39, 65,
30, 40, 66,
31, 41, 67,
0, 42, 68,
1, 43, 69,
2, 44, 70,
3, 45, 71,
4, 46, 72,
5, 47, 73,
6, 48, 74,
7, 49, 75,
8, 50, 76,
9, 51, 77,
10, 52, 78,
11, 53, 79,
12, 54, 80,
13, 55, 81,
14, 56, 82,
15, 57, 83,
16, 58, 84,
17, 59, 85,
18, 60, 86,
19, 61, 87,
20, 62, 88,
21, 63, 89,
59, 94, 124,
60, 95, 125,
61, 64, 126,
62, 65, 127,
63, 66, 96,
32, 67, 97,
33, 68, 98,
34, 69, 99,
35, 70, 100,
36, 71, 101,
37, 72, 102,
38, 73, 103,
39, 74, 104,
40, 75, 105,
41, 76, 106,
42, 77, 107,
43, 78, 108,
44, 79, 109,
45, 80, 110,
46, 81, 111,
47, 82, 112,
48, 83, 113,
49, 84, 114,
50, 85, 115,
51, 86, 116,
52, 87, 117,
53, 88, 118,
54, 89, 119,
55, 90, 120,
56, 91, 121,
57, 92, 122,
58, 93, 123,
18, 76, 126,
19, 77, 127,
20, 78, 96,
21, 79, 97,
22, 80, 98,
23, 81, 99,
24, 82, 100,
25, 83, 101,
26, 84, 102,
27, 85, 103,
28, 86, 104,
29, 87, 105,
30, 88, 106,
31, 89, 107,
0, 90, 108,
1, 91, 109,
2, 92, 110,
3, 93, 111,
4, 94, 112,
5, 95, 113,
6, 64, 114,
7, 65, 115,
8, 66, 116,
9, 67, 117,
10, 68, 118,
11, 69, 119,
12, 70, 120,
13, 71, 121,
14, 72, 122,
15, 73, 123,
16, 74, 124,
17, 75, 125,
19, 46, 109,
20, 47, 110,
21, 48, 111,
22, 49, 112,
23, 50, 113,
24, 51, 114,
25, 52, 115,
26, 53, 116,
27, 54, 117,
28, 55, 118,
29, 56, 119,
30, 57, 120,
31, 58, 121,
0, 59, 122,
1, 60, 123,
2, 61, 124,
3, 62, 125,
4, 63, 126,
5, 32, 127,
6, 33, 96,
7, 34, 97,
8, 35, 98,
9, 36, 99,
10, 37, 100,
11, 38, 101,
12, 39, 102,
13, 40, 103,
14, 41, 104,
15, 42, 105,
16, 43, 106,
17, 44, 107,
18, 45, 108
 };
vars_3_45 varinx18B_1024_f[512] = {
5, 50, 0,
6, 51, 1,
7, 52, 2,
8, 53, 3,
9, 54, 4,
10, 55, 5,
11, 56, 6,
12, 57, 7,
13, 58, 8,
14, 59, 9,
15, 60, 10,
16, 61, 11,
17, 62, 12,
18, 63, 13,
19, 32, 14,
20, 33, 15,
21, 34, 16,
22, 35, 17,
23, 36, 18,
24, 37, 19,
25, 38, 20,
26, 39, 21,
27, 40, 22,
28, 41, 23,
29, 42, 24,
30, 43, 25,
31, 44, 26,
0, 45, 27,
1, 46, 28,
2, 47, 29,
3, 48, 30,
4, 49, 31,
40, 84, 32,
41, 85, 33,
42, 86, 34,
43, 87, 35,
44, 88, 36,
45, 89, 37,
46, 90, 38,
47, 91, 39,
48, 92, 40,
49, 93, 41,
50, 94, 42,
51, 95, 43,
52, 64, 44,
53, 65, 45,
54, 66, 46,
55, 67, 47,
56, 68, 48,
57, 69, 49,
58, 70, 50,
59, 71, 51,
60, 72, 52,
61, 73, 53,
62, 74, 54,
63, 75, 55,
32, 76, 56,
33, 77, 57,
34, 78, 58,
35, 79, 59,
36, 80, 60,
37, 81, 61,
38, 82, 62,
39, 83, 63,
77, 105, 64,
78, 106, 65,
79, 107, 66,
80, 108, 67,
81, 109, 68,
82, 110, 69,
83, 111, 70,
84, 112, 71,
85, 113, 72,
86, 114, 73,
87, 115, 74,
88, 116, 75,
89, 117, 76,
90, 118, 77,
91, 119, 78,
92, 120, 79,
93, 121, 80,
94, 122, 81,
95, 123, 82,
64, 124, 83,
65, 125, 84,
66, 126, 85,
67, 127, 86,
68, 96, 87,
69, 97, 88,
70, 98, 89,
71, 99, 90,
72, 100, 91,
73, 101, 92,
74, 102, 93,
75, 103, 94,
76, 104, 95,
4, 113, 96,
5, 114, 97,
6, 115, 98,
7, 116, 99,
8, 117, 100,
9, 118, 101,
10, 119, 102,
11, 120, 103,
12, 121, 104,
13, 122, 105,
14, 123, 106,
15, 124, 107,
16, 125, 108,
17, 126, 109,
18, 127, 110,
19, 96, 111,
20, 97, 112,
21, 98, 113,
22, 99, 114,
23, 100, 115,
24, 101, 116,
25, 102, 117,
26, 103, 118,
27, 104, 119,
28, 105, 120,
29, 106, 121,
30, 107, 122,
31, 108, 123,
0, 109, 124,
1, 110, 125,
2, 111, 126,
3, 112, 127
 };
#pragma line 290 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc1024_4_5_trichk.h" 1
#pragma empty_line
vars_3_45 varinx3_1024_45[512] = {
0, 0, 97,
1, 1, 98,
2, 2, 99,
3, 3, 100,
4, 4, 101,
5, 5, 102,
6, 6, 103,
7, 7, 104,
8, 8, 105,
9, 9, 106,
10, 10, 107,
11, 11, 108,
12, 12, 109,
13, 13, 110,
14, 14, 111,
15, 15, 112,
16, 16, 113,
17, 17, 114,
18, 18, 115,
19, 19, 116,
20, 20, 117,
21, 21, 118,
22, 22, 119,
23, 23, 120,
24, 24, 121,
25, 25, 122,
26, 26, 123,
27, 27, 124,
28, 28, 125,
29, 29, 126,
30, 30, 127,
31, 31, 96,
32, 0, 32,
33, 1, 33,
34, 2, 34,
35, 3, 35,
36, 4, 36,
37, 5, 37,
38, 6, 38,
39, 7, 39,
40, 8, 40,
41, 9, 41,
42, 10, 42,
43, 11, 43,
44, 12, 44,
45, 13, 45,
46, 14, 46,
47, 15, 47,
48, 16, 48,
49, 17, 49,
50, 18, 50,
51, 19, 51,
52, 20, 52,
53, 21, 53,
54, 22, 54,
55, 23, 55,
56, 24, 56,
57, 25, 57,
58, 26, 58,
59, 27, 59,
60, 28, 60,
61, 29, 61,
62, 30, 62,
63, 31, 63,
64, 32, 64,
65, 33, 65,
66, 34, 66,
67, 35, 67,
68, 36, 68,
69, 37, 69,
70, 38, 70,
71, 39, 71,
72, 40, 72,
73, 41, 73,
74, 42, 74,
75, 43, 75,
76, 44, 76,
77, 45, 77,
78, 46, 78,
79, 47, 79,
80, 48, 80,
81, 49, 81,
82, 50, 82,
83, 51, 83,
84, 52, 84,
85, 53, 85,
86, 54, 86,
87, 55, 87,
88, 56, 88,
89, 57, 89,
90, 58, 90,
91, 59, 91,
92, 60, 92,
93, 61, 93,
94, 62, 94,
95, 63, 95,
96, 64, 96,
97, 65, 97,
98, 66, 98,
99, 67, 99,
100, 68, 100,
101, 69, 101,
102, 70, 102,
103, 71, 103,
104, 72, 104,
105, 73, 105,
106, 74, 106,
107, 75, 107,
108, 76, 108,
109, 77, 109,
110, 78, 110,
111, 79, 111,
112, 80, 112,
113, 81, 113,
114, 82, 114,
115, 83, 115,
116, 84, 116,
117, 85, 117,
118, 86, 118,
119, 87, 119,
120, 88, 120,
121, 89, 121,
122, 90, 122,
123, 91, 123,
124, 92, 124,
125, 93, 125,
126, 94, 126,
127, 95, 127
 };
#pragma line 291 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_1_trichk.h" 1
vars_3_45a varinx18A_4096_a[] = {
86, 129, 298,
87, 130, 299,
88, 131, 300,
89, 132, 301,
90, 133, 302,
91, 134, 303,
92, 135, 304,
93, 136, 305,
94, 137, 306,
95, 138, 307,
96, 139, 308,
97, 140, 309,
98, 141, 310,
99, 142, 311,
100, 143, 312,
101, 144, 313,
102, 145, 314,
103, 146, 315,
104, 147, 316,
105, 148, 317,
106, 149, 318,
107, 150, 319,
108, 151, 320,
109, 152, 321,
110, 153, 322,
111, 154, 323,
112, 155, 324,
113, 156, 325,
114, 157, 326,
115, 158, 327,
116, 159, 328,
117, 160, 329,
118, 161, 330,
119, 162, 331,
120, 163, 332,
121, 164, 333,
122, 165, 334,
123, 166, 335,
124, 167, 336,
125, 168, 337,
126, 169, 338,
127, 170, 339,
0, 171, 340,
1, 172, 341,
2, 173, 342,
3, 174, 343,
4, 175, 344,
5, 176, 345,
6, 177, 346,
7, 178, 347,
8, 179, 348,
9, 180, 349,
10, 181, 350,
11, 182, 351,
12, 183, 352,
13, 184, 353,
14, 185, 354,
15, 186, 355,
16, 187, 356,
17, 188, 357,
18, 189, 358,
19, 190, 359,
20, 191, 360,
21, 192, 361,
22, 193, 362,
23, 194, 363,
24, 195, 364,
25, 196, 365,
26, 197, 366,
27, 198, 367,
28, 199, 368,
29, 200, 369,
30, 201, 370,
31, 202, 371,
32, 203, 372,
33, 204, 373,
34, 205, 374,
35, 206, 375,
36, 207, 376,
37, 208, 377,
38, 209, 378,
39, 210, 379,
40, 211, 380,
41, 212, 381,
42, 213, 382,
43, 214, 383,
44, 215, 256,
45, 216, 257,
46, 217, 258,
47, 218, 259,
48, 219, 260,
49, 220, 261,
50, 221, 262,
51, 222, 263,
52, 223, 264,
53, 224, 265,
54, 225, 266,
55, 226, 267,
56, 227, 268,
57, 228, 269,
58, 229, 270,
59, 230, 271,
60, 231, 272,
61, 232, 273,
62, 233, 274,
63, 234, 275,
64, 235, 276,
65, 236, 277,
66, 237, 278,
67, 238, 279,
68, 239, 280,
69, 240, 281,
70, 241, 282,
71, 242, 283,
72, 243, 284,
73, 244, 285,
74, 245, 286,
75, 246, 287,
76, 247, 288,
77, 248, 289,
78, 249, 290,
79, 250, 291,
80, 251, 292,
81, 252, 293,
82, 253, 294,
83, 254, 295,
84, 255, 296,
85, 128, 297,
184, 310, 492,
185, 311, 493,
186, 312, 494,
187, 313, 495,
188, 314, 496,
189, 315, 497,
190, 316, 498,
191, 317, 499,
192, 318, 500,
193, 319, 501,
194, 320, 502,
195, 321, 503,
196, 322, 504,
197, 323, 505,
198, 324, 506,
199, 325, 507,
200, 326, 508,
201, 327, 509,
202, 328, 510,
203, 329, 511,
204, 330, 384,
205, 331, 385,
206, 332, 386,
207, 333, 387,
208, 334, 388,
209, 335, 389,
210, 336, 390,
211, 337, 391,
212, 338, 392,
213, 339, 393,
214, 340, 394,
215, 341, 395,
216, 342, 396,
217, 343, 397,
218, 344, 398,
219, 345, 399,
220, 346, 400,
221, 347, 401,
222, 348, 402,
223, 349, 403,
224, 350, 404,
225, 351, 405,
226, 352, 406,
227, 353, 407,
228, 354, 408,
229, 355, 409,
230, 356, 410,
231, 357, 411,
232, 358, 412,
233, 359, 413,
234, 360, 414,
235, 361, 415,
236, 362, 416,
237, 363, 417,
238, 364, 418,
239, 365, 419,
240, 366, 420,
241, 367, 421,
242, 368, 422,
243, 369, 423,
244, 370, 424,
245, 371, 425,
246, 372, 426,
247, 373, 427,
248, 374, 428,
249, 375, 429,
250, 376, 430,
251, 377, 431,
252, 378, 432,
253, 379, 433,
254, 380, 434,
255, 381, 435,
128, 382, 436,
129, 383, 437,
130, 256, 438,
131, 257, 439,
132, 258, 440,
133, 259, 441,
134, 260, 442,
135, 261, 443,
136, 262, 444,
137, 263, 445,
138, 264, 446,
139, 265, 447,
140, 266, 448,
141, 267, 449,
142, 268, 450,
143, 269, 451,
144, 270, 452,
145, 271, 453,
146, 272, 454,
147, 273, 455,
148, 274, 456,
149, 275, 457,
150, 276, 458,
151, 277, 459,
152, 278, 460,
153, 279, 461,
154, 280, 462,
155, 281, 463,
156, 282, 464,
157, 283, 465,
158, 284, 466,
159, 285, 467,
160, 286, 468,
161, 287, 469,
162, 288, 470,
163, 289, 471,
164, 290, 472,
165, 291, 473,
166, 292, 474,
167, 293, 475,
168, 294, 476,
169, 295, 477,
170, 296, 478,
171, 297, 479,
172, 298, 480,
173, 299, 481,
174, 300, 482,
175, 301, 483,
176, 302, 484,
177, 303, 485,
178, 304, 486,
179, 305, 487,
180, 306, 488,
181, 307, 489,
182, 308, 490,
183, 309, 491,
25, 314, 408,
26, 315, 409,
27, 316, 410,
28, 317, 411,
29, 318, 412,
30, 319, 413,
31, 320, 414,
32, 321, 415,
33, 322, 416,
34, 323, 417,
35, 324, 418,
36, 325, 419,
37, 326, 420,
38, 327, 421,
39, 328, 422,
40, 329, 423,
41, 330, 424,
42, 331, 425,
43, 332, 426,
44, 333, 427,
45, 334, 428,
46, 335, 429,
47, 336, 430,
48, 337, 431,
49, 338, 432,
50, 339, 433,
51, 340, 434,
52, 341, 435,
53, 342, 436,
54, 343, 437,
55, 344, 438,
56, 345, 439,
57, 346, 440,
58, 347, 441,
59, 348, 442,
60, 349, 443,
61, 350, 444,
62, 351, 445,
63, 352, 446,
64, 353, 447,
65, 354, 448,
66, 355, 449,
67, 356, 450,
68, 357, 451,
69, 358, 452,
70, 359, 453,
71, 360, 454,
72, 361, 455,
73, 362, 456,
74, 363, 457,
75, 364, 458,
76, 365, 459,
77, 366, 460,
78, 367, 461,
79, 368, 462,
80, 369, 463,
81, 370, 464,
82, 371, 465,
83, 372, 466,
84, 373, 467,
85, 374, 468,
86, 375, 469,
87, 376, 470,
88, 377, 471,
89, 378, 472,
90, 379, 473,
91, 380, 474,
92, 381, 475,
93, 382, 476,
94, 383, 477,
95, 256, 478,
96, 257, 479,
97, 258, 480,
98, 259, 481,
99, 260, 482,
100, 261, 483,
101, 262, 484,
102, 263, 485,
103, 264, 486,
104, 265, 487,
105, 266, 488,
106, 267, 489,
107, 268, 490,
108, 269, 491,
109, 270, 492,
110, 271, 493,
111, 272, 494,
112, 273, 495,
113, 274, 496,
114, 275, 497,
115, 276, 498,
116, 277, 499,
117, 278, 500,
118, 279, 501,
119, 280, 502,
120, 281, 503,
121, 282, 504,
122, 283, 505,
123, 284, 506,
124, 285, 507,
125, 286, 508,
126, 287, 509,
127, 288, 510,
0, 289, 511,
1, 290, 384,
2, 291, 385,
3, 292, 386,
4, 293, 387,
5, 294, 388,
6, 295, 389,
7, 296, 390,
8, 297, 391,
9, 298, 392,
10, 299, 393,
11, 300, 394,
12, 301, 395,
13, 302, 396,
14, 303, 397,
15, 304, 398,
16, 305, 399,
17, 306, 400,
18, 307, 401,
19, 308, 402,
20, 309, 403,
21, 310, 404,
22, 311, 405,
23, 312, 406,
24, 313, 407,
98, 151, 511,
99, 152, 384,
100, 153, 385,
101, 154, 386,
102, 155, 387,
103, 156, 388,
104, 157, 389,
105, 158, 390,
106, 159, 391,
107, 160, 392,
108, 161, 393,
109, 162, 394,
110, 163, 395,
111, 164, 396,
112, 165, 397,
113, 166, 398,
114, 167, 399,
115, 168, 400,
116, 169, 401,
117, 170, 402,
118, 171, 403,
119, 172, 404,
120, 173, 405,
121, 174, 406,
122, 175, 407,
123, 176, 408,
124, 177, 409,
125, 178, 410,
126, 179, 411,
127, 180, 412,
0, 181, 413,
1, 182, 414,
2, 183, 415,
3, 184, 416,
4, 185, 417,
5, 186, 418,
6, 187, 419,
7, 188, 420,
8, 189, 421,
9, 190, 422,
10, 191, 423,
11, 192, 424,
12, 193, 425,
13, 194, 426,
14, 195, 427,
15, 196, 428,
16, 197, 429,
17, 198, 430,
18, 199, 431,
19, 200, 432,
20, 201, 433,
21, 202, 434,
22, 203, 435,
23, 204, 436,
24, 205, 437,
25, 206, 438,
26, 207, 439,
27, 208, 440,
28, 209, 441,
29, 210, 442,
30, 211, 443,
31, 212, 444,
32, 213, 445,
33, 214, 446,
34, 215, 447,
35, 216, 448,
36, 217, 449,
37, 218, 450,
38, 219, 451,
39, 220, 452,
40, 221, 453,
41, 222, 454,
42, 223, 455,
43, 224, 456,
44, 225, 457,
45, 226, 458,
46, 227, 459,
47, 228, 460,
48, 229, 461,
49, 230, 462,
50, 231, 463,
51, 232, 464,
52, 233, 465,
53, 234, 466,
54, 235, 467,
55, 236, 468,
56, 237, 469,
57, 238, 470,
58, 239, 471,
59, 240, 472,
60, 241, 473,
61, 242, 474,
62, 243, 475,
63, 244, 476,
64, 245, 477,
65, 246, 478,
66, 247, 479,
67, 248, 480,
68, 249, 481,
69, 250, 482,
70, 251, 483,
71, 252, 484,
72, 253, 485,
73, 254, 486,
74, 255, 487,
75, 128, 488,
76, 129, 489,
77, 130, 490,
78, 131, 491,
79, 132, 492,
80, 133, 493,
81, 134, 494,
82, 135, 495,
83, 136, 496,
84, 137, 497,
85, 138, 498,
86, 139, 499,
87, 140, 500,
88, 141, 501,
89, 142, 502,
90, 143, 503,
91, 144, 504,
92, 145, 505,
93, 146, 506,
94, 147, 507,
95, 148, 508,
96, 149, 509,
97, 150, 510
};
#pragma empty_line
vars_3_45a varinx18B_4096_a[] = {
0, 246, 289,
1, 247, 290,
2, 248, 291,
3, 249, 292,
4, 250, 293,
5, 251, 294,
6, 252, 295,
7, 253, 296,
8, 254, 297,
9, 255, 298,
10, 128, 299,
11, 129, 300,
12, 130, 301,
13, 131, 302,
14, 132, 303,
15, 133, 304,
16, 134, 305,
17, 135, 306,
18, 136, 307,
19, 137, 308,
20, 138, 309,
21, 139, 310,
22, 140, 311,
23, 141, 312,
24, 142, 313,
25, 143, 314,
26, 144, 315,
27, 145, 316,
28, 146, 317,
29, 147, 318,
30, 148, 319,
31, 149, 320,
32, 150, 321,
33, 151, 322,
34, 152, 323,
35, 153, 324,
36, 154, 325,
37, 155, 326,
38, 156, 327,
39, 157, 328,
40, 158, 329,
41, 159, 330,
42, 160, 331,
43, 161, 332,
44, 162, 333,
45, 163, 334,
46, 164, 335,
47, 165, 336,
48, 166, 337,
49, 167, 338,
50, 168, 339,
51, 169, 340,
52, 170, 341,
53, 171, 342,
54, 172, 343,
55, 173, 344,
56, 174, 345,
57, 175, 346,
58, 176, 347,
59, 177, 348,
60, 178, 349,
61, 179, 350,
62, 180, 351,
63, 181, 352,
64, 182, 353,
65, 183, 354,
66, 184, 355,
67, 185, 356,
68, 186, 357,
69, 187, 358,
70, 188, 359,
71, 189, 360,
72, 190, 361,
73, 191, 362,
74, 192, 363,
75, 193, 364,
76, 194, 365,
77, 195, 366,
78, 196, 367,
79, 197, 368,
80, 198, 369,
81, 199, 370,
82, 200, 371,
83, 201, 372,
84, 202, 373,
85, 203, 374,
86, 204, 375,
87, 205, 376,
88, 206, 377,
89, 207, 378,
90, 208, 379,
91, 209, 380,
92, 210, 381,
93, 211, 382,
94, 212, 383,
95, 213, 256,
96, 214, 257,
97, 215, 258,
98, 216, 259,
99, 217, 260,
100, 218, 261,
101, 219, 262,
102, 220, 263,
103, 221, 264,
104, 222, 265,
105, 223, 266,
106, 224, 267,
107, 225, 268,
108, 226, 269,
109, 227, 270,
110, 228, 271,
111, 229, 272,
112, 230, 273,
113, 231, 274,
114, 232, 275,
115, 233, 276,
116, 234, 277,
117, 235, 278,
118, 236, 279,
119, 237, 280,
120, 238, 281,
121, 239, 282,
122, 240, 283,
123, 241, 284,
124, 242, 285,
125, 243, 286,
126, 244, 287,
127, 245, 288,
128, 116, 270,
129, 117, 271,
130, 118, 272,
131, 119, 273,
132, 120, 274,
133, 121, 275,
134, 122, 276,
135, 123, 277,
136, 124, 278,
137, 125, 279,
138, 126, 280,
139, 127, 281,
140, 0, 282,
141, 1, 283,
142, 2, 284,
143, 3, 285,
144, 4, 286,
145, 5, 287,
146, 6, 288,
147, 7, 289,
148, 8, 290,
149, 9, 291,
150, 10, 292,
151, 11, 293,
152, 12, 294,
153, 13, 295,
154, 14, 296,
155, 15, 297,
156, 16, 298,
157, 17, 299,
158, 18, 300,
159, 19, 301,
160, 20, 302,
161, 21, 303,
162, 22, 304,
163, 23, 305,
164, 24, 306,
165, 25, 307,
166, 26, 308,
167, 27, 309,
168, 28, 310,
169, 29, 311,
170, 30, 312,
171, 31, 313,
172, 32, 314,
173, 33, 315,
174, 34, 316,
175, 35, 317,
176, 36, 318,
177, 37, 319,
178, 38, 320,
179, 39, 321,
180, 40, 322,
181, 41, 323,
182, 42, 324,
183, 43, 325,
184, 44, 326,
185, 45, 327,
186, 46, 328,
187, 47, 329,
188, 48, 330,
189, 49, 331,
190, 50, 332,
191, 51, 333,
192, 52, 334,
193, 53, 335,
194, 54, 336,
195, 55, 337,
196, 56, 338,
197, 57, 339,
198, 58, 340,
199, 59, 341,
200, 60, 342,
201, 61, 343,
202, 62, 344,
203, 63, 345,
204, 64, 346,
205, 65, 347,
206, 66, 348,
207, 67, 349,
208, 68, 350,
209, 69, 351,
210, 70, 352,
211, 71, 353,
212, 72, 354,
213, 73, 355,
214, 74, 356,
215, 75, 357,
216, 76, 358,
217, 77, 359,
218, 78, 360,
219, 79, 361,
220, 80, 362,
221, 81, 363,
222, 82, 364,
223, 83, 365,
224, 84, 366,
225, 85, 367,
226, 86, 368,
227, 87, 369,
228, 88, 370,
229, 89, 371,
230, 90, 372,
231, 91, 373,
232, 92, 374,
233, 93, 375,
234, 94, 376,
235, 95, 377,
236, 96, 378,
237, 97, 379,
238, 98, 380,
239, 99, 381,
240, 100, 382,
241, 101, 383,
242, 102, 256,
243, 103, 257,
244, 104, 258,
245, 105, 259,
246, 106, 260,
247, 107, 261,
248, 108, 262,
249, 109, 263,
250, 110, 264,
251, 111, 265,
252, 112, 266,
253, 113, 267,
254, 114, 268,
255, 115, 269,
256, 38, 248,
257, 39, 249,
258, 40, 250,
259, 41, 251,
260, 42, 252,
261, 43, 253,
262, 44, 254,
263, 45, 255,
264, 46, 128,
265, 47, 129,
266, 48, 130,
267, 49, 131,
268, 50, 132,
269, 51, 133,
270, 52, 134,
271, 53, 135,
272, 54, 136,
273, 55, 137,
274, 56, 138,
275, 57, 139,
276, 58, 140,
277, 59, 141,
278, 60, 142,
279, 61, 143,
280, 62, 144,
281, 63, 145,
282, 64, 146,
283, 65, 147,
284, 66, 148,
285, 67, 149,
286, 68, 150,
287, 69, 151,
288, 70, 152,
289, 71, 153,
290, 72, 154,
291, 73, 155,
292, 74, 156,
293, 75, 157,
294, 76, 158,
295, 77, 159,
296, 78, 160,
297, 79, 161,
298, 80, 162,
299, 81, 163,
300, 82, 164,
301, 83, 165,
302, 84, 166,
303, 85, 167,
304, 86, 168,
305, 87, 169,
306, 88, 170,
307, 89, 171,
308, 90, 172,
309, 91, 173,
310, 92, 174,
311, 93, 175,
312, 94, 176,
313, 95, 177,
314, 96, 178,
315, 97, 179,
316, 98, 180,
317, 99, 181,
318, 100, 182,
319, 101, 183,
320, 102, 184,
321, 103, 185,
322, 104, 186,
323, 105, 187,
324, 106, 188,
325, 107, 189,
326, 108, 190,
327, 109, 191,
328, 110, 192,
329, 111, 193,
330, 112, 194,
331, 113, 195,
332, 114, 196,
333, 115, 197,
334, 116, 198,
335, 117, 199,
336, 118, 200,
337, 119, 201,
338, 120, 202,
339, 121, 203,
340, 122, 204,
341, 123, 205,
342, 124, 206,
343, 125, 207,
344, 126, 208,
345, 127, 209,
346, 0, 210,
347, 1, 211,
348, 2, 212,
349, 3, 213,
350, 4, 214,
351, 5, 215,
352, 6, 216,
353, 7, 217,
354, 8, 218,
355, 9, 219,
356, 10, 220,
357, 11, 221,
358, 12, 222,
359, 13, 223,
360, 14, 224,
361, 15, 225,
362, 16, 226,
363, 17, 227,
364, 18, 228,
365, 19, 229,
366, 20, 230,
367, 21, 231,
368, 22, 232,
369, 23, 233,
370, 24, 234,
371, 25, 235,
372, 26, 236,
373, 27, 237,
374, 28, 238,
375, 29, 239,
376, 30, 240,
377, 31, 241,
378, 32, 242,
379, 33, 243,
380, 34, 244,
381, 35, 245,
382, 36, 246,
383, 37, 247,
384, 38, 146,
385, 39, 147,
386, 40, 148,
387, 41, 149,
388, 42, 150,
389, 43, 151,
390, 44, 152,
391, 45, 153,
392, 46, 154,
393, 47, 155,
394, 48, 156,
395, 49, 157,
396, 50, 158,
397, 51, 159,
398, 52, 160,
399, 53, 161,
400, 54, 162,
401, 55, 163,
402, 56, 164,
403, 57, 165,
404, 58, 166,
405, 59, 167,
406, 60, 168,
407, 61, 169,
408, 62, 170,
409, 63, 171,
410, 64, 172,
411, 65, 173,
412, 66, 174,
413, 67, 175,
414, 68, 176,
415, 69, 177,
416, 70, 178,
417, 71, 179,
418, 72, 180,
419, 73, 181,
420, 74, 182,
421, 75, 183,
422, 76, 184,
423, 77, 185,
424, 78, 186,
425, 79, 187,
426, 80, 188,
427, 81, 189,
428, 82, 190,
429, 83, 191,
430, 84, 192,
431, 85, 193,
432, 86, 194,
433, 87, 195,
434, 88, 196,
435, 89, 197,
436, 90, 198,
437, 91, 199,
438, 92, 200,
439, 93, 201,
440, 94, 202,
441, 95, 203,
442, 96, 204,
443, 97, 205,
444, 98, 206,
445, 99, 207,
446, 100, 208,
447, 101, 209,
448, 102, 210,
449, 103, 211,
450, 104, 212,
451, 105, 213,
452, 106, 214,
453, 107, 215,
454, 108, 216,
455, 109, 217,
456, 110, 218,
457, 111, 219,
458, 112, 220,
459, 113, 221,
460, 114, 222,
461, 115, 223,
462, 116, 224,
463, 117, 225,
464, 118, 226,
465, 119, 227,
466, 120, 228,
467, 121, 229,
468, 122, 230,
469, 123, 231,
470, 124, 232,
471, 125, 233,
472, 126, 234,
473, 127, 235,
474, 0, 236,
475, 1, 237,
476, 2, 238,
477, 3, 239,
478, 4, 240,
479, 5, 241,
480, 6, 242,
481, 7, 243,
482, 8, 244,
483, 9, 245,
484, 10, 246,
485, 11, 247,
486, 12, 248,
487, 13, 249,
488, 14, 250,
489, 15, 251,
490, 16, 252,
491, 17, 253,
492, 18, 254,
493, 19, 255,
494, 20, 128,
495, 21, 129,
496, 22, 130,
497, 23, 131,
498, 24, 132,
499, 25, 133,
500, 26, 134,
501, 27, 135,
502, 28, 136,
503, 29, 137,
504, 30, 138,
505, 31, 139,
506, 32, 140,
507, 33, 141,
508, 34, 142,
509, 35, 143,
510, 36, 144,
511, 37, 145
};
#pragma line 293 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_2_trichk.h" 1
vars_3_45a varinx18A_4096_b[] = {
0, 79, 198,
1, 80, 199,
2, 81, 200,
3, 82, 201,
4, 83, 202,
5, 84, 203,
6, 85, 204,
7, 86, 205,
8, 87, 206,
9, 88, 207,
10, 89, 208,
11, 90, 209,
12, 91, 210,
13, 92, 211,
14, 93, 212,
15, 94, 213,
16, 95, 214,
17, 96, 215,
18, 97, 216,
19, 98, 217,
20, 99, 218,
21, 100, 219,
22, 101, 220,
23, 102, 221,
24, 103, 222,
25, 104, 223,
26, 105, 224,
27, 106, 225,
28, 107, 226,
29, 108, 227,
30, 109, 228,
31, 110, 229,
32, 111, 230,
33, 112, 231,
34, 113, 232,
35, 114, 233,
36, 115, 234,
37, 116, 235,
38, 117, 236,
39, 118, 237,
40, 119, 238,
41, 120, 239,
42, 121, 240,
43, 122, 241,
44, 123, 242,
45, 124, 243,
46, 125, 244,
47, 126, 245,
48, 127, 246,
49, 0, 247,
50, 1, 248,
51, 2, 249,
52, 3, 250,
53, 4, 251,
54, 5, 252,
55, 6, 253,
56, 7, 254,
57, 8, 255,
58, 9, 128,
59, 10, 129,
60, 11, 130,
61, 12, 131,
62, 13, 132,
63, 14, 133,
64, 15, 134,
65, 16, 135,
66, 17, 136,
67, 18, 137,
68, 19, 138,
69, 20, 139,
70, 21, 140,
71, 22, 141,
72, 23, 142,
73, 24, 143,
74, 25, 144,
75, 26, 145,
76, 27, 146,
77, 28, 147,
78, 29, 148,
79, 30, 149,
80, 31, 150,
81, 32, 151,
82, 33, 152,
83, 34, 153,
84, 35, 154,
85, 36, 155,
86, 37, 156,
87, 38, 157,
88, 39, 158,
89, 40, 159,
90, 41, 160,
91, 42, 161,
92, 43, 162,
93, 44, 163,
94, 45, 164,
95, 46, 165,
96, 47, 166,
97, 48, 167,
98, 49, 168,
99, 50, 169,
100, 51, 170,
101, 52, 171,
102, 53, 172,
103, 54, 173,
104, 55, 174,
105, 56, 175,
106, 57, 176,
107, 58, 177,
108, 59, 178,
109, 60, 179,
110, 61, 180,
111, 62, 181,
112, 63, 182,
113, 64, 183,
114, 65, 184,
115, 66, 185,
116, 67, 186,
117, 68, 187,
118, 69, 188,
119, 70, 189,
120, 71, 190,
121, 72, 191,
122, 73, 192,
123, 74, 193,
124, 75, 194,
125, 76, 195,
126, 77, 196,
127, 78, 197,
128, 219, 326,
129, 220, 327,
130, 221, 328,
131, 222, 329,
132, 223, 330,
133, 224, 331,
134, 225, 332,
135, 226, 333,
136, 227, 334,
137, 228, 335,
138, 229, 336,
139, 230, 337,
140, 231, 338,
141, 232, 339,
142, 233, 340,
143, 234, 341,
144, 235, 342,
145, 236, 343,
146, 237, 344,
147, 238, 345,
148, 239, 346,
149, 240, 347,
150, 241, 348,
151, 242, 349,
152, 243, 350,
153, 244, 351,
154, 245, 352,
155, 246, 353,
156, 247, 354,
157, 248, 355,
158, 249, 356,
159, 250, 357,
160, 251, 358,
161, 252, 359,
162, 253, 360,
163, 254, 361,
164, 255, 362,
165, 128, 363,
166, 129, 364,
167, 130, 365,
168, 131, 366,
169, 132, 367,
170, 133, 368,
171, 134, 369,
172, 135, 370,
173, 136, 371,
174, 137, 372,
175, 138, 373,
176, 139, 374,
177, 140, 375,
178, 141, 376,
179, 142, 377,
180, 143, 378,
181, 144, 379,
182, 145, 380,
183, 146, 381,
184, 147, 382,
185, 148, 383,
186, 149, 256,
187, 150, 257,
188, 151, 258,
189, 152, 259,
190, 153, 260,
191, 154, 261,
192, 155, 262,
193, 156, 263,
194, 157, 264,
195, 158, 265,
196, 159, 266,
197, 160, 267,
198, 161, 268,
199, 162, 269,
200, 163, 270,
201, 164, 271,
202, 165, 272,
203, 166, 273,
204, 167, 274,
205, 168, 275,
206, 169, 276,
207, 170, 277,
208, 171, 278,
209, 172, 279,
210, 173, 280,
211, 174, 281,
212, 175, 282,
213, 176, 283,
214, 177, 284,
215, 178, 285,
216, 179, 286,
217, 180, 287,
218, 181, 288,
219, 182, 289,
220, 183, 290,
221, 184, 291,
222, 185, 292,
223, 186, 293,
224, 187, 294,
225, 188, 295,
226, 189, 296,
227, 190, 297,
228, 191, 298,
229, 192, 299,
230, 193, 300,
231, 194, 301,
232, 195, 302,
233, 196, 303,
234, 197, 304,
235, 198, 305,
236, 199, 306,
237, 200, 307,
238, 201, 308,
239, 202, 309,
240, 203, 310,
241, 204, 311,
242, 205, 312,
243, 206, 313,
244, 207, 314,
245, 208, 315,
246, 209, 316,
247, 210, 317,
248, 211, 318,
249, 212, 319,
250, 213, 320,
251, 214, 321,
252, 215, 322,
253, 216, 323,
254, 217, 324,
255, 218, 325,
256, 96, 305,
257, 97, 306,
258, 98, 307,
259, 99, 308,
260, 100, 309,
261, 101, 310,
262, 102, 311,
263, 103, 312,
264, 104, 313,
265, 105, 314,
266, 106, 315,
267, 107, 316,
268, 108, 317,
269, 109, 318,
270, 110, 319,
271, 111, 320,
272, 112, 321,
273, 113, 322,
274, 114, 323,
275, 115, 324,
276, 116, 325,
277, 117, 326,
278, 118, 327,
279, 119, 328,
280, 120, 329,
281, 121, 330,
282, 122, 331,
283, 123, 332,
284, 124, 333,
285, 125, 334,
286, 126, 335,
287, 127, 336,
288, 0, 337,
289, 1, 338,
290, 2, 339,
291, 3, 340,
292, 4, 341,
293, 5, 342,
294, 6, 343,
295, 7, 344,
296, 8, 345,
297, 9, 346,
298, 10, 347,
299, 11, 348,
300, 12, 349,
301, 13, 350,
302, 14, 351,
303, 15, 352,
304, 16, 353,
305, 17, 354,
306, 18, 355,
307, 19, 356,
308, 20, 357,
309, 21, 358,
310, 22, 359,
311, 23, 360,
312, 24, 361,
313, 25, 362,
314, 26, 363,
315, 27, 364,
316, 28, 365,
317, 29, 366,
318, 30, 367,
319, 31, 368,
320, 32, 369,
321, 33, 370,
322, 34, 371,
323, 35, 372,
324, 36, 373,
325, 37, 374,
326, 38, 375,
327, 39, 376,
328, 40, 377,
329, 41, 378,
330, 42, 379,
331, 43, 380,
332, 44, 381,
333, 45, 382,
334, 46, 383,
335, 47, 256,
336, 48, 257,
337, 49, 258,
338, 50, 259,
339, 51, 260,
340, 52, 261,
341, 53, 262,
342, 54, 263,
343, 55, 264,
344, 56, 265,
345, 57, 266,
346, 58, 267,
347, 59, 268,
348, 60, 269,
349, 61, 270,
350, 62, 271,
351, 63, 272,
352, 64, 273,
353, 65, 274,
354, 66, 275,
355, 67, 276,
356, 68, 277,
357, 69, 278,
358, 70, 279,
359, 71, 280,
360, 72, 281,
361, 73, 282,
362, 74, 283,
363, 75, 284,
364, 76, 285,
365, 77, 286,
366, 78, 287,
367, 79, 288,
368, 80, 289,
369, 81, 290,
370, 82, 291,
371, 83, 292,
372, 84, 293,
373, 85, 294,
374, 86, 295,
375, 87, 296,
376, 88, 297,
377, 89, 298,
378, 90, 299,
379, 91, 300,
380, 92, 301,
381, 93, 302,
382, 94, 303,
383, 95, 304,
384, 119, 202,
385, 120, 203,
386, 121, 204,
387, 122, 205,
388, 123, 206,
389, 124, 207,
390, 125, 208,
391, 126, 209,
392, 127, 210,
393, 0, 211,
394, 1, 212,
395, 2, 213,
396, 3, 214,
397, 4, 215,
398, 5, 216,
399, 6, 217,
400, 7, 218,
401, 8, 219,
402, 9, 220,
403, 10, 221,
404, 11, 222,
405, 12, 223,
406, 13, 224,
407, 14, 225,
408, 15, 226,
409, 16, 227,
410, 17, 228,
411, 18, 229,
412, 19, 230,
413, 20, 231,
414, 21, 232,
415, 22, 233,
416, 23, 234,
417, 24, 235,
418, 25, 236,
419, 26, 237,
420, 27, 238,
421, 28, 239,
422, 29, 240,
423, 30, 241,
424, 31, 242,
425, 32, 243,
426, 33, 244,
427, 34, 245,
428, 35, 246,
429, 36, 247,
430, 37, 248,
431, 38, 249,
432, 39, 250,
433, 40, 251,
434, 41, 252,
435, 42, 253,
436, 43, 254,
437, 44, 255,
438, 45, 128,
439, 46, 129,
440, 47, 130,
441, 48, 131,
442, 49, 132,
443, 50, 133,
444, 51, 134,
445, 52, 135,
446, 53, 136,
447, 54, 137,
448, 55, 138,
449, 56, 139,
450, 57, 140,
451, 58, 141,
452, 59, 142,
453, 60, 143,
454, 61, 144,
455, 62, 145,
456, 63, 146,
457, 64, 147,
458, 65, 148,
459, 66, 149,
460, 67, 150,
461, 68, 151,
462, 69, 152,
463, 70, 153,
464, 71, 154,
465, 72, 155,
466, 73, 156,
467, 74, 157,
468, 75, 158,
469, 76, 159,
470, 77, 160,
471, 78, 161,
472, 79, 162,
473, 80, 163,
474, 81, 164,
475, 82, 165,
476, 83, 166,
477, 84, 167,
478, 85, 168,
479, 86, 169,
480, 87, 170,
481, 88, 171,
482, 89, 172,
483, 90, 173,
484, 91, 174,
485, 92, 175,
486, 93, 176,
487, 94, 177,
488, 95, 178,
489, 96, 179,
490, 97, 180,
491, 98, 181,
492, 99, 182,
493, 100, 183,
494, 101, 184,
495, 102, 185,
496, 103, 186,
497, 104, 187,
498, 105, 188,
499, 106, 189,
500, 107, 190,
501, 108, 191,
502, 109, 192,
503, 110, 193,
504, 111, 194,
505, 112, 195,
506, 113, 196,
507, 114, 197,
508, 115, 198,
509, 116, 199,
510, 117, 200,
511, 118, 201
};
#pragma empty_line
vars_3_45a varinx18B_4096_b[] = {
510, 0, 32,
511, 1, 33,
384, 2, 34,
385, 3, 35,
386, 4, 36,
387, 5, 37,
388, 6, 38,
389, 7, 39,
390, 8, 40,
391, 9, 41,
392, 10, 42,
393, 11, 43,
394, 12, 44,
395, 13, 45,
396, 14, 46,
397, 15, 47,
398, 16, 48,
399, 17, 49,
400, 18, 50,
401, 19, 51,
402, 20, 52,
403, 21, 53,
404, 22, 54,
405, 23, 55,
406, 24, 56,
407, 25, 57,
408, 26, 58,
409, 27, 59,
410, 28, 60,
411, 29, 61,
412, 30, 62,
413, 31, 63,
414, 32, 64,
415, 33, 65,
416, 34, 66,
417, 35, 67,
418, 36, 68,
419, 37, 69,
420, 38, 70,
421, 39, 71,
422, 40, 72,
423, 41, 73,
424, 42, 74,
425, 43, 75,
426, 44, 76,
427, 45, 77,
428, 46, 78,
429, 47, 79,
430, 48, 80,
431, 49, 81,
432, 50, 82,
433, 51, 83,
434, 52, 84,
435, 53, 85,
436, 54, 86,
437, 55, 87,
438, 56, 88,
439, 57, 89,
440, 58, 90,
441, 59, 91,
442, 60, 92,
443, 61, 93,
444, 62, 94,
445, 63, 95,
446, 64, 96,
447, 65, 97,
448, 66, 98,
449, 67, 99,
450, 68, 100,
451, 69, 101,
452, 70, 102,
453, 71, 103,
454, 72, 104,
455, 73, 105,
456, 74, 106,
457, 75, 107,
458, 76, 108,
459, 77, 109,
460, 78, 110,
461, 79, 111,
462, 80, 112,
463, 81, 113,
464, 82, 114,
465, 83, 115,
466, 84, 116,
467, 85, 117,
468, 86, 118,
469, 87, 119,
470, 88, 120,
471, 89, 121,
472, 90, 122,
473, 91, 123,
474, 92, 124,
475, 93, 125,
476, 94, 126,
477, 95, 127,
478, 96, 0,
479, 97, 1,
480, 98, 2,
481, 99, 3,
482, 100, 4,
483, 101, 5,
484, 102, 6,
485, 103, 7,
486, 104, 8,
487, 105, 9,
488, 106, 10,
489, 107, 11,
490, 108, 12,
491, 109, 13,
492, 110, 14,
493, 111, 15,
494, 112, 16,
495, 113, 17,
496, 114, 18,
497, 115, 19,
498, 116, 20,
499, 117, 21,
500, 118, 22,
501, 119, 23,
502, 120, 24,
503, 121, 25,
504, 122, 26,
505, 123, 27,
506, 124, 28,
507, 125, 29,
508, 126, 30,
509, 127, 31,
414, 128, 159,
415, 129, 160,
416, 130, 161,
417, 131, 162,
418, 132, 163,
419, 133, 164,
420, 134, 165,
421, 135, 166,
422, 136, 167,
423, 137, 168,
424, 138, 169,
425, 139, 170,
426, 140, 171,
427, 141, 172,
428, 142, 173,
429, 143, 174,
430, 144, 175,
431, 145, 176,
432, 146, 177,
433, 147, 178,
434, 148, 179,
435, 149, 180,
436, 150, 181,
437, 151, 182,
438, 152, 183,
439, 153, 184,
440, 154, 185,
441, 155, 186,
442, 156, 187,
443, 157, 188,
444, 158, 189,
445, 159, 190,
446, 160, 191,
447, 161, 192,
448, 162, 193,
449, 163, 194,
450, 164, 195,
451, 165, 196,
452, 166, 197,
453, 167, 198,
454, 168, 199,
455, 169, 200,
456, 170, 201,
457, 171, 202,
458, 172, 203,
459, 173, 204,
460, 174, 205,
461, 175, 206,
462, 176, 207,
463, 177, 208,
464, 178, 209,
465, 179, 210,
466, 180, 211,
467, 181, 212,
468, 182, 213,
469, 183, 214,
470, 184, 215,
471, 185, 216,
472, 186, 217,
473, 187, 218,
474, 188, 219,
475, 189, 220,
476, 190, 221,
477, 191, 222,
478, 192, 223,
479, 193, 224,
480, 194, 225,
481, 195, 226,
482, 196, 227,
483, 197, 228,
484, 198, 229,
485, 199, 230,
486, 200, 231,
487, 201, 232,
488, 202, 233,
489, 203, 234,
490, 204, 235,
491, 205, 236,
492, 206, 237,
493, 207, 238,
494, 208, 239,
495, 209, 240,
496, 210, 241,
497, 211, 242,
498, 212, 243,
499, 213, 244,
500, 214, 245,
501, 215, 246,
502, 216, 247,
503, 217, 248,
504, 218, 249,
505, 219, 250,
506, 220, 251,
507, 221, 252,
508, 222, 253,
509, 223, 254,
510, 224, 255,
511, 225, 128,
384, 226, 129,
385, 227, 130,
386, 228, 131,
387, 229, 132,
388, 230, 133,
389, 231, 134,
390, 232, 135,
391, 233, 136,
392, 234, 137,
393, 235, 138,
394, 236, 139,
395, 237, 140,
396, 238, 141,
397, 239, 142,
398, 240, 143,
399, 241, 144,
400, 242, 145,
401, 243, 146,
402, 244, 147,
403, 245, 148,
404, 246, 149,
405, 247, 150,
406, 248, 151,
407, 249, 152,
408, 250, 153,
409, 251, 154,
410, 252, 155,
411, 253, 156,
412, 254, 157,
413, 255, 158,
476, 256, 42,
477, 257, 43,
478, 258, 44,
479, 259, 45,
480, 260, 46,
481, 261, 47,
482, 262, 48,
483, 263, 49,
484, 264, 50,
485, 265, 51,
486, 266, 52,
487, 267, 53,
488, 268, 54,
489, 269, 55,
490, 270, 56,
491, 271, 57,
492, 272, 58,
493, 273, 59,
494, 274, 60,
495, 275, 61,
496, 276, 62,
497, 277, 63,
498, 278, 64,
499, 279, 65,
500, 280, 66,
501, 281, 67,
502, 282, 68,
503, 283, 69,
504, 284, 70,
505, 285, 71,
506, 286, 72,
507, 287, 73,
508, 288, 74,
509, 289, 75,
510, 290, 76,
511, 291, 77,
384, 292, 78,
385, 293, 79,
386, 294, 80,
387, 295, 81,
388, 296, 82,
389, 297, 83,
390, 298, 84,
391, 299, 85,
392, 300, 86,
393, 301, 87,
394, 302, 88,
395, 303, 89,
396, 304, 90,
397, 305, 91,
398, 306, 92,
399, 307, 93,
400, 308, 94,
401, 309, 95,
402, 310, 96,
403, 311, 97,
404, 312, 98,
405, 313, 99,
406, 314, 100,
407, 315, 101,
408, 316, 102,
409, 317, 103,
410, 318, 104,
411, 319, 105,
412, 320, 106,
413, 321, 107,
414, 322, 108,
415, 323, 109,
416, 324, 110,
417, 325, 111,
418, 326, 112,
419, 327, 113,
420, 328, 114,
421, 329, 115,
422, 330, 116,
423, 331, 117,
424, 332, 118,
425, 333, 119,
426, 334, 120,
427, 335, 121,
428, 336, 122,
429, 337, 123,
430, 338, 124,
431, 339, 125,
432, 340, 126,
433, 341, 127,
434, 342, 0,
435, 343, 1,
436, 344, 2,
437, 345, 3,
438, 346, 4,
439, 347, 5,
440, 348, 6,
441, 349, 7,
442, 350, 8,
443, 351, 9,
444, 352, 10,
445, 353, 11,
446, 354, 12,
447, 355, 13,
448, 356, 14,
449, 357, 15,
450, 358, 16,
451, 359, 17,
452, 360, 18,
453, 361, 19,
454, 362, 20,
455, 363, 21,
456, 364, 22,
457, 365, 23,
458, 366, 24,
459, 367, 25,
460, 368, 26,
461, 369, 27,
462, 370, 28,
463, 371, 29,
464, 372, 30,
465, 373, 31,
466, 374, 32,
467, 375, 33,
468, 376, 34,
469, 377, 35,
470, 378, 36,
471, 379, 37,
472, 380, 38,
473, 381, 39,
474, 382, 40,
475, 383, 41,
318, 384, 116,
319, 385, 117,
320, 386, 118,
321, 387, 119,
322, 388, 120,
323, 389, 121,
324, 390, 122,
325, 391, 123,
326, 392, 124,
327, 393, 125,
328, 394, 126,
329, 395, 127,
330, 396, 0,
331, 397, 1,
332, 398, 2,
333, 399, 3,
334, 400, 4,
335, 401, 5,
336, 402, 6,
337, 403, 7,
338, 404, 8,
339, 405, 9,
340, 406, 10,
341, 407, 11,
342, 408, 12,
343, 409, 13,
344, 410, 14,
345, 411, 15,
346, 412, 16,
347, 413, 17,
348, 414, 18,
349, 415, 19,
350, 416, 20,
351, 417, 21,
352, 418, 22,
353, 419, 23,
354, 420, 24,
355, 421, 25,
356, 422, 26,
357, 423, 27,
358, 424, 28,
359, 425, 29,
360, 426, 30,
361, 427, 31,
362, 428, 32,
363, 429, 33,
364, 430, 34,
365, 431, 35,
366, 432, 36,
367, 433, 37,
368, 434, 38,
369, 435, 39,
370, 436, 40,
371, 437, 41,
372, 438, 42,
373, 439, 43,
374, 440, 44,
375, 441, 45,
376, 442, 46,
377, 443, 47,
378, 444, 48,
379, 445, 49,
380, 446, 50,
381, 447, 51,
382, 448, 52,
383, 449, 53,
256, 450, 54,
257, 451, 55,
258, 452, 56,
259, 453, 57,
260, 454, 58,
261, 455, 59,
262, 456, 60,
263, 457, 61,
264, 458, 62,
265, 459, 63,
266, 460, 64,
267, 461, 65,
268, 462, 66,
269, 463, 67,
270, 464, 68,
271, 465, 69,
272, 466, 70,
273, 467, 71,
274, 468, 72,
275, 469, 73,
276, 470, 74,
277, 471, 75,
278, 472, 76,
279, 473, 77,
280, 474, 78,
281, 475, 79,
282, 476, 80,
283, 477, 81,
284, 478, 82,
285, 479, 83,
286, 480, 84,
287, 481, 85,
288, 482, 86,
289, 483, 87,
290, 484, 88,
291, 485, 89,
292, 486, 90,
293, 487, 91,
294, 488, 92,
295, 489, 93,
296, 490, 94,
297, 491, 95,
298, 492, 96,
299, 493, 97,
300, 494, 98,
301, 495, 99,
302, 496, 100,
303, 497, 101,
304, 498, 102,
305, 499, 103,
306, 500, 104,
307, 501, 105,
308, 502, 106,
309, 503, 107,
310, 504, 108,
311, 505, 109,
312, 506, 110,
313, 507, 111,
314, 508, 112,
315, 509, 113,
316, 510, 114,
317, 511, 115
};
#pragma line 294 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_3_trichk.h" 1
vars_3_45a varinx18A_4096_c[] = {
285, 0, 92,
286, 1, 93,
287, 2, 94,
288, 3, 95,
289, 4, 96,
290, 5, 97,
291, 6, 98,
292, 7, 99,
293, 8, 100,
294, 9, 101,
295, 10, 102,
296, 11, 103,
297, 12, 104,
298, 13, 105,
299, 14, 106,
300, 15, 107,
301, 16, 108,
302, 17, 109,
303, 18, 110,
304, 19, 111,
305, 20, 112,
306, 21, 113,
307, 22, 114,
308, 23, 115,
309, 24, 116,
310, 25, 117,
311, 26, 118,
312, 27, 119,
313, 28, 120,
314, 29, 121,
315, 30, 122,
316, 31, 123,
317, 32, 124,
318, 33, 125,
319, 34, 126,
320, 35, 127,
321, 36, 0,
322, 37, 1,
323, 38, 2,
324, 39, 3,
325, 40, 4,
326, 41, 5,
327, 42, 6,
328, 43, 7,
329, 44, 8,
330, 45, 9,
331, 46, 10,
332, 47, 11,
333, 48, 12,
334, 49, 13,
335, 50, 14,
336, 51, 15,
337, 52, 16,
338, 53, 17,
339, 54, 18,
340, 55, 19,
341, 56, 20,
342, 57, 21,
343, 58, 22,
344, 59, 23,
345, 60, 24,
346, 61, 25,
347, 62, 26,
348, 63, 27,
349, 64, 28,
350, 65, 29,
351, 66, 30,
352, 67, 31,
353, 68, 32,
354, 69, 33,
355, 70, 34,
356, 71, 35,
357, 72, 36,
358, 73, 37,
359, 74, 38,
360, 75, 39,
361, 76, 40,
362, 77, 41,
363, 78, 42,
364, 79, 43,
365, 80, 44,
366, 81, 45,
367, 82, 46,
368, 83, 47,
369, 84, 48,
370, 85, 49,
371, 86, 50,
372, 87, 51,
373, 88, 52,
374, 89, 53,
375, 90, 54,
376, 91, 55,
377, 92, 56,
378, 93, 57,
379, 94, 58,
380, 95, 59,
381, 96, 60,
382, 97, 61,
383, 98, 62,
256, 99, 63,
257, 100, 64,
258, 101, 65,
259, 102, 66,
260, 103, 67,
261, 104, 68,
262, 105, 69,
263, 106, 70,
264, 107, 71,
265, 108, 72,
266, 109, 73,
267, 110, 74,
268, 111, 75,
269, 112, 76,
270, 113, 77,
271, 114, 78,
272, 115, 79,
273, 116, 80,
274, 117, 81,
275, 118, 82,
276, 119, 83,
277, 120, 84,
278, 121, 85,
279, 122, 86,
280, 123, 87,
281, 124, 88,
282, 125, 89,
283, 126, 90,
284, 127, 91,
499, 128, 153,
500, 129, 154,
501, 130, 155,
502, 131, 156,
503, 132, 157,
504, 133, 158,
505, 134, 159,
506, 135, 160,
507, 136, 161,
508, 137, 162,
509, 138, 163,
510, 139, 164,
511, 140, 165,
384, 141, 166,
385, 142, 167,
386, 143, 168,
387, 144, 169,
388, 145, 170,
389, 146, 171,
390, 147, 172,
391, 148, 173,
392, 149, 174,
393, 150, 175,
394, 151, 176,
395, 152, 177,
396, 153, 178,
397, 154, 179,
398, 155, 180,
399, 156, 181,
400, 157, 182,
401, 158, 183,
402, 159, 184,
403, 160, 185,
404, 161, 186,
405, 162, 187,
406, 163, 188,
407, 164, 189,
408, 165, 190,
409, 166, 191,
410, 167, 192,
411, 168, 193,
412, 169, 194,
413, 170, 195,
414, 171, 196,
415, 172, 197,
416, 173, 198,
417, 174, 199,
418, 175, 200,
419, 176, 201,
420, 177, 202,
421, 178, 203,
422, 179, 204,
423, 180, 205,
424, 181, 206,
425, 182, 207,
426, 183, 208,
427, 184, 209,
428, 185, 210,
429, 186, 211,
430, 187, 212,
431, 188, 213,
432, 189, 214,
433, 190, 215,
434, 191, 216,
435, 192, 217,
436, 193, 218,
437, 194, 219,
438, 195, 220,
439, 196, 221,
440, 197, 222,
441, 198, 223,
442, 199, 224,
443, 200, 225,
444, 201, 226,
445, 202, 227,
446, 203, 228,
447, 204, 229,
448, 205, 230,
449, 206, 231,
450, 207, 232,
451, 208, 233,
452, 209, 234,
453, 210, 235,
454, 211, 236,
455, 212, 237,
456, 213, 238,
457, 214, 239,
458, 215, 240,
459, 216, 241,
460, 217, 242,
461, 218, 243,
462, 219, 244,
463, 220, 245,
464, 221, 246,
465, 222, 247,
466, 223, 248,
467, 224, 249,
468, 225, 250,
469, 226, 251,
470, 227, 252,
471, 228, 253,
472, 229, 254,
473, 230, 255,
474, 231, 128,
475, 232, 129,
476, 233, 130,
477, 234, 131,
478, 235, 132,
479, 236, 133,
480, 237, 134,
481, 238, 135,
482, 239, 136,
483, 240, 137,
484, 241, 138,
485, 242, 139,
486, 243, 140,
487, 244, 141,
488, 245, 142,
489, 246, 143,
490, 247, 144,
491, 248, 145,
492, 249, 146,
493, 250, 147,
494, 251, 148,
495, 252, 149,
496, 253, 150,
497, 254, 151,
498, 255, 152,
465, 256, 11,
466, 257, 12,
467, 258, 13,
468, 259, 14,
469, 260, 15,
470, 261, 16,
471, 262, 17,
472, 263, 18,
473, 264, 19,
474, 265, 20,
475, 266, 21,
476, 267, 22,
477, 268, 23,
478, 269, 24,
479, 270, 25,
480, 271, 26,
481, 272, 27,
482, 273, 28,
483, 274, 29,
484, 275, 30,
485, 276, 31,
486, 277, 32,
487, 278, 33,
488, 279, 34,
489, 280, 35,
490, 281, 36,
491, 282, 37,
492, 283, 38,
493, 284, 39,
494, 285, 40,
495, 286, 41,
496, 287, 42,
497, 288, 43,
498, 289, 44,
499, 290, 45,
500, 291, 46,
501, 292, 47,
502, 293, 48,
503, 294, 49,
504, 295, 50,
505, 296, 51,
506, 297, 52,
507, 298, 53,
508, 299, 54,
509, 300, 55,
510, 301, 56,
511, 302, 57,
384, 303, 58,
385, 304, 59,
386, 305, 60,
387, 306, 61,
388, 307, 62,
389, 308, 63,
390, 309, 64,
391, 310, 65,
392, 311, 66,
393, 312, 67,
394, 313, 68,
395, 314, 69,
396, 315, 70,
397, 316, 71,
398, 317, 72,
399, 318, 73,
400, 319, 74,
401, 320, 75,
402, 321, 76,
403, 322, 77,
404, 323, 78,
405, 324, 79,
406, 325, 80,
407, 326, 81,
408, 327, 82,
409, 328, 83,
410, 329, 84,
411, 330, 85,
412, 331, 86,
413, 332, 87,
414, 333, 88,
415, 334, 89,
416, 335, 90,
417, 336, 91,
418, 337, 92,
419, 338, 93,
420, 339, 94,
421, 340, 95,
422, 341, 96,
423, 342, 97,
424, 343, 98,
425, 344, 99,
426, 345, 100,
427, 346, 101,
428, 347, 102,
429, 348, 103,
430, 349, 104,
431, 350, 105,
432, 351, 106,
433, 352, 107,
434, 353, 108,
435, 354, 109,
436, 355, 110,
437, 356, 111,
438, 357, 112,
439, 358, 113,
440, 359, 114,
441, 360, 115,
442, 361, 116,
443, 362, 117,
444, 363, 118,
445, 364, 119,
446, 365, 120,
447, 366, 121,
448, 367, 122,
449, 368, 123,
450, 369, 124,
451, 370, 125,
452, 371, 126,
453, 372, 127,
454, 373, 0,
455, 374, 1,
456, 375, 2,
457, 376, 3,
458, 377, 4,
459, 378, 5,
460, 379, 6,
461, 380, 7,
462, 381, 8,
463, 382, 9,
464, 383, 10,
476, 384, 91,
477, 385, 92,
478, 386, 93,
479, 387, 94,
480, 388, 95,
481, 389, 96,
482, 390, 97,
483, 391, 98,
484, 392, 99,
485, 393, 100,
486, 394, 101,
487, 395, 102,
488, 396, 103,
489, 397, 104,
490, 398, 105,
491, 399, 106,
492, 400, 107,
493, 401, 108,
494, 402, 109,
495, 403, 110,
496, 404, 111,
497, 405, 112,
498, 406, 113,
499, 407, 114,
500, 408, 115,
501, 409, 116,
502, 410, 117,
503, 411, 118,
504, 412, 119,
505, 413, 120,
506, 414, 121,
507, 415, 122,
508, 416, 123,
509, 417, 124,
510, 418, 125,
511, 419, 126,
384, 420, 127,
385, 421, 0,
386, 422, 1,
387, 423, 2,
388, 424, 3,
389, 425, 4,
390, 426, 5,
391, 427, 6,
392, 428, 7,
393, 429, 8,
394, 430, 9,
395, 431, 10,
396, 432, 11,
397, 433, 12,
398, 434, 13,
399, 435, 14,
400, 436, 15,
401, 437, 16,
402, 438, 17,
403, 439, 18,
404, 440, 19,
405, 441, 20,
406, 442, 21,
407, 443, 22,
408, 444, 23,
409, 445, 24,
410, 446, 25,
411, 447, 26,
412, 448, 27,
413, 449, 28,
414, 450, 29,
415, 451, 30,
416, 452, 31,
417, 453, 32,
418, 454, 33,
419, 455, 34,
420, 456, 35,
421, 457, 36,
422, 458, 37,
423, 459, 38,
424, 460, 39,
425, 461, 40,
426, 462, 41,
427, 463, 42,
428, 464, 43,
429, 465, 44,
430, 466, 45,
431, 467, 46,
432, 468, 47,
433, 469, 48,
434, 470, 49,
435, 471, 50,
436, 472, 51,
437, 473, 52,
438, 474, 53,
439, 475, 54,
440, 476, 55,
441, 477, 56,
442, 478, 57,
443, 479, 58,
444, 480, 59,
445, 481, 60,
446, 482, 61,
447, 483, 62,
448, 484, 63,
449, 485, 64,
450, 486, 65,
451, 487, 66,
452, 488, 67,
453, 489, 68,
454, 490, 69,
455, 491, 70,
456, 492, 71,
457, 493, 72,
458, 494, 73,
459, 495, 74,
460, 496, 75,
461, 497, 76,
462, 498, 77,
463, 499, 78,
464, 500, 79,
465, 501, 80,
466, 502, 81,
467, 503, 82,
468, 504, 83,
469, 505, 84,
470, 506, 85,
471, 507, 86,
472, 508, 87,
473, 509, 88,
474, 510, 89,
475, 511, 90
};
#pragma empty_line
vars_3_45a varinx18B_4096_c[] = {
173, 369, 0,
174, 370, 1,
175, 371, 2,
176, 372, 3,
177, 373, 4,
178, 374, 5,
179, 375, 6,
180, 376, 7,
181, 377, 8,
182, 378, 9,
183, 379, 10,
184, 380, 11,
185, 381, 12,
186, 382, 13,
187, 383, 14,
188, 256, 15,
189, 257, 16,
190, 258, 17,
191, 259, 18,
192, 260, 19,
193, 261, 20,
194, 262, 21,
195, 263, 22,
196, 264, 23,
197, 265, 24,
198, 266, 25,
199, 267, 26,
200, 268, 27,
201, 269, 28,
202, 270, 29,
203, 271, 30,
204, 272, 31,
205, 273, 32,
206, 274, 33,
207, 275, 34,
208, 276, 35,
209, 277, 36,
210, 278, 37,
211, 279, 38,
212, 280, 39,
213, 281, 40,
214, 282, 41,
215, 283, 42,
216, 284, 43,
217, 285, 44,
218, 286, 45,
219, 287, 46,
220, 288, 47,
221, 289, 48,
222, 290, 49,
223, 291, 50,
224, 292, 51,
225, 293, 52,
226, 294, 53,
227, 295, 54,
228, 296, 55,
229, 297, 56,
230, 298, 57,
231, 299, 58,
232, 300, 59,
233, 301, 60,
234, 302, 61,
235, 303, 62,
236, 304, 63,
237, 305, 64,
238, 306, 65,
239, 307, 66,
240, 308, 67,
241, 309, 68,
242, 310, 69,
243, 311, 70,
244, 312, 71,
245, 313, 72,
246, 314, 73,
247, 315, 74,
248, 316, 75,
249, 317, 76,
250, 318, 77,
251, 319, 78,
252, 320, 79,
253, 321, 80,
254, 322, 81,
255, 323, 82,
128, 324, 83,
129, 325, 84,
130, 326, 85,
131, 327, 86,
132, 328, 87,
133, 329, 88,
134, 330, 89,
135, 331, 90,
136, 332, 91,
137, 333, 92,
138, 334, 93,
139, 335, 94,
140, 336, 95,
141, 337, 96,
142, 338, 97,
143, 339, 98,
144, 340, 99,
145, 341, 100,
146, 342, 101,
147, 343, 102,
148, 344, 103,
149, 345, 104,
150, 346, 105,
151, 347, 106,
152, 348, 107,
153, 349, 108,
154, 350, 109,
155, 351, 110,
156, 352, 111,
157, 353, 112,
158, 354, 113,
159, 355, 114,
160, 356, 115,
161, 357, 116,
162, 358, 117,
163, 359, 118,
164, 360, 119,
165, 361, 120,
166, 362, 121,
167, 363, 122,
168, 364, 123,
169, 365, 124,
170, 366, 125,
171, 367, 126,
172, 368, 127,
377, 429, 128,
378, 430, 129,
379, 431, 130,
380, 432, 131,
381, 433, 132,
382, 434, 133,
383, 435, 134,
256, 436, 135,
257, 437, 136,
258, 438, 137,
259, 439, 138,
260, 440, 139,
261, 441, 140,
262, 442, 141,
263, 443, 142,
264, 444, 143,
265, 445, 144,
266, 446, 145,
267, 447, 146,
268, 448, 147,
269, 449, 148,
270, 450, 149,
271, 451, 150,
272, 452, 151,
273, 453, 152,
274, 454, 153,
275, 455, 154,
276, 456, 155,
277, 457, 156,
278, 458, 157,
279, 459, 158,
280, 460, 159,
281, 461, 160,
282, 462, 161,
283, 463, 162,
284, 464, 163,
285, 465, 164,
286, 466, 165,
287, 467, 166,
288, 468, 167,
289, 469, 168,
290, 470, 169,
291, 471, 170,
292, 472, 171,
293, 473, 172,
294, 474, 173,
295, 475, 174,
296, 476, 175,
297, 477, 176,
298, 478, 177,
299, 479, 178,
300, 480, 179,
301, 481, 180,
302, 482, 181,
303, 483, 182,
304, 484, 183,
305, 485, 184,
306, 486, 185,
307, 487, 186,
308, 488, 187,
309, 489, 188,
310, 490, 189,
311, 491, 190,
312, 492, 191,
313, 493, 192,
314, 494, 193,
315, 495, 194,
316, 496, 195,
317, 497, 196,
318, 498, 197,
319, 499, 198,
320, 500, 199,
321, 501, 200,
322, 502, 201,
323, 503, 202,
324, 504, 203,
325, 505, 204,
326, 506, 205,
327, 507, 206,
328, 508, 207,
329, 509, 208,
330, 510, 209,
331, 511, 210,
332, 384, 211,
333, 385, 212,
334, 386, 213,
335, 387, 214,
336, 388, 215,
337, 389, 216,
338, 390, 217,
339, 391, 218,
340, 392, 219,
341, 393, 220,
342, 394, 221,
343, 395, 222,
344, 396, 223,
345, 397, 224,
346, 398, 225,
347, 399, 226,
348, 400, 227,
349, 401, 228,
350, 402, 229,
351, 403, 230,
352, 404, 231,
353, 405, 232,
354, 406, 233,
355, 407, 234,
356, 408, 235,
357, 409, 236,
358, 410, 237,
359, 411, 238,
360, 412, 239,
361, 413, 240,
362, 414, 241,
363, 415, 242,
364, 416, 243,
365, 417, 244,
366, 418, 245,
367, 419, 246,
368, 420, 247,
369, 421, 248,
370, 422, 249,
371, 423, 250,
372, 424, 251,
373, 425, 252,
374, 426, 253,
375, 427, 254,
376, 428, 255,
294, 467, 256,
295, 468, 257,
296, 469, 258,
297, 470, 259,
298, 471, 260,
299, 472, 261,
300, 473, 262,
301, 474, 263,
302, 475, 264,
303, 476, 265,
304, 477, 266,
305, 478, 267,
306, 479, 268,
307, 480, 269,
308, 481, 270,
309, 482, 271,
310, 483, 272,
311, 484, 273,
312, 485, 274,
313, 486, 275,
314, 487, 276,
315, 488, 277,
316, 489, 278,
317, 490, 279,
318, 491, 280,
319, 492, 281,
320, 493, 282,
321, 494, 283,
322, 495, 284,
323, 496, 285,
324, 497, 286,
325, 498, 287,
326, 499, 288,
327, 500, 289,
328, 501, 290,
329, 502, 291,
330, 503, 292,
331, 504, 293,
332, 505, 294,
333, 506, 295,
334, 507, 296,
335, 508, 297,
336, 509, 298,
337, 510, 299,
338, 511, 300,
339, 384, 301,
340, 385, 302,
341, 386, 303,
342, 387, 304,
343, 388, 305,
344, 389, 306,
345, 390, 307,
346, 391, 308,
347, 392, 309,
348, 393, 310,
349, 394, 311,
350, 395, 312,
351, 396, 313,
352, 397, 314,
353, 398, 315,
354, 399, 316,
355, 400, 317,
356, 401, 318,
357, 402, 319,
358, 403, 320,
359, 404, 321,
360, 405, 322,
361, 406, 323,
362, 407, 324,
363, 408, 325,
364, 409, 326,
365, 410, 327,
366, 411, 328,
367, 412, 329,
368, 413, 330,
369, 414, 331,
370, 415, 332,
371, 416, 333,
372, 417, 334,
373, 418, 335,
374, 419, 336,
375, 420, 337,
376, 421, 338,
377, 422, 339,
378, 423, 340,
379, 424, 341,
380, 425, 342,
381, 426, 343,
382, 427, 344,
383, 428, 345,
256, 429, 346,
257, 430, 347,
258, 431, 348,
259, 432, 349,
260, 433, 350,
261, 434, 351,
262, 435, 352,
263, 436, 353,
264, 437, 354,
265, 438, 355,
266, 439, 356,
267, 440, 357,
268, 441, 358,
269, 442, 359,
270, 443, 360,
271, 444, 361,
272, 445, 362,
273, 446, 363,
274, 447, 364,
275, 448, 365,
276, 449, 366,
277, 450, 367,
278, 451, 368,
279, 452, 369,
280, 453, 370,
281, 454, 371,
282, 455, 372,
283, 456, 373,
284, 457, 374,
285, 458, 375,
286, 459, 376,
287, 460, 377,
288, 461, 378,
289, 462, 379,
290, 463, 380,
291, 464, 381,
292, 465, 382,
293, 466, 383,
159, 457, 384,
160, 458, 385,
161, 459, 386,
162, 460, 387,
163, 461, 388,
164, 462, 389,
165, 463, 390,
166, 464, 391,
167, 465, 392,
168, 466, 393,
169, 467, 394,
170, 468, 395,
171, 469, 396,
172, 470, 397,
173, 471, 398,
174, 472, 399,
175, 473, 400,
176, 474, 401,
177, 475, 402,
178, 476, 403,
179, 477, 404,
180, 478, 405,
181, 479, 406,
182, 480, 407,
183, 481, 408,
184, 482, 409,
185, 483, 410,
186, 484, 411,
187, 485, 412,
188, 486, 413,
189, 487, 414,
190, 488, 415,
191, 489, 416,
192, 490, 417,
193, 491, 418,
194, 492, 419,
195, 493, 420,
196, 494, 421,
197, 495, 422,
198, 496, 423,
199, 497, 424,
200, 498, 425,
201, 499, 426,
202, 500, 427,
203, 501, 428,
204, 502, 429,
205, 503, 430,
206, 504, 431,
207, 505, 432,
208, 506, 433,
209, 507, 434,
210, 508, 435,
211, 509, 436,
212, 510, 437,
213, 511, 438,
214, 384, 439,
215, 385, 440,
216, 386, 441,
217, 387, 442,
218, 388, 443,
219, 389, 444,
220, 390, 445,
221, 391, 446,
222, 392, 447,
223, 393, 448,
224, 394, 449,
225, 395, 450,
226, 396, 451,
227, 397, 452,
228, 398, 453,
229, 399, 454,
230, 400, 455,
231, 401, 456,
232, 402, 457,
233, 403, 458,
234, 404, 459,
235, 405, 460,
236, 406, 461,
237, 407, 462,
238, 408, 463,
239, 409, 464,
240, 410, 465,
241, 411, 466,
242, 412, 467,
243, 413, 468,
244, 414, 469,
245, 415, 470,
246, 416, 471,
247, 417, 472,
248, 418, 473,
249, 419, 474,
250, 420, 475,
251, 421, 476,
252, 422, 477,
253, 423, 478,
254, 424, 479,
255, 425, 480,
128, 426, 481,
129, 427, 482,
130, 428, 483,
131, 429, 484,
132, 430, 485,
133, 431, 486,
134, 432, 487,
135, 433, 488,
136, 434, 489,
137, 435, 490,
138, 436, 491,
139, 437, 492,
140, 438, 493,
141, 439, 494,
142, 440, 495,
143, 441, 496,
144, 442, 497,
145, 443, 498,
146, 444, 499,
147, 445, 500,
148, 446, 501,
149, 447, 502,
150, 448, 503,
151, 449, 504,
152, 450, 505,
153, 451, 506,
154, 452, 507,
155, 453, 508,
156, 454, 509,
157, 455, 510,
158, 456, 511
};
#pragma line 295 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_4_trichk.h" 1
vars_3_45a varinx18A_4096_d[] = {
206, 326, 0,
207, 327, 1,
208, 328, 2,
209, 329, 3,
210, 330, 4,
211, 331, 5,
212, 332, 6,
213, 333, 7,
214, 334, 8,
215, 335, 9,
216, 336, 10,
217, 337, 11,
218, 338, 12,
219, 339, 13,
220, 340, 14,
221, 341, 15,
222, 342, 16,
223, 343, 17,
224, 344, 18,
225, 345, 19,
226, 346, 20,
227, 347, 21,
228, 348, 22,
229, 349, 23,
230, 350, 24,
231, 351, 25,
232, 352, 26,
233, 353, 27,
234, 354, 28,
235, 355, 29,
236, 356, 30,
237, 357, 31,
238, 358, 32,
239, 359, 33,
240, 360, 34,
241, 361, 35,
242, 362, 36,
243, 363, 37,
244, 364, 38,
245, 365, 39,
246, 366, 40,
247, 367, 41,
248, 368, 42,
249, 369, 43,
250, 370, 44,
251, 371, 45,
252, 372, 46,
253, 373, 47,
254, 374, 48,
255, 375, 49,
128, 376, 50,
129, 377, 51,
130, 378, 52,
131, 379, 53,
132, 380, 54,
133, 381, 55,
134, 382, 56,
135, 383, 57,
136, 256, 58,
137, 257, 59,
138, 258, 60,
139, 259, 61,
140, 260, 62,
141, 261, 63,
142, 262, 64,
143, 263, 65,
144, 264, 66,
145, 265, 67,
146, 266, 68,
147, 267, 69,
148, 268, 70,
149, 269, 71,
150, 270, 72,
151, 271, 73,
152, 272, 74,
153, 273, 75,
154, 274, 76,
155, 275, 77,
156, 276, 78,
157, 277, 79,
158, 278, 80,
159, 279, 81,
160, 280, 82,
161, 281, 83,
162, 282, 84,
163, 283, 85,
164, 284, 86,
165, 285, 87,
166, 286, 88,
167, 287, 89,
168, 288, 90,
169, 289, 91,
170, 290, 92,
171, 291, 93,
172, 292, 94,
173, 293, 95,
174, 294, 96,
175, 295, 97,
176, 296, 98,
177, 297, 99,
178, 298, 100,
179, 299, 101,
180, 300, 102,
181, 301, 103,
182, 302, 104,
183, 303, 105,
184, 304, 106,
185, 305, 107,
186, 306, 108,
187, 307, 109,
188, 308, 110,
189, 309, 111,
190, 310, 112,
191, 311, 113,
192, 312, 114,
193, 313, 115,
194, 314, 116,
195, 315, 117,
196, 316, 118,
197, 317, 119,
198, 318, 120,
199, 319, 121,
200, 320, 122,
201, 321, 123,
202, 322, 124,
203, 323, 125,
204, 324, 126,
205, 325, 127,
259, 472, 128,
260, 473, 129,
261, 474, 130,
262, 475, 131,
263, 476, 132,
264, 477, 133,
265, 478, 134,
266, 479, 135,
267, 480, 136,
268, 481, 137,
269, 482, 138,
270, 483, 139,
271, 484, 140,
272, 485, 141,
273, 486, 142,
274, 487, 143,
275, 488, 144,
276, 489, 145,
277, 490, 146,
278, 491, 147,
279, 492, 148,
280, 493, 149,
281, 494, 150,
282, 495, 151,
283, 496, 152,
284, 497, 153,
285, 498, 154,
286, 499, 155,
287, 500, 156,
288, 501, 157,
289, 502, 158,
290, 503, 159,
291, 504, 160,
292, 505, 161,
293, 506, 162,
294, 507, 163,
295, 508, 164,
296, 509, 165,
297, 510, 166,
298, 511, 167,
299, 384, 168,
300, 385, 169,
301, 386, 170,
302, 387, 171,
303, 388, 172,
304, 389, 173,
305, 390, 174,
306, 391, 175,
307, 392, 176,
308, 393, 177,
309, 394, 178,
310, 395, 179,
311, 396, 180,
312, 397, 181,
313, 398, 182,
314, 399, 183,
315, 400, 184,
316, 401, 185,
317, 402, 186,
318, 403, 187,
319, 404, 188,
320, 405, 189,
321, 406, 190,
322, 407, 191,
323, 408, 192,
324, 409, 193,
325, 410, 194,
326, 411, 195,
327, 412, 196,
328, 413, 197,
329, 414, 198,
330, 415, 199,
331, 416, 200,
332, 417, 201,
333, 418, 202,
334, 419, 203,
335, 420, 204,
336, 421, 205,
337, 422, 206,
338, 423, 207,
339, 424, 208,
340, 425, 209,
341, 426, 210,
342, 427, 211,
343, 428, 212,
344, 429, 213,
345, 430, 214,
346, 431, 215,
347, 432, 216,
348, 433, 217,
349, 434, 218,
350, 435, 219,
351, 436, 220,
352, 437, 221,
353, 438, 222,
354, 439, 223,
355, 440, 224,
356, 441, 225,
357, 442, 226,
358, 443, 227,
359, 444, 228,
360, 445, 229,
361, 446, 230,
362, 447, 231,
363, 448, 232,
364, 449, 233,
365, 450, 234,
366, 451, 235,
367, 452, 236,
368, 453, 237,
369, 454, 238,
370, 455, 239,
371, 456, 240,
372, 457, 241,
373, 458, 242,
374, 459, 243,
375, 460, 244,
376, 461, 245,
377, 462, 246,
378, 463, 247,
379, 464, 248,
380, 465, 249,
381, 466, 250,
382, 467, 251,
383, 468, 252,
256, 469, 253,
257, 470, 254,
258, 471, 255,
348, 431, 256,
349, 432, 257,
350, 433, 258,
351, 434, 259,
352, 435, 260,
353, 436, 261,
354, 437, 262,
355, 438, 263,
356, 439, 264,
357, 440, 265,
358, 441, 266,
359, 442, 267,
360, 443, 268,
361, 444, 269,
362, 445, 270,
363, 446, 271,
364, 447, 272,
365, 448, 273,
366, 449, 274,
367, 450, 275,
368, 451, 276,
369, 452, 277,
370, 453, 278,
371, 454, 279,
372, 455, 280,
373, 456, 281,
374, 457, 282,
375, 458, 283,
376, 459, 284,
377, 460, 285,
378, 461, 286,
379, 462, 287,
380, 463, 288,
381, 464, 289,
382, 465, 290,
383, 466, 291,
256, 467, 292,
257, 468, 293,
258, 469, 294,
259, 470, 295,
260, 471, 296,
261, 472, 297,
262, 473, 298,
263, 474, 299,
264, 475, 300,
265, 476, 301,
266, 477, 302,
267, 478, 303,
268, 479, 304,
269, 480, 305,
270, 481, 306,
271, 482, 307,
272, 483, 308,
273, 484, 309,
274, 485, 310,
275, 486, 311,
276, 487, 312,
277, 488, 313,
278, 489, 314,
279, 490, 315,
280, 491, 316,
281, 492, 317,
282, 493, 318,
283, 494, 319,
284, 495, 320,
285, 496, 321,
286, 497, 322,
287, 498, 323,
288, 499, 324,
289, 500, 325,
290, 501, 326,
291, 502, 327,
292, 503, 328,
293, 504, 329,
294, 505, 330,
295, 506, 331,
296, 507, 332,
297, 508, 333,
298, 509, 334,
299, 510, 335,
300, 511, 336,
301, 384, 337,
302, 385, 338,
303, 386, 339,
304, 387, 340,
305, 388, 341,
306, 389, 342,
307, 390, 343,
308, 391, 344,
309, 392, 345,
310, 393, 346,
311, 394, 347,
312, 395, 348,
313, 396, 349,
314, 397, 350,
315, 398, 351,
316, 399, 352,
317, 400, 353,
318, 401, 354,
319, 402, 355,
320, 403, 356,
321, 404, 357,
322, 405, 358,
323, 406, 359,
324, 407, 360,
325, 408, 361,
326, 409, 362,
327, 410, 363,
328, 411, 364,
329, 412, 365,
330, 413, 366,
331, 414, 367,
332, 415, 368,
333, 416, 369,
334, 417, 370,
335, 418, 371,
336, 419, 372,
337, 420, 373,
338, 421, 374,
339, 422, 375,
340, 423, 376,
341, 424, 377,
342, 425, 378,
343, 426, 379,
344, 427, 380,
345, 428, 381,
346, 429, 382,
347, 430, 383,
131, 487, 384,
132, 488, 385,
133, 489, 386,
134, 490, 387,
135, 491, 388,
136, 492, 389,
137, 493, 390,
138, 494, 391,
139, 495, 392,
140, 496, 393,
141, 497, 394,
142, 498, 395,
143, 499, 396,
144, 500, 397,
145, 501, 398,
146, 502, 399,
147, 503, 400,
148, 504, 401,
149, 505, 402,
150, 506, 403,
151, 507, 404,
152, 508, 405,
153, 509, 406,
154, 510, 407,
155, 511, 408,
156, 384, 409,
157, 385, 410,
158, 386, 411,
159, 387, 412,
160, 388, 413,
161, 389, 414,
162, 390, 415,
163, 391, 416,
164, 392, 417,
165, 393, 418,
166, 394, 419,
167, 395, 420,
168, 396, 421,
169, 397, 422,
170, 398, 423,
171, 399, 424,
172, 400, 425,
173, 401, 426,
174, 402, 427,
175, 403, 428,
176, 404, 429,
177, 405, 430,
178, 406, 431,
179, 407, 432,
180, 408, 433,
181, 409, 434,
182, 410, 435,
183, 411, 436,
184, 412, 437,
185, 413, 438,
186, 414, 439,
187, 415, 440,
188, 416, 441,
189, 417, 442,
190, 418, 443,
191, 419, 444,
192, 420, 445,
193, 421, 446,
194, 422, 447,
195, 423, 448,
196, 424, 449,
197, 425, 450,
198, 426, 451,
199, 427, 452,
200, 428, 453,
201, 429, 454,
202, 430, 455,
203, 431, 456,
204, 432, 457,
205, 433, 458,
206, 434, 459,
207, 435, 460,
208, 436, 461,
209, 437, 462,
210, 438, 463,
211, 439, 464,
212, 440, 465,
213, 441, 466,
214, 442, 467,
215, 443, 468,
216, 444, 469,
217, 445, 470,
218, 446, 471,
219, 447, 472,
220, 448, 473,
221, 449, 474,
222, 450, 475,
223, 451, 476,
224, 452, 477,
225, 453, 478,
226, 454, 479,
227, 455, 480,
228, 456, 481,
229, 457, 482,
230, 458, 483,
231, 459, 484,
232, 460, 485,
233, 461, 486,
234, 462, 487,
235, 463, 488,
236, 464, 489,
237, 465, 490,
238, 466, 491,
239, 467, 492,
240, 468, 493,
241, 469, 494,
242, 470, 495,
243, 471, 496,
244, 472, 497,
245, 473, 498,
246, 474, 499,
247, 475, 500,
248, 476, 501,
249, 477, 502,
250, 478, 503,
251, 479, 504,
252, 480, 505,
253, 481, 506,
254, 482, 507,
255, 483, 508,
128, 484, 509,
129, 485, 510,
130, 486, 511
};
#pragma empty_line
vars_3_45a varinx18B_4096_d[] = {
66, 295, 468,
67, 296, 469,
68, 297, 470,
69, 298, 471,
70, 299, 472,
71, 300, 473,
72, 301, 474,
73, 302, 475,
74, 303, 476,
75, 304, 477,
76, 305, 478,
77, 306, 479,
78, 307, 480,
79, 308, 481,
80, 309, 482,
81, 310, 483,
82, 311, 484,
83, 312, 485,
84, 313, 486,
85, 314, 487,
86, 315, 488,
87, 316, 489,
88, 317, 490,
89, 318, 491,
90, 319, 492,
91, 320, 493,
92, 321, 494,
93, 322, 495,
94, 323, 496,
95, 324, 497,
96, 325, 498,
97, 326, 499,
98, 327, 500,
99, 328, 501,
100, 329, 502,
101, 330, 503,
102, 331, 504,
103, 332, 505,
104, 333, 506,
105, 334, 507,
106, 335, 508,
107, 336, 509,
108, 337, 510,
109, 338, 511,
110, 339, 384,
111, 340, 385,
112, 341, 386,
113, 342, 387,
114, 343, 388,
115, 344, 389,
116, 345, 390,
117, 346, 391,
118, 347, 392,
119, 348, 393,
120, 349, 394,
121, 350, 395,
122, 351, 396,
123, 352, 397,
124, 353, 398,
125, 354, 399,
126, 355, 400,
127, 356, 401,
0, 357, 402,
1, 358, 403,
2, 359, 404,
3, 360, 405,
4, 361, 406,
5, 362, 407,
6, 363, 408,
7, 364, 409,
8, 365, 410,
9, 366, 411,
10, 367, 412,
11, 368, 413,
12, 369, 414,
13, 370, 415,
14, 371, 416,
15, 372, 417,
16, 373, 418,
17, 374, 419,
18, 375, 420,
19, 376, 421,
20, 377, 422,
21, 378, 423,
22, 379, 424,
23, 380, 425,
24, 381, 426,
25, 382, 427,
26, 383, 428,
27, 256, 429,
28, 257, 430,
29, 258, 431,
30, 259, 432,
31, 260, 433,
32, 261, 434,
33, 262, 435,
34, 263, 436,
35, 264, 437,
36, 265, 438,
37, 266, 439,
38, 267, 440,
39, 268, 441,
40, 269, 442,
41, 270, 443,
42, 271, 444,
43, 272, 445,
44, 273, 446,
45, 274, 447,
46, 275, 448,
47, 276, 449,
48, 277, 450,
49, 278, 451,
50, 279, 452,
51, 280, 453,
52, 281, 454,
53, 282, 455,
54, 283, 456,
55, 284, 457,
56, 285, 458,
57, 286, 459,
58, 287, 460,
59, 288, 461,
60, 289, 462,
61, 290, 463,
62, 291, 464,
63, 292, 465,
64, 293, 466,
65, 294, 467,
68, 193, 446,
69, 194, 447,
70, 195, 448,
71, 196, 449,
72, 197, 450,
73, 198, 451,
74, 199, 452,
75, 200, 453,
76, 201, 454,
77, 202, 455,
78, 203, 456,
79, 204, 457,
80, 205, 458,
81, 206, 459,
82, 207, 460,
83, 208, 461,
84, 209, 462,
85, 210, 463,
86, 211, 464,
87, 212, 465,
88, 213, 466,
89, 214, 467,
90, 215, 468,
91, 216, 469,
92, 217, 470,
93, 218, 471,
94, 219, 472,
95, 220, 473,
96, 221, 474,
97, 222, 475,
98, 223, 476,
99, 224, 477,
100, 225, 478,
101, 226, 479,
102, 227, 480,
103, 228, 481,
104, 229, 482,
105, 230, 483,
106, 231, 484,
107, 232, 485,
108, 233, 486,
109, 234, 487,
110, 235, 488,
111, 236, 489,
112, 237, 490,
113, 238, 491,
114, 239, 492,
115, 240, 493,
116, 241, 494,
117, 242, 495,
118, 243, 496,
119, 244, 497,
120, 245, 498,
121, 246, 499,
122, 247, 500,
123, 248, 501,
124, 249, 502,
125, 250, 503,
126, 251, 504,
127, 252, 505,
0, 253, 506,
1, 254, 507,
2, 255, 508,
3, 128, 509,
4, 129, 510,
5, 130, 511,
6, 131, 384,
7, 132, 385,
8, 133, 386,
9, 134, 387,
10, 135, 388,
11, 136, 389,
12, 137, 390,
13, 138, 391,
14, 139, 392,
15, 140, 393,
16, 141, 394,
17, 142, 395,
18, 143, 396,
19, 144, 397,
20, 145, 398,
21, 146, 399,
22, 147, 400,
23, 148, 401,
24, 149, 402,
25, 150, 403,
26, 151, 404,
27, 152, 405,
28, 153, 406,
29, 154, 407,
30, 155, 408,
31, 156, 409,
32, 157, 410,
33, 158, 411,
34, 159, 412,
35, 160, 413,
36, 161, 414,
37, 162, 415,
38, 163, 416,
39, 164, 417,
40, 165, 418,
41, 166, 419,
42, 167, 420,
43, 168, 421,
44, 169, 422,
45, 170, 423,
46, 171, 424,
47, 172, 425,
48, 173, 426,
49, 174, 427,
50, 175, 428,
51, 176, 429,
52, 177, 430,
53, 178, 431,
54, 179, 432,
55, 180, 433,
56, 181, 434,
57, 182, 435,
58, 183, 436,
59, 184, 437,
60, 185, 438,
61, 186, 439,
62, 187, 440,
63, 188, 441,
64, 189, 442,
65, 190, 443,
66, 191, 444,
67, 192, 445,
19, 194, 287,
20, 195, 288,
21, 196, 289,
22, 197, 290,
23, 198, 291,
24, 199, 292,
25, 200, 293,
26, 201, 294,
27, 202, 295,
28, 203, 296,
29, 204, 297,
30, 205, 298,
31, 206, 299,
32, 207, 300,
33, 208, 301,
34, 209, 302,
35, 210, 303,
36, 211, 304,
37, 212, 305,
38, 213, 306,
39, 214, 307,
40, 215, 308,
41, 216, 309,
42, 217, 310,
43, 218, 311,
44, 219, 312,
45, 220, 313,
46, 221, 314,
47, 222, 315,
48, 223, 316,
49, 224, 317,
50, 225, 318,
51, 226, 319,
52, 227, 320,
53, 228, 321,
54, 229, 322,
55, 230, 323,
56, 231, 324,
57, 232, 325,
58, 233, 326,
59, 234, 327,
60, 235, 328,
61, 236, 329,
62, 237, 330,
63, 238, 331,
64, 239, 332,
65, 240, 333,
66, 241, 334,
67, 242, 335,
68, 243, 336,
69, 244, 337,
70, 245, 338,
71, 246, 339,
72, 247, 340,
73, 248, 341,
74, 249, 342,
75, 250, 343,
76, 251, 344,
77, 252, 345,
78, 253, 346,
79, 254, 347,
80, 255, 348,
81, 128, 349,
82, 129, 350,
83, 130, 351,
84, 131, 352,
85, 132, 353,
86, 133, 354,
87, 134, 355,
88, 135, 356,
89, 136, 357,
90, 137, 358,
91, 138, 359,
92, 139, 360,
93, 140, 361,
94, 141, 362,
95, 142, 363,
96, 143, 364,
97, 144, 365,
98, 145, 366,
99, 146, 367,
100, 147, 368,
101, 148, 369,
102, 149, 370,
103, 150, 371,
104, 151, 372,
105, 152, 373,
106, 153, 374,
107, 154, 375,
108, 155, 376,
109, 156, 377,
110, 157, 378,
111, 158, 379,
112, 159, 380,
113, 160, 381,
114, 161, 382,
115, 162, 383,
116, 163, 256,
117, 164, 257,
118, 165, 258,
119, 166, 259,
120, 167, 260,
121, 168, 261,
122, 169, 262,
123, 170, 263,
124, 171, 264,
125, 172, 265,
126, 173, 266,
127, 174, 267,
0, 175, 268,
1, 176, 269,
2, 177, 270,
3, 178, 271,
4, 179, 272,
5, 180, 273,
6, 181, 274,
7, 182, 275,
8, 183, 276,
9, 184, 277,
10, 185, 278,
11, 186, 279,
12, 187, 280,
13, 188, 281,
14, 189, 282,
15, 190, 283,
16, 191, 284,
17, 192, 285,
18, 193, 286,
167, 369, 390,
168, 370, 391,
169, 371, 392,
170, 372, 393,
171, 373, 394,
172, 374, 395,
173, 375, 396,
174, 376, 397,
175, 377, 398,
176, 378, 399,
177, 379, 400,
178, 380, 401,
179, 381, 402,
180, 382, 403,
181, 383, 404,
182, 256, 405,
183, 257, 406,
184, 258, 407,
185, 259, 408,
186, 260, 409,
187, 261, 410,
188, 262, 411,
189, 263, 412,
190, 264, 413,
191, 265, 414,
192, 266, 415,
193, 267, 416,
194, 268, 417,
195, 269, 418,
196, 270, 419,
197, 271, 420,
198, 272, 421,
199, 273, 422,
200, 274, 423,
201, 275, 424,
202, 276, 425,
203, 277, 426,
204, 278, 427,
205, 279, 428,
206, 280, 429,
207, 281, 430,
208, 282, 431,
209, 283, 432,
210, 284, 433,
211, 285, 434,
212, 286, 435,
213, 287, 436,
214, 288, 437,
215, 289, 438,
216, 290, 439,
217, 291, 440,
218, 292, 441,
219, 293, 442,
220, 294, 443,
221, 295, 444,
222, 296, 445,
223, 297, 446,
224, 298, 447,
225, 299, 448,
226, 300, 449,
227, 301, 450,
228, 302, 451,
229, 303, 452,
230, 304, 453,
231, 305, 454,
232, 306, 455,
233, 307, 456,
234, 308, 457,
235, 309, 458,
236, 310, 459,
237, 311, 460,
238, 312, 461,
239, 313, 462,
240, 314, 463,
241, 315, 464,
242, 316, 465,
243, 317, 466,
244, 318, 467,
245, 319, 468,
246, 320, 469,
247, 321, 470,
248, 322, 471,
249, 323, 472,
250, 324, 473,
251, 325, 474,
252, 326, 475,
253, 327, 476,
254, 328, 477,
255, 329, 478,
128, 330, 479,
129, 331, 480,
130, 332, 481,
131, 333, 482,
132, 334, 483,
133, 335, 484,
134, 336, 485,
135, 337, 486,
136, 338, 487,
137, 339, 488,
138, 340, 489,
139, 341, 490,
140, 342, 491,
141, 343, 492,
142, 344, 493,
143, 345, 494,
144, 346, 495,
145, 347, 496,
146, 348, 497,
147, 349, 498,
148, 350, 499,
149, 351, 500,
150, 352, 501,
151, 353, 502,
152, 354, 503,
153, 355, 504,
154, 356, 505,
155, 357, 506,
156, 358, 507,
157, 359, 508,
158, 360, 509,
159, 361, 510,
160, 362, 511,
161, 363, 384,
162, 364, 385,
163, 365, 386,
164, 366, 387,
165, 367, 388,
166, 368, 389
};
#pragma line 296 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_5_trichk.h" 1
vars_3_45a varinx18A_4096_e[] = {
0, 0, 0,
1, 1, 1,
2, 2, 2,
3, 3, 3,
4, 4, 4,
5, 5, 5,
6, 6, 6,
7, 7, 7,
8, 8, 8,
9, 9, 9,
10, 10, 10,
11, 11, 11,
12, 12, 12,
13, 13, 13,
14, 14, 14,
15, 15, 15,
16, 16, 16,
17, 17, 17,
18, 18, 18,
19, 19, 19,
20, 20, 20,
21, 21, 21,
22, 22, 22,
23, 23, 23,
24, 24, 24,
25, 25, 25,
26, 26, 26,
27, 27, 27,
28, 28, 28,
29, 29, 29,
30, 30, 30,
31, 31, 31,
32, 32, 32,
33, 33, 33,
34, 34, 34,
35, 35, 35,
36, 36, 36,
37, 37, 37,
38, 38, 38,
39, 39, 39,
40, 40, 40,
41, 41, 41,
42, 42, 42,
43, 43, 43,
44, 44, 44,
45, 45, 45,
46, 46, 46,
47, 47, 47,
48, 48, 48,
49, 49, 49,
50, 50, 50,
51, 51, 51,
52, 52, 52,
53, 53, 53,
54, 54, 54,
55, 55, 55,
56, 56, 56,
57, 57, 57,
58, 58, 58,
59, 59, 59,
60, 60, 60,
61, 61, 61,
62, 62, 62,
63, 63, 63,
64, 64, 64,
65, 65, 65,
66, 66, 66,
67, 67, 67,
68, 68, 68,
69, 69, 69,
70, 70, 70,
71, 71, 71,
72, 72, 72,
73, 73, 73,
74, 74, 74,
75, 75, 75,
76, 76, 76,
77, 77, 77,
78, 78, 78,
79, 79, 79,
80, 80, 80,
81, 81, 81,
82, 82, 82,
83, 83, 83,
84, 84, 84,
85, 85, 85,
86, 86, 86,
87, 87, 87,
88, 88, 88,
89, 89, 89,
90, 90, 90,
91, 91, 91,
92, 92, 92,
93, 93, 93,
94, 94, 94,
95, 95, 95,
96, 96, 96,
97, 97, 97,
98, 98, 98,
99, 99, 99,
100, 100, 100,
101, 101, 101,
102, 102, 102,
103, 103, 103,
104, 104, 104,
105, 105, 105,
106, 106, 106,
107, 107, 107,
108, 108, 108,
109, 109, 109,
110, 110, 110,
111, 111, 111,
112, 112, 112,
113, 113, 113,
114, 114, 114,
115, 115, 115,
116, 116, 116,
117, 117, 117,
118, 118, 118,
119, 119, 119,
120, 120, 120,
121, 121, 121,
122, 122, 122,
123, 123, 123,
124, 124, 124,
125, 125, 125,
126, 126, 126,
127, 127, 127,
128, 128, 128,
129, 129, 129,
130, 130, 130,
131, 131, 131,
132, 132, 132,
133, 133, 133,
134, 134, 134,
135, 135, 135,
136, 136, 136,
137, 137, 137,
138, 138, 138,
139, 139, 139,
140, 140, 140,
141, 141, 141,
142, 142, 142,
143, 143, 143,
144, 144, 144,
145, 145, 145,
146, 146, 146,
147, 147, 147,
148, 148, 148,
149, 149, 149,
150, 150, 150,
151, 151, 151,
152, 152, 152,
153, 153, 153,
154, 154, 154,
155, 155, 155,
156, 156, 156,
157, 157, 157,
158, 158, 158,
159, 159, 159,
160, 160, 160,
161, 161, 161,
162, 162, 162,
163, 163, 163,
164, 164, 164,
165, 165, 165,
166, 166, 166,
167, 167, 167,
168, 168, 168,
169, 169, 169,
170, 170, 170,
171, 171, 171,
172, 172, 172,
173, 173, 173,
174, 174, 174,
175, 175, 175,
176, 176, 176,
177, 177, 177,
178, 178, 178,
179, 179, 179,
180, 180, 180,
181, 181, 181,
182, 182, 182,
183, 183, 183,
184, 184, 184,
185, 185, 185,
186, 186, 186,
187, 187, 187,
188, 188, 188,
189, 189, 189,
190, 190, 190,
191, 191, 191,
192, 192, 192,
193, 193, 193,
194, 194, 194,
195, 195, 195,
196, 196, 196,
197, 197, 197,
198, 198, 198,
199, 199, 199,
200, 200, 200,
201, 201, 201,
202, 202, 202,
203, 203, 203,
204, 204, 204,
205, 205, 205,
206, 206, 206,
207, 207, 207,
208, 208, 208,
209, 209, 209,
210, 210, 210,
211, 211, 211,
212, 212, 212,
213, 213, 213,
214, 214, 214,
215, 215, 215,
216, 216, 216,
217, 217, 217,
218, 218, 218,
219, 219, 219,
220, 220, 220,
221, 221, 221,
222, 222, 222,
223, 223, 223,
224, 224, 224,
225, 225, 225,
226, 226, 226,
227, 227, 227,
228, 228, 228,
229, 229, 229,
230, 230, 230,
231, 231, 231,
232, 232, 232,
233, 233, 233,
234, 234, 234,
235, 235, 235,
236, 236, 236,
237, 237, 237,
238, 238, 238,
239, 239, 239,
240, 240, 240,
241, 241, 241,
242, 242, 242,
243, 243, 243,
244, 244, 244,
245, 245, 245,
246, 246, 246,
247, 247, 247,
248, 248, 248,
249, 249, 249,
250, 250, 250,
251, 251, 251,
252, 252, 252,
253, 253, 253,
254, 254, 254,
255, 255, 255,
256, 256, 256,
257, 257, 257,
258, 258, 258,
259, 259, 259,
260, 260, 260,
261, 261, 261,
262, 262, 262,
263, 263, 263,
264, 264, 264,
265, 265, 265,
266, 266, 266,
267, 267, 267,
268, 268, 268,
269, 269, 269,
270, 270, 270,
271, 271, 271,
272, 272, 272,
273, 273, 273,
274, 274, 274,
275, 275, 275,
276, 276, 276,
277, 277, 277,
278, 278, 278,
279, 279, 279,
280, 280, 280,
281, 281, 281,
282, 282, 282,
283, 283, 283,
284, 284, 284,
285, 285, 285,
286, 286, 286,
287, 287, 287,
288, 288, 288,
289, 289, 289,
290, 290, 290,
291, 291, 291,
292, 292, 292,
293, 293, 293,
294, 294, 294,
295, 295, 295,
296, 296, 296,
297, 297, 297,
298, 298, 298,
299, 299, 299,
300, 300, 300,
301, 301, 301,
302, 302, 302,
303, 303, 303,
304, 304, 304,
305, 305, 305,
306, 306, 306,
307, 307, 307,
308, 308, 308,
309, 309, 309,
310, 310, 310,
311, 311, 311,
312, 312, 312,
313, 313, 313,
314, 314, 314,
315, 315, 315,
316, 316, 316,
317, 317, 317,
318, 318, 318,
319, 319, 319,
320, 320, 320,
321, 321, 321,
322, 322, 322,
323, 323, 323,
324, 324, 324,
325, 325, 325,
326, 326, 326,
327, 327, 327,
328, 328, 328,
329, 329, 329,
330, 330, 330,
331, 331, 331,
332, 332, 332,
333, 333, 333,
334, 334, 334,
335, 335, 335,
336, 336, 336,
337, 337, 337,
338, 338, 338,
339, 339, 339,
340, 340, 340,
341, 341, 341,
342, 342, 342,
343, 343, 343,
344, 344, 344,
345, 345, 345,
346, 346, 346,
347, 347, 347,
348, 348, 348,
349, 349, 349,
350, 350, 350,
351, 351, 351,
352, 352, 352,
353, 353, 353,
354, 354, 354,
355, 355, 355,
356, 356, 356,
357, 357, 357,
358, 358, 358,
359, 359, 359,
360, 360, 360,
361, 361, 361,
362, 362, 362,
363, 363, 363,
364, 364, 364,
365, 365, 365,
366, 366, 366,
367, 367, 367,
368, 368, 368,
369, 369, 369,
370, 370, 370,
371, 371, 371,
372, 372, 372,
373, 373, 373,
374, 374, 374,
375, 375, 375,
376, 376, 376,
377, 377, 377,
378, 378, 378,
379, 379, 379,
380, 380, 380,
381, 381, 381,
382, 382, 382,
383, 383, 383,
384, 384, 384,
385, 385, 385,
386, 386, 386,
387, 387, 387,
388, 388, 388,
389, 389, 389,
390, 390, 390,
391, 391, 391,
392, 392, 392,
393, 393, 393,
394, 394, 394,
395, 395, 395,
396, 396, 396,
397, 397, 397,
398, 398, 398,
399, 399, 399,
400, 400, 400,
401, 401, 401,
402, 402, 402,
403, 403, 403,
404, 404, 404,
405, 405, 405,
406, 406, 406,
407, 407, 407,
408, 408, 408,
409, 409, 409,
410, 410, 410,
411, 411, 411,
412, 412, 412,
413, 413, 413,
414, 414, 414,
415, 415, 415,
416, 416, 416,
417, 417, 417,
418, 418, 418,
419, 419, 419,
420, 420, 420,
421, 421, 421,
422, 422, 422,
423, 423, 423,
424, 424, 424,
425, 425, 425,
426, 426, 426,
427, 427, 427,
428, 428, 428,
429, 429, 429,
430, 430, 430,
431, 431, 431,
432, 432, 432,
433, 433, 433,
434, 434, 434,
435, 435, 435,
436, 436, 436,
437, 437, 437,
438, 438, 438,
439, 439, 439,
440, 440, 440,
441, 441, 441,
442, 442, 442,
443, 443, 443,
444, 444, 444,
445, 445, 445,
446, 446, 446,
447, 447, 447,
448, 448, 448,
449, 449, 449,
450, 450, 450,
451, 451, 451,
452, 452, 452,
453, 453, 453,
454, 454, 454,
455, 455, 455,
456, 456, 456,
457, 457, 457,
458, 458, 458,
459, 459, 459,
460, 460, 460,
461, 461, 461,
462, 462, 462,
463, 463, 463,
464, 464, 464,
465, 465, 465,
466, 466, 466,
467, 467, 467,
468, 468, 468,
469, 469, 469,
470, 470, 470,
471, 471, 471,
472, 472, 472,
473, 473, 473,
474, 474, 474,
475, 475, 475,
476, 476, 476,
477, 477, 477,
478, 478, 478,
479, 479, 479,
480, 480, 480,
481, 481, 481,
482, 482, 482,
483, 483, 483,
484, 484, 484,
485, 485, 485,
486, 486, 486,
487, 487, 487,
488, 488, 488,
489, 489, 489,
490, 490, 490,
491, 491, 491,
492, 492, 492,
493, 493, 493,
494, 494, 494,
495, 495, 495,
496, 496, 496,
497, 497, 497,
498, 498, 498,
499, 499, 499,
500, 500, 500,
501, 501, 501,
502, 502, 502,
503, 503, 503,
504, 504, 504,
505, 505, 505,
506, 506, 506,
507, 507, 507,
508, 508, 508,
509, 509, 509,
510, 510, 510,
511, 511, 511
};
#pragma empty_line
vars_3_45a varinx18B_4096_e[] = {
0, 306, 413,
1, 307, 414,
2, 308, 415,
3, 309, 416,
4, 310, 417,
5, 311, 418,
6, 312, 419,
7, 313, 420,
8, 314, 421,
9, 315, 422,
10, 316, 423,
11, 317, 424,
12, 318, 425,
13, 319, 426,
14, 320, 427,
15, 321, 428,
16, 322, 429,
17, 323, 430,
18, 324, 431,
19, 325, 432,
20, 326, 433,
21, 327, 434,
22, 328, 435,
23, 329, 436,
24, 330, 437,
25, 331, 438,
26, 332, 439,
27, 333, 440,
28, 334, 441,
29, 335, 442,
30, 336, 443,
31, 337, 444,
32, 338, 445,
33, 339, 446,
34, 340, 447,
35, 341, 448,
36, 342, 449,
37, 343, 450,
38, 344, 451,
39, 345, 452,
40, 346, 453,
41, 347, 454,
42, 348, 455,
43, 349, 456,
44, 350, 457,
45, 351, 458,
46, 352, 459,
47, 353, 460,
48, 354, 461,
49, 355, 462,
50, 356, 463,
51, 357, 464,
52, 358, 465,
53, 359, 466,
54, 360, 467,
55, 361, 468,
56, 362, 469,
57, 363, 470,
58, 364, 471,
59, 365, 472,
60, 366, 473,
61, 367, 474,
62, 368, 475,
63, 369, 476,
64, 370, 477,
65, 371, 478,
66, 372, 479,
67, 373, 480,
68, 374, 481,
69, 375, 482,
70, 376, 483,
71, 377, 484,
72, 378, 485,
73, 379, 486,
74, 380, 487,
75, 381, 488,
76, 382, 489,
77, 383, 490,
78, 256, 491,
79, 257, 492,
80, 258, 493,
81, 259, 494,
82, 260, 495,
83, 261, 496,
84, 262, 497,
85, 263, 498,
86, 264, 499,
87, 265, 500,
88, 266, 501,
89, 267, 502,
90, 268, 503,
91, 269, 504,
92, 270, 505,
93, 271, 506,
94, 272, 507,
95, 273, 508,
96, 274, 509,
97, 275, 510,
98, 276, 511,
99, 277, 384,
100, 278, 385,
101, 279, 386,
102, 280, 387,
103, 281, 388,
104, 282, 389,
105, 283, 390,
106, 284, 391,
107, 285, 392,
108, 286, 393,
109, 287, 394,
110, 288, 395,
111, 289, 396,
112, 290, 397,
113, 291, 398,
114, 292, 399,
115, 293, 400,
116, 294, 401,
117, 295, 402,
118, 296, 403,
119, 297, 404,
120, 298, 405,
121, 299, 406,
122, 300, 407,
123, 301, 408,
124, 302, 409,
125, 303, 410,
126, 304, 411,
127, 305, 412,
128, 0, 431,
129, 1, 432,
130, 2, 433,
131, 3, 434,
132, 4, 435,
133, 5, 436,
134, 6, 437,
135, 7, 438,
136, 8, 439,
137, 9, 440,
138, 10, 441,
139, 11, 442,
140, 12, 443,
141, 13, 444,
142, 14, 445,
143, 15, 446,
144, 16, 447,
145, 17, 448,
146, 18, 449,
147, 19, 450,
148, 20, 451,
149, 21, 452,
150, 22, 453,
151, 23, 454,
152, 24, 455,
153, 25, 456,
154, 26, 457,
155, 27, 458,
156, 28, 459,
157, 29, 460,
158, 30, 461,
159, 31, 462,
160, 32, 463,
161, 33, 464,
162, 34, 465,
163, 35, 466,
164, 36, 467,
165, 37, 468,
166, 38, 469,
167, 39, 470,
168, 40, 471,
169, 41, 472,
170, 42, 473,
171, 43, 474,
172, 44, 475,
173, 45, 476,
174, 46, 477,
175, 47, 478,
176, 48, 479,
177, 49, 480,
178, 50, 481,
179, 51, 482,
180, 52, 483,
181, 53, 484,
182, 54, 485,
183, 55, 486,
184, 56, 487,
185, 57, 488,
186, 58, 489,
187, 59, 490,
188, 60, 491,
189, 61, 492,
190, 62, 493,
191, 63, 494,
192, 64, 495,
193, 65, 496,
194, 66, 497,
195, 67, 498,
196, 68, 499,
197, 69, 500,
198, 70, 501,
199, 71, 502,
200, 72, 503,
201, 73, 504,
202, 74, 505,
203, 75, 506,
204, 76, 507,
205, 77, 508,
206, 78, 509,
207, 79, 510,
208, 80, 511,
209, 81, 384,
210, 82, 385,
211, 83, 386,
212, 84, 387,
213, 85, 388,
214, 86, 389,
215, 87, 390,
216, 88, 391,
217, 89, 392,
218, 90, 393,
219, 91, 394,
220, 92, 395,
221, 93, 396,
222, 94, 397,
223, 95, 398,
224, 96, 399,
225, 97, 400,
226, 98, 401,
227, 99, 402,
228, 100, 403,
229, 101, 404,
230, 102, 405,
231, 103, 406,
232, 104, 407,
233, 105, 408,
234, 106, 409,
235, 107, 410,
236, 108, 411,
237, 109, 412,
238, 110, 413,
239, 111, 414,
240, 112, 415,
241, 113, 416,
242, 114, 417,
243, 115, 418,
244, 116, 419,
245, 117, 420,
246, 118, 421,
247, 119, 422,
248, 120, 423,
249, 121, 424,
250, 122, 425,
251, 123, 426,
252, 124, 427,
253, 125, 428,
254, 126, 429,
255, 127, 430,
256, 31, 250,
257, 32, 251,
258, 33, 252,
259, 34, 253,
260, 35, 254,
261, 36, 255,
262, 37, 128,
263, 38, 129,
264, 39, 130,
265, 40, 131,
266, 41, 132,
267, 42, 133,
268, 43, 134,
269, 44, 135,
270, 45, 136,
271, 46, 137,
272, 47, 138,
273, 48, 139,
274, 49, 140,
275, 50, 141,
276, 51, 142,
277, 52, 143,
278, 53, 144,
279, 54, 145,
280, 55, 146,
281, 56, 147,
282, 57, 148,
283, 58, 149,
284, 59, 150,
285, 60, 151,
286, 61, 152,
287, 62, 153,
288, 63, 154,
289, 64, 155,
290, 65, 156,
291, 66, 157,
292, 67, 158,
293, 68, 159,
294, 69, 160,
295, 70, 161,
296, 71, 162,
297, 72, 163,
298, 73, 164,
299, 74, 165,
300, 75, 166,
301, 76, 167,
302, 77, 168,
303, 78, 169,
304, 79, 170,
305, 80, 171,
306, 81, 172,
307, 82, 173,
308, 83, 174,
309, 84, 175,
310, 85, 176,
311, 86, 177,
312, 87, 178,
313, 88, 179,
314, 89, 180,
315, 90, 181,
316, 91, 182,
317, 92, 183,
318, 93, 184,
319, 94, 185,
320, 95, 186,
321, 96, 187,
322, 97, 188,
323, 98, 189,
324, 99, 190,
325, 100, 191,
326, 101, 192,
327, 102, 193,
328, 103, 194,
329, 104, 195,
330, 105, 196,
331, 106, 197,
332, 107, 198,
333, 108, 199,
334, 109, 200,
335, 110, 201,
336, 111, 202,
337, 112, 203,
338, 113, 204,
339, 114, 205,
340, 115, 206,
341, 116, 207,
342, 117, 208,
343, 118, 209,
344, 119, 210,
345, 120, 211,
346, 121, 212,
347, 122, 213,
348, 123, 214,
349, 124, 215,
350, 125, 216,
351, 126, 217,
352, 127, 218,
353, 0, 219,
354, 1, 220,
355, 2, 221,
356, 3, 222,
357, 4, 223,
358, 5, 224,
359, 6, 225,
360, 7, 226,
361, 8, 227,
362, 9, 228,
363, 10, 229,
364, 11, 230,
365, 12, 231,
366, 13, 232,
367, 14, 233,
368, 15, 234,
369, 16, 235,
370, 17, 236,
371, 18, 237,
372, 19, 238,
373, 20, 239,
374, 21, 240,
375, 22, 241,
376, 23, 242,
377, 24, 243,
378, 25, 244,
379, 26, 245,
380, 27, 246,
381, 28, 247,
382, 29, 248,
383, 30, 249,
384, 192, 349,
385, 193, 350,
386, 194, 351,
387, 195, 352,
388, 196, 353,
389, 197, 354,
390, 198, 355,
391, 199, 356,
392, 200, 357,
393, 201, 358,
394, 202, 359,
395, 203, 360,
396, 204, 361,
397, 205, 362,
398, 206, 363,
399, 207, 364,
400, 208, 365,
401, 209, 366,
402, 210, 367,
403, 211, 368,
404, 212, 369,
405, 213, 370,
406, 214, 371,
407, 215, 372,
408, 216, 373,
409, 217, 374,
410, 218, 375,
411, 219, 376,
412, 220, 377,
413, 221, 378,
414, 222, 379,
415, 223, 380,
416, 224, 381,
417, 225, 382,
418, 226, 383,
419, 227, 256,
420, 228, 257,
421, 229, 258,
422, 230, 259,
423, 231, 260,
424, 232, 261,
425, 233, 262,
426, 234, 263,
427, 235, 264,
428, 236, 265,
429, 237, 266,
430, 238, 267,
431, 239, 268,
432, 240, 269,
433, 241, 270,
434, 242, 271,
435, 243, 272,
436, 244, 273,
437, 245, 274,
438, 246, 275,
439, 247, 276,
440, 248, 277,
441, 249, 278,
442, 250, 279,
443, 251, 280,
444, 252, 281,
445, 253, 282,
446, 254, 283,
447, 255, 284,
448, 128, 285,
449, 129, 286,
450, 130, 287,
451, 131, 288,
452, 132, 289,
453, 133, 290,
454, 134, 291,
455, 135, 292,
456, 136, 293,
457, 137, 294,
458, 138, 295,
459, 139, 296,
460, 140, 297,
461, 141, 298,
462, 142, 299,
463, 143, 300,
464, 144, 301,
465, 145, 302,
466, 146, 303,
467, 147, 304,
468, 148, 305,
469, 149, 306,
470, 150, 307,
471, 151, 308,
472, 152, 309,
473, 153, 310,
474, 154, 311,
475, 155, 312,
476, 156, 313,
477, 157, 314,
478, 158, 315,
479, 159, 316,
480, 160, 317,
481, 161, 318,
482, 162, 319,
483, 163, 320,
484, 164, 321,
485, 165, 322,
486, 166, 323,
487, 167, 324,
488, 168, 325,
489, 169, 326,
490, 170, 327,
491, 171, 328,
492, 172, 329,
493, 173, 330,
494, 174, 331,
495, 175, 332,
496, 176, 333,
497, 177, 334,
498, 178, 335,
499, 179, 336,
500, 180, 337,
501, 181, 338,
502, 182, 339,
503, 183, 340,
504, 184, 341,
505, 185, 342,
506, 186, 343,
507, 187, 344,
508, 188, 345,
509, 189, 346,
510, 190, 347,
511, 191, 348
};
#pragma line 297 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_6_trichk.h" 1
vars_3_45a varinx18A_4096_f[] = {
103, 233, 256,
104, 234, 257,
105, 235, 258,
106, 236, 259,
107, 237, 260,
108, 238, 261,
109, 239, 262,
110, 240, 263,
111, 241, 264,
112, 242, 265,
113, 243, 266,
114, 244, 267,
115, 245, 268,
116, 246, 269,
117, 247, 270,
118, 248, 271,
119, 249, 272,
120, 250, 273,
121, 251, 274,
122, 252, 275,
123, 253, 276,
124, 254, 277,
125, 255, 278,
126, 128, 279,
127, 129, 280,
0, 130, 281,
1, 131, 282,
2, 132, 283,
3, 133, 284,
4, 134, 285,
5, 135, 286,
6, 136, 287,
7, 137, 288,
8, 138, 289,
9, 139, 290,
10, 140, 291,
11, 141, 292,
12, 142, 293,
13, 143, 294,
14, 144, 295,
15, 145, 296,
16, 146, 297,
17, 147, 298,
18, 148, 299,
19, 149, 300,
20, 150, 301,
21, 151, 302,
22, 152, 303,
23, 153, 304,
24, 154, 305,
25, 155, 306,
26, 156, 307,
27, 157, 308,
28, 158, 309,
29, 159, 310,
30, 160, 311,
31, 161, 312,
32, 162, 313,
33, 163, 314,
34, 164, 315,
35, 165, 316,
36, 166, 317,
37, 167, 318,
38, 168, 319,
39, 169, 320,
40, 170, 321,
41, 171, 322,
42, 172, 323,
43, 173, 324,
44, 174, 325,
45, 175, 326,
46, 176, 327,
47, 177, 328,
48, 178, 329,
49, 179, 330,
50, 180, 331,
51, 181, 332,
52, 182, 333,
53, 183, 334,
54, 184, 335,
55, 185, 336,
56, 186, 337,
57, 187, 338,
58, 188, 339,
59, 189, 340,
60, 190, 341,
61, 191, 342,
62, 192, 343,
63, 193, 344,
64, 194, 345,
65, 195, 346,
66, 196, 347,
67, 197, 348,
68, 198, 349,
69, 199, 350,
70, 200, 351,
71, 201, 352,
72, 202, 353,
73, 203, 354,
74, 204, 355,
75, 205, 356,
76, 206, 357,
77, 207, 358,
78, 208, 359,
79, 209, 360,
80, 210, 361,
81, 211, 362,
82, 212, 363,
83, 213, 364,
84, 214, 365,
85, 215, 366,
86, 216, 367,
87, 217, 368,
88, 218, 369,
89, 219, 370,
90, 220, 371,
91, 221, 372,
92, 222, 373,
93, 223, 374,
94, 224, 375,
95, 225, 376,
96, 226, 377,
97, 227, 378,
98, 228, 379,
99, 229, 380,
100, 230, 381,
101, 231, 382,
102, 232, 383,
181, 330, 429,
182, 331, 430,
183, 332, 431,
184, 333, 432,
185, 334, 433,
186, 335, 434,
187, 336, 435,
188, 337, 436,
189, 338, 437,
190, 339, 438,
191, 340, 439,
192, 341, 440,
193, 342, 441,
194, 343, 442,
195, 344, 443,
196, 345, 444,
197, 346, 445,
198, 347, 446,
199, 348, 447,
200, 349, 448,
201, 350, 449,
202, 351, 450,
203, 352, 451,
204, 353, 452,
205, 354, 453,
206, 355, 454,
207, 356, 455,
208, 357, 456,
209, 358, 457,
210, 359, 458,
211, 360, 459,
212, 361, 460,
213, 362, 461,
214, 363, 462,
215, 364, 463,
216, 365, 464,
217, 366, 465,
218, 367, 466,
219, 368, 467,
220, 369, 468,
221, 370, 469,
222, 371, 470,
223, 372, 471,
224, 373, 472,
225, 374, 473,
226, 375, 474,
227, 376, 475,
228, 377, 476,
229, 378, 477,
230, 379, 478,
231, 380, 479,
232, 381, 480,
233, 382, 481,
234, 383, 482,
235, 256, 483,
236, 257, 484,
237, 258, 485,
238, 259, 486,
239, 260, 487,
240, 261, 488,
241, 262, 489,
242, 263, 490,
243, 264, 491,
244, 265, 492,
245, 266, 493,
246, 267, 494,
247, 268, 495,
248, 269, 496,
249, 270, 497,
250, 271, 498,
251, 272, 499,
252, 273, 500,
253, 274, 501,
254, 275, 502,
255, 276, 503,
128, 277, 504,
129, 278, 505,
130, 279, 506,
131, 280, 507,
132, 281, 508,
133, 282, 509,
134, 283, 510,
135, 284, 511,
136, 285, 384,
137, 286, 385,
138, 287, 386,
139, 288, 387,
140, 289, 388,
141, 290, 389,
142, 291, 390,
143, 292, 391,
144, 293, 392,
145, 294, 393,
146, 295, 394,
147, 296, 395,
148, 297, 396,
149, 298, 397,
150, 299, 398,
151, 300, 399,
152, 301, 400,
153, 302, 401,
154, 303, 402,
155, 304, 403,
156, 305, 404,
157, 306, 405,
158, 307, 406,
159, 308, 407,
160, 309, 408,
161, 310, 409,
162, 311, 410,
163, 312, 411,
164, 313, 412,
165, 314, 413,
166, 315, 414,
167, 316, 415,
168, 317, 416,
169, 318, 417,
170, 319, 418,
171, 320, 419,
172, 321, 420,
173, 322, 421,
174, 323, 422,
175, 324, 423,
176, 325, 424,
177, 326, 425,
178, 327, 426,
179, 328, 427,
180, 329, 428,
89, 264, 503,
90, 265, 504,
91, 266, 505,
92, 267, 506,
93, 268, 507,
94, 269, 508,
95, 270, 509,
96, 271, 510,
97, 272, 511,
98, 273, 384,
99, 274, 385,
100, 275, 386,
101, 276, 387,
102, 277, 388,
103, 278, 389,
104, 279, 390,
105, 280, 391,
106, 281, 392,
107, 282, 393,
108, 283, 394,
109, 284, 395,
110, 285, 396,
111, 286, 397,
112, 287, 398,
113, 288, 399,
114, 289, 400,
115, 290, 401,
116, 291, 402,
117, 292, 403,
118, 293, 404,
119, 294, 405,
120, 295, 406,
121, 296, 407,
122, 297, 408,
123, 298, 409,
124, 299, 410,
125, 300, 411,
126, 301, 412,
127, 302, 413,
0, 303, 414,
1, 304, 415,
2, 305, 416,
3, 306, 417,
4, 307, 418,
5, 308, 419,
6, 309, 420,
7, 310, 421,
8, 311, 422,
9, 312, 423,
10, 313, 424,
11, 314, 425,
12, 315, 426,
13, 316, 427,
14, 317, 428,
15, 318, 429,
16, 319, 430,
17, 320, 431,
18, 321, 432,
19, 322, 433,
20, 323, 434,
21, 324, 435,
22, 325, 436,
23, 326, 437,
24, 327, 438,
25, 328, 439,
26, 329, 440,
27, 330, 441,
28, 331, 442,
29, 332, 443,
30, 333, 444,
31, 334, 445,
32, 335, 446,
33, 336, 447,
34, 337, 448,
35, 338, 449,
36, 339, 450,
37, 340, 451,
38, 341, 452,
39, 342, 453,
40, 343, 454,
41, 344, 455,
42, 345, 456,
43, 346, 457,
44, 347, 458,
45, 348, 459,
46, 349, 460,
47, 350, 461,
48, 351, 462,
49, 352, 463,
50, 353, 464,
51, 354, 465,
52, 355, 466,
53, 356, 467,
54, 357, 468,
55, 358, 469,
56, 359, 470,
57, 360, 471,
58, 361, 472,
59, 362, 473,
60, 363, 474,
61, 364, 475,
62, 365, 476,
63, 366, 477,
64, 367, 478,
65, 368, 479,
66, 369, 480,
67, 370, 481,
68, 371, 482,
69, 372, 483,
70, 373, 484,
71, 374, 485,
72, 375, 486,
73, 376, 487,
74, 377, 488,
75, 378, 489,
76, 379, 490,
77, 380, 491,
78, 381, 492,
79, 382, 493,
80, 383, 494,
81, 256, 495,
82, 257, 496,
83, 258, 497,
84, 259, 498,
85, 260, 499,
86, 261, 500,
87, 262, 501,
88, 263, 502,
97, 240, 419,
98, 241, 420,
99, 242, 421,
100, 243, 422,
101, 244, 423,
102, 245, 424,
103, 246, 425,
104, 247, 426,
105, 248, 427,
106, 249, 428,
107, 250, 429,
108, 251, 430,
109, 252, 431,
110, 253, 432,
111, 254, 433,
112, 255, 434,
113, 128, 435,
114, 129, 436,
115, 130, 437,
116, 131, 438,
117, 132, 439,
118, 133, 440,
119, 134, 441,
120, 135, 442,
121, 136, 443,
122, 137, 444,
123, 138, 445,
124, 139, 446,
125, 140, 447,
126, 141, 448,
127, 142, 449,
0, 143, 450,
1, 144, 451,
2, 145, 452,
3, 146, 453,
4, 147, 454,
5, 148, 455,
6, 149, 456,
7, 150, 457,
8, 151, 458,
9, 152, 459,
10, 153, 460,
11, 154, 461,
12, 155, 462,
13, 156, 463,
14, 157, 464,
15, 158, 465,
16, 159, 466,
17, 160, 467,
18, 161, 468,
19, 162, 469,
20, 163, 470,
21, 164, 471,
22, 165, 472,
23, 166, 473,
24, 167, 474,
25, 168, 475,
26, 169, 476,
27, 170, 477,
28, 171, 478,
29, 172, 479,
30, 173, 480,
31, 174, 481,
32, 175, 482,
33, 176, 483,
34, 177, 484,
35, 178, 485,
36, 179, 486,
37, 180, 487,
38, 181, 488,
39, 182, 489,
40, 183, 490,
41, 184, 491,
42, 185, 492,
43, 186, 493,
44, 187, 494,
45, 188, 495,
46, 189, 496,
47, 190, 497,
48, 191, 498,
49, 192, 499,
50, 193, 500,
51, 194, 501,
52, 195, 502,
53, 196, 503,
54, 197, 504,
55, 198, 505,
56, 199, 506,
57, 200, 507,
58, 201, 508,
59, 202, 509,
60, 203, 510,
61, 204, 511,
62, 205, 384,
63, 206, 385,
64, 207, 386,
65, 208, 387,
66, 209, 388,
67, 210, 389,
68, 211, 390,
69, 212, 391,
70, 213, 392,
71, 214, 393,
72, 215, 394,
73, 216, 395,
74, 217, 396,
75, 218, 397,
76, 219, 398,
77, 220, 399,
78, 221, 400,
79, 222, 401,
80, 223, 402,
81, 224, 403,
82, 225, 404,
83, 226, 405,
84, 227, 406,
85, 228, 407,
86, 229, 408,
87, 230, 409,
88, 231, 410,
89, 232, 411,
90, 233, 412,
91, 234, 413,
92, 235, 414,
93, 236, 415,
94, 237, 416,
95, 238, 417,
96, 239, 418
};
#pragma empty_line
vars_3_45a varinx18B_4096_f[] = {
115, 158, 0,
116, 159, 1,
117, 160, 2,
118, 161, 3,
119, 162, 4,
120, 163, 5,
121, 164, 6,
122, 165, 7,
123, 166, 8,
124, 167, 9,
125, 168, 10,
126, 169, 11,
127, 170, 12,
0, 171, 13,
1, 172, 14,
2, 173, 15,
3, 174, 16,
4, 175, 17,
5, 176, 18,
6, 177, 19,
7, 178, 20,
8, 179, 21,
9, 180, 22,
10, 181, 23,
11, 182, 24,
12, 183, 25,
13, 184, 26,
14, 185, 27,
15, 186, 28,
16, 187, 29,
17, 188, 30,
18, 189, 31,
19, 190, 32,
20, 191, 33,
21, 192, 34,
22, 193, 35,
23, 194, 36,
24, 195, 37,
25, 196, 38,
26, 197, 39,
27, 198, 40,
28, 199, 41,
29, 200, 42,
30, 201, 43,
31, 202, 44,
32, 203, 45,
33, 204, 46,
34, 205, 47,
35, 206, 48,
36, 207, 49,
37, 208, 50,
38, 209, 51,
39, 210, 52,
40, 211, 53,
41, 212, 54,
42, 213, 55,
43, 214, 56,
44, 215, 57,
45, 216, 58,
46, 217, 59,
47, 218, 60,
48, 219, 61,
49, 220, 62,
50, 221, 63,
51, 222, 64,
52, 223, 65,
53, 224, 66,
54, 225, 67,
55, 226, 68,
56, 227, 69,
57, 228, 70,
58, 229, 71,
59, 230, 72,
60, 231, 73,
61, 232, 74,
62, 233, 75,
63, 234, 76,
64, 235, 77,
65, 236, 78,
66, 237, 79,
67, 238, 80,
68, 239, 81,
69, 240, 82,
70, 241, 83,
71, 242, 84,
72, 243, 85,
73, 244, 86,
74, 245, 87,
75, 246, 88,
76, 247, 89,
77, 248, 90,
78, 249, 91,
79, 250, 92,
80, 251, 93,
81, 252, 94,
82, 253, 95,
83, 254, 96,
84, 255, 97,
85, 128, 98,
86, 129, 99,
87, 130, 100,
88, 131, 101,
89, 132, 102,
90, 133, 103,
91, 134, 104,
92, 135, 105,
93, 136, 106,
94, 137, 107,
95, 138, 108,
96, 139, 109,
97, 140, 110,
98, 141, 111,
99, 142, 112,
100, 143, 113,
101, 144, 114,
102, 145, 115,
103, 146, 116,
104, 147, 117,
105, 148, 118,
106, 149, 119,
107, 150, 120,
108, 151, 121,
109, 152, 122,
110, 153, 123,
111, 154, 124,
112, 155, 125,
113, 156, 126,
114, 157, 127,
187, 358, 128,
188, 359, 129,
189, 360, 130,
190, 361, 131,
191, 362, 132,
192, 363, 133,
193, 364, 134,
194, 365, 135,
195, 366, 136,
196, 367, 137,
197, 368, 138,
198, 369, 139,
199, 370, 140,
200, 371, 141,
201, 372, 142,
202, 373, 143,
203, 374, 144,
204, 375, 145,
205, 376, 146,
206, 377, 147,
207, 378, 148,
208, 379, 149,
209, 380, 150,
210, 381, 151,
211, 382, 152,
212, 383, 153,
213, 256, 154,
214, 257, 155,
215, 258, 156,
216, 259, 157,
217, 260, 158,
218, 261, 159,
219, 262, 160,
220, 263, 161,
221, 264, 162,
222, 265, 163,
223, 266, 164,
224, 267, 165,
225, 268, 166,
226, 269, 167,
227, 270, 168,
228, 271, 169,
229, 272, 170,
230, 273, 171,
231, 274, 172,
232, 275, 173,
233, 276, 174,
234, 277, 175,
235, 278, 176,
236, 279, 177,
237, 280, 178,
238, 281, 179,
239, 282, 180,
240, 283, 181,
241, 284, 182,
242, 285, 183,
243, 286, 184,
244, 287, 185,
245, 288, 186,
246, 289, 187,
247, 290, 188,
248, 291, 189,
249, 292, 190,
250, 293, 191,
251, 294, 192,
252, 295, 193,
253, 296, 194,
254, 297, 195,
255, 298, 196,
128, 299, 197,
129, 300, 198,
130, 301, 199,
131, 302, 200,
132, 303, 201,
133, 304, 202,
134, 305, 203,
135, 306, 204,
136, 307, 205,
137, 308, 206,
138, 309, 207,
139, 310, 208,
140, 311, 209,
141, 312, 210,
142, 313, 211,
143, 314, 212,
144, 315, 213,
145, 316, 214,
146, 317, 215,
147, 318, 216,
148, 319, 217,
149, 320, 218,
150, 321, 219,
151, 322, 220,
152, 323, 221,
153, 324, 222,
154, 325, 223,
155, 326, 224,
156, 327, 225,
157, 328, 226,
158, 329, 227,
159, 330, 228,
160, 331, 229,
161, 332, 230,
162, 333, 231,
163, 334, 232,
164, 335, 233,
165, 336, 234,
166, 337, 235,
167, 338, 236,
168, 339, 237,
169, 340, 238,
170, 341, 239,
171, 342, 240,
172, 343, 241,
173, 344, 242,
174, 345, 243,
175, 346, 244,
176, 347, 245,
177, 348, 246,
178, 349, 247,
179, 350, 248,
180, 351, 249,
181, 352, 250,
182, 353, 251,
183, 354, 252,
184, 355, 253,
185, 356, 254,
186, 357, 255,
257, 453, 256,
258, 454, 257,
259, 455, 258,
260, 456, 259,
261, 457, 260,
262, 458, 261,
263, 459, 262,
264, 460, 263,
265, 461, 264,
266, 462, 265,
267, 463, 266,
268, 464, 267,
269, 465, 268,
270, 466, 269,
271, 467, 270,
272, 468, 271,
273, 469, 272,
274, 470, 273,
275, 471, 274,
276, 472, 275,
277, 473, 276,
278, 474, 277,
279, 475, 278,
280, 476, 279,
281, 477, 280,
282, 478, 281,
283, 479, 282,
284, 480, 283,
285, 481, 284,
286, 482, 285,
287, 483, 286,
288, 484, 287,
289, 485, 288,
290, 486, 289,
291, 487, 290,
292, 488, 291,
293, 489, 292,
294, 490, 293,
295, 491, 294,
296, 492, 295,
297, 493, 296,
298, 494, 297,
299, 495, 298,
300, 496, 299,
301, 497, 300,
302, 498, 301,
303, 499, 302,
304, 500, 303,
305, 501, 304,
306, 502, 305,
307, 503, 306,
308, 504, 307,
309, 505, 308,
310, 506, 309,
311, 507, 310,
312, 508, 311,
313, 509, 312,
314, 510, 313,
315, 511, 314,
316, 384, 315,
317, 385, 316,
318, 386, 317,
319, 387, 318,
320, 388, 319,
321, 389, 320,
322, 390, 321,
323, 391, 322,
324, 392, 323,
325, 393, 324,
326, 394, 325,
327, 395, 326,
328, 396, 327,
329, 397, 328,
330, 398, 329,
331, 399, 330,
332, 400, 331,
333, 401, 332,
334, 402, 333,
335, 403, 334,
336, 404, 335,
337, 405, 336,
338, 406, 337,
339, 407, 338,
340, 408, 339,
341, 409, 340,
342, 410, 341,
343, 411, 342,
344, 412, 343,
345, 413, 344,
346, 414, 345,
347, 415, 346,
348, 416, 347,
349, 417, 348,
350, 418, 349,
351, 419, 350,
352, 420, 351,
353, 421, 352,
354, 422, 353,
355, 423, 354,
356, 424, 355,
357, 425, 356,
358, 426, 357,
359, 427, 358,
360, 428, 359,
361, 429, 360,
362, 430, 361,
363, 431, 362,
364, 432, 363,
365, 433, 364,
366, 434, 365,
367, 435, 366,
368, 436, 367,
369, 437, 368,
370, 438, 369,
371, 439, 370,
372, 440, 371,
373, 441, 372,
374, 442, 373,
375, 443, 374,
376, 444, 375,
377, 445, 376,
378, 446, 377,
379, 447, 378,
380, 448, 379,
381, 449, 380,
382, 450, 381,
383, 451, 382,
256, 452, 383,
94, 483, 384,
95, 484, 385,
96, 485, 386,
97, 486, 387,
98, 487, 388,
99, 488, 389,
100, 489, 390,
101, 490, 391,
102, 491, 392,
103, 492, 393,
104, 493, 394,
105, 494, 395,
106, 495, 396,
107, 496, 397,
108, 497, 398,
109, 498, 399,
110, 499, 400,
111, 500, 401,
112, 501, 402,
113, 502, 403,
114, 503, 404,
115, 504, 405,
116, 505, 406,
117, 506, 407,
118, 507, 408,
119, 508, 409,
120, 509, 410,
121, 510, 411,
122, 511, 412,
123, 384, 413,
124, 385, 414,
125, 386, 415,
126, 387, 416,
127, 388, 417,
0, 389, 418,
1, 390, 419,
2, 391, 420,
3, 392, 421,
4, 393, 422,
5, 394, 423,
6, 395, 424,
7, 396, 425,
8, 397, 426,
9, 398, 427,
10, 399, 428,
11, 400, 429,
12, 401, 430,
13, 402, 431,
14, 403, 432,
15, 404, 433,
16, 405, 434,
17, 406, 435,
18, 407, 436,
19, 408, 437,
20, 409, 438,
21, 410, 439,
22, 411, 440,
23, 412, 441,
24, 413, 442,
25, 414, 443,
26, 415, 444,
27, 416, 445,
28, 417, 446,
29, 418, 447,
30, 419, 448,
31, 420, 449,
32, 421, 450,
33, 422, 451,
34, 423, 452,
35, 424, 453,
36, 425, 454,
37, 426, 455,
38, 427, 456,
39, 428, 457,
40, 429, 458,
41, 430, 459,
42, 431, 460,
43, 432, 461,
44, 433, 462,
45, 434, 463,
46, 435, 464,
47, 436, 465,
48, 437, 466,
49, 438, 467,
50, 439, 468,
51, 440, 469,
52, 441, 470,
53, 442, 471,
54, 443, 472,
55, 444, 473,
56, 445, 474,
57, 446, 475,
58, 447, 476,
59, 448, 477,
60, 449, 478,
61, 450, 479,
62, 451, 480,
63, 452, 481,
64, 453, 482,
65, 454, 483,
66, 455, 484,
67, 456, 485,
68, 457, 486,
69, 458, 487,
70, 459, 488,
71, 460, 489,
72, 461, 490,
73, 462, 491,
74, 463, 492,
75, 464, 493,
76, 465, 494,
77, 466, 495,
78, 467, 496,
79, 468, 497,
80, 469, 498,
81, 470, 499,
82, 471, 500,
83, 472, 501,
84, 473, 502,
85, 474, 503,
86, 475, 504,
87, 476, 505,
88, 477, 506,
89, 478, 507,
90, 479, 508,
91, 480, 509,
92, 481, 510,
93, 482, 511
};
#pragma line 298 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma line 1 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/ldpc4096_4_5_trichk.h" 1
#pragma empty_line
vars_3_45a varinx3_4096_45[] = {
0, 0, 400,
1, 1, 401,
2, 2, 402,
3, 3, 403,
4, 4, 404,
5, 5, 405,
6, 6, 406,
7, 7, 407,
8, 8, 408,
9, 9, 409,
10, 10, 410,
11, 11, 411,
12, 12, 412,
13, 13, 413,
14, 14, 414,
15, 15, 415,
16, 16, 416,
17, 17, 417,
18, 18, 418,
19, 19, 419,
20, 20, 420,
21, 21, 421,
22, 22, 422,
23, 23, 423,
24, 24, 424,
25, 25, 425,
26, 26, 426,
27, 27, 427,
28, 28, 428,
29, 29, 429,
30, 30, 430,
31, 31, 431,
32, 32, 432,
33, 33, 433,
34, 34, 434,
35, 35, 435,
36, 36, 436,
37, 37, 437,
38, 38, 438,
39, 39, 439,
40, 40, 440,
41, 41, 441,
42, 42, 442,
43, 43, 443,
44, 44, 444,
45, 45, 445,
46, 46, 446,
47, 47, 447,
48, 48, 448,
49, 49, 449,
50, 50, 450,
51, 51, 451,
52, 52, 452,
53, 53, 453,
54, 54, 454,
55, 55, 455,
56, 56, 456,
57, 57, 457,
58, 58, 458,
59, 59, 459,
60, 60, 460,
61, 61, 461,
62, 62, 462,
63, 63, 463,
64, 64, 464,
65, 65, 465,
66, 66, 466,
67, 67, 467,
68, 68, 468,
69, 69, 469,
70, 70, 470,
71, 71, 471,
72, 72, 472,
73, 73, 473,
74, 74, 474,
75, 75, 475,
76, 76, 476,
77, 77, 477,
78, 78, 478,
79, 79, 479,
80, 80, 480,
81, 81, 481,
82, 82, 482,
83, 83, 483,
84, 84, 484,
85, 85, 485,
86, 86, 486,
87, 87, 487,
88, 88, 488,
89, 89, 489,
90, 90, 490,
91, 91, 491,
92, 92, 492,
93, 93, 493,
94, 94, 494,
95, 95, 495,
96, 96, 496,
97, 97, 497,
98, 98, 498,
99, 99, 499,
100, 100, 500,
101, 101, 501,
102, 102, 502,
103, 103, 503,
104, 104, 504,
105, 105, 505,
106, 106, 506,
107, 107, 507,
108, 108, 508,
109, 109, 509,
110, 110, 510,
111, 111, 511,
112, 112, 384,
113, 113, 385,
114, 114, 386,
115, 115, 387,
116, 116, 388,
117, 117, 389,
118, 118, 390,
119, 119, 391,
120, 120, 392,
121, 121, 393,
122, 122, 394,
123, 123, 395,
124, 124, 396,
125, 125, 397,
126, 126, 398,
127, 127, 399,
128, 0, 128,
129, 1, 129,
130, 2, 130,
131, 3, 131,
132, 4, 132,
133, 5, 133,
134, 6, 134,
135, 7, 135,
136, 8, 136,
137, 9, 137,
138, 10, 138,
139, 11, 139,
140, 12, 140,
141, 13, 141,
142, 14, 142,
143, 15, 143,
144, 16, 144,
145, 17, 145,
146, 18, 146,
147, 19, 147,
148, 20, 148,
149, 21, 149,
150, 22, 150,
151, 23, 151,
152, 24, 152,
153, 25, 153,
154, 26, 154,
155, 27, 155,
156, 28, 156,
157, 29, 157,
158, 30, 158,
159, 31, 159,
160, 32, 160,
161, 33, 161,
162, 34, 162,
163, 35, 163,
164, 36, 164,
165, 37, 165,
166, 38, 166,
167, 39, 167,
168, 40, 168,
169, 41, 169,
170, 42, 170,
171, 43, 171,
172, 44, 172,
173, 45, 173,
174, 46, 174,
175, 47, 175,
176, 48, 176,
177, 49, 177,
178, 50, 178,
179, 51, 179,
180, 52, 180,
181, 53, 181,
182, 54, 182,
183, 55, 183,
184, 56, 184,
185, 57, 185,
186, 58, 186,
187, 59, 187,
188, 60, 188,
189, 61, 189,
190, 62, 190,
191, 63, 191,
192, 64, 192,
193, 65, 193,
194, 66, 194,
195, 67, 195,
196, 68, 196,
197, 69, 197,
198, 70, 198,
199, 71, 199,
200, 72, 200,
201, 73, 201,
202, 74, 202,
203, 75, 203,
204, 76, 204,
205, 77, 205,
206, 78, 206,
207, 79, 207,
208, 80, 208,
209, 81, 209,
210, 82, 210,
211, 83, 211,
212, 84, 212,
213, 85, 213,
214, 86, 214,
215, 87, 215,
216, 88, 216,
217, 89, 217,
218, 90, 218,
219, 91, 219,
220, 92, 220,
221, 93, 221,
222, 94, 222,
223, 95, 223,
224, 96, 224,
225, 97, 225,
226, 98, 226,
227, 99, 227,
228, 100, 228,
229, 101, 229,
230, 102, 230,
231, 103, 231,
232, 104, 232,
233, 105, 233,
234, 106, 234,
235, 107, 235,
236, 108, 236,
237, 109, 237,
238, 110, 238,
239, 111, 239,
240, 112, 240,
241, 113, 241,
242, 114, 242,
243, 115, 243,
244, 116, 244,
245, 117, 245,
246, 118, 246,
247, 119, 247,
248, 120, 248,
249, 121, 249,
250, 122, 250,
251, 123, 251,
252, 124, 252,
253, 125, 253,
254, 126, 254,
255, 127, 255,
256, 128, 256,
257, 129, 257,
258, 130, 258,
259, 131, 259,
260, 132, 260,
261, 133, 261,
262, 134, 262,
263, 135, 263,
264, 136, 264,
265, 137, 265,
266, 138, 266,
267, 139, 267,
268, 140, 268,
269, 141, 269,
270, 142, 270,
271, 143, 271,
272, 144, 272,
273, 145, 273,
274, 146, 274,
275, 147, 275,
276, 148, 276,
277, 149, 277,
278, 150, 278,
279, 151, 279,
280, 152, 280,
281, 153, 281,
282, 154, 282,
283, 155, 283,
284, 156, 284,
285, 157, 285,
286, 158, 286,
287, 159, 287,
288, 160, 288,
289, 161, 289,
290, 162, 290,
291, 163, 291,
292, 164, 292,
293, 165, 293,
294, 166, 294,
295, 167, 295,
296, 168, 296,
297, 169, 297,
298, 170, 298,
299, 171, 299,
300, 172, 300,
301, 173, 301,
302, 174, 302,
303, 175, 303,
304, 176, 304,
305, 177, 305,
306, 178, 306,
307, 179, 307,
308, 180, 308,
309, 181, 309,
310, 182, 310,
311, 183, 311,
312, 184, 312,
313, 185, 313,
314, 186, 314,
315, 187, 315,
316, 188, 316,
317, 189, 317,
318, 190, 318,
319, 191, 319,
320, 192, 320,
321, 193, 321,
322, 194, 322,
323, 195, 323,
324, 196, 324,
325, 197, 325,
326, 198, 326,
327, 199, 327,
328, 200, 328,
329, 201, 329,
330, 202, 330,
331, 203, 331,
332, 204, 332,
333, 205, 333,
334, 206, 334,
335, 207, 335,
336, 208, 336,
337, 209, 337,
338, 210, 338,
339, 211, 339,
340, 212, 340,
341, 213, 341,
342, 214, 342,
343, 215, 343,
344, 216, 344,
345, 217, 345,
346, 218, 346,
347, 219, 347,
348, 220, 348,
349, 221, 349,
350, 222, 350,
351, 223, 351,
352, 224, 352,
353, 225, 353,
354, 226, 354,
355, 227, 355,
356, 228, 356,
357, 229, 357,
358, 230, 358,
359, 231, 359,
360, 232, 360,
361, 233, 361,
362, 234, 362,
363, 235, 363,
364, 236, 364,
365, 237, 365,
366, 238, 366,
367, 239, 367,
368, 240, 368,
369, 241, 369,
370, 242, 370,
371, 243, 371,
372, 244, 372,
373, 245, 373,
374, 246, 374,
375, 247, 375,
376, 248, 376,
377, 249, 377,
378, 250, 378,
379, 251, 379,
380, 252, 380,
381, 253, 381,
382, 254, 382,
383, 255, 383,
384, 256, 384,
385, 257, 385,
386, 258, 386,
387, 259, 387,
388, 260, 388,
389, 261, 389,
390, 262, 390,
391, 263, 391,
392, 264, 392,
393, 265, 393,
394, 266, 394,
395, 267, 395,
396, 268, 396,
397, 269, 397,
398, 270, 398,
399, 271, 399,
400, 272, 400,
401, 273, 401,
402, 274, 402,
403, 275, 403,
404, 276, 404,
405, 277, 405,
406, 278, 406,
407, 279, 407,
408, 280, 408,
409, 281, 409,
410, 282, 410,
411, 283, 411,
412, 284, 412,
413, 285, 413,
414, 286, 414,
415, 287, 415,
416, 288, 416,
417, 289, 417,
418, 290, 418,
419, 291, 419,
420, 292, 420,
421, 293, 421,
422, 294, 422,
423, 295, 423,
424, 296, 424,
425, 297, 425,
426, 298, 426,
427, 299, 427,
428, 300, 428,
429, 301, 429,
430, 302, 430,
431, 303, 431,
432, 304, 432,
433, 305, 433,
434, 306, 434,
435, 307, 435,
436, 308, 436,
437, 309, 437,
438, 310, 438,
439, 311, 439,
440, 312, 440,
441, 313, 441,
442, 314, 442,
443, 315, 443,
444, 316, 444,
445, 317, 445,
446, 318, 446,
447, 319, 447,
448, 320, 448,
449, 321, 449,
450, 322, 450,
451, 323, 451,
452, 324, 452,
453, 325, 453,
454, 326, 454,
455, 327, 455,
456, 328, 456,
457, 329, 457,
458, 330, 458,
459, 331, 459,
460, 332, 460,
461, 333, 461,
462, 334, 462,
463, 335, 463,
464, 336, 464,
465, 337, 465,
466, 338, 466,
467, 339, 467,
468, 340, 468,
469, 341, 469,
470, 342, 470,
471, 343, 471,
472, 344, 472,
473, 345, 473,
474, 346, 474,
475, 347, 475,
476, 348, 476,
477, 349, 477,
478, 350, 478,
479, 351, 479,
480, 352, 480,
481, 353, 481,
482, 354, 482,
483, 355, 483,
484, 356, 484,
485, 357, 485,
486, 358, 486,
487, 359, 487,
488, 360, 488,
489, 361, 489,
490, 362, 490,
491, 363, 491,
492, 364, 492,
493, 365, 493,
494, 366, 494,
495, 367, 495,
496, 368, 496,
497, 369, 497,
498, 370, 498,
499, 371, 499,
500, 372, 500,
501, 373, 501,
502, 374, 502,
503, 375, 503,
504, 376, 504,
505, 377, 505,
506, 378, 506,
507, 379, 507,
508, 380, 508,
509, 381, 509,
510, 382, 510,
511, 383, 511
};
#pragma line 299 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp" 2
#pragma empty_line
#pragma empty_line
#pragma empty_line
void calc_m(tab_int nCodeM, bool prev);
void calc_m_23(tab_int nCodeM, bool prev);
void calc_m_12(tab_int nCodeM, bool prev);
#pragma empty_line
#pragma empty_line
#pragma empty_line
void mcalcB(short num, short *ptab, short *ltab, short *atab);
void mcalcC(short num);
void mcalcD(short num);
void mcalcE(short num);
void mcalcF(short num);
void mcalcG(short num);
#pragma empty_line
#pragma empty_line
#pragma empty_line
void calc_ma(short num,short num_1, short num_2, short num_3);
void calc_n(tab_int nCodeN);
void calc_n_23(tab_int nCodeN);
void calc_n_12(tab_int nCodeN);
#pragma empty_line
void write_pcHat( bool *ppbhat0, bool *ppbhat1, bool *ppbhat2, bool *ppbhat3,
      bool *ppbhat4, bool *ppbhat5, bool *ppbhat6, bool *ppbhat7 );
#pragma empty_line
#pragma empty_line
void HLSLdpcLogDecScaledMin(int8_t pR[2048], int8_t pR1[2048], int8_t pR2[2048], int8_t pR3[2048], int8_t pR4[1024], int8_t pR5[1024],
             int8_t pR6[1024], int8_t pR7[1024], int8_t pR8[1024], int8_t pR9[1024], int8_t pR10[1024],
            bool pbhat0[2048], bool pbhat1[2048], bool pbhat2[1024], bool pbhat3[1024],
         bool pbhat4[1024], bool pbhat5[1024], bool pbhat6[1024], bool pbhat7[1024], int *cnt, tab_int nR_M,
            tab_int etaIndexM_M, tab_int pCodeM, tab_int pMaxIterations, int8_t *itt_num,
         tab_int numbits, volatile bool *mux)
#pragma empty_line
{
#pragma empty_line
#pragma HLS data_pack variable=SpEtaPrev
#pragma HLS data_pack variable=SpEtaPrevC
#pragma HLS data_pack variable=SpEtaPrevA
#pragma HLS data_pack variable=SpEtaPrevAa
#pragma HLS data_pack variable=SpEtaPrevAb
#pragma HLS data_pack variable=SpEtaPrevAc
#pragma HLS data_pack variable=SpEtaPrevAd
#pragma HLS data_pack variable=SpEtaPrevB
#pragma HLS data_pack variable=SpEtaPrevBa
#pragma HLS data_pack variable=SpEtaPrevBb
#pragma HLS data_pack variable=SpEtaPrevBc
#pragma HLS data_pack variable=SpEtaPrevBd
#pragma HLS data_pack variable=SpEtaPrevD
#pragma HLS data_pack variable=SpEtaPrevDa
#pragma HLS data_pack variable=SpEtaPrevDb
#pragma HLS data_pack variable=SpEtaPrevDc
#pragma HLS data_pack variable=SpEtaPrevDd
#pragma HLS data_pack variable=SpEtaPrevE
#pragma HLS data_pack variable=SpEtaPrevEa
#pragma HLS data_pack variable=SpEtaPrevEb
#pragma HLS data_pack variable=SpEtaPrevEc
#pragma HLS data_pack variable=SpEtaPrevEd
#pragma empty_line
#pragma HLS data_pack variable=varinx3_1024_12
#pragma empty_line
#pragma HLS data_pack variable=varinx6A_1024_a
#pragma HLS data_pack variable=varinx6B_1024_a
#pragma HLS data_pack variable=varinx6A_1024_b
#pragma HLS data_pack variable=varinx6B_1024_b
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma HLS data_pack variable=varinx3_1024_23
#pragma empty_line
#pragma HLS data_pack variable=varinx10A_1024_a
#pragma HLS data_pack variable=varinx10B_1024_a
#pragma HLS data_pack variable=varinx10A_1024_b
#pragma HLS data_pack variable=varinx10B_1024_b
#pragma HLS data_pack variable=varinx10A_1024_c
#pragma HLS data_pack variable=varinx10B_1024_c
#pragma empty_line
#pragma HLS data_pack variable=varinx3_1024_45
#pragma empty_line
#pragma HLS data_pack variable=varinx18A_1024_a
#pragma HLS data_pack variable=varinx18B_1024_a
#pragma HLS data_pack variable=varinx18A_1024_b
#pragma HLS data_pack variable=varinx18B_1024_b
#pragma HLS data_pack variable=varinx18A_1024_c
#pragma HLS data_pack variable=varinx18B_1024_c
#pragma HLS data_pack variable=varinx18A_1024_d
#pragma HLS data_pack variable=varinx18B_1024_d
#pragma HLS data_pack variable=varinx18A_1024_e
#pragma HLS data_pack variable=varinx18B_1024_e
#pragma HLS data_pack variable=varinx18A_1024_f
#pragma HLS data_pack variable=varinx18B_1024_f
#pragma empty_line
#pragma HLS data_pack variable=varinx3_4096_12
#pragma empty_line
#pragma HLS data_pack variable=varinx6A_4096_a
#pragma HLS data_pack variable=varinx6B_4096_a
#pragma HLS data_pack variable=varinx6A_4096_b
#pragma HLS data_pack variable=varinx6B_4096_b
#pragma empty_line
#pragma empty_line
#pragma HLS data_pack variable=varinx3_4096_23
#pragma empty_line
#pragma HLS data_pack variable=varinx10A_4096_a
#pragma HLS data_pack variable=varinx10B_4096_a
#pragma HLS data_pack variable=varinx10A_4096_b
#pragma HLS data_pack variable=varinx10B_4096_b
#pragma HLS data_pack variable=varinx10A_4096_c
#pragma HLS data_pack variable=varinx10B_4096_c
#pragma empty_line
#pragma HLS data_pack variable=varinx3_4096_45
#pragma empty_line
#pragma HLS data_pack variable=varinx18A_4096_a
#pragma HLS data_pack variable=varinx18B_4096_a
#pragma HLS data_pack variable=varinx18A_4096_b
#pragma HLS data_pack variable=varinx18B_4096_b
#pragma HLS data_pack variable=varinx18A_4096_c
#pragma HLS data_pack variable=varinx18B_4096_c
#pragma HLS data_pack variable=varinx18A_4096_d
#pragma HLS data_pack variable=varinx18B_4096_d
#pragma HLS data_pack variable=varinx18A_4096_e
#pragma HLS data_pack variable=varinx18B_4096_e
#pragma HLS data_pack variable=varinx18A_4096_f
#pragma HLS data_pack variable=varinx18B_4096_f
#pragma empty_line
#pragma empty_line
 numb = numbits;
#pragma empty_line
 if (numbits == 1280)
 {
  rows = 128;
  cols = 128;
  bitsperblock = 128;
 }
 else if (numbits == 5120)
 {
  rows = 512;
  cols = 512;
  bitsperblock = 512;
 }
 else if (numbits == 1536)
 {
  rows = 256;
  cols = 256;
  bitsperblock = 192;
 }
 else if (numbits == 6144)
 {
  rows = 1024;
  cols = 1024;
  bitsperblock = 768;
 }
 else if (numbits == 2048)
 {
  rows = 512;
  cols = 512;
  bitsperblock = 256;
 }
 else if (numbits == 8192)
 {
  rows = 2048;
  cols = 2048;
  bitsperblock = 1024;
 }
 else
 {
  rows = 128;
  cols = 128;
  bitsperblock = 128;
 }
#pragma empty_line
#pragma empty_line
 tab_int nCodeN = nR_M;
 tab_int nCodeN11 = cols;
 tab_int nCodeM = pCodeM;
 tab_int nMaxIterations = pMaxIterations;
 tab_int nLenEta = etaIndexM_M - pCodeM;
 short pos = 0, loop = 0;
 int out_cnt, dinx;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 for (int inx=0; inx < cols; inx++)
 {
#pragma empty_line
#pragma empty_line
  if (inx < 1024)
  {
   pLambda0[inx] = pR[inx];
   pLambda1[inx] = pR1[inx];
   pLambda2[inx] = pR2[inx];
   pLambda3[inx] = pR3[inx];
   pLambda4[inx] = pR4[inx];
#pragma empty_line
#pragma empty_line
   Lam_buf2[inx] = pR2[inx];
   Lam_buf4[inx] = pR4[inx];
   Lam_buf4a[inx] = pR4[inx];
#pragma empty_line
   Lam_bufAa[inx] = pR[inx];
   Lam_bufAb[inx] = pR[inx];
   Lam_bufAc[inx] = pR[inx];
   Lam_bufA1[inx] = pR1[inx];
   Lam_bufA2a[inx] = pR2[inx];
   Lam_bufA2b[inx] = pR2[inx];
   Lam_bufA2c[inx] = pR2[inx];
   Lam_bufA3[inx] = pR3[inx];
   Lam_buf4a[inx] = pR4[inx];
   Lam_bufA4a[inx] = pR4[inx];
   Lam_bufA4b[inx] = pR4[inx];
   Lam_bufA4c[inx] = pR4[inx];
#pragma empty_line
   Lam_bufB[inx] = pR[inx];
   Lam_bufB1a[inx] = pR1[inx];
   Lam_bufB1b[inx] = pR1[inx];
   Lam_bufB1c[inx] = pR1[inx];
   Lam_bufB2[inx] = pR2[inx];
   Lam_bufB3a[inx] = pR3[inx];
   Lam_bufB3b[inx] = pR3[inx];
   Lam_bufB3c[inx] = pR3[inx];
   Lam_bufB4[inx] = pR4[inx];
#pragma empty_line
   if ( (numbits == 2048) || (numbits == 8192))
   {
    pLambda4[inx] = blk_val;
    Lam_buf4[inx] = blk_val;
    Lam_buf4a[inx] = blk_val;
    Lam_bufA4a[inx] = blk_val;
    Lam_bufA4b[inx] = blk_val;
    Lam_bufA4c[inx] = blk_val;
    Lam_bufB4[inx] = blk_val;
   }
#pragma empty_line
#pragma empty_line
   prLamB_buf[inx] = 0;
   prLamC_buf[inx] = 0;
   prLamC_bufa[inx] = 0;
   prLamC_bufb[inx] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
   prLam2B_buf[inx] = 0;
   prLam2C_buf[inx] = 0;
   prLam2C_bufa[inx] = 0;
   prLam2C_bufb[inx] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
   prLamB_buf1[inx] = 0;
   prLamB_buf1a[inx] = 0;
   prLamB_buf1b[inx] = 0;
   prLamC_buf1[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam2B_buf1[inx] = 0;
   prLam2B_buf1a[inx] = 0;
   prLam2B_buf1b[inx] = 0;
   prLam2C_buf1[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam_buf2[inx] = 0;
   prLamB_buf2[inx] = 0;
   prLamC_buf2[inx] = 0;
   prLamC_buf2a[inx] = 0;
   prLamC_buf2b[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam2_buf2[inx] = 0;
   prLam2B_buf2[inx] = 0;
   prLam2C_buf2[inx] = 0;
   prLam2C_buf2a[inx] = 0;
   prLam2C_buf2b[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLamB_buf3[inx] = 0;
   prLamB_buf3a[inx] = 0;
   prLamB_buf3b[inx] = 0;
   prLamC_buf3[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam2B_buf3[inx] = 0;
   prLam2B_buf3a[inx] = 0;
   prLam2B_buf3b[inx] = 0;
   prLam2C_buf3[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam_buf4[inx] = 0;
   prLam_buf4a[inx] = 0;
   prLamB_buf4[inx] = 0;
   prLamC_buf4[inx] = 0;
   prLamC_buf4a[inx] = 0;
   prLamC_buf4b[inx] = 0;
#pragma empty_line
#pragma empty_line
   prLam2_buf4[inx] = 0;
   prLam2_buf4a[inx] = 0;
   prLam2B_buf4[inx] = 0;
   prLam2C_buf4[inx] = 0;
   prLam2C_buf4a[inx] = 0;
   prLam2C_buf4b[inx] = 0;
#pragma empty_line
   pLambda5[inx] = pR5[inx];
#pragma empty_line
   Lam_bufA5[inx] = pR5[inx];
#pragma empty_line
   Lam_buf6[inx] = pR6[inx];
   Lam_buf6a[inx] = pR6[inx];
   pLambda6[inx] = pR6[inx];
   Lam_bufA6[inx] = pR6[inx];
   Lam_bufA6b[inx] = pR6[inx];
   Lam_bufA6c[inx] = pR6[inx];
   Lam_bufB6[inx] = pR6[inx];
#pragma empty_line
   if ( (numbits == 1536) || (numbits == 6144))
   {
    pLambda6[inx] = blk_val;
    Lam_buf6[inx] = blk_val;
    Lam_buf6a[inx] = blk_val;
    Lam_bufA6[inx] = blk_val;
    Lam_bufA6b[inx] = blk_val;
    Lam_bufA6c[inx] = blk_val;
    Lam_bufB6[inx] = blk_val;
   }
#pragma empty_line
   Lam_bufB5a[inx] = pR5[inx];
   Lam_bufB5b[inx] = pR5[inx];
   Lam_bufB5c[inx] = pR5[inx];
#pragma empty_line
   prLamB_buf5[inx] = 0;
   prLamB_buf5a[inx] = 0;
   prLamB_buf5b[inx] = 0;
   prLamC_buf5[inx] = 0;
#pragma empty_line
   prLam2B_buf5[inx] = 0;
   prLam2B_buf5a[inx] = 0;
   prLam2B_buf5b[inx] = 0;
   prLam2C_buf5[inx] = 0;
#pragma empty_line
   prLamB_buf6[inx] = 0;
   prLamC_buf6[inx] = 0;
#pragma empty_line
   prLam2B_buf6[inx] = 0;
   prLam2C_buf6[inx] = 0;
#pragma empty_line
   pLambda7[inx] = pR7[inx];
   pLambda8[inx] = pR8[inx];
   pLambda9[inx] = pR9[inx];
   pLambda10[inx+0] = blk_val;
#pragma empty_line
   Lam_buf8[inx] = pR8[inx];
   Lam_buf10[inx+0] = blk_val;
   Lam_buf10a[inx+0] = blk_val;
#pragma empty_line
   Lam_bufA7[inx] = pR7[inx];
   Lam_bufA9[inx] = pR9[inx];
   Lam_bufA10a[inx] = blk_val;
   Lam_bufA10b[inx] = blk_val;
   Lam_bufA10c[inx] = blk_val;
#pragma empty_line
   Lam_bufB7a[inx] = pR7[inx];
   Lam_bufB7b[inx] = pR7[inx];
   Lam_bufB9a[inx] = pR9[inx];
   Lam_bufB9b[inx] = pR9[inx];
   Lam_bufB10[inx+0] = blk_val;
#pragma empty_line
   prLamB_buf7[inx] = 0;
   prLamB_buf7a[inx] = 0;
   prLamC_buf7[inx] = 0;
#pragma empty_line
   prLam2B_buf7[inx] = 0;
   prLam2B_buf7a[inx] = 0;
   prLam2C_buf7[inx] = 0;
#pragma empty_line
   prLamB_buf9[inx] = 0;
   prLamB_buf9a[inx] = 0;
   prLamC_buf9[inx] = 0;
#pragma empty_line
   prLam2B_buf9[inx] = 0;
   prLam2B_buf9a[inx] = 0;
   prLam2C_buf9[inx] = 0;
#pragma empty_line
   prLamB_buf10[inx] = 0;
   prLamC_buf10[inx] = 0;
   prLamC_buf10a[inx] = 0;
   prLamC_buf10b[inx] = 0;
#pragma empty_line
   prLam2B_buf10[inx] = 0;
   prLam2C_buf10[inx] = 0;
   prLam2C_buf10a[inx] = 0;
   prLam2C_buf10b[inx] = 0;
  }
  else
  {
   pLambda0[inx] = pR[inx];
   pLambda1[inx] = pR1[inx];
   pLambda2[inx] = pR2[inx];
   pLambda3[inx] = pR3[inx];
   pLambda4[inx] = pR4[inx];
#pragma empty_line
   pos = inx -1024;
#pragma empty_line
   Lam_buf8[pos] = pR2[inx];
   Lam_buf6[pos] = pR4[inx];
   Lam_buf6a[pos] = pR4[inx];
#pragma empty_line
   Lam_bufAb[pos] = pR[inx];
   Lam_bufAc[pos] = pR1[inx];
   Lam_bufA2a[pos] = pR3[inx];
   Lam_bufA6[pos] = pR4[inx];
   Lam_bufA6b[pos] = pR4[inx];
   Lam_bufA6c[pos] = pR4[inx];
#pragma empty_line
   Lam_bufB6[pos] = pR[inx];
   Lam_bufB7a[pos] = pR1[inx];
   Lam_bufB7b[pos] = pR1[inx];
   Lam_bufB9a[pos] = pR3[inx];
   Lam_bufB9b[pos] = pR3[inx];
   Lam_bufB10[pos] = pR4[inx];
#pragma empty_line
   if ( (numbits == 2048) || (numbits == 8192))
   {
    pLambda4[inx] = blk_val;
    Lam_buf6[pos] = blk_val;
    Lam_buf6a[pos] = blk_val;
    Lam_bufA6[pos] = blk_val;
    Lam_bufA6b[pos] = blk_val;
    Lam_bufA6c[pos] = blk_val;
    Lam_bufB10[pos] = blk_val;
   }
#pragma empty_line
  }
#pragma empty_line
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 tab_int m, mSparse, nLenMset, n, nSparse, nLenNset, nLenNset_1, jSparse;
 tab_int nThisCheck;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short vMetric, vArg, minval;
 short min, last, est[20], test, flag;
 int num_cal=0, dug;
 int8_t step =0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
   for(nIterationCounter=0;nIterationCounter<nMaxIterations;++nIterationCounter)
 {
#pragma empty_line
#pragma empty_line
#pragma empty_line
     *itt_num = (int8_t) nIterationCounter;
#pragma line 764 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  bAllChecksPassed = true;
#pragma empty_line
  if ( (numbits == 1280) || (numbits == 5120))
   calc_m(nCodeM, true);
  else if ( (numbits == 1536) || (numbits == 6144))
   calc_m_23(nCodeM, true);
  else if ( (numbits == 2048) || (numbits == 8192))
   calc_m_12(nCodeM, true);
#pragma empty_line
  if((bAllChecksPassed == true) && nIterationCounter != 0)
  {
   ++nIterationCounter;
   break;
  }
#pragma line 790 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  if ( (numbits == 1280) || (numbits == 5120))
   calc_n(nCodeN11);
  else if ( (numbits == 1536) || (numbits == 6144))
   calc_n_23(nCodeN11);
  else if ( (numbits == 2048) || (numbits == 8192))
   calc_n_12(nCodeN11);
#pragma line 804 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  ++nIterationCounter;
     *itt_num = (int8_t) nIterationCounter;
#pragma empty_line
  if( nIterationCounter >= nMaxIterations)
  {
   break;
  }
#pragma line 821 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  bAllChecksPassed = true;
#pragma empty_line
  if ( (numbits == 1280) || (numbits == 5120))
   calc_m(nCodeM, false);
  else if ( (numbits == 1536) || (numbits == 6144))
   calc_m_23(nCodeM, false);
  else if ( (numbits == 2048) || (numbits == 8192))
   calc_m_12(nCodeM, false);
#pragma empty_line
  if(bAllChecksPassed == true)
  {
   ++nIterationCounter;
   break;
  }
#pragma line 844 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  if ( (numbits == 1280) || (numbits == 5120))
   calc_n(nCodeN11);
  else if ( (numbits == 1536) || (numbits == 6144))
   calc_n_23(nCodeN11);
  else if ( (numbits == 2048) || (numbits == 8192))
   calc_n_12(nCodeN11);
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 }
#pragma empty_line
    if(bAllChecksPassed == false)
 {
  printf("Decoding failure after %d iterations\n", nMaxIterations);
 }
 else
 {
#pragma empty_line
  printf("Loop Counter = %i\n",nIterationCounter);
 }
#pragma empty_line
    out_cnt =0;
    bool test_in;
    test_in = *mux;
    while (!test_in)
    {
     *cnt = out_cnt;
     out_cnt++;
     test_in = *mux;
#pragma empty_line
    }
#pragma empty_line
 write_pcHat( pbhat0, pbhat1, pbhat2, pbhat3, pbhat4, pbhat5, pbhat6, pbhat7);
 *cnt = nIterationCounter ;
#pragma empty_line
}
#pragma empty_line
void mcalcAA_23(short *eTab, short *lTab, short *pTab, short num_nt, short num_shnt,
  short *eTabA, short *lTabA, short *pTabA, short num_ntA, short num_shntA,
  short *eTabB, short *lTabB, short *pTabB, short num_ntB, short num_shntB,
  short *eTabE, short *lTabE, short *pTabE, short *eTabF, short *lTabF, short *pTabF,
  short *eTabG, short *lTabG, short *pTabG, short *eTabH, short *lTabH, short *pTabH,
  short *eTabI, short *lTabI, short *pTabI, short *eTabJ, short *lTabJ, short *pTabJ,
  short *eTabK, short *lTabK, short *pTabK, short *eTabL, short *lTabL, short *pTabL,
  short *eTabM, short *lTabM, short *pTabM, bool prevflg)
{
 tab_int jSparse, nLenNset, nSparse;
 unsigned short a, b, c, d, e, f;
 unsigned short a2, b2, c2, d2, e2, f2;
#pragma empty_line
 unsigned short a18A, b18A, c18A, d18A, e18A, f18A, g18A, h18A, i18A, j18A, k18A, l18A;
 unsigned short m18A, n18A, o18A, p18A, q18A, r18A;
 unsigned short a18A2, b18A2, c18A2, d18A2, e18A2, f18A2, g18A2, h18A2, i18A2, j18A2, k18A2, l18A2;
 unsigned short m18A2, n18A2, o18A2, p18A2, q18A2, r18A2;
 unsigned short a18A3, b18A3, c18A3, d18A3, e18A3, f18A3, g18A3, h18A3, i18A3, j18A3, k18A3, l18A3;
 unsigned short m18A3, n18A3, o18A3, p18A3, q18A3, r18A3;
 unsigned short a18A4, b18A4, c18A4, d18A4, e18A4, f18A4, g18A4, h18A4, i18A4, j18A4, k18A4, l18A4;
 unsigned short m18A4, n18A4, o18A4, p18A4, q18A4, r18A4;
#pragma empty_line
 unsigned short a18B, b18B, c18B, d18B, e18B, f18B, g18B, h18B, i18B, j18B, k18B, l18B;
 unsigned short m18B, n18B, o18B, p18B, q18B, r18B;
 unsigned short a18B2, b18B2, c18B2, d18B2, e18B2, f18B2, g18B2, h18B2, i18B2, j18B2, k18B2, l18B2;
 unsigned short m18B2, n18B2, o18B2, p18B2, q18B2, r18B2;
 unsigned short a18B3, b18B3, c18B3, d18B3, e18B3, f18B3, g18B3, h18B3, i18B3, j18B3, k18B3, l18B3;
 unsigned short m18B3, n18B3, o18B3, p18B3, q18B3, r18B3;
 unsigned short a18B4, b18B4, c18B4, d18B4, e18B4, f18B4, g18B4, h18B4, i18B4, j18B4, k18B4, l18B4;
 unsigned short m18B4, n18B4, o18B4, p18B4, q18B4, r18B4;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short inx=num_nt;
 short inx1=inx+1;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (numb == 1536)
 {
  a = varinx3_1024_23[inx].inx1;
  b = varinx3_1024_23[inx].inx2;
  c = varinx3_1024_23[inx].inx3;
#pragma empty_line
  d = varinx3_1024_23[inx1].inx1;
  e = varinx3_1024_23[inx1].inx2;
  f = varinx3_1024_23[inx1].inx3;
#pragma empty_line
#pragma empty_line
  a18A = varinx10A_1024_a[inx].inx1;
  b18A = varinx10A_1024_a[inx].inx2;
  c18A = varinx10A_1024_a[inx].inx3;
  d18A = varinx10A_1024_b[inx].inx1;
  e18A = varinx10A_1024_b[inx].inx2;
  f18A = varinx10A_1024_b[inx].inx3;
  g18A = varinx10A_1024_c[inx].inx1;
  h18A = varinx10A_1024_c[inx].inx2;
  i18A = varinx10A_1024_c[inx].inx3;
  j18A = varinx10A_1024_d[inx];
#pragma empty_line
  a18A2 = varinx10A_1024_a[inx1].inx1;
  b18A2 = varinx10A_1024_a[inx1].inx2;
  c18A2 = varinx10A_1024_a[inx1].inx3;
  d18A2 = varinx10A_1024_b[inx1].inx1;
  e18A2 = varinx10A_1024_b[inx1].inx2;
  f18A2 = varinx10A_1024_b[inx1].inx3;
  g18A2 = varinx10A_1024_c[inx1].inx1;
  h18A2 = varinx10A_1024_c[inx1].inx2;
  i18A2 = varinx10A_1024_c[inx1].inx3;
  j18A2 = varinx10A_1024_d[inx1];
#pragma empty_line
  a18B = varinx10B_1024_a[inx].inx1;
  b18B = varinx10B_1024_a[inx].inx2;
  c18B = varinx10B_1024_a[inx].inx3;
  d18B = varinx10B_1024_b[inx].inx1;
  e18B = varinx10B_1024_b[inx].inx2;
  f18B = varinx10B_1024_b[inx].inx3;
  g18B = varinx10B_1024_c[inx].inx1;
  h18B = varinx10B_1024_c[inx].inx2;
  i18B = varinx10B_1024_c[inx].inx3;
  j18B = varinx10B_1024_d[inx];
#pragma empty_line
  a18B2 = varinx10B_1024_a[inx1].inx1;
  b18B2 = varinx10B_1024_a[inx1].inx2;
  c18B2 = varinx10B_1024_a[inx1].inx3;
  d18B2 = varinx10B_1024_b[inx1].inx1;
  e18B2 = varinx10B_1024_b[inx1].inx2;
  f18B2 = varinx10B_1024_b[inx1].inx3;
  g18B2 = varinx10B_1024_c[inx1].inx1;
  h18B2 = varinx10B_1024_c[inx1].inx2;
  i18B2 = varinx10B_1024_c[inx1].inx3;
  j18B2 = varinx10B_1024_d[inx1];
 }
 else
 {
  a = varinx3_4096_23[inx].inx1;
  b = varinx3_4096_23[inx].inx2;
  c = varinx3_4096_23[inx].inx3;
#pragma empty_line
  d = varinx3_4096_23[inx1].inx1;
  e = varinx3_4096_23[inx1].inx2;
  f = varinx3_4096_23[inx1].inx3;
#pragma empty_line
#pragma empty_line
  a18A = varinx10A_4096_a[inx].inx1;
  b18A = varinx10A_4096_a[inx].inx2;
  c18A = varinx10A_4096_a[inx].inx3;
  d18A = varinx10A_4096_b[inx].inx1;
  e18A = varinx10A_4096_b[inx].inx2;
  f18A = varinx10A_4096_b[inx].inx3;
  g18A = varinx10A_4096_c[inx].inx1;
  h18A = varinx10A_4096_c[inx].inx2;
  i18A = varinx10A_4096_c[inx].inx3;
  j18A = varinx10A_4096_d[inx];
#pragma empty_line
  a18A2 = varinx10A_4096_a[inx1].inx1;
  b18A2 = varinx10A_4096_a[inx1].inx2;
  c18A2 = varinx10A_4096_a[inx1].inx3;
  d18A2 = varinx10A_4096_b[inx1].inx1;
  e18A2 = varinx10A_4096_b[inx1].inx2;
  f18A2 = varinx10A_4096_b[inx1].inx3;
  g18A2 = varinx10A_4096_c[inx1].inx1;
  h18A2 = varinx10A_4096_c[inx1].inx2;
  i18A2 = varinx10A_4096_c[inx1].inx3;
  j18A2 = varinx10A_4096_d[inx1];
#pragma empty_line
  a18B = varinx10B_4096_a[inx].inx1;
  b18B = varinx10B_4096_a[inx].inx2;
  c18B = varinx10B_4096_a[inx].inx3;
  d18B = varinx10B_4096_b[inx].inx1;
  e18B = varinx10B_4096_b[inx].inx2;
  f18B = varinx10B_4096_b[inx].inx3;
  g18B = varinx10B_4096_c[inx].inx1;
  h18B = varinx10B_4096_c[inx].inx2;
  i18B = varinx10B_4096_c[inx].inx3;
  j18B = varinx10B_4096_d[inx];
#pragma empty_line
  a18B2 = varinx10B_4096_a[inx1].inx1;
  b18B2 = varinx10B_4096_a[inx1].inx2;
  c18B2 = varinx10B_4096_a[inx1].inx3;
  d18B2 = varinx10B_4096_b[inx1].inx1;
  e18B2 = varinx10B_4096_b[inx1].inx2;
  f18B2 = varinx10B_4096_b[inx1].inx3;
  g18B2 = varinx10B_4096_c[inx1].inx1;
  h18B2 = varinx10B_4096_c[inx1].inx2;
  i18B2 = varinx10B_4096_c[inx1].inx3;
  j18B2 = varinx10B_4096_d[inx1];
 }
#pragma empty_line
#pragma empty_line
 eTab[0] = (a) ;
 eTab[1] = (b) ;
 eTab[2] = (c) ;
#pragma empty_line
 eTabE[0] = (d) ;
 eTabE[1] = (e) ;
 eTabE[2] = (f) ;
#pragma empty_line
 lTab[0] = Lam_buf4[(a) ];
 lTab[1] = Lam_buf6[(b) ];
 lTab[2] = Lam_buf6[(c) ];
#pragma empty_line
 lTabE[0] = Lam_buf4[(d) ];
 lTabE[1] = Lam_buf6a[(e) ];
 lTabE[2] = Lam_buf6a[(f) ];
#pragma empty_line
 pTab[0] = SpEtaPrev[inx].one;
 pTab[1] = SpEtaPrev[inx].two;
 pTab[2] = SpEtaPrev[inx].three;
#pragma empty_line
 pTabE[0] = SpEtaPrevC[inx1].one;
 pTabE[1] = SpEtaPrevC[inx1].two;
 pTabE[2] = SpEtaPrevC[inx1].three;
#pragma empty_line
 inx = num_ntA;
#pragma empty_line
 eTabA[0] = a18A;
 eTabA[1] = b18A;
 eTabA[2] = c18A;
 eTabA[3] = (d18A) ;
 eTabA[4] = (e18A) ;
 eTabA[5] = (f18A) ;
 eTabA[6] = (g18A) ;
 eTabA[7] = (h18A) ;
 eTabA[8] = (i18A) ;
 eTabA[9] = (j18A) ;
#pragma empty_line
 lTabA[0] = Lam_bufAa[a18A];
 lTabA[1] = Lam_bufAb[b18A];
 lTabA[2] = Lam_bufAc[c18A];
 lTabA[3] = Lam_bufA1[(d18A) ];
 lTabA[4] = Lam_bufA2a[(e18A) ];
 lTabA[5] = Lam_bufA3[(f18A) ];
 lTabA[6] = Lam_bufA5[(g18A) ];
 lTabA[7] = Lam_buf6[(h18A) ];
 lTabA[8] = Lam_bufA6b[(i18A) ];
 lTabA[9] = Lam_bufA6c[(j18A) ];
 lTabA[10] = 0;
 lTabA[11] = 0;
 lTabA[12] = 0;
 lTabA[13] = 0;
 lTabA[14] = 0;
 lTabA[15] = 0;
 lTabA[16] = 0;
 lTabA[17] = 0;
#pragma empty_line
#pragma empty_line
 eTabF[0] = a18A2;
 eTabF[1] = b18A2;
 eTabF[2] = c18A2;
 eTabF[3] = (d18A2);
 eTabF[4] = (e18A2) ;
 eTabF[5] = (f18A2) ;
 eTabF[6] = (g18A2) ;
 eTabF[7] = (h18A2) ;
 eTabF[8] = (i18A2) ;
 eTabF[9] = (j18A2) ;
#pragma empty_line
 lTabF[0] = Lam_bufAa[a18A2];
 lTabF[1] = Lam_bufAb[b18A2];
 lTabF[2] = Lam_bufAc[c18A2];
 lTabF[3] = Lam_bufA1[(d18A2) ];
 lTabF[4] = Lam_bufA2a[(e18A2) ];
 lTabF[5] = Lam_bufA3[(f18A2) ];
 lTabF[6] = Lam_bufA5[(g18A2) ];
 lTabF[7] = Lam_bufA6[(h18A2) ];
 lTabF[8] = Lam_bufA6b[(i18A2) ];
 lTabF[9] = Lam_bufA6c[(j18A2) ];
 lTabF[10] = 0;
 lTabF[11] = 0;
 lTabF[12] = 0;
 lTabF[13] = 0;
 lTabF[14] = 0;
 lTabF[15] = 0;
 lTabF[16] = 0;
 lTabF[17] = 0;
#pragma empty_line
#pragma empty_line
 pTabA[0] = SpEtaPrevA[inx].one;
 pTabA[1] = SpEtaPrevA[inx].two;
 pTabA[2] = SpEtaPrevAa[inx].three;
 pTabA[3] = SpEtaPrevAa[inx].four;
 pTabA[4] = SpEtaPrevAa[inx].five;
 pTabA[5] = SpEtaPrevAa[inx].six;
 pTabA[6] = SpEtaPrevAb[inx].seven;
 pTabA[7] = SpEtaPrevAb[inx].eight;
 pTabA[8] = SpEtaPrevAb[inx].nine;
 pTabA[9] = SpEtaPrevAb[inx].ten;
 pTabA[10] = 128;
 pTabA[11] = 128;
 pTabA[12] = 128;
 pTabA[13] = 128;
 pTabA[14] = 128;
 pTabA[15] = 128;
 pTabA[16] = 128;
 pTabA[17] = 128;
#pragma empty_line
 pTabF[0] = SpEtaPrevD[inx1].one;
 pTabF[1] = SpEtaPrevD[inx1].two;
 pTabF[2] = SpEtaPrevDa[inx1].three;
 pTabF[3] = SpEtaPrevDa[inx1].four;
 pTabF[4] = SpEtaPrevDa[inx1].five;
 pTabF[5] = SpEtaPrevDa[inx1].six;
 pTabF[6] = SpEtaPrevDb[inx1].seven;
 pTabF[7] = SpEtaPrevDb[inx1].eight;
 pTabF[8] = SpEtaPrevDb[inx1].nine;
 pTabF[9] = SpEtaPrevDb[inx1].ten;
 pTabF[10] = 128;
 pTabF[11] = 128;
 pTabF[12] = 128;
 pTabF[13] = 128;
 pTabF[14] = 128;
 pTabF[15] = 128;
 pTabF[16] = 128;
 pTabF[17] = 128;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 inx = num_ntB;
#pragma empty_line
 eTabB[0] = a18B;
 eTabB[1] = (b18B) ;
 eTabB[2] = (c18B) ;
 eTabB[3] = (d18B) ;
 eTabB[4] = (e18B) ;
 eTabB[5] = (f18B) ;
 eTabB[6] = (g18B) ;
 eTabB[7] = (h18B) ;
 eTabB[8] = (i18B) ;
 eTabB[9] = (j18B) ;
#pragma empty_line
#pragma empty_line
 lTabB[0] = Lam_bufB[a18B];
 lTabB[1] = Lam_bufB1a[(b18B) ];
 lTabB[2] = Lam_bufB1b[(c18B) ];
 lTabB[3] = Lam_bufB1c[(d18B) ];
 lTabB[4] = Lam_bufB2[(e18B) ];
 lTabB[5] = Lam_bufB3a[(f18B) ];
 lTabB[6] = Lam_bufB3b[(g18B) ];
 lTabB[7] = Lam_bufB5a[(h18B) ];
 lTabB[8] = Lam_bufB5b[(i18B) ];
 lTabB[9] = Lam_bufB6[(j18B) ];
 lTabB[10] = 0;
 lTabB[11] = 0;
 lTabB[12] = 0;
 lTabB[13] = 0;
 lTabB[14] = 0;
 lTabB[15] = 0;
 lTabB[16] = 0;
 lTabB[17] = 0;
#pragma empty_line
#pragma empty_line
 eTabG[0] = a18B2;
 eTabG[1] = (b18B2) ;
 eTabG[2] = (c18B2) ;
 eTabG[3] = (d18B2) ;
 eTabG[4] = (e18B2) ;
 eTabG[5] = (f18B2) ;
 eTabG[6] = (g18B2) ;
 eTabG[7] = (h18B2) ;
 eTabG[8] = (i18B2) ;
 eTabG[9] = (j18B2) ;
#pragma empty_line
#pragma empty_line
 lTabG[0] = Lam_bufB[a18B2];
 lTabG[1] = Lam_bufB1a[(b18B2) ];
 lTabG[2] = Lam_bufB1b[(c18B2) ];
 lTabG[3] = Lam_bufB1c[(d18B2) ];
 lTabG[4] = Lam_bufB2[(e18B2) ];
 lTabG[5] = Lam_bufB3a[(f18B2) ];
 lTabG[6] = Lam_bufB3b[(g18B2) ];
 lTabG[7] = Lam_bufB5a[(h18B2) ];
 lTabG[8] = Lam_bufB5b[(i18B2) ];
 lTabG[9] = Lam_bufB6[(j18B2) ];
 lTabG[10] = 0;
 lTabG[11] = 0;
 lTabG[12] = 0;
 lTabG[13] = 0;
 lTabG[14] = 0;
 lTabG[15] = 0;
 lTabG[16] = 0;
 lTabG[17] = 0;
#pragma empty_line
#pragma empty_line
 pTabB[0] = SpEtaPrevB[inx].one;
 pTabB[1] = SpEtaPrevB[inx].two;
 pTabB[2] = SpEtaPrevBa[inx].three;
 pTabB[3] = SpEtaPrevBa[inx].four;
 pTabB[4] = SpEtaPrevBa[inx].five;
 pTabB[5] = SpEtaPrevBa[inx].six;
 pTabB[6] = SpEtaPrevBb[inx].seven;
 pTabB[7] = SpEtaPrevBb[inx].eight;
 pTabB[8] = SpEtaPrevBb[inx].nine;
 pTabB[9] = SpEtaPrevBb[inx].ten;
 pTabB[10] = 128;
 pTabB[11] = 128;
 pTabB[12] = 128;
 pTabB[13] = 128;
 pTabB[14] = 128;
 pTabB[15] = 128;
 pTabB[16] = 128;
 pTabB[17] = 128;
#pragma empty_line
 pTabG[0] = SpEtaPrevE[inx1].one;
 pTabG[1] = SpEtaPrevE[inx1].two;
 pTabG[2] = SpEtaPrevEa[inx1].three;
 pTabG[3] = SpEtaPrevEa[inx1].four;
 pTabG[4] = SpEtaPrevEa[inx1].five;
 pTabG[5] = SpEtaPrevEa[inx1].six;
 pTabG[6] = SpEtaPrevEb[inx1].seven;
 pTabG[7] = SpEtaPrevEb[inx1].eight;
 pTabG[8] = SpEtaPrevEb[inx1].nine;
 pTabG[9] = SpEtaPrevEb[inx1].ten;
 pTabG[10] = 128;
 pTabG[11] = 128;
 pTabG[12] = 128;
 pTabG[13] = 128;
 pTabG[14] = 128;
 pTabG[15] = 128;
 pTabG[16] = 128;
 pTabG[17] = 128;
#pragma empty_line
#pragma empty_line
 if (nIterationCounter == 0)
 {
#pragma empty_line
  pTab[0] = 0;
  pTab[1] = 0;
  pTab[2] = 0;
#pragma empty_line
  pTabE[0] = 0;
  pTabE[1] = 0;
  pTabE[2] = 0;
#pragma empty_line
  pTabA[0] = 0;
  pTabA[1] = 0;
  pTabA[2] = 0;
  pTabA[3] = 0;
  pTabA[4] = 0;
  pTabA[5] = 0;
  pTabA[6] = 0;
  pTabA[7] = 0;
  pTabA[8] = 0;
  pTabA[9] = 0;
  pTabA[10] = 128;
  pTabA[11] = 128;
  pTabA[12] = 128;
  pTabA[13] = 128;
  pTabA[14] = 128;
  pTabA[15] = 128;
  pTabA[16] = 128;
  pTabA[17] = 128;
#pragma empty_line
  pTabF[0] = 0;
  pTabF[1] = 0;
  pTabF[2] = 0;
  pTabF[3] = 0;
  pTabF[4] = 0;
  pTabF[5] = 0;
  pTabF[6] = 0;
  pTabF[7] = 0;
  pTabF[8] = 0;
  pTabF[9] = 0;
  pTabF[10] = 128;
  pTabF[11] = 128;
  pTabF[12] = 128;
  pTabF[13] = 128;
  pTabF[14] = 128;
  pTabF[15] = 128;
  pTabF[16] = 128;
  pTabF[17] = 128;
#pragma empty_line
  pTabB[0] = 0;
  pTabB[1] = 0;
  pTabB[2] = 0;
  pTabB[3] = 0;
  pTabB[4] = 0;
  pTabB[5] = 0;
  pTabB[6] = 0;
  pTabB[7] = 0;
  pTabB[8] = 0;
  pTabB[9] = 0;
  pTabB[10] = 128;
  pTabB[11] = 128;
  pTabB[12] = 128;
  pTabB[13] = 128;
  pTabB[14] = 128;
  pTabB[15] = 128;
  pTabB[16] = 128;
  pTabB[17] = 128;
#pragma empty_line
  pTabG[0] = 0;
  pTabG[1] = 0;
  pTabG[2] = 0;
  pTabG[3] = 0;
  pTabG[4] = 0;
  pTabG[5] = 0;
  pTabG[6] = 0;
  pTabG[7] = 0;
  pTabG[8] = 0;
  pTabG[9] = 0;
  pTabG[10] = 128;
  pTabG[11] = 128;
  pTabG[12] = 128;
  pTabG[13] = 128;
  pTabG[14] = 128;
  pTabG[15] = 128;
  pTabG[16] = 128;
  pTabG[17] = 128;
#pragma empty_line
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
void mcalcAA_12(short *eTab, short *lTab, short *pTab, short num_nt, short num_shnt,
  short *eTabA, short *lTabA, short *pTabA, short num_ntA, short num_shntA,
  short *eTabB, short *lTabB, short *pTabB, short num_ntB, short num_shntB,
  short *eTabE, short *lTabE, short *pTabE, short *eTabF, short *lTabF, short *pTabF,
  short *eTabG, short *lTabG, short *pTabG, short *eTabH, short *lTabH, short *pTabH,
  short *eTabI, short *lTabI, short *pTabI, short *eTabJ, short *lTabJ, short *pTabJ,
  short *eTabK, short *lTabK, short *pTabK, short *eTabL, short *lTabL, short *pTabL,
  short *eTabM, short *lTabM, short *pTabM, bool prevflg)
{
 tab_int jSparse, nLenNset, nSparse;
 unsigned short a, b, c, d, e, f;
 unsigned short a2, b2, c2, d2, e2, f2;
#pragma empty_line
 unsigned short a18A, b18A, c18A, d18A, e18A, f18A, g18A, h18A, i18A, j18A, k18A, l18A;
 unsigned short m18A, n18A, o18A, p18A, q18A, r18A;
 unsigned short a18A2, b18A2, c18A2, d18A2, e18A2, f18A2, g18A2, h18A2, i18A2, j18A2, k18A2, l18A2;
 unsigned short m18A2, n18A2, o18A2, p18A2, q18A2, r18A2;
 unsigned short a18A3, b18A3, c18A3, d18A3, e18A3, f18A3, g18A3, h18A3, i18A3, j18A3, k18A3, l18A3;
 unsigned short m18A3, n18A3, o18A3, p18A3, q18A3, r18A3;
 unsigned short a18A4, b18A4, c18A4, d18A4, e18A4, f18A4, g18A4, h18A4, i18A4, j18A4, k18A4, l18A4;
 unsigned short m18A4, n18A4, o18A4, p18A4, q18A4, r18A4;
#pragma empty_line
 unsigned short a18B, b18B, c18B, d18B, e18B, f18B, g18B, h18B, i18B, j18B, k18B, l18B;
 unsigned short m18B, n18B, o18B, p18B, q18B, r18B;
 unsigned short a18B2, b18B2, c18B2, d18B2, e18B2, f18B2, g18B2, h18B2, i18B2, j18B2, k18B2, l18B2;
 unsigned short m18B2, n18B2, o18B2, p18B2, q18B2, r18B2;
 unsigned short a18B3, b18B3, c18B3, d18B3, e18B3, f18B3, g18B3, h18B3, i18B3, j18B3, k18B3, l18B3;
 unsigned short m18B3, n18B3, o18B3, p18B3, q18B3, r18B3;
 unsigned short a18B4, b18B4, c18B4, d18B4, e18B4, f18B4, g18B4, h18B4, i18B4, j18B4, k18B4, l18B4;
 unsigned short m18B4, n18B4, o18B4, p18B4, q18B4, r18B4;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short inx=num_nt;
 short inx1=inx+1;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (numb == 2048)
 {
  a = varinx3_1024_12[inx].inx1;
  b = varinx3_1024_12[inx].inx2;
  c = varinx3_1024_12[inx].inx3;
#pragma empty_line
  d = varinx3_1024_12[inx1].inx1;
  e = varinx3_1024_12[inx1].inx2;
  f = varinx3_1024_12[inx1].inx3;
#pragma empty_line
#pragma empty_line
  a18A = varinx6A_1024_a[inx].inx1;
  b18A = varinx6A_1024_a[inx].inx2;
  c18A = varinx6A_1024_a[inx].inx3;
  d18A = varinx6A_1024_b[inx].inx1;
  e18A = varinx6A_1024_b[inx].inx2;
  f18A = varinx6A_1024_b[inx].inx3;
#pragma empty_line
#pragma empty_line
  a18A2 = varinx6A_1024_a[inx1].inx1;
  b18A2 = varinx6A_1024_a[inx1].inx2;
  c18A2 = varinx6A_1024_a[inx1].inx3;
  d18A2 = varinx6A_1024_b[inx1].inx1;
  e18A2 = varinx6A_1024_b[inx1].inx2;
  f18A2 = varinx6A_1024_b[inx1].inx3;
#pragma empty_line
#pragma empty_line
  a18B = varinx6B_1024_a[inx].inx1;
  b18B = varinx6B_1024_a[inx].inx2;
  c18B = varinx6B_1024_a[inx].inx3;
  d18B = varinx6B_1024_b[inx].inx1;
  e18B = varinx6B_1024_b[inx].inx2;
  f18B = varinx6B_1024_b[inx].inx3;
#pragma empty_line
  a18B2 = varinx6B_1024_a[inx1].inx1;
  b18B2 = varinx6B_1024_a[inx1].inx2;
  c18B2 = varinx6B_1024_a[inx1].inx3;
  d18B2 = varinx6B_1024_b[inx1].inx1;
  e18B2 = varinx6B_1024_b[inx1].inx2;
  f18B2 = varinx6B_1024_b[inx1].inx3;
#pragma empty_line
 }
 else
 {
  a = varinx3_4096_12[inx].inx1;
  b = varinx3_4096_12[inx].inx2;
  c = varinx3_4096_12[inx].inx3;
#pragma empty_line
  d = varinx3_4096_12[inx1].inx1;
  e = varinx3_4096_12[inx1].inx2;
  f = varinx3_4096_12[inx1].inx3;
#pragma empty_line
#pragma empty_line
  a18A = varinx6A_4096_a[inx].inx1;
  b18A = varinx6A_4096_a[inx].inx2;
  c18A = varinx6A_4096_a[inx].inx3;
  d18A = varinx6A_4096_b[inx].inx1;
  e18A = varinx6A_4096_b[inx].inx2;
  f18A = varinx6A_4096_b[inx].inx3;
#pragma empty_line
  a18A2 = varinx6A_4096_a[inx1].inx1;
  b18A2 = varinx6A_4096_a[inx1].inx2;
  c18A2 = varinx6A_4096_a[inx1].inx3;
  d18A2 = varinx6A_4096_b[inx1].inx1;
  e18A2 = varinx6A_4096_b[inx1].inx2;
  f18A2 = varinx6A_4096_b[inx1].inx3;
#pragma empty_line
  a18B = varinx6B_4096_a[inx].inx1;
  b18B = varinx6B_4096_a[inx].inx2;
  c18B = varinx6B_4096_a[inx].inx3;
  d18B = varinx6B_4096_b[inx].inx1;
  e18B = varinx6B_4096_b[inx].inx2;
  f18B = varinx6B_4096_b[inx].inx3;
#pragma empty_line
  a18B2 = varinx6B_4096_a[inx1].inx1;
  b18B2 = varinx6B_4096_a[inx1].inx2;
  c18B2 = varinx6B_4096_a[inx1].inx3;
  d18B2 = varinx6B_4096_b[inx1].inx1;
  e18B2 = varinx6B_4096_b[inx1].inx2;
  f18B2 = varinx6B_4096_b[inx1].inx3;
#pragma empty_line
 }
#pragma empty_line
#pragma empty_line
 eTab[0] = (a) ;
 eTab[1] = (b) ;
 eTab[2] = (c) ;
#pragma empty_line
 eTabE[0] = (d) ;
 eTabE[1] = (e) ;
 eTabE[2] = (f) ;
#pragma empty_line
 if (a < 1024)
  lTab[0] = Lam_buf2[(a) ];
 else
  lTab[0] = Lam_buf8[(a)-1024 ];
#pragma empty_line
 if (b < 1024)
  lTab[1] = Lam_buf4[(b) ];
 else
  lTab[1] = Lam_buf6[(b) - 1024 ];
#pragma empty_line
 if ( c < 1024)
  lTab[2] = Lam_buf4a[(c) ];
 else
  lTab[2] = Lam_buf6a[(c)- 1024];
#pragma empty_line
 if ( d < 1024)
  lTabE[0] = Lam_buf2[(d) ];
 else
  lTabE[0] = Lam_buf8[(d)- 1024 ];
#pragma empty_line
 if ( e < 1024)
  lTabE[1] = Lam_buf4[(e) ];
 else
  lTabE[1] = Lam_buf6[(e)- 1024 ];
#pragma empty_line
 if ( f < 1024)
  lTabE[2] = Lam_buf4a[(f) ];
 else
  lTabE[2] = Lam_buf6a[(f)- 1024 ];
#pragma empty_line
 pTab[0] = SpEtaPrev[inx].one;
 pTab[1] = SpEtaPrev[inx].two;
 pTab[2] = SpEtaPrev[inx].three;
#pragma empty_line
 pTabE[0] = SpEtaPrevC[inx1].one;
 pTabE[1] = SpEtaPrevC[inx1].two;
 pTabE[2] = SpEtaPrevC[inx1].three;
#pragma empty_line
#pragma empty_line
 inx = num_ntA;
#pragma empty_line
 eTabA[0] = a18A;
 eTabA[1] = b18A;
 eTabA[2] = c18A;
 eTabA[3] = (d18A) ;
 eTabA[4] = (e18A) ;
 eTabA[5] = (f18A) ;
#pragma empty_line
 if (a18A < 1024)
  lTabA[0] = Lam_bufAa[a18A];
 else
  lTabA[0] = Lam_bufAb[a18A - 1024];
 if ( b18A < 1024)
  lTabA[1] = Lam_bufA1[b18A];
 else
  lTabA[1] = Lam_bufAc[b18A - 1024];
 if (c18A < 1024)
  lTabA[2] = Lam_bufA3[c18A];
 else
  lTabA[2] = Lam_bufA2a[c18A -1024];
 if ( d18A < 1024)
  lTabA[3] = Lam_bufA4a[(d18A) ];
 else
  lTabA[3] = Lam_bufA6[(d18A)-1024 ];
 if (e18A < 1024)
  lTabA[4] = Lam_bufA4b[(e18A) ];
 else
  lTabA[4] = Lam_bufA6b[(e18A)-1024 ];
 if ( f18A < 1024)
  lTabA[5] = Lam_bufA4c[(f18A) ];
 else
  lTabA[5] = Lam_bufA6c[(f18A) - 1024];
 lTabA[6] = 0;
 lTabA[7] = 0;
 lTabA[8] = 0;
 lTabA[9] = 0;
 lTabA[10] = 0;
 lTabA[11] = 0;
 lTabA[12] = 0;
 lTabA[13] = 0;
 lTabA[14] = 0;
 lTabA[15] = 0;
 lTabA[16] = 0;
 lTabA[17] = 0;
#pragma empty_line
#pragma empty_line
 eTabF[0] = a18A2;
 eTabF[1] = b18A2;
 eTabF[2] = c18A2;
 eTabF[3] = (d18A2);
 eTabF[4] = (e18A2) ;
 eTabF[5] = (f18A2) ;
#pragma line 1590 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (a18A2 < 1024)
  lTabF[0] = Lam_bufAa[a18A2];
 else
  lTabF[0] = Lam_bufAb[a18A2 - 1024];
 if ( b18A2 < 1024)
  lTabF[1] = Lam_bufA1[b18A2];
 else
  lTabF[1] = Lam_bufAc[b18A2 - 1024];
 if (c18A2 < 1024)
  lTabF[2] = Lam_bufA3[c18A2];
 else
  lTabF[2] = Lam_bufA2a[c18A2 -1024];
 if ( d18A2 < 1024)
  lTabF[3] = Lam_bufA4a[(d18A2) ];
 else
  lTabF[3] = Lam_bufA6[(d18A2)-1024 ];
 if (e18A2 < 1024)
  lTabF[4] = Lam_bufA4b[(e18A2) ];
 else
  lTabF[4] = Lam_bufA6b[(e18A2)-1024 ];
 if ( f18A2 < 1024)
  lTabF[5] = Lam_bufA4c[(f18A2) ];
 else
  lTabF[5] = Lam_bufA6c[(f18A2) - 1024];
 lTabF[6] = 0;
 lTabF[7] = 0;
 lTabF[8] = 0;
 lTabF[9] = 0;
 lTabF[10] = 0;
 lTabF[11] = 0;
 lTabF[12] = 0;
 lTabF[13] = 0;
 lTabF[14] = 0;
 lTabF[15] = 0;
 lTabF[16] = 0;
 lTabF[17] = 0;
#pragma empty_line
 pTabA[6] = 128;
 pTabA[7] = 128;
 pTabA[8] = 128;
 pTabA[9] = 128;
 pTabA[10] = 128;
 pTabA[11] = 128;
 pTabA[12] = 128;
 pTabA[13] = 128;
 pTabA[14] = 128;
 pTabA[15] = 128;
 pTabA[16] = 128;
 pTabA[17] = 128;
#pragma empty_line
 pTabF[6] = 128;
 pTabF[7] = 128;
 pTabF[8] = 128;
 pTabF[9] = 128;
 pTabF[10] = 128;
 pTabF[11] = 128;
 pTabF[12] = 128;
 pTabF[13] = 128;
 pTabF[14] = 128;
 pTabF[15] = 128;
 pTabF[16] = 128;
 pTabF[17] = 128;
#pragma empty_line
 pTabA[0] = SpEtaPrevA[inx].one;
 pTabA[1] = SpEtaPrevA[inx].two;
 pTabA[2] = SpEtaPrevAa[inx].three;
 pTabA[3] = SpEtaPrevAa[inx].four;
 pTabA[4] = SpEtaPrevAa[inx].five;
 pTabA[5] = SpEtaPrevAa[inx].six;
#pragma empty_line
#pragma empty_line
 pTabF[0] = SpEtaPrevD[inx1].one;
 pTabF[1] = SpEtaPrevD[inx1].two;
 pTabF[2] = SpEtaPrevDa[inx1].three;
 pTabF[3] = SpEtaPrevDa[inx1].four;
 pTabF[4] = SpEtaPrevDa[inx1].five;
 pTabF[5] = SpEtaPrevDa[inx1].six;
#pragma empty_line
 inx = num_ntB;
#pragma empty_line
 eTabB[0] = a18B;
 eTabB[1] = (b18B) ;
 eTabB[2] = (c18B) ;
 eTabB[3] = (d18B) ;
 eTabB[4] = (e18B) ;
 eTabB[5] = (f18B) ;
#pragma line 1686 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (a18B < 1024)
  lTabB[0] = Lam_bufB[a18B];
 else
  lTabB[0] = Lam_bufB6[a18B - 1024];
 if ( b18B < 1024)
  lTabB[1] = Lam_bufB1a[b18B];
 else
  lTabB[1] = Lam_bufB7a[b18B - 1024];
 if (c18B < 1024)
  lTabB[2] = Lam_bufB1b[c18B];
 else
  lTabB[2] = Lam_bufB7b[c18B -1024];
 if ( d18B < 1024)
  lTabB[3] = Lam_bufB3a[(d18B) ];
 else
  lTabB[3] = Lam_bufB9a[(d18B)-1024 ];
 if (e18B < 1024)
  lTabB[4] = Lam_bufB3b[(e18B) ];
 else
  lTabB[4] = Lam_bufB9b[(e18B)-1024 ];
 if ( f18B < 1024)
  lTabB[5] = Lam_bufB4[(f18B) ];
 else
  lTabB[5] = Lam_bufB10[(f18B) - 1024];
#pragma empty_line
 lTabB[6] = 0;
 lTabB[7] = 0;
 lTabB[8] = 0;
 lTabB[9] = 0;
 lTabB[10] = 0;
 lTabB[11] = 0;
 lTabB[12] = 0;
 lTabB[13] = 0;
 lTabB[14] = 0;
 lTabB[15] = 0;
 lTabB[16] = 0;
 lTabB[17] = 0;
#pragma empty_line
#pragma empty_line
 eTabG[0] = a18B2;
 eTabG[1] = (b18B2) ;
 eTabG[2] = (c18B2) ;
 eTabG[3] = (d18B2) ;
 eTabG[4] = (e18B2) ;
 eTabG[5] = (f18B2) ;
#pragma line 1741 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (a18B2 < 1024)
  lTabG[0] = Lam_bufB[a18B2];
 else
  lTabG[0] = Lam_bufB6[a18B2 - 1024];
 if ( b18B2 < 1024)
  lTabG[1] = Lam_bufB1a[b18B2];
 else
  lTabG[1] = Lam_bufB7a[b18B2 - 1024];
 if (c18B2 < 1024)
  lTabG[2] = Lam_bufB1b[c18B2];
 else
  lTabG[2] = Lam_bufB7b[c18B2 -1024];
 if ( d18B2 < 1024)
  lTabG[3] = Lam_bufB3a[(d18B2) ];
 else
  lTabG[3] = Lam_bufB9a[(d18B2)-1024 ];
 if (e18B2 < 1024)
  lTabG[4] = Lam_bufB3b[(e18B2) ];
 else
  lTabG[4] = Lam_bufB9b[(e18B2)-1024 ];
 if ( f18B2 < 1024)
  lTabG[5] = Lam_bufB4[(f18B2) ];
 else
  lTabG[5] = Lam_bufB10[(f18B2) - 1024];
#pragma empty_line
 lTabG[6] = 0;
 lTabG[7] = 0;
 lTabG[8] = 0;
 lTabG[9] = 0;
 lTabG[10] = 0;
 lTabG[11] = 0;
 lTabG[12] = 0;
 lTabG[13] = 0;
 lTabG[14] = 0;
 lTabG[15] = 0;
 lTabG[16] = 0;
 lTabG[17] = 0;
#pragma empty_line
 pTabB[6] = 128;
 pTabB[7] = 128;
 pTabB[8] = 128;
 pTabB[9] = 128;
 pTabB[10] = 128;
 pTabB[11] = 128;
 pTabB[12] = 128;
 pTabB[13] = 128;
 pTabB[14] = 128;
 pTabB[15] = 128;
 pTabB[16] = 128;
 pTabB[17] = 128;
#pragma empty_line
 pTabG[6] = 128;
 pTabG[7] = 128;
 pTabG[8] = 128;
 pTabG[9] = 128;
 pTabG[10] = 128;
 pTabG[11] = 128;
 pTabG[12] = 128;
 pTabG[13] = 128;
 pTabG[14] = 128;
 pTabG[15] = 128;
 pTabG[16] = 128;
 pTabG[17] = 128;
#pragma empty_line
#pragma empty_line
 pTabB[0] = SpEtaPrevB[inx].one;
 pTabB[1] = SpEtaPrevB[inx].two;
 pTabB[2] = SpEtaPrevBa[inx].three;
 pTabB[3] = SpEtaPrevBa[inx].four;
 pTabB[4] = SpEtaPrevBa[inx].five;
 pTabB[5] = SpEtaPrevBa[inx].six;
#pragma empty_line
#pragma empty_line
 pTabG[0] = SpEtaPrevE[inx1].one;
 pTabG[1] = SpEtaPrevE[inx1].two;
 pTabG[2] = SpEtaPrevEa[inx1].three;
 pTabG[3] = SpEtaPrevEa[inx1].four;
 pTabG[4] = SpEtaPrevEa[inx1].five;
 pTabG[5] = SpEtaPrevEa[inx1].six;
#pragma empty_line
#pragma empty_line
 if (nIterationCounter == 0)
 {
#pragma empty_line
  pTab[0] = 0;
  pTab[1] = 0;
  pTab[2] = 0;
#pragma empty_line
  pTabE[0] = 0;
  pTabE[1] = 0;
  pTabE[2] = 0;
#pragma empty_line
  pTabA[0] = 0;
  pTabA[1] = 0;
  pTabA[2] = 0;
  pTabA[3] = 0;
  pTabA[4] = 0;
  pTabA[5] = 0;
  pTabA[6] = 128;
  pTabA[7] = 128;
  pTabA[8] = 128;
  pTabA[9] = 128;
  pTabA[10] = 128;
  pTabA[11] = 128;
  pTabA[12] = 128;
  pTabA[13] = 128;
  pTabA[14] = 128;
  pTabA[15] = 128;
  pTabA[16] = 128;
  pTabA[17] = 128;
#pragma empty_line
  pTabF[0] = 0;
  pTabF[1] = 0;
  pTabF[2] = 0;
  pTabF[3] = 0;
  pTabF[4] = 0;
  pTabF[5] = 0;
  pTabF[6] = 128;
  pTabF[7] = 128;
  pTabF[8] = 128;
  pTabF[9] = 128;
  pTabF[10] = 128;
  pTabF[11] = 128;
  pTabF[12] = 128;
  pTabF[13] = 128;
  pTabF[14] = 128;
  pTabF[15] = 128;
  pTabF[16] = 128;
  pTabF[17] = 128;
#pragma empty_line
  pTabB[0] = 0;
  pTabB[1] = 0;
  pTabB[2] = 0;
  pTabB[3] = 0;
  pTabB[4] = 0;
  pTabB[5] = 0;
  pTabB[6] = 128;
  pTabB[7] = 128;
  pTabB[8] = 128;
  pTabB[9] = 128;
  pTabB[10] = 128;
  pTabB[11] = 128;
  pTabB[12] = 128;
  pTabB[13] = 128;
  pTabB[14] = 128;
  pTabB[15] = 128;
  pTabB[16] = 128;
  pTabB[17] = 128;
#pragma empty_line
  pTabG[0] = 0;
  pTabG[1] = 0;
  pTabG[2] = 0;
  pTabG[3] = 0;
  pTabG[4] = 0;
  pTabG[5] = 0;
  pTabG[6] = 128;
  pTabG[7] = 128;
  pTabG[8] = 128;
  pTabG[9] = 128;
  pTabG[10] = 128;
  pTabG[11] = 128;
  pTabG[12] = 128;
  pTabG[13] = 128;
  pTabG[14] = 128;
  pTabG[15] = 128;
  pTabG[16] = 128;
  pTabG[17] = 128;
#pragma empty_line
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
void mcalcAA(short *eTab, short *lTab, short *pTab, short num_nt, short num_shnt,
  short *eTabA, short *lTabA, short *pTabA, short num_ntA, short num_shntA,
  short *eTabB, short *lTabB, short *pTabB, short num_ntB, short num_shntB,
  short *eTabE, short *lTabE, short *pTabE, short *eTabF, short *lTabF, short *pTabF,
  short *eTabG, short *lTabG, short *pTabG, bool prevflg)
{
 tab_int jSparse, nLenNset, nSparse;
 unsigned short a, b, c, d, e, f;
 unsigned short a2, b2, c2, d2, e2, f2;
#pragma empty_line
 unsigned short a18A, b18A, c18A, d18A, e18A, f18A, g18A, h18A, i18A, j18A, k18A, l18A;
 unsigned short m18A, n18A, o18A, p18A, q18A, r18A;
 unsigned short a18A2, b18A2, c18A2, d18A2, e18A2, f18A2, g18A2, h18A2, i18A2, j18A2, k18A2, l18A2;
 unsigned short m18A2, n18A2, o18A2, p18A2, q18A2, r18A2;
 unsigned short a18A3, b18A3, c18A3, d18A3, e18A3, f18A3, g18A3, h18A3, i18A3, j18A3, k18A3, l18A3;
 unsigned short m18A3, n18A3, o18A3, p18A3, q18A3, r18A3;
 unsigned short a18A4, b18A4, c18A4, d18A4, e18A4, f18A4, g18A4, h18A4, i18A4, j18A4, k18A4, l18A4;
 unsigned short m18A4, n18A4, o18A4, p18A4, q18A4, r18A4;
#pragma empty_line
 unsigned short a18B, b18B, c18B, d18B, e18B, f18B, g18B, h18B, i18B, j18B, k18B, l18B;
 unsigned short m18B, n18B, o18B, p18B, q18B, r18B;
 unsigned short a18B2, b18B2, c18B2, d18B2, e18B2, f18B2, g18B2, h18B2, i18B2, j18B2, k18B2, l18B2;
 unsigned short m18B2, n18B2, o18B2, p18B2, q18B2, r18B2;
 unsigned short a18B3, b18B3, c18B3, d18B3, e18B3, f18B3, g18B3, h18B3, i18B3, j18B3, k18B3, l18B3;
 unsigned short m18B3, n18B3, o18B3, p18B3, q18B3, r18B3;
 unsigned short a18B4, b18B4, c18B4, d18B4, e18B4, f18B4, g18B4, h18B4, i18B4, j18B4, k18B4, l18B4;
 unsigned short m18B4, n18B4, o18B4, p18B4, q18B4, r18B4;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short inx=num_nt;
 short inx1=inx+1;
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (numb == 1280)
 {
  a = varinx3_1024_45[inx].inx1;
  b = varinx3_1024_45[inx].inx2;
  c = varinx3_1024_45[inx].inx3;
#pragma empty_line
  d = varinx3_1024_45[inx1].inx1;
  e = varinx3_1024_45[inx1].inx2;
  f = varinx3_1024_45[inx1].inx3;
#pragma empty_line
  a18A = varinx18A_1024_a[inx].inx1;
  b18A = varinx18A_1024_a[inx].inx2;
  c18A = varinx18A_1024_a[inx].inx3;
  d18A = varinx18A_1024_b[inx].inx1;
  e18A = varinx18A_1024_b[inx].inx2;
  f18A = varinx18A_1024_b[inx].inx3;
  g18A = varinx18A_1024_c[inx].inx1;
  h18A = varinx18A_1024_c[inx].inx2;
  i18A = varinx18A_1024_c[inx].inx3;
  j18A = varinx18A_1024_d[inx].inx1;
  k18A = varinx18A_1024_d[inx].inx2;
  l18A = varinx18A_1024_d[inx].inx3;
  m18A = varinx18A_1024_e[inx].inx1;
  n18A = varinx18A_1024_e[inx].inx2;
  o18A = varinx18A_1024_e[inx].inx3;
  p18A = varinx18A_1024_f[inx].inx1;
  q18A = varinx18A_1024_f[inx].inx2;
  r18A = varinx18A_1024_f[inx].inx3;
#pragma empty_line
#pragma empty_line
  a18A2 = varinx18A_1024_a[inx1].inx1;
  b18A2 = varinx18A_1024_a[inx1].inx2;
  c18A2 = varinx18A_1024_a[inx1].inx3;
  d18A2 = varinx18A_1024_b[inx1].inx1;
  e18A2 = varinx18A_1024_b[inx1].inx2;
  f18A2 = varinx18A_1024_b[inx1].inx3;
  g18A2 = varinx18A_1024_c[inx1].inx1;
  h18A2 = varinx18A_1024_c[inx1].inx2;
  i18A2 = varinx18A_1024_c[inx1].inx3;
  j18A2 = varinx18A_1024_d[inx1].inx1;
  k18A2 = varinx18A_1024_d[inx1].inx2;
  l18A2 = varinx18A_1024_d[inx1].inx3;
  m18A2 = varinx18A_1024_e[inx1].inx1;
  n18A2 = varinx18A_1024_e[inx1].inx2;
  o18A2 = varinx18A_1024_e[inx1].inx3;
  p18A2 = varinx18A_1024_f[inx1].inx1;
  q18A2 = varinx18A_1024_f[inx1].inx2;
  r18A2 = varinx18A_1024_f[inx1].inx3;
#pragma empty_line
  a18B = varinx18B_1024_a[inx].inx1;
  b18B = varinx18B_1024_a[inx].inx2;
  c18B = varinx18B_1024_a[inx].inx3;
  d18B = varinx18B_1024_b[inx].inx1;
  e18B = varinx18B_1024_b[inx].inx2;
  f18B = varinx18B_1024_b[inx].inx3;
  g18B = varinx18B_1024_c[inx].inx1;
  h18B = varinx18B_1024_c[inx].inx2;
  i18B = varinx18B_1024_c[inx].inx3;
  j18B = varinx18B_1024_d[inx].inx1;
  k18B = varinx18B_1024_d[inx].inx2;
  l18B = varinx18B_1024_d[inx].inx3;
  m18B = varinx18B_1024_e[inx].inx1;
  n18B = varinx18B_1024_e[inx].inx2;
  o18B = varinx18B_1024_e[inx].inx3;
  p18B = varinx18B_1024_f[inx].inx1;
  q18B = varinx18B_1024_f[inx].inx2;
  r18B = varinx18B_1024_f[inx].inx3;
#pragma empty_line
#pragma empty_line
  a18B2 = varinx18B_1024_a[inx1].inx1;
  b18B2 = varinx18B_1024_a[inx1].inx2;
  c18B2 = varinx18B_1024_a[inx1].inx3;
  d18B2 = varinx18B_1024_b[inx1].inx1;
  e18B2 = varinx18B_1024_b[inx1].inx2;
  f18B2 = varinx18B_1024_b[inx1].inx3;
  g18B2 = varinx18B_1024_c[inx1].inx1;
  h18B2 = varinx18B_1024_c[inx1].inx2;
  i18B2 = varinx18B_1024_c[inx1].inx3;
  j18B2 = varinx18B_1024_d[inx1].inx1;
  k18B2 = varinx18B_1024_d[inx1].inx2;
  l18B2 = varinx18B_1024_d[inx1].inx3;
  m18B2 = varinx18B_1024_e[inx1].inx1;
  n18B2 = varinx18B_1024_e[inx1].inx2;
  o18B2 = varinx18B_1024_e[inx1].inx3;
  p18B2 = varinx18B_1024_f[inx1].inx1;
  q18B2 = varinx18B_1024_f[inx1].inx2;
  r18B2 = varinx18B_1024_f[inx1].inx3;
 }
 else
 {
#pragma empty_line
  a = varinx3_4096_45[inx].inx1;
  b = varinx3_4096_45[inx].inx2;
  c = varinx3_4096_45[inx].inx3;
#pragma empty_line
  d = varinx3_4096_45[inx1].inx1;
  e = varinx3_4096_45[inx1].inx2;
  f = varinx3_4096_45[inx1].inx3;
#pragma empty_line
  a18A = varinx18A_4096_a[inx].inx1;
  b18A = varinx18A_4096_a[inx].inx2;
  c18A = varinx18A_4096_a[inx].inx3;
  d18A = varinx18A_4096_b[inx].inx1;
  e18A = varinx18A_4096_b[inx].inx2;
  f18A = varinx18A_4096_b[inx].inx3;
  g18A = varinx18A_4096_c[inx].inx1;
  h18A = varinx18A_4096_c[inx].inx2;
  i18A = varinx18A_4096_c[inx].inx3;
  j18A = varinx18A_4096_d[inx].inx1;
  k18A = varinx18A_4096_d[inx].inx2;
  l18A = varinx18A_4096_d[inx].inx3;
  m18A = varinx18A_4096_e[inx].inx1;
  n18A = varinx18A_4096_e[inx].inx2;
  o18A = varinx18A_4096_e[inx].inx3;
  p18A = varinx18A_4096_f[inx].inx1;
  q18A = varinx18A_4096_f[inx].inx2;
  r18A = varinx18A_4096_f[inx].inx3;
#pragma empty_line
#pragma empty_line
  a18A2 = varinx18A_4096_a[inx1].inx1;
  b18A2 = varinx18A_4096_a[inx1].inx2;
  c18A2 = varinx18A_4096_a[inx1].inx3;
  d18A2 = varinx18A_4096_b[inx1].inx1;
  e18A2 = varinx18A_4096_b[inx1].inx2;
  f18A2 = varinx18A_4096_b[inx1].inx3;
  g18A2 = varinx18A_4096_c[inx1].inx1;
  h18A2 = varinx18A_4096_c[inx1].inx2;
  i18A2 = varinx18A_4096_c[inx1].inx3;
  j18A2 = varinx18A_4096_d[inx1].inx1;
  k18A2 = varinx18A_4096_d[inx1].inx2;
  l18A2 = varinx18A_4096_d[inx1].inx3;
  m18A2 = varinx18A_4096_e[inx1].inx1;
  n18A2 = varinx18A_4096_e[inx1].inx2;
  o18A2 = varinx18A_4096_e[inx1].inx3;
  p18A2 = varinx18A_4096_f[inx1].inx1;
  q18A2 = varinx18A_4096_f[inx1].inx2;
  r18A2 = varinx18A_4096_f[inx1].inx3;
#pragma empty_line
  a18B = varinx18B_4096_a[inx].inx1;
  b18B = varinx18B_4096_a[inx].inx2;
  c18B = varinx18B_4096_a[inx].inx3;
  d18B = varinx18B_4096_b[inx].inx1;
  e18B = varinx18B_4096_b[inx].inx2;
  f18B = varinx18B_4096_b[inx].inx3;
  g18B = varinx18B_4096_c[inx].inx1;
  h18B = varinx18B_4096_c[inx].inx2;
  i18B = varinx18B_4096_c[inx].inx3;
  j18B = varinx18B_4096_d[inx].inx1;
  k18B = varinx18B_4096_d[inx].inx2;
  l18B = varinx18B_4096_d[inx].inx3;
  m18B = varinx18B_4096_e[inx].inx1;
  n18B = varinx18B_4096_e[inx].inx2;
  o18B = varinx18B_4096_e[inx].inx3;
  p18B = varinx18B_4096_f[inx].inx1;
  q18B = varinx18B_4096_f[inx].inx2;
  r18B = varinx18B_4096_f[inx].inx3;
#pragma empty_line
#pragma empty_line
  a18B2 = varinx18B_4096_a[inx1].inx1;
  b18B2 = varinx18B_4096_a[inx1].inx2;
  c18B2 = varinx18B_4096_a[inx1].inx3;
  d18B2 = varinx18B_4096_b[inx1].inx1;
  e18B2 = varinx18B_4096_b[inx1].inx2;
  f18B2 = varinx18B_4096_b[inx1].inx3;
  g18B2 = varinx18B_4096_c[inx1].inx1;
  h18B2 = varinx18B_4096_c[inx1].inx2;
  i18B2 = varinx18B_4096_c[inx1].inx3;
  j18B2 = varinx18B_4096_d[inx1].inx1;
  k18B2 = varinx18B_4096_d[inx1].inx2;
  l18B2 = varinx18B_4096_d[inx1].inx3;
  m18B2 = varinx18B_4096_e[inx1].inx1;
  n18B2 = varinx18B_4096_e[inx1].inx2;
  o18B2 = varinx18B_4096_e[inx1].inx3;
  p18B2 = varinx18B_4096_f[inx1].inx1;
  q18B2 = varinx18B_4096_f[inx1].inx2;
  r18B2 = varinx18B_4096_f[inx1].inx3;
 }
#pragma empty_line
#pragma empty_line
 eTab[0] = (a) ;
 eTab[1] = (b) ;
 eTab[2] = (c) ;
#pragma empty_line
 eTabE[0] = (d) ;
 eTabE[1] = (e) ;
 eTabE[2] = (f) ;
#pragma empty_line
 lTab[0] = Lam_buf8[(a) ];
 lTab[1] = Lam_buf10[(b) ];
 lTab[2] = Lam_buf10[(c) ];
#pragma empty_line
 lTabE[0] = Lam_buf8[(d) ];
 lTabE[1] = Lam_buf10a[(e) ];
 lTabE[2] = Lam_buf10a[(f) ];
#pragma empty_line
 pTab[0] = SpEtaPrev[inx].one;
 pTab[1] = SpEtaPrev[inx].two;
 pTab[2] = SpEtaPrev[inx].three;
#pragma empty_line
 pTabE[0] = SpEtaPrevC[inx1].one;
 pTabE[1] = SpEtaPrevC[inx1].two;
 pTabE[2] = SpEtaPrevC[inx1].three;
#pragma empty_line
#pragma empty_line
 inx = num_ntA;
#pragma empty_line
 eTabA[0] = a18A;
 eTabA[1] = b18A;
 eTabA[2] = c18A;
 eTabA[3] = (d18A) ;
 eTabA[4] = (e18A) ;
 eTabA[5] = (f18A) ;
 eTabA[6] = (g18A) ;
 eTabA[7] = (h18A) ;
 eTabA[8] = (i18A) ;
 eTabA[9] = (j18A) ;
 eTabA[10] = (k18A) ;
 eTabA[11] = (l18A) ;
 eTabA[12] = (m18A) ;
 eTabA[13] = (n18A) ;
 eTabA[14] = (o18A) ;
 eTabA[15] = (p18A) ;
 eTabA[16] = (q18A) ;
 eTabA[17] = (r18A) ;
#pragma empty_line
 lTabA[0] = Lam_bufAa[a18A];
 lTabA[1] = Lam_bufAb[b18A];
 lTabA[2] = Lam_bufAc[c18A];
 lTabA[3] = Lam_bufA1[(d18A) ];
 lTabA[4] = Lam_bufA2a[(e18A) ];
 lTabA[5] = Lam_bufA2b[(f18A) ];
 lTabA[6] = Lam_bufA2c[(g18A) ];
 lTabA[7] = Lam_bufA3[(h18A) ];
 lTabA[8] = Lam_bufA4a[(i18A) ];
 lTabA[9] = Lam_bufA4b[(j18A) ];
 lTabA[10] = Lam_bufA4c[(k18A) ];
 lTabA[11] = Lam_bufA5[(l18A) ];
 lTabA[12] = Lam_bufA6[(m18A) ];
 lTabA[13] = Lam_bufA7[(n18A) ];
 lTabA[14] = Lam_bufA9[(o18A) ];
 lTabA[15] = Lam_bufA10a[(p18A) ];
 lTabA[16] = Lam_bufA10b[(q18A) ];
 lTabA[17] = Lam_bufA10c[(r18A) ];
#pragma empty_line
 eTabF[0] = a18A2;
 eTabF[1] = b18A2;
 eTabF[2] = c18A2;
 eTabF[3] = (d18A2);
 eTabF[4] = (e18A2) ;
 eTabF[5] = (f18A2) ;
 eTabF[6] = (g18A2) ;
 eTabF[7] = (h18A2) ;
 eTabF[8] = (i18A2) ;
 eTabF[9] = (j18A2) ;
 eTabF[10] = (k18A2) ;
 eTabF[11] = (l18A2) ;
 eTabF[12] = (m18A2) ;
 eTabF[13] = (n18A2) ;
 eTabF[14] = (o18A2) ;
 eTabF[15] = (p18A2) ;
 eTabF[16] = (q18A2) ;
 eTabF[17] = (r18A2) ;
#pragma empty_line
 lTabF[0] = Lam_bufAa[a18A2];
 lTabF[1] = Lam_bufAb[b18A2];
 lTabF[2] = Lam_bufAc[c18A2];
 lTabF[3] = Lam_bufA1[(d18A2) ];
 lTabF[4] = Lam_bufA2a[(e18A2) ];
 lTabF[5] = Lam_bufA2b[(f18A2) ];
 lTabF[6] = Lam_bufA2c[(g18A2) ];
 lTabF[7] = Lam_bufA3[(h18A2) ];
 lTabF[8] = Lam_bufA4a[(i18A2) ];
 lTabF[9] = Lam_bufA4b[(j18A2) ];
 lTabF[10] = Lam_bufA4c[(k18A2) ];
 lTabF[11] = Lam_bufA5[(l18A2) ];
 lTabF[12] = Lam_bufA6[(m18A2) ];
 lTabF[13] = Lam_bufA7[(n18A2) ];
 lTabF[14] = Lam_bufA9[(o18A2) ];
 lTabF[15] = Lam_bufA10a[(p18A2) ];
 lTabF[16] = Lam_bufA10b[(q18A2) ];
 lTabF[17] = Lam_bufA10c[(r18A2) ];
#pragma empty_line
 pTabA[0] = SpEtaPrevA[inx].one;
 pTabA[1] = SpEtaPrevA[inx].two;
 pTabA[2] = SpEtaPrevAa[inx].three;
 pTabA[3] = SpEtaPrevAa[inx].four;
 pTabA[4] = SpEtaPrevAa[inx].five;
 pTabA[5] = SpEtaPrevAa[inx].six;
 pTabA[6] = SpEtaPrevAb[inx].seven;
 pTabA[7] = SpEtaPrevAb[inx].eight;
 pTabA[8] = SpEtaPrevAb[inx].nine;
 pTabA[9] = SpEtaPrevAb[inx].ten;
 pTabA[10] = SpEtaPrevAc[inx].eleven;
 pTabA[11] = SpEtaPrevAc[inx].twelve;
 pTabA[12] = SpEtaPrevAc[inx].thirteen;
 pTabA[13] = SpEtaPrevAc[inx].fourteen;
 pTabA[14] = SpEtaPrevAd[inx].fifteen;
 pTabA[15] = SpEtaPrevAd[inx].sixteen;
 pTabA[16] = SpEtaPrevAd[inx].seventeen;
 pTabA[17] = SpEtaPrevAd[inx].eighteen;
#pragma empty_line
 pTabF[0] = SpEtaPrevD[inx1].one;
 pTabF[1] = SpEtaPrevD[inx1].two;
 pTabF[2] = SpEtaPrevDa[inx1].three;
 pTabF[3] = SpEtaPrevDa[inx1].four;
 pTabF[4] = SpEtaPrevDa[inx1].five;
 pTabF[5] = SpEtaPrevDa[inx1].six;
 pTabF[6] = SpEtaPrevDb[inx1].seven;
 pTabF[7] = SpEtaPrevDb[inx1].eight;
 pTabF[8] = SpEtaPrevDb[inx1].nine;
 pTabF[9] = SpEtaPrevDb[inx1].ten;
 pTabF[10] = SpEtaPrevDc[inx1].eleven;
 pTabF[11] = SpEtaPrevDc[inx1].twelve;
 pTabF[12] = SpEtaPrevDc[inx1].thirteen;
 pTabF[13] = SpEtaPrevDc[inx1].fourteen;
 pTabF[14] = SpEtaPrevDd[inx1].fifteen;
 pTabF[15] = SpEtaPrevDd[inx1].sixteen;
 pTabF[16] = SpEtaPrevDd[inx1].seventeen;
 pTabF[17] = SpEtaPrevDd[inx1].eighteen;
#pragma empty_line
 inx = num_ntB;
#pragma empty_line
 eTabB[0] = a18B;
 eTabB[1] = (b18B) ;
 eTabB[2] = (c18B) ;
 eTabB[3] = (d18B) ;
 eTabB[4] = (e18B) ;
 eTabB[5] = (f18B) ;
 eTabB[6] = (g18B) ;
 eTabB[7] = (h18B) ;
 eTabB[8] = (i18B) ;
 eTabB[9] = (j18B) ;
 eTabB[10] = (k18B) ;
 eTabB[11] = (l18B) ;
 eTabB[12] = (m18B) ;
 eTabB[13] = (n18B) ;
 eTabB[14] = (o18B) ;
 eTabB[15] = (p18B) ;
 eTabB[16] = (q18B) ;
 eTabB[17] = (r18B) ;
#pragma empty_line
 lTabB[0] = Lam_bufB[a18B];
 lTabB[1] = Lam_bufB1a[(b18B) ];
 lTabB[2] = Lam_bufB1b[(c18B) ];
 lTabB[3] = Lam_bufB1c[(d18B) ];
 lTabB[4] = Lam_bufB2[(e18B) ];
 lTabB[5] = Lam_bufB3a[(f18B) ];
 lTabB[6] = Lam_bufB3b[(g18B) ];
 lTabB[7] = Lam_bufB3c[(h18B) ];
 lTabB[8] = Lam_bufB4[(i18B) ];
 lTabB[9] = Lam_bufB5a[(j18B) ];
 lTabB[10] = Lam_bufB5b[(k18B) ];
 lTabB[11] = Lam_bufB5c[(l18B) ];
 lTabB[12] = Lam_bufB6[(m18B) ];
 lTabB[13] = Lam_bufB7a[(n18B) ];
 lTabB[14] = Lam_bufB7b[(o18B) ];
 lTabB[15] = Lam_bufB9a[(p18B) ];
 lTabB[16] = Lam_bufB9b[(q18B) ];
 lTabB[17] = Lam_bufB10[(r18B)];
#pragma empty_line
 eTabG[0] = a18B2;
 eTabG[1] = (b18B2) ;
 eTabG[2] = (c18B2) ;
 eTabG[3] = (d18B2) ;
 eTabG[4] = (e18B2) ;
 eTabG[5] = (f18B2) ;
 eTabG[6] = (g18B2) ;
 eTabG[7] = (h18B2) ;
 eTabG[8] = (i18B2) ;
 eTabG[9] = (j18B2) ;
 eTabG[10] = (k18B2) ;
 eTabG[11] = (l18B2) ;
 eTabG[12] = (m18B2) ;
 eTabG[13] = (n18B2) ;
 eTabG[14] = (o18B2) ;
 eTabG[15] = (p18B2) ;
 eTabG[16] = (q18B2) ;
 eTabG[17] = (r18B2) ;
#pragma empty_line
 lTabG[0] = Lam_bufB[a18B2];
 lTabG[1] = Lam_bufB1a[(b18B2) ];
 lTabG[2] = Lam_bufB1b[(c18B2) ];
 lTabG[3] = Lam_bufB1c[(d18B2) ];
 lTabG[4] = Lam_bufB2[(e18B2) ];
 lTabG[5] = Lam_bufB3a[(f18B2) ];
 lTabG[6] = Lam_bufB3b[(g18B2) ];
 lTabG[7] = Lam_bufB3c[(h18B2) ];
 lTabG[8] = Lam_bufB4[(i18B2) ];
 lTabG[9] = Lam_bufB5a[(j18B2) ];
 lTabG[10] = Lam_bufB5b[(k18B2) ];
 lTabG[11] = Lam_bufB5c[(l18B2) ];
 lTabG[12] = Lam_bufB6[(m18B2) ];
 lTabG[13] = Lam_bufB7a[(n18B2) ];
 lTabG[14] = Lam_bufB7b[(o18B2) ];
 lTabG[15] = Lam_bufB9a[(p18B2) ];
 lTabG[16] = Lam_bufB9b[(q18B2) ];
 lTabG[17] = Lam_bufB10[(r18B2) ];
#pragma empty_line
#pragma empty_line
 pTabB[0] = SpEtaPrevB[inx].one;
 pTabB[1] = SpEtaPrevB[inx].two;
 pTabB[2] = SpEtaPrevBa[inx].three;
 pTabB[3] = SpEtaPrevBa[inx].four;
 pTabB[4] = SpEtaPrevBa[inx].five;
 pTabB[5] = SpEtaPrevBa[inx].six;
 pTabB[6] = SpEtaPrevBb[inx].seven;
 pTabB[7] = SpEtaPrevBb[inx].eight;
 pTabB[8] = SpEtaPrevBb[inx].nine;
 pTabB[9] = SpEtaPrevBb[inx].ten;
 pTabB[10] = SpEtaPrevBc[inx].eleven;
 pTabB[11] = SpEtaPrevBc[inx].twelve;
 pTabB[12] = SpEtaPrevBc[inx].thirteen;
 pTabB[13] = SpEtaPrevBc[inx].fourteen;
 pTabB[14] = SpEtaPrevBd[inx].fifteen;
 pTabB[15] = SpEtaPrevBd[inx].sixteen;
 pTabB[16] = SpEtaPrevBd[inx].seventeen;
 pTabB[17] = SpEtaPrevBd[inx].eighteen;
#pragma empty_line
 pTabG[0] = SpEtaPrevE[inx1].one;
 pTabG[1] = SpEtaPrevE[inx1].two;
 pTabG[2] = SpEtaPrevEa[inx1].three;
 pTabG[3] = SpEtaPrevEa[inx1].four;
 pTabG[4] = SpEtaPrevEa[inx1].five;
 pTabG[5] = SpEtaPrevEa[inx1].six;
 pTabG[6] = SpEtaPrevEb[inx1].seven;
 pTabG[7] = SpEtaPrevEb[inx1].eight;
 pTabG[8] = SpEtaPrevEb[inx1].nine;
 pTabG[9] = SpEtaPrevEb[inx1].ten;
 pTabG[10] = SpEtaPrevEc[inx1].eleven;
 pTabG[11] = SpEtaPrevEc[inx1].twelve;
 pTabG[12] = SpEtaPrevEc[inx1].thirteen;
 pTabG[13] = SpEtaPrevEc[inx1].fourteen;
 pTabG[14] = SpEtaPrevEd[inx1].fifteen;
 pTabG[15] = SpEtaPrevEd[inx1].sixteen;
 pTabG[16] = SpEtaPrevEd[inx1].seventeen;
 pTabG[17] = SpEtaPrevEd[inx1].eighteen;
#pragma empty_line
#pragma empty_line
 if (nIterationCounter == 0)
 {
#pragma empty_line
  pTab[0] = 0;
  pTab[1] = 0;
  pTab[2] = 0;
#pragma empty_line
  pTabE[0] = 0;
  pTabE[1] = 0;
  pTabE[2] = 0;
#pragma empty_line
  pTabA[0] = 0;
  pTabA[1] = 0;
  pTabA[2] = 0;
  pTabA[3] = 0;
  pTabA[4] = 0;
  pTabA[5] = 0;
  pTabA[6] = 0;
  pTabA[7] = 0;
  pTabA[8] = 0;
  pTabA[9] = 0;
  pTabA[10] = 0;
  pTabA[11] = 0;
  pTabA[12] = 0;
  pTabA[13] = 0;
  pTabA[14] = 0;
  pTabA[15] = 0;
  pTabA[16] = 0;
  pTabA[17] = 0;
#pragma empty_line
  pTabF[0] = 0;
  pTabF[1] = 0;
  pTabF[2] = 0;
  pTabF[3] = 0;
  pTabF[4] = 0;
  pTabF[5] = 0;
  pTabF[6] = 0;
  pTabF[7] = 0;
  pTabF[8] = 0;
  pTabF[9] = 0;
  pTabF[10] = 0;
  pTabF[11] = 0;
  pTabF[12] = 0;
  pTabF[13] = 0;
  pTabF[14] = 0;
  pTabF[15] = 0;
  pTabF[16] = 0;
  pTabF[17] = 0;
#pragma empty_line
  pTabB[0] = 0;
  pTabB[1] = 0;
  pTabB[2] = 0;
  pTabB[3] = 0;
  pTabB[4] = 0;
  pTabB[5] = 0;
  pTabB[6] = 0;
  pTabB[7] = 0;
  pTabB[8] = 0;
  pTabB[9] = 0;
  pTabB[10] = 0;
  pTabB[11] = 0;
  pTabB[12] = 0;
  pTabB[13] = 0;
  pTabB[14] = 0;
  pTabB[15] = 0;
  pTabB[16] = 0;
  pTabB[17] = 0;
#pragma empty_line
  pTabG[0] = 0;
  pTabG[1] = 0;
  pTabG[2] = 0;
  pTabG[3] = 0;
  pTabG[4] = 0;
  pTabG[5] = 0;
  pTabG[6] = 0;
  pTabG[7] = 0;
  pTabG[8] = 0;
  pTabG[9] = 0;
  pTabG[10] = 0;
  pTabG[11] = 0;
  pTabG[12] = 0;
  pTabG[13] = 0;
  pTabG[14] = 0;
  pTabG[15] = 0;
  pTabG[16] = 0;
  pTabG[17] = 0;
#pragma empty_line
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
#pragma empty_line
void write_result(tab_int len, tab_int len1, tab_int len2, tab_int len3, bool prevflg)
{
 short inx;
 bool par_chk;
#pragma empty_line
 bool AllChecksPassed = false;
 bool parity, parityA, parityB;
 bool parity1, parityA1, parityB1;
 bool parity2, parityA2, parityB2;
 bool parity3, parityA3, parityB3;
#pragma empty_line
 AllChecksPassed = true;
#pragma empty_line
 inx = inxtab[0];
#pragma empty_line
 prLam_buf2[Eta_tabx[0]] += Eta_ans[0];
 prLam_buf4[Eta_tabx[1]] += Eta_ans[1];
 prLam_buf4a[Eta_tabx[2]] += Eta_ans[2];
#pragma empty_line
 prLam2_buf2[Eta_tabe[0]] += Eta_ans_3[0];
 prLam2_buf4[Eta_tabe[1]] += Eta_ans_3[1];
 prLam2_buf4a[Eta_tabe[2]] += Eta_ans_3[2];
#pragma empty_line
 parity = prHat_buf8[Eta_tabx[0]] ^ prHat_buf10[Eta_tabx[1]] ^ prHat_buf10b[Eta_tabx[2]];
 parity1 = prHat_buf8[Eta_tabe[0]] ^ prHat_buf10a[Eta_tabe[1]] ^ prHat_buf10a[Eta_tabe[2]];
#pragma empty_line
#pragma empty_line
 inx = inxtab[1];
#pragma empty_line
 prLamC_buf[Eta_taby[0]]+= Eta_ans_1[0];
 prLamC_bufa[Eta_taby[1]]+= Eta_ans_1[1];
 prLamC_bufb[Eta_taby[2]]+= Eta_ans_1[2];
 prLamC_buf1[Eta_taby[3]]+= Eta_ans_1[3];
 prLamC_buf2[Eta_taby[4]]+= Eta_ans_1[4];
 prLamC_buf2a[Eta_taby[5]]+= Eta_ans_1[5];
 prLamC_buf2b[Eta_taby[6]]+= Eta_ans_1[6];
 prLamC_buf3[Eta_taby[7]]+= Eta_ans_1[7];
 prLamC_buf4[Eta_taby[8]]+= Eta_ans_1[8];
 prLamC_buf4a[Eta_taby[9]]+= Eta_ans_1[9];
 prLamC_buf4b[Eta_taby[10]]+= Eta_ans_1[10];
 prLamC_buf5[Eta_taby[11]]+= Eta_ans_1[11];
 prLamC_buf6[Eta_taby[12]]+= Eta_ans_1[12];
 prLamC_buf7[Eta_taby[13]]+= Eta_ans_1[13];
 prLamC_buf9[Eta_taby[14]]+= Eta_ans_1[14];
 prLamC_buf10[Eta_taby[15]]+= Eta_ans_1[15];
 prLamC_buf10a[Eta_taby[16]]+= Eta_ans_1[16];
 prLamC_buf10b[Eta_taby[17]]+= Eta_ans_1[17];
#pragma empty_line
 prLam2C_buf[Eta_tabf[0]]+= Eta_ans_4[0];
 prLam2C_bufa[Eta_tabf[1]]+= Eta_ans_4[1];
 prLam2C_bufb[Eta_tabf[2]]+= Eta_ans_4[2];
 prLam2C_buf1[Eta_tabf[3]]+= Eta_ans_4[3];
 prLam2C_buf2[Eta_tabf[4]]+= Eta_ans_4[4];
 prLam2C_buf2a[Eta_tabf[5]]+= Eta_ans_4[5];
 prLam2C_buf2b[Eta_tabf[6]]+= Eta_ans_4[6];
 prLam2C_buf3[Eta_tabf[7]]+= Eta_ans_4[7];
 prLam2C_buf4[Eta_tabf[8]]+= Eta_ans_4[8];
 prLam2C_buf4a[Eta_tabf[9]]+= Eta_ans_4[9];
 prLam2C_buf4b[Eta_tabf[10]]+= Eta_ans_4[10];
 prLam2C_buf5[Eta_tabf[11]]+= Eta_ans_4[11];
 prLam2C_buf6[Eta_tabf[12]]+= Eta_ans_4[12];
 prLam2C_buf7[Eta_tabf[13]]+= Eta_ans_4[13];
 prLam2C_buf9[Eta_tabf[14]]+= Eta_ans_4[14];
 prLam2C_buf10[Eta_tabf[15]]+= Eta_ans_4[15];
 prLam2C_buf10a[Eta_tabf[16]]+= Eta_ans_4[16];
 prLam2C_buf10b[Eta_tabf[17]]+= Eta_ans_4[17];
#pragma empty_line
#pragma empty_line
 parityA = prHat_bufA[Eta_taby[0]] ^ prHat_bufA[Eta_taby[1]] ^ prHat_bufAb[Eta_taby[2]] ^
   prHat_bufA1[Eta_taby[3]] ^ prHat_bufA2[Eta_taby[4]] ^ prHat_bufA2[Eta_taby[5]] ^
   prHat_bufA2b[Eta_taby[6]] ^ prHat_bufA3[Eta_taby[7]] ^ prHat_bufA4[Eta_taby[8]] ^
   prHat_bufA4[Eta_taby[9]] ^ prHat_bufA4b[Eta_taby[10]] ^ prHat_bufA5[Eta_taby[11]] ^
   prHat_bufA6[Eta_taby[12]] ^ prHat_bufA7[Eta_taby[13]] ^ prHat_bufA9[Eta_taby[14]] ^
   prHat_bufA10[Eta_taby[15]] ^ prHat_bufA10[Eta_taby[16]] ^ prHat_bufA10b[Eta_taby[17]];
#pragma empty_line
 parityA1 = prHat_bufAa[Eta_tabf[0]] ^ prHat_bufAa[Eta_tabf[1]] ^ prHat_bufAc[Eta_tabf[2]] ^
   prHat_bufA1[Eta_tabf[3]] ^ prHat_bufA2a[Eta_tabf[4]] ^ prHat_bufA2a[Eta_tabf[5]] ^
   prHat_bufA2c[Eta_tabf[6]] ^ prHat_bufA3[Eta_tabf[7]] ^ prHat_bufA4a[Eta_tabf[8]] ^
   prHat_bufA4a[Eta_tabf[9]] ^ prHat_bufA4b[Eta_tabf[10]] ^ prHat_bufA5[Eta_tabf[11]] ^
   prHat_bufA6a[Eta_tabf[12]] ^ prHat_bufA7[Eta_tabf[13]] ^ prHat_bufA9[Eta_tabf[14]] ^
   prHat_bufA10a[Eta_tabf[15]] ^ prHat_bufA10a[Eta_tabf[16]] ^ prHat_bufA10c[Eta_tabf[17]];
#pragma empty_line
#pragma empty_line
 inx = inxtab[2];
#pragma empty_line
#pragma empty_line
 prLamB_buf[Eta_tabz[0]]+= Eta_ans_2[0];
 prLamB_buf1[Eta_tabz[1]]+= Eta_ans_2[1];
 prLamB_buf1a[Eta_tabz[2]]+= Eta_ans_2[2];
 prLamB_buf1b[Eta_tabz[3]]+= Eta_ans_2[3];
 prLamB_buf2[Eta_tabz[4]]+= Eta_ans_2[4];
 prLamB_buf3[Eta_tabz[5]]+= Eta_ans_2[5];
 prLamB_buf3a[Eta_tabz[6]]+= Eta_ans_2[6];
 prLamB_buf3b[Eta_tabz[7]]+= Eta_ans_2[7];
 prLamB_buf4[Eta_tabz[8]]+= Eta_ans_2[8];
 prLamB_buf5[Eta_tabz[9]]+= Eta_ans_2[9];
 prLamB_buf5a[Eta_tabz[10]]+= Eta_ans_2[10];
 prLamB_buf5b[Eta_tabz[11]]+= Eta_ans_2[11];
 prLamB_buf6[Eta_tabz[12]]+= Eta_ans_2[12];
 prLamB_buf7[Eta_tabz[13]]+= Eta_ans_2[13];
 prLamB_buf7a[Eta_tabz[14]]+= Eta_ans_2[14];
 prLamB_buf9[Eta_tabz[15]]+= Eta_ans_2[15];
 prLamB_buf9a[Eta_tabz[16]]+= Eta_ans_2[16];
 prLamB_buf10[Eta_tabz[17]]+= Eta_ans_2[17];
#pragma empty_line
 prLam2B_buf[Eta_tabg[0]]+= Eta_ans_5[0];
 prLam2B_buf1[Eta_tabg[1]]+= Eta_ans_5[1];
 prLam2B_buf1a[Eta_tabg[2]]+= Eta_ans_5[2];
 prLam2B_buf1b[Eta_tabg[3]]+= Eta_ans_5[3];
 prLam2B_buf2[Eta_tabg[4]]+= Eta_ans_5[4];
 prLam2B_buf3[Eta_tabg[5]]+= Eta_ans_5[5];
 prLam2B_buf3a[Eta_tabg[6]]+= Eta_ans_5[6];
 prLam2B_buf3b[Eta_tabg[7]]+= Eta_ans_5[7];
 prLam2B_buf4[Eta_tabg[8]]+= Eta_ans_5[8];
 prLam2B_buf5[Eta_tabg[9]]+= Eta_ans_5[9];
 prLam2B_buf5a[Eta_tabg[10]]+= Eta_ans_5[10];
 prLam2B_buf5b[Eta_tabg[11]]+= Eta_ans_5[11];
 prLam2B_buf6[Eta_tabg[12]]+= Eta_ans_5[12];
 prLam2B_buf7[Eta_tabg[13]]+= Eta_ans_5[13];
 prLam2B_buf7a[Eta_tabg[14]]+= Eta_ans_5[14];
 prLam2B_buf9[Eta_tabg[15]]+= Eta_ans_5[15];
 prLam2B_buf9a[Eta_tabg[16]]+= Eta_ans_5[16];
 prLam2B_buf10[Eta_tabg[17]]+= Eta_ans_5[17];
#pragma empty_line
#pragma empty_line
 SpEtaPrevB[inx].one = Eta_ans_2[0];
 SpEtaPrevB[inx].two = Eta_ans_2[1];
 SpEtaPrevBa[inx].three = Eta_ans_2[2];
 SpEtaPrevBa[inx].four = Eta_ans_2[3];
 SpEtaPrevBa[inx].five = Eta_ans_2[4];
 SpEtaPrevBa[inx].six = Eta_ans_2[5];
 SpEtaPrevBb[inx].seven = Eta_ans_2[6];
 SpEtaPrevBb[inx].eight = Eta_ans_2[7];
 SpEtaPrevBb[inx].nine = Eta_ans_2[8];
 SpEtaPrevBb[inx].ten = Eta_ans_2[9];
 SpEtaPrevBc[inx].eleven = Eta_ans_2[10];
 SpEtaPrevBc[inx].twelve = Eta_ans_2[11];
 SpEtaPrevBc[inx].thirteen = Eta_ans_2[12];
 SpEtaPrevBc[inx].fourteen = Eta_ans_2[13];
 SpEtaPrevBd[inx].fifteen = Eta_ans_2[14];
 SpEtaPrevBd[inx].sixteen = Eta_ans_2[15];
 SpEtaPrevBd[inx].seventeen = Eta_ans_2[16];
 SpEtaPrevBd[inx].eighteen = Eta_ans_2[17];
#pragma empty_line
 SpEtaPrevE[inx+1].one = Eta_ans_5[0];
 SpEtaPrevE[inx+1].two = Eta_ans_5[1];
 SpEtaPrevEa[inx+1].three = Eta_ans_5[2];
 SpEtaPrevEa[inx+1].four = Eta_ans_5[3];
 SpEtaPrevEa[inx+1].five = Eta_ans_5[4];
 SpEtaPrevEa[inx+1].six = Eta_ans_5[5];
 SpEtaPrevEb[inx+1].seven = Eta_ans_5[6];
 SpEtaPrevEb[inx+1].eight = Eta_ans_5[7];
 SpEtaPrevEb[inx+1].nine = Eta_ans_5[8];
 SpEtaPrevEb[inx+1].ten = Eta_ans_5[9];
 SpEtaPrevEc[inx+1].eleven = Eta_ans_5[10];
 SpEtaPrevEc[inx+1].twelve = Eta_ans_5[11];
 SpEtaPrevEc[inx+1].thirteen = Eta_ans_5[12];
 SpEtaPrevEc[inx+1].fourteen = Eta_ans_5[13];
 SpEtaPrevEd[inx+1].fifteen = Eta_ans_5[14];
 SpEtaPrevEd[inx+1].sixteen = Eta_ans_5[15];
 SpEtaPrevEd[inx+1].seventeen = Eta_ans_5[16];
 SpEtaPrevEd[inx+1].eighteen = Eta_ans_5[17];
#pragma empty_line
 SpEtaPrev[inx].one = Eta_ans[0];
 SpEtaPrev[inx].two = Eta_ans[1];
 SpEtaPrev[inx].three = Eta_ans[2];
#pragma empty_line
 SpEtaPrevC[inx+1].one = Eta_ans_3[0];
 SpEtaPrevC[inx+1].two = Eta_ans_3[1];
 SpEtaPrevC[inx+1].three = Eta_ans_3[2];
#pragma empty_line
 SpEtaPrevA[inx].one = Eta_ans_1[0];
 SpEtaPrevA[inx].two = Eta_ans_1[1];
 SpEtaPrevAa[inx].three = Eta_ans_1[2];
 SpEtaPrevAa[inx].four = Eta_ans_1[3];
 SpEtaPrevAa[inx].five = Eta_ans_1[4];
 SpEtaPrevAa[inx].six = Eta_ans_1[5];
 SpEtaPrevAb[inx].seven = Eta_ans_1[6];
 SpEtaPrevAb[inx].eight = Eta_ans_1[7];
 SpEtaPrevAb[inx].nine = Eta_ans_1[8];
 SpEtaPrevAb[inx].ten = Eta_ans_1[9];
 SpEtaPrevAc[inx].eleven = Eta_ans_1[10];
 SpEtaPrevAc[inx].twelve = Eta_ans_1[11];
 SpEtaPrevAc[inx].thirteen = Eta_ans_1[12];
 SpEtaPrevAc[inx].fourteen = Eta_ans_1[13];
 SpEtaPrevAd[inx].fifteen = Eta_ans_1[14];
 SpEtaPrevAd[inx].sixteen = Eta_ans_1[15];
 SpEtaPrevAd[inx].seventeen = Eta_ans_1[16];
 SpEtaPrevAd[inx].eighteen = Eta_ans_1[17];
#pragma empty_line
 SpEtaPrevD[inx+1].one = Eta_ans_4[0];
 SpEtaPrevD[inx+1].two = Eta_ans_4[1];
 SpEtaPrevDa[inx+1].three = Eta_ans_4[2];
 SpEtaPrevDa[inx+1].four = Eta_ans_4[3];
 SpEtaPrevDa[inx+1].five = Eta_ans_4[4];
 SpEtaPrevDa[inx+1].six = Eta_ans_4[5];
 SpEtaPrevDb[inx+1].seven = Eta_ans_4[6];
 SpEtaPrevDb[inx+1].eight = Eta_ans_4[7];
 SpEtaPrevDb[inx+1].nine = Eta_ans_4[8];
 SpEtaPrevDb[inx+1].ten = Eta_ans_4[9];
 SpEtaPrevDc[inx+1].eleven = Eta_ans_4[10];
 SpEtaPrevDc[inx+1].twelve = Eta_ans_4[11];
 SpEtaPrevDc[inx+1].thirteen = Eta_ans_4[12];
 SpEtaPrevDc[inx+1].fourteen = Eta_ans_4[13];
 SpEtaPrevDd[inx+1].fifteen = Eta_ans_4[14];
 SpEtaPrevDd[inx+1].sixteen = Eta_ans_4[15];
 SpEtaPrevDd[inx+1].seventeen = Eta_ans_4[16];
 SpEtaPrevDd[inx+1].eighteen = Eta_ans_4[17];
#pragma empty_line
#pragma empty_line
 parityB = prHat_bufB[Eta_tabz[0]] ^ prHat_bufB1[Eta_tabz[1]] ^ prHat_bufB1b[Eta_tabz[2]] ^
   prHat_bufB1[Eta_tabz[3]] ^ prHat_bufB2[Eta_tabz[4]] ^ prHat_bufB3[Eta_tabz[5]] ^
   prHat_bufB3[Eta_tabz[6]] ^ prHat_bufB3b[Eta_tabz[7]] ^ prHat_bufB4[Eta_tabz[8]] ^
   prHat_bufB5[Eta_tabz[9]] ^ prHat_bufB5[Eta_tabz[10]] ^ prHat_bufB5b[Eta_tabz[11]] ^
   prHat_bufB6[Eta_tabz[12]] ^ prHat_bufB7[Eta_tabz[13]] ^ prHat_bufB7[Eta_tabz[14]] ^
   prHat_bufB9[Eta_tabz[15]] ^ prHat_bufB9[Eta_tabz[16]] ^ prHat_bufB10[Eta_tabz[17]];
#pragma empty_line
 parityB1 = prHat_bufB[Eta_tabg[0]] ^ prHat_bufB1a[Eta_tabg[1]] ^ prHat_bufB1a[Eta_tabg[2]] ^
   prHat_bufB1c[Eta_tabg[3]] ^ prHat_bufB2[Eta_tabg[4]] ^ prHat_bufB3a[Eta_tabg[5]] ^
   prHat_bufB3a[Eta_tabg[6]] ^ prHat_bufB3c[Eta_tabg[7]] ^ prHat_bufB4[Eta_tabg[8]] ^
   prHat_bufB5a[Eta_tabg[9]] ^ prHat_bufB5a[Eta_tabg[10]] ^ prHat_bufB5c[Eta_tabg[11]] ^
   prHat_bufB6[Eta_tabg[12]] ^ prHat_bufB7a[Eta_tabg[13]] ^ prHat_bufB7a[Eta_tabg[14]] ^
   prHat_bufB9a[Eta_tabg[15]] ^ prHat_bufB9a[Eta_tabg[16]] ^ prHat_bufB10[Eta_tabg[17]];
#pragma empty_line
#pragma empty_line
 if ( (parity || parity1 || parityA || parityA1 ||
   parityB || parityB1) == true)
 {
  bAllChecksPassed = false;
 }
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
void write_result_23(tab_int len, tab_int len1, tab_int len2, tab_int len3, bool prevflg)
{
 short inx;
 bool par_chk;
#pragma empty_line
 bool AllChecksPassed = false;
 bool parity, parityA, parityB;
 bool parity1, parityA1, parityB1;
 bool parity2, parityA2, parityB2;
 bool parity3, parityA3, parityB3;
#pragma empty_line
 AllChecksPassed = true;
#pragma empty_line
 inx = inxtab[0];
#pragma empty_line
 SpEtaPrev[inx].one = Eta_ans[0];
 SpEtaPrev[inx].two = Eta_ans[1];
 SpEtaPrev[inx].three = Eta_ans[2];
#pragma empty_line
 SpEtaPrevC[inx+1].one = Eta_ans_3[0];
 SpEtaPrevC[inx+1].two = Eta_ans_3[1];
 SpEtaPrevC[inx+1].three = Eta_ans_3[2];
#pragma empty_line
 prLam_buf4[Eta_tabx[0]] += Eta_ans[0];
 prLam_buf2[Eta_tabx[1]] += Eta_ans[1];
 prLam_buf4a[Eta_tabx[2]] += Eta_ans[2];
#pragma empty_line
 prLam2_buf4[Eta_tabe[0]] += Eta_ans_3[0];
 prLam2_buf2[Eta_tabe[1]] += Eta_ans_3[1];
 prLam2_buf4a[Eta_tabe[2]] += Eta_ans_3[2];
#pragma empty_line
 parity = prHat_buf4[Eta_tabx[0]] ^ prHat_buf6[Eta_tabx[1]] ^ prHat_buf6[Eta_tabx[2]];
 parity1 = prHat_buf4a[Eta_tabe[0]] ^ prHat_buf6a[Eta_tabe[1]] ^ prHat_buf6a[Eta_tabe[2]];
#pragma empty_line
#pragma empty_line
 inx = inxtab[1];
#pragma empty_line
 prLamC_buf[Eta_taby[0]]+= Eta_ans_1[0];
 prLamC_bufa[Eta_taby[1]]+= Eta_ans_1[1];
 prLamC_bufb[Eta_taby[2]]+= Eta_ans_1[2];
 prLamC_buf1[Eta_taby[3]]+= Eta_ans_1[3];
 prLamC_buf2[Eta_taby[4]]+= Eta_ans_1[4];
 prLamC_buf3[Eta_taby[5]]+= Eta_ans_1[5];
 prLamC_buf5[Eta_taby[6]]+= Eta_ans_1[6];
 prLamC_buf6[Eta_taby[7]]+= Eta_ans_1[7];
 prLamC_buf10a[Eta_taby[8]]+= Eta_ans_1[8];
 prLamC_buf10b[Eta_taby[9]]+= Eta_ans_1[9];
#pragma empty_line
 prLam2C_buf[Eta_tabf[0]]+= Eta_ans_4[0];
 prLam2C_bufa[Eta_tabf[1]]+= Eta_ans_4[1];
 prLam2C_bufb[Eta_tabf[2]]+= Eta_ans_4[2];
 prLam2C_buf1[Eta_tabf[3]]+= Eta_ans_4[3];
 prLam2C_buf2[Eta_tabf[4]]+= Eta_ans_4[4];
 prLam2C_buf3[Eta_tabf[5]]+= Eta_ans_4[5];
 prLam2C_buf5[Eta_tabf[6]]+= Eta_ans_4[6];
 prLam2C_buf6[Eta_tabf[7]]+= Eta_ans_4[7];
 prLam2C_buf10a[Eta_tabf[8]]+= Eta_ans_4[8];
 prLam2C_buf10b[Eta_tabf[9]]+= Eta_ans_4[9];
#pragma empty_line
 SpEtaPrevA[inx].one = Eta_ans_1[0];
 SpEtaPrevA[inx].two = Eta_ans_1[1];
 SpEtaPrevAa[inx].three = Eta_ans_1[2];
 SpEtaPrevAa[inx].four = Eta_ans_1[3];
 SpEtaPrevAa[inx].five = Eta_ans_1[4];
 SpEtaPrevAa[inx].six = Eta_ans_1[5];
 SpEtaPrevAb[inx].seven = Eta_ans_1[6];
 SpEtaPrevAb[inx].eight = Eta_ans_1[7];
 SpEtaPrevAb[inx].nine = Eta_ans_1[8];
 SpEtaPrevAb[inx].ten = Eta_ans_1[9];
#pragma empty_line
 SpEtaPrevD[inx+1].one = Eta_ans_4[0];
 SpEtaPrevD[inx+1].two = Eta_ans_4[1];
 SpEtaPrevDa[inx+1].three = Eta_ans_4[2];
 SpEtaPrevDa[inx+1].four = Eta_ans_4[3];
 SpEtaPrevDa[inx+1].five = Eta_ans_4[4];
 SpEtaPrevDa[inx+1].six = Eta_ans_4[5];
 SpEtaPrevDb[inx+1].seven = Eta_ans_4[6];
 SpEtaPrevDb[inx+1].eight = Eta_ans_4[7];
 SpEtaPrevDb[inx+1].nine = Eta_ans_4[8];
 SpEtaPrevDb[inx+1].ten = Eta_ans_4[9];
#pragma empty_line
 parityA = prHat_bufA[Eta_taby[0]] ^ prHat_bufA[Eta_taby[1]] ^ prHat_bufAb[Eta_taby[2]] ^
   prHat_bufA1[Eta_taby[3]] ^ prHat_bufA2[Eta_taby[4]] ^ prHat_bufA3[Eta_taby[5]] ^
   prHat_bufA5[Eta_taby[6]] ^ prHat_bufA6[Eta_taby[7]] ^ prHat_bufA6[Eta_taby[8]] ^
   prHat_bufA6b[Eta_taby[9]] ;
#pragma empty_line
 parityA1 = prHat_bufAa[Eta_tabf[0]] ^ prHat_bufAa[Eta_tabf[1]] ^ prHat_bufAc[Eta_tabf[2]] ^
   prHat_bufA1[Eta_tabf[3]] ^ prHat_bufA2a[Eta_tabf[4]] ^ prHat_bufA3[Eta_tabf[5]] ^
   prHat_bufA5[Eta_tabf[6]] ^ prHat_bufA6a[Eta_tabf[7]] ^ prHat_bufA6a[Eta_tabf[8]] ^
   prHat_bufA6c[Eta_tabf[9]] ;
#pragma empty_line
#pragma empty_line
 inx = inxtab[2];
#pragma empty_line
#pragma empty_line
 prLamB_buf[Eta_tabz[0]]+= Eta_ans_2[0];
 prLamB_buf1[Eta_tabz[1]]+= Eta_ans_2[1];
 prLamB_buf1a[Eta_tabz[2]]+= Eta_ans_2[2];
 prLamB_buf1b[Eta_tabz[3]]+= Eta_ans_2[3];
 prLamB_buf2[Eta_tabz[4]]+= Eta_ans_2[4];
 prLamB_buf3[Eta_tabz[5]]+= Eta_ans_2[5];
 prLamB_buf3a[Eta_tabz[6]]+= Eta_ans_2[6];
 prLamB_buf5[Eta_tabz[7]]+= Eta_ans_2[7];
 prLamB_buf5a[Eta_tabz[8]]+= Eta_ans_2[8];
 prLamB_buf6[Eta_tabz[9]]+= Eta_ans_2[9];
#pragma empty_line
 prLam2B_buf[Eta_tabg[0]]+= Eta_ans_5[0];
 prLam2B_buf1[Eta_tabg[1]]+= Eta_ans_5[1];
 prLam2B_buf1a[Eta_tabg[2]]+= Eta_ans_5[2];
 prLam2B_buf1b[Eta_tabg[3]]+= Eta_ans_5[3];
 prLam2B_buf2[Eta_tabg[4]]+= Eta_ans_5[4];
 prLam2B_buf3[Eta_tabg[5]]+= Eta_ans_5[5];
 prLam2B_buf3a[Eta_tabg[6]]+= Eta_ans_5[6];
 prLam2B_buf5[Eta_tabg[7]]+= Eta_ans_5[7];
 prLam2B_buf5a[Eta_tabg[8]]+= Eta_ans_5[8];
 prLam2B_buf6[Eta_tabg[9]]+= Eta_ans_5[9];
#pragma empty_line
 SpEtaPrevB[inx].one = Eta_ans_2[0];
 SpEtaPrevB[inx].two = Eta_ans_2[1];
 SpEtaPrevBa[inx].three = Eta_ans_2[2];
 SpEtaPrevBa[inx].four = Eta_ans_2[3];
 SpEtaPrevBa[inx].five = Eta_ans_2[4];
 SpEtaPrevBa[inx].six = Eta_ans_2[5];
 SpEtaPrevBb[inx].seven = Eta_ans_2[6];
 SpEtaPrevBb[inx].eight = Eta_ans_2[7];
 SpEtaPrevBb[inx].nine = Eta_ans_2[8];
 SpEtaPrevBb[inx].ten = Eta_ans_2[9];
#pragma empty_line
 SpEtaPrevE[inx+1].one = Eta_ans_5[0];
 SpEtaPrevE[inx+1].two = Eta_ans_5[1];
 SpEtaPrevEa[inx+1].three = Eta_ans_5[2];
 SpEtaPrevEa[inx+1].four = Eta_ans_5[3];
 SpEtaPrevEa[inx+1].five = Eta_ans_5[4];
 SpEtaPrevEa[inx+1].six = Eta_ans_5[5];
 SpEtaPrevEb[inx+1].seven = Eta_ans_5[6];
 SpEtaPrevEb[inx+1].eight = Eta_ans_5[7];
 SpEtaPrevEb[inx+1].nine = Eta_ans_5[8];
 SpEtaPrevEb[inx+1].ten = Eta_ans_5[9];
#pragma empty_line
#pragma empty_line
 parityB = prHat_bufB[Eta_tabz[0]] ^ prHat_bufB1[Eta_tabz[1]] ^ prHat_bufB1[Eta_tabz[2]] ^
   prHat_bufB1b[Eta_tabz[3]] ^ prHat_bufB2[Eta_tabz[4]] ^ prHat_bufB3[Eta_tabz[5]] ^
   prHat_bufB3b[Eta_tabz[6]] ^ prHat_bufB5[Eta_tabz[7]] ^ prHat_bufB5b[Eta_tabz[8]] ^
   prHat_bufB6[Eta_tabz[9]] ;
#pragma empty_line
 parityB1 = prHat_bufB[Eta_tabg[0]] ^ prHat_bufB1a[Eta_tabg[1]] ^ prHat_bufB1a[Eta_tabg[2]] ^
   prHat_bufB1c[Eta_tabg[3]] ^ prHat_bufB2[Eta_tabg[4]] ^ prHat_bufB3a[Eta_tabg[5]] ^
   prHat_bufB3c[Eta_tabg[6]] ^ prHat_bufB5a[Eta_tabg[7]] ^ prHat_bufB5c[Eta_tabg[8]] ^
   prHat_bufB6[Eta_tabg[9]];
#pragma empty_line
#pragma empty_line
 if ( (parity || parity1 || parityA || parityA1 ||
   parityB || parityB1) == true)
 {
  bAllChecksPassed = false;
 }
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
void write_result_12(tab_int len, tab_int len1, tab_int len2, tab_int len3, bool prevflg)
{
 short inx;
 bool par_chk;
#pragma empty_line
 bool AllChecksPassed = false;
 bool parity, parityA, parityB;
 bool parity1, parityA1, parityB1;
 bool parity2, parityA2, parityB2;
 bool parity3, parityA3, parityB3;
#pragma empty_line
 AllChecksPassed = true;
#pragma empty_line
 inx = inxtab[0];
#pragma empty_line
 SpEtaPrev[inx].one = Eta_ans[0];
 SpEtaPrev[inx].two = Eta_ans[1];
 SpEtaPrev[inx].three = Eta_ans[2];
#pragma empty_line
 SpEtaPrevC[inx+1].one = Eta_ans_3[0];
 SpEtaPrevC[inx+1].two = Eta_ans_3[1];
 SpEtaPrevC[inx+1].three = Eta_ans_3[2];
#pragma empty_line
 if (Eta_tabx[0] <1024)
  prLam_buf2[Eta_tabx[0]] += Eta_ans[0];
 else
  prLamB_buf6[Eta_tabx[0] -1024 ] += Eta_ans[0];
 if (Eta_tabx[1] < 1024)
  prLam_buf4[Eta_tabx[1]] += Eta_ans[1];
 else
  prLamB_buf9a[Eta_tabx[1] -1024 ] += Eta_ans[1];
 if (Eta_tabx[2] < 1024)
  prLam_buf4a[Eta_tabx[2]] += Eta_ans[2];
 else
  prLamB_buf10[Eta_tabx[2]-1024 ] += Eta_ans[2];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 if (Eta_tabe[0] <1024)
  prLam2_buf2[Eta_tabe[0]] += Eta_ans_3[0];
 else
  prLam2B_buf6[Eta_tabe[0] -1024 ] += Eta_ans_3[0];
 if (Eta_tabe[1] < 1024)
  prLam2_buf4[Eta_tabe[1]] += Eta_ans_3[1];
 else
  prLam2B_buf9a[Eta_tabe[1] -1024 ] += Eta_ans_3[1];
 if (Eta_tabe[2] < 1024)
  prLam2_buf4a[Eta_tabe[2]] += Eta_ans_3[2];
 else
  prLam2B_buf10[Eta_tabe[2]-1024 ] += Eta_ans_3[2];
#pragma empty_line
#pragma empty_line
 parity = prHat_buf2[Eta_tabx[0]] ^ prHat_buf4[Eta_tabx[1]] ^ prHat_buf4[Eta_tabx[2]];
 parity1 = prHat_buf2[Eta_tabe[0]] ^ prHat_buf4a[Eta_tabe[1]] ^ prHat_buf4a[Eta_tabe[2]];
#pragma empty_line
#pragma empty_line
 inx = inxtab[1];
#pragma empty_line
 if (Eta_taby[0] < 1024)
  prLamC_buf[Eta_taby[0]]+= Eta_ans_1[0];
 else
  prLamC_buf5[Eta_taby[0]-1024 ]+= Eta_ans_1[0];
 if (Eta_taby[1] < 1024)
  prLamC_buf1[Eta_taby[1]]+= Eta_ans_1[1];
 else
  prLamC_buf6[Eta_taby[1]-1024]+= Eta_ans_1[1];
 if (Eta_taby[2] < 1024)
  prLamC_buf3[Eta_taby[2]]+= Eta_ans_1[2];
 else
  prLamC_buf7[Eta_taby[2]-1024]+= Eta_ans_1[2];
 if (Eta_taby[3] < 1024)
  prLamC_buf4[Eta_taby[3]]+= Eta_ans_1[3];
 else
  prLamC_buf10[Eta_taby[3]-1024]+= Eta_ans_1[3];
 if (Eta_taby[4] < 1024)
  prLamC_buf4a[Eta_taby[4]]+= Eta_ans_1[4];
 else
  prLamC_buf10a[Eta_taby[4]-1024]+= Eta_ans_1[4];
 if (Eta_taby[5] < 1024)
  prLamC_buf4b[Eta_taby[5]]+= Eta_ans_1[5];
 else
  prLamC_buf10b[Eta_taby[5]-1024]+= Eta_ans_1[5];
#pragma line 2976 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (Eta_tabf[0] < 1024)
  prLam2C_buf[Eta_tabf[0]]+= Eta_ans_4[0];
 else
  prLam2C_buf5[Eta_tabf[0]-1024 ]+= Eta_ans_4[0];
 if (Eta_tabf[1] < 1024)
  prLam2C_buf1[Eta_tabf[1]]+= Eta_ans_4[1];
 else
  prLam2C_buf6[Eta_tabf[1]-1024]+= Eta_ans_4[1];
 if (Eta_tabf[2] < 1024)
  prLam2C_buf3[Eta_tabf[2]]+= Eta_ans_4[2];
 else
  prLam2C_buf7[Eta_tabf[2]-1024]+= Eta_ans_4[2];
 if (Eta_tabf[3] < 1024)
  prLam2C_buf4[Eta_tabf[3]]+= Eta_ans_4[3];
 else
  prLam2C_buf10[Eta_tabf[3]-1024]+= Eta_ans_4[3];
 if (Eta_tabf[4] < 1024)
  prLam2C_buf4a[Eta_tabf[4]]+= Eta_ans_4[4];
 else
  prLam2C_buf10a[Eta_tabf[4]-1024]+= Eta_ans_4[4];
 if (Eta_tabf[5] < 1024)
  prLam2C_buf4b[Eta_tabf[5]]+= Eta_ans_4[5];
 else
  prLam2C_buf10b[Eta_tabf[5]-1024]+= Eta_ans_4[5];
#pragma empty_line
 SpEtaPrevA[inx].one = Eta_ans_1[0];
 SpEtaPrevA[inx].two = Eta_ans_1[1];
 SpEtaPrevAa[inx].three = Eta_ans_1[2];
 SpEtaPrevAa[inx].four = Eta_ans_1[3];
 SpEtaPrevAa[inx].five = Eta_ans_1[4];
 SpEtaPrevAa[inx].six = Eta_ans_1[5];
#pragma empty_line
 SpEtaPrevD[inx+1].one = Eta_ans_4[0];
 SpEtaPrevD[inx+1].two = Eta_ans_4[1];
 SpEtaPrevDa[inx+1].three = Eta_ans_4[2];
 SpEtaPrevDa[inx+1].four = Eta_ans_4[3];
 SpEtaPrevDa[inx+1].five = Eta_ans_4[4];
 SpEtaPrevDa[inx+1].six = Eta_ans_4[5];
#pragma empty_line
 parityA = prHat_bufA[Eta_taby[0]] ^ prHat_buf1[Eta_taby[1]] ^ prHat_buf3[Eta_taby[2]] ^
   prHat_bufA4[Eta_taby[3]] ^ prHat_bufA4[Eta_taby[4]] ^ prHat_bufA4b[Eta_taby[5]] ;
#pragma empty_line
 parityA1 = prHat_bufAa[Eta_tabf[0]] ^ prHat_bufA1[Eta_tabf[1]] ^ prHat_bufA3[Eta_tabf[2]] ^
   prHat_bufA4a[Eta_tabf[3]] ^ prHat_bufA4a[Eta_tabf[4]] ^ prHat_bufA4b[Eta_tabf[5]] ;
#pragma empty_line
#pragma empty_line
 inx = inxtab[2];
#pragma line 3033 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (Eta_tabz[0] < 1024)
  prLamB_buf[Eta_tabz[0]]+= Eta_ans_2[0];
 else
  prLamB_buf3b[Eta_tabz[0]-1024 ]+= Eta_ans_2[0];
 if (Eta_tabz[1] < 1024)
  prLamB_buf1[Eta_tabz[1]]+= Eta_ans_2[1];
 else
  prLamB_buf5[Eta_tabz[1]-1024]+= Eta_ans_2[1];
 if (Eta_tabz[2] < 1024)
  prLamB_buf1a[Eta_tabz[2]]+= Eta_ans_2[2];
 else
  prLamB_buf5a[Eta_tabz[2]-1024]+= Eta_ans_2[2];
 if (Eta_tabz[3] < 1024)
  prLamB_buf3[Eta_tabz[3]]+= Eta_ans_2[3];
 else
  prLamB_buf7[Eta_tabz[3]-1024]+= Eta_ans_2[3];
 if (Eta_tabz[4] < 1024)
  prLamB_buf3a[Eta_tabz[4]]+= Eta_ans_2[4];
 else
  prLamB_buf7a[Eta_tabz[4]-1024]+= Eta_ans_2[4];
 if (Eta_tabz[5] < 1024)
  prLamB_buf4[Eta_tabz[5]]+= Eta_ans_2[5];
 else
  prLamB_buf9[Eta_tabz[5]-1024]+= Eta_ans_2[5];
#pragma line 3067 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 if (Eta_tabg[0] < 1024)
  prLam2B_buf[Eta_tabg[0]]+= Eta_ans_5[0];
 else
  prLam2B_buf3b[Eta_tabg[0]-1024 ]+= Eta_ans_5[0];
 if (Eta_tabg[1] < 1024)
  prLam2B_buf1[Eta_tabg[1]]+= Eta_ans_5[1];
 else
  prLam2B_buf5[Eta_tabg[1]-1024]+= Eta_ans_5[1];
 if (Eta_tabg[2] < 1024)
  prLam2B_buf1a[Eta_tabg[2]]+= Eta_ans_5[2];
 else
  prLam2B_buf5a[Eta_tabg[2]-1024]+= Eta_ans_5[2];
 if (Eta_tabg[3] < 1024)
  prLam2B_buf3[Eta_tabg[3]]+= Eta_ans_5[3];
 else
  prLam2B_buf7[Eta_tabg[3]-1024]+= Eta_ans_5[3];
 if (Eta_tabg[4] < 1024)
  prLam2B_buf3a[Eta_tabg[4]]+= Eta_ans_5[4];
 else
  prLam2B_buf7a[Eta_tabg[4]-1024]+= Eta_ans_5[4];
 if (Eta_tabg[5] < 1024)
  prLam2B_buf4[Eta_tabg[5]]+= Eta_ans_5[5];
 else
  prLam2B_buf9[Eta_tabg[5]-1024]+= Eta_ans_5[5];
#pragma empty_line
 SpEtaPrevB[inx].one = Eta_ans_2[0];
 SpEtaPrevB[inx].two = Eta_ans_2[1];
 SpEtaPrevBa[inx].three = Eta_ans_2[2];
 SpEtaPrevBa[inx].four = Eta_ans_2[3];
 SpEtaPrevBa[inx].five = Eta_ans_2[4];
 SpEtaPrevBa[inx].six = Eta_ans_2[5];
#pragma empty_line
 SpEtaPrevE[inx+1].one = Eta_ans_5[0];
 SpEtaPrevE[inx+1].two = Eta_ans_5[1];
 SpEtaPrevEa[inx+1].three = Eta_ans_5[2];
 SpEtaPrevEa[inx+1].four = Eta_ans_5[3];
 SpEtaPrevEa[inx+1].five = Eta_ans_5[4];
 SpEtaPrevEa[inx+1].six = Eta_ans_5[5];
#pragma empty_line
 parityB = prHat_bufB[Eta_tabz[0]] ^ prHat_bufB1[Eta_tabz[1]] ^ prHat_bufB1b[Eta_tabz[2]] ^
   prHat_bufB3[Eta_tabz[3]] ^ prHat_bufB3b[Eta_tabz[4]] ^ prHat_bufB4[Eta_tabz[5]];
#pragma empty_line
 parityB1 = prHat_bufB[Eta_tabg[0]] ^ prHat_bufB1a[Eta_tabg[1]] ^ prHat_bufB1c[Eta_tabg[2]] ^
   prHat_bufB3a[Eta_tabg[3]] ^ prHat_bufB3c[Eta_tabg[4]] ^ prHat_bufB4[Eta_tabg[5]];
#pragma empty_line
#pragma empty_line
 if ( (parity || parity1 || parityA || parityA1 ||
   parityB || parityB1) == true)
 {
  bAllChecksPassed = false;
 }
#pragma empty_line
#pragma empty_line
}
#pragma empty_line
void setup_calc(short m, short num_shnt,
     short mA, short num_shntA, short mB, short num_shntB,
     bool prevflg, short *num, short *num1, short *num2, short *num3, bool sec)
{
 short num_nt=0;
 short numpos;
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 short *ltab, *etab, *ptab;
 short *ltab1, *etab1, *ptab1;
 short *ltab2, *etab2, *ptab2;
#pragma empty_line
 short *ltab3, *etab3, *ptab3;
 short *ltab4, *etab4, *ptab4;
 short *ltab5, *etab5, *ptab5;
#pragma empty_line
 short *ltab6, *etab6, *ptab6;
 short *ltab7, *etab7, *ptab7;
 short *ltab8, *etab8, *ptab8;
#pragma empty_line
 short *ltab9, *etab9, *ptab9;
 short *ltab10, *etab10, *ptab10;
 short *ltab11, *etab11, *ptab11;
#pragma empty_line
#pragma empty_line
 short num_nt0, num_ntA, num_ntB, num_nt3;
 short num_shnt0, num_shnt1, num_shnt2, num_shnt3;
#pragma empty_line
 ltab = Lam_tabx;
 etab = Eta_tabx;
 ptab = Peta_tabx;
 ltab3 = Lam_tabe;
 etab3 = Eta_tabe;
 ptab3 = Peta_tabe;
#pragma empty_line
 ltab6 = Lam_tabh;
 etab6 = Eta_tabh;
 ptab6 = Peta_tabh;
 ltab9 = Lam_tabk;
 etab9 = Eta_tabk;
 ptab9 = Peta_tabk;
#pragma empty_line
 num_nt = m;
 inxtab[0] = m;
 num_shnt++;
#pragma empty_line
 ltab1 = Lam_taby;
 etab1 = Eta_taby;
 ptab1 = Peta_taby;
 ltab4 = Lam_tabf;
 etab4 = Eta_tabf;
 ptab4 = Peta_tabf;
#pragma empty_line
 ltab7 = Lam_tabi;
 etab7 = Eta_tabi;
 ptab7 = Peta_tabi;
 ltab10 = Lam_tabl;
 etab10= Eta_tabl;
 ptab10 = Peta_tabl;
#pragma empty_line
#pragma empty_line
 num_ntA = mA;
 inxtab[1] = num_ntA;
 num_shntA++;
#pragma empty_line
 ltab2 = Lam_tabz;
 etab2 = Eta_tabz;
 ptab2 = Peta_tabz;
 ltab5 = Lam_tabg;
 etab5 = Eta_tabg;
 ptab5 = Peta_tabg;
#pragma empty_line
 ltab8 = Lam_tabj;
 etab8 = Eta_tabj;
 ptab8 = Peta_tabj;
 ltab11 = Lam_tabm;
 etab11 = Eta_tabm;
 ptab11 = Peta_tabm;
#pragma empty_line
#pragma empty_line
 num_ntB = mB;
 inxtab[2] = num_ntB;
 num_shntB++;
#pragma empty_line
#pragma empty_line
 mcalcAA(etab, ltab, ptab, num_nt, num_shnt,
   etab1, ltab1, ptab1, num_ntA, num_shntA,
   etab2, ltab2, ptab2, num_ntB, num_shntB,
   etab3, ltab3, ptab3, etab4, ltab4, ptab4,
   etab5, ltab5, ptab5, prevflg);
#pragma empty_line
#pragma empty_line
 *num = 3+4+8;
 *num1 = 18+19+38;
 *num2 = 18+19+38;
 *num3 = 0;
#pragma empty_line
}
#pragma empty_line
void setup_calc_23(short m, short num_shnt,
     short mA, short num_shntA, short mB, short num_shntB,
     bool prevflg, short *num, short *num1, short *num2, short *num3, bool sec)
{
 short num_nt=0;
 short numpos;
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 short *ltab, *etab, *ptab;
 short *ltab1, *etab1, *ptab1;
 short *ltab2, *etab2, *ptab2;
#pragma empty_line
 short *ltab3, *etab3, *ptab3;
 short *ltab4, *etab4, *ptab4;
 short *ltab5, *etab5, *ptab5;
#pragma empty_line
 short *ltab6, *etab6, *ptab6;
 short *ltab7, *etab7, *ptab7;
 short *ltab8, *etab8, *ptab8;
#pragma empty_line
 short *ltab9, *etab9, *ptab9;
 short *ltab10, *etab10, *ptab10;
 short *ltab11, *etab11, *ptab11;
#pragma empty_line
#pragma empty_line
 short num_nt0, num_ntA, num_ntB, num_nt3;
 short num_shnt0, num_shnt1, num_shnt2, num_shnt3;
#pragma empty_line
 ltab = Lam_tabx;
 etab = Eta_tabx;
 ptab = Peta_tabx;
 ltab3 = Lam_tabe;
 etab3 = Eta_tabe;
 ptab3 = Peta_tabe;
#pragma empty_line
 ltab6 = Lam_tabh;
 etab6 = Eta_tabh;
 ptab6 = Peta_tabh;
 ltab9 = Lam_tabk;
 etab9 = Eta_tabk;
 ptab9 = Peta_tabk;
#pragma empty_line
 num_nt = m;
 inxtab[0] = m;
 num_shnt++;
#pragma empty_line
 ltab1 = Lam_taby;
 etab1 = Eta_taby;
 ptab1 = Peta_taby;
 ltab4 = Lam_tabf;
 etab4 = Eta_tabf;
 ptab4 = Peta_tabf;
#pragma empty_line
 ltab7 = Lam_tabi;
 etab7 = Eta_tabi;
 ptab7 = Peta_tabi;
 ltab10 = Lam_tabl;
 etab10= Eta_tabl;
 ptab10 = Peta_tabl;
#pragma empty_line
#pragma empty_line
 num_ntA = mA;
 inxtab[1] = num_ntA;
 num_shntA++;
#pragma empty_line
 ltab2 = Lam_tabz;
 etab2 = Eta_tabz;
 ptab2 = Peta_tabz;
 ltab5 = Lam_tabg;
 etab5 = Eta_tabg;
 ptab5 = Peta_tabg;
#pragma empty_line
 ltab8 = Lam_tabj;
 etab8 = Eta_tabj;
 ptab8 = Peta_tabj;
 ltab11 = Lam_tabm;
 etab11 = Eta_tabm;
 ptab11 = Peta_tabm;
#pragma empty_line
#pragma empty_line
 num_ntB = mB;
 inxtab[2] = num_ntB;
 num_shntB++;
#pragma empty_line
 mcalcAA_23(etab, ltab, ptab, num_nt, num_shnt,
   etab1, ltab1, ptab1, num_ntA, num_shntA,
   etab2, ltab2, ptab2, num_ntB, num_shntB,
   etab3, ltab3, ptab3, etab4, ltab4, ptab4,
   etab5, ltab5, ptab5, etab6, ltab6, ptab6,
   etab7, ltab7, ptab7, etab8, ltab8, ptab8,
   etab9, ltab9, ptab9, etab10, ltab10, ptab10,
   etab11, ltab11, ptab11, prevflg);
#pragma empty_line
#pragma empty_line
 *num = 3+4+8;
 *num1 = 18+19+38;
 *num2 = 18+19+38;
 *num3 = 0;
#pragma empty_line
}
#pragma empty_line
void setup_calc_12(short m, short num_shnt,
     short mA, short num_shntA, short mB, short num_shntB,
     bool prevflg, short *num, short *num1, short *num2, short *num3, bool sec)
{
 short num_nt=0;
 short numpos;
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 short *ltab, *etab, *ptab;
 short *ltab1, *etab1, *ptab1;
 short *ltab2, *etab2, *ptab2;
#pragma empty_line
 short *ltab3, *etab3, *ptab3;
 short *ltab4, *etab4, *ptab4;
 short *ltab5, *etab5, *ptab5;
#pragma empty_line
 short *ltab6, *etab6, *ptab6;
 short *ltab7, *etab7, *ptab7;
 short *ltab8, *etab8, *ptab8;
#pragma empty_line
 short *ltab9, *etab9, *ptab9;
 short *ltab10, *etab10, *ptab10;
 short *ltab11, *etab11, *ptab11;
#pragma empty_line
#pragma empty_line
 short num_nt0, num_ntA, num_ntB, num_nt3;
 short num_shnt0, num_shnt1, num_shnt2, num_shnt3;
#pragma empty_line
 ltab = Lam_tabx;
 etab = Eta_tabx;
 ptab = Peta_tabx;
 ltab3 = Lam_tabe;
 etab3 = Eta_tabe;
 ptab3 = Peta_tabe;
#pragma empty_line
 ltab6 = Lam_tabh;
 etab6 = Eta_tabh;
 ptab6 = Peta_tabh;
 ltab9 = Lam_tabk;
 etab9 = Eta_tabk;
 ptab9 = Peta_tabk;
#pragma empty_line
 num_nt = m;
 inxtab[0] = m;
 num_shnt++;
#pragma empty_line
 ltab1 = Lam_taby;
 etab1 = Eta_taby;
 ptab1 = Peta_taby;
 ltab4 = Lam_tabf;
 etab4 = Eta_tabf;
 ptab4 = Peta_tabf;
#pragma empty_line
 ltab7 = Lam_tabi;
 etab7 = Eta_tabi;
 ptab7 = Peta_tabi;
 ltab10 = Lam_tabl;
 etab10= Eta_tabl;
 ptab10 = Peta_tabl;
#pragma empty_line
#pragma empty_line
 num_ntA = mA;
 inxtab[1] = num_ntA;
 num_shntA++;
#pragma empty_line
 ltab2 = Lam_tabz;
 etab2 = Eta_tabz;
 ptab2 = Peta_tabz;
 ltab5 = Lam_tabg;
 etab5 = Eta_tabg;
 ptab5 = Peta_tabg;
#pragma empty_line
 ltab8 = Lam_tabj;
 etab8 = Eta_tabj;
 ptab8 = Peta_tabj;
 ltab11 = Lam_tabm;
 etab11 = Eta_tabm;
 ptab11 = Peta_tabm;
#pragma empty_line
#pragma empty_line
 num_ntB = mB;
 inxtab[2] = num_ntB;
 num_shntB++;
#pragma empty_line
 mcalcAA_12(etab, ltab, ptab, num_nt, num_shnt,
   etab1, ltab1, ptab1, num_ntA, num_shntA,
   etab2, ltab2, ptab2, num_ntB, num_shntB,
   etab3, ltab3, ptab3, etab4, ltab4, ptab4,
   etab5, ltab5, ptab5, etab6, ltab6, ptab6,
   etab7, ltab7, ptab7, etab8, ltab8, ptab8,
   etab9, ltab9, ptab9, etab10, ltab10, ptab10,
   etab11, ltab11, ptab11, prevflg);
#pragma empty_line
#pragma empty_line
 *num = 3+4+8;
 *num1 = 18+19+38;
 *num2 = 18+19+38;
 *num3 = 0;
#pragma empty_line
}
#pragma empty_line
void calc_m(tab_int nCodeM, bool prevflg)
{
 short m, mA, mB;
#pragma empty_line
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 tab_int nLenNset_4, nLenNset_5, nLenNset_6, nLenNset_7;
#pragma empty_line
 tab_int nLenNset_8, nLenNset_9, nLenNset_10, nLenNset_11;
 tab_int nLenNset_12, nLenNset_13, nLenNset_14, nLenNset_15;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short num_nt=0;
 short num_shnt=0;
 short num_deg;
 short num_ntA, num_ntB, num_shntB, num_shntA;
#pragma empty_line
 short *ltab, *etab, *ptab;
#pragma empty_line
 m = 0;
 mA = 128;
 mB = 256;
#pragma empty_line
 num_shntA = 512;
 num_shntB = 2944;
#pragma empty_line
 calc_m_labe45:
 for(m=0;m<rows;++m)
#pragma empty_line
 {
#pragma empty_line
  setup_calc(m, num_shnt, m, num_shntA, m, num_shntB, true, &nLenNset, &nLenNset_1, &nLenNset_2, &nLenNset_3, true);
#pragma empty_line
  mA++;
  mA++;
  mB++;
  mB++;
  m++;
#pragma empty_line
  calc_ma(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3);
#pragma empty_line
  write_result(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3, false);
 }
#pragma empty_line
}
#pragma empty_line
void calc_m_23(tab_int nCodeM, bool prevflg)
{
 short m, mA, mB;
#pragma empty_line
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 tab_int nLenNset_4, nLenNset_5, nLenNset_6, nLenNset_7;
#pragma empty_line
 tab_int nLenNset_8, nLenNset_9, nLenNset_10, nLenNset_11;
 tab_int nLenNset_12, nLenNset_13, nLenNset_14, nLenNset_15;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short num_nt=0;
 short num_shnt=0;
 short num_deg;
 short num_ntA, num_ntB, num_shntB, num_shntA;
#pragma empty_line
 short *ltab, *etab, *ptab;
#pragma empty_line
 m = 0;
 mA = 128;
 mB = 256;
#pragma empty_line
 num_shntA = 512;
 num_shntB = 2944;
#pragma empty_line
 calc_m_label0:for(m=0;m<rows;++m)
#pragma empty_line
 {
#pragma empty_line
  setup_calc_23(m, num_shnt, m, num_shntA, m, num_shntB, true, &nLenNset, &nLenNset_1, &nLenNset_2, &nLenNset_3, true);
#pragma empty_line
  mA++;
  mA++;
  mB++;
  mB++;
  m++;
#pragma empty_line
  calc_ma(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3);
#pragma empty_line
  write_result_23(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3, false);
 }
#pragma empty_line
}
#pragma empty_line
void calc_m_12(tab_int nCodeM, bool prevflg)
{
 short m, mA, mB;
#pragma empty_line
 short nLenNset, nLenNset_1, nLenNset_2, nLenNset_3;
 tab_int nLenNset_4, nLenNset_5, nLenNset_6, nLenNset_7;
#pragma empty_line
 tab_int nLenNset_8, nLenNset_9, nLenNset_10, nLenNset_11;
 tab_int nLenNset_12, nLenNset_13, nLenNset_14, nLenNset_15;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
 short num_nt=0;
 short num_shnt=0;
 short num_deg;
 short num_ntA, num_ntB, num_shntB, num_shntA;
#pragma empty_line
 short *ltab, *etab, *ptab;
#pragma empty_line
 m = 0;
 mA = 128;
 mB = 256;
#pragma empty_line
 num_shntA = 512;
 num_shntB = 2944;
#pragma empty_line
 calc_m_label0:for(m=0;m<rows;++m)
#pragma empty_line
 {
#pragma empty_line
  setup_calc_12(m, num_shnt, m, num_shntA, m, num_shntB, true, &nLenNset, &nLenNset_1, &nLenNset_2, &nLenNset_3, true);
#pragma empty_line
  mA++;
  mA++;
  mB++;
  mB++;
  m++;
#pragma empty_line
  calc_ma(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3);
#pragma empty_line
  write_result_12(nLenNset, nLenNset_1, nLenNset_2, nLenNset_3, false);
 }
#pragma empty_line
}
#pragma empty_line
void calc_ma(short num, short num_1, short num_2, short num_3)
{
 mcalcB(num, Peta_tabx, Lam_tabx, Eta_ans);
 mcalcC(num_1);
 mcalcD(num_2);
 mcalcE(num_3);
 mcalcF(num_3);
 mcalcG(num_3);
#pragma empty_line
}
#pragma empty_line
void mcalcB(short num, short *ptab, short *ltab, short *atab)
{
  int12 vMetric, vArg, minval, min, last, test, flag;
  tab_int jSparse, nLenNset, nSparse;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  ptab=Peta_tabx;
  ltab=Lam_tabx;
  atab=Eta_ans;
#pragma empty_line
  int12 est[20];
#pragma empty_line
#pragma empty_line
  int12 mul1 = 1, mul2 =1, mul3 =1;
#pragma empty_line
  bool sgn[18];
#pragma empty_line
#pragma empty_line
    for(jSparse=0;jSparse<3;++jSparse)
    {
      vArg = -ltab[jSparse]
             + ptab[jSparse];
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
      if (vArg >= 0)
       sgn[jSparse] = false;
      else
      {
       sgn[jSparse] = true;
       vArg = vArg *-1;
      }
#pragma empty_line
#pragma empty_line
      if (vArg >= 127)
       est[jSparse] = 127;
      else if (vArg >= 63)
       est[jSparse] = 63;
      else if (vArg >= 31)
       est[jSparse] = 31;
      else if (vArg >= 15)
       est[jSparse] = 15;
      else if (vArg >= 7)
       est[jSparse] = 7;
      else if (vArg >= 3)
       est[jSparse] = 3;
      else
       est[jSparse] =1;
#pragma empty_line
#pragma empty_line
    }
#pragma empty_line
    if ( !(sgn[1] ^ sgn[2] ))
     mul1 = -1;
#pragma empty_line
    if ( !(sgn[0] ^ sgn[2] ))
     mul2 = -1;
#pragma empty_line
    if ( !(sgn[0] ^ sgn[1] ))
     mul3 = -1;
#pragma empty_line
#pragma empty_line
#pragma empty_line
    atab[0]= (est[1] & est[2]) * mul1 ;
#pragma empty_line
    atab[1]= (est[0] & est[2]) * mul2 ;
#pragma empty_line
    atab[2]= (est[0] & est[1]) * mul3 ;
#pragma line 3652 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
}
#pragma empty_line
void mcalcC(short num)
{
  int12 vMetric, vArg, minval, min, last, est[20], test, flag;
  tab_int jSparse, nLenNset, nSparse;
#pragma empty_line
  int12 mul0 = 1, mul1 = 1, mul2 =1, mul3= 1, mul4 = 1, mul5 = 1;
  int12 mul6 = 1, mul7 = 1, mul8 =1, mul9= 1, mul10 = 1, mul11 = 1;
  int12 mul12 = 1, mul13 = 1, mul14 =1, mul15= 1, mul16 = 1, mul17 = 1;
#pragma empty_line
  bool sgn[18];
#pragma empty_line
#pragma empty_line
   for(jSparse=0;jSparse<18;++jSparse)
   {
     vArg = -Lam_taby[jSparse]
            + Peta_taby[jSparse];
#pragma empty_line
     if (vArg >= 0)
      sgn[jSparse] = false;
     else
     {
      sgn[jSparse] = true;
      vArg = vArg *-1;
     }
#pragma empty_line
     if (vArg >= 127)
      est[jSparse] = 127;
     else if (vArg >= 63)
      est[jSparse] = 63;
     else if (vArg >= 31)
      est[jSparse] = 31;
     else if (vArg >= 15)
      est[jSparse] = 15;
     else if (vArg >= 7)
      est[jSparse] = 7;
     else if (vArg >= 3)
      est[jSparse] = 3;
     else
      est[jSparse] =1;
#pragma empty_line
   }
#pragma empty_line
   if ( !(sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul0 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul1 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul2 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul3 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul4 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul5 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul6 = -1;
#pragma empty_line
   if (!( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul7 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul8 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul9 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul10 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul11 = -1;
#pragma empty_line
   if ( !( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul12= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul13= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul14 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[16] ^ sgn[17]))
    mul15 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[17]))
    mul16 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[16]))
    mul17 = -1;
#pragma empty_line
   Eta_ans_1[0]= (est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul0;
#pragma empty_line
   Eta_ans_1[1]= (est[0] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul1;
#pragma empty_line
   Eta_ans_1[2]= (est[0] & est[1] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul2;
#pragma empty_line
   Eta_ans_1[3]= (est[0] & est[1] & est[2] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul3;
#pragma empty_line
   Eta_ans_1[4]= (est[0] & est[1] & est[2] & est[3] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul4 ;
#pragma empty_line
   Eta_ans_1[5]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul5 ;
#pragma empty_line
   Eta_ans_1[6]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul6 ;
#pragma empty_line
   Eta_ans_1[7]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul7 ;
#pragma empty_line
   Eta_ans_1[8]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul8;
#pragma empty_line
   Eta_ans_1[9]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul9;
#pragma empty_line
   Eta_ans_1[10]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul10 ;
#pragma empty_line
   Eta_ans_1[11]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul11;
#pragma empty_line
   Eta_ans_1[12]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul12;
#pragma empty_line
   Eta_ans_1[13]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[14] & est[15] & est[16] & est[17]) * mul13;
#pragma empty_line
   Eta_ans_1[14]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[15] & est[16] & est[17]) * mul14;
#pragma empty_line
   Eta_ans_1[15]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[16] & est[17]) * mul15 ;
#pragma empty_line
   Eta_ans_1[16]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[17]) * mul16;
#pragma empty_line
   Eta_ans_1[17]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[16]) * mul17;
#pragma empty_line
}
#pragma empty_line
void mcalcD(short num)
{
  int12 vMetric, vArg, minval, min, last, est[20], test, flag;
  tab_int jSparse, nLenNset, nSparse;
#pragma empty_line
  int12 mul0 = 1, mul1 = 1, mul2 =1, mul3= 1, mul4 = 1, mul5 = 1;
  int12 mul6 = 1, mul7 = 1, mul8 =1, mul9= 1, mul10 = 1, mul11 = 1;
  int12 mul12 = 1, mul13 = 1, mul14 =1, mul15= 1, mul16 = 1, mul17 = 1;
  bool sgn[18];
#pragma empty_line
#pragma empty_line
   for(jSparse=0;jSparse<18;++jSparse)
   {
     vArg = -Lam_tabz[jSparse]
            + Peta_tabz[jSparse];
#pragma empty_line
     if (vArg >= 0)
      sgn[jSparse] = false;
     else
     {
      sgn[jSparse] = true;
      vArg = vArg *-1;
     }
#pragma empty_line
     if (vArg >= 127)
      est[jSparse] = 127;
     else if (vArg >= 63)
      est[jSparse] = 63;
     else if (vArg >= 31)
      est[jSparse] = 31;
     else if (vArg >= 15)
      est[jSparse] = 15;
     else if (vArg >= 7)
      est[jSparse] = 7;
     else if (vArg >= 3)
      est[jSparse] = 3;
     else
      est[jSparse] =1;
#pragma empty_line
   }
#pragma empty_line
   if ( !(sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul0 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul1 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul2 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul3 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul4 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul5 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul6 = -1;
#pragma empty_line
   if (!( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul7 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul8 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul9 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul10 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul11 = -1;
#pragma empty_line
   if ( !( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul12= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul13= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul14 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[16] ^ sgn[17]))
    mul15 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[17]))
    mul16 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[16]))
    mul17 = -1;
#pragma empty_line
   Eta_ans_2[0]= (est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul0;
#pragma empty_line
   Eta_ans_2[1]= (est[0] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul1;
#pragma empty_line
   Eta_ans_2[2]= (est[0] & est[1] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul2;
#pragma empty_line
   Eta_ans_2[3]= (est[0] & est[1] & est[2] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul3;
#pragma empty_line
   Eta_ans_2[4]= (est[0] & est[1] & est[2] & est[3] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul4 ;
#pragma empty_line
   Eta_ans_2[5]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul5 ;
#pragma empty_line
   Eta_ans_2[6]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul6 ;
#pragma empty_line
   Eta_ans_2[7]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul7 ;
#pragma empty_line
   Eta_ans_2[8]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul8;
#pragma empty_line
   Eta_ans_2[9]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul9;
#pragma empty_line
   Eta_ans_2[10]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul10 ;
#pragma empty_line
   Eta_ans_2[11]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul11;
#pragma empty_line
   Eta_ans_2[12]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul12;
#pragma empty_line
   Eta_ans_2[13]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[14] & est[15] & est[16] & est[17]) * mul13;
#pragma empty_line
   Eta_ans_2[14]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[15] & est[16] & est[17]) * mul14;
#pragma empty_line
   Eta_ans_2[15]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[16] & est[17]) * mul15 ;
#pragma empty_line
   Eta_ans_2[16]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[17]) * mul16;
#pragma empty_line
   Eta_ans_2[17]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[16]) * mul17;
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
void mcalcE(short num)
{
  int12 vMetric, vArg, minval, min, last, est[20], test, flag;
  tab_int jSparse, nLenNset, nSparse;
  int12 mul1 = 1, mul2 =1, mul3 =1;
#pragma empty_line
  bool sgn[18];
#pragma empty_line
#pragma empty_line
    for(jSparse=0;jSparse<3;++jSparse)
    {
      vArg = -Lam_tabe[jSparse]
             + Peta_tabe[jSparse];
#pragma empty_line
      if (vArg >= 0)
       sgn[jSparse] = false;
      else
      {
       sgn[jSparse] = true;
       vArg = vArg *-1;
      }
#pragma empty_line
      if (vArg >= 127)
       est[jSparse] = 127;
      else if (vArg >= 63)
       est[jSparse] = 63;
      else if (vArg >= 31)
       est[jSparse] = 31;
      else if (vArg >= 15)
       est[jSparse] = 15;
      else if (vArg >= 7)
       est[jSparse] = 7;
      else if (vArg >= 3)
       est[jSparse] = 3;
      else
       est[jSparse] =1;
#pragma empty_line
    }
#pragma empty_line
    if ( !(sgn[1] ^ sgn[2] ))
     mul1 = -1;
#pragma empty_line
    if ( !(sgn[0] ^ sgn[2] ))
     mul2 = -1;
#pragma empty_line
    if ( !(sgn[0] ^ sgn[1] ))
     mul3 = -1;
#pragma empty_line
    Eta_ans_3[0]= (est[1] & est[2]) * mul1 ;
#pragma empty_line
    Eta_ans_3[1]= (est[0] & est[2]) * mul2 ;
#pragma empty_line
    Eta_ans_3[2]= (est[0] & est[1]) * mul3 ;
#pragma line 4059 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
 }
#pragma empty_line
void mcalcF(short num)
{
  int12 vMetric, vArg, minval, min, last, est[20], test, flag;
  tab_int jSparse, nLenNset, nSparse;
  int12 mul0 = 1, mul1 = 1, mul2 =1, mul3= 1, mul4 = 1, mul5 = 1;
  int12 mul6 = 1, mul7 = 1, mul8 =1, mul9= 1, mul10 = 1, mul11 = 1;
  int12 mul12 = 1, mul13 = 1, mul14 =1, mul15= 1, mul16 = 1, mul17 = 1;
#pragma empty_line
  bool sgn[18];
#pragma empty_line
#pragma empty_line
   for(jSparse=0;jSparse<18;++jSparse)
   {
     vArg = -Lam_tabf[jSparse]
            + Peta_tabf[jSparse];
#pragma empty_line
     if (vArg >= 0)
      sgn[jSparse] = false;
     else
     {
      sgn[jSparse] = true;
      vArg = vArg *-1;
     }
#pragma empty_line
     if (vArg >= 127)
      est[jSparse] = 127;
     else if (vArg >= 63)
      est[jSparse] = 63;
     else if (vArg >= 31)
      est[jSparse] = 31;
     else if (vArg >= 15)
      est[jSparse] = 15;
     else if (vArg >= 7)
      est[jSparse] = 7;
     else if (vArg >= 3)
      est[jSparse] = 3;
     else
      est[jSparse] =1;
#pragma empty_line
   }
#pragma empty_line
   if ( !(sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul0 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul1 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul2 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul3 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul4 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul5 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul6 = -1;
#pragma empty_line
   if (!( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul7 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul8 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul9 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul10 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul11 = -1;
#pragma empty_line
   if ( !( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul12= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul13= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul14 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[16] ^ sgn[17]))
    mul15 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[17]))
    mul16 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[16]))
    mul17 = -1;
#pragma empty_line
   Eta_ans_4[0]= (est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul0;
#pragma empty_line
   Eta_ans_4[1]= (est[0] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul1;
#pragma empty_line
   Eta_ans_4[2]= (est[0] & est[1] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul2;
#pragma empty_line
   Eta_ans_4[3]= (est[0] & est[1] & est[2] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul3;
#pragma empty_line
   Eta_ans_4[4]= (est[0] & est[1] & est[2] & est[3] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul4 ;
#pragma empty_line
   Eta_ans_4[5]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul5 ;
#pragma empty_line
   Eta_ans_4[6]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul6 ;
#pragma empty_line
   Eta_ans_4[7]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul7 ;
#pragma empty_line
   Eta_ans_4[8]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul8;
#pragma empty_line
   Eta_ans_4[9]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul9;
#pragma empty_line
   Eta_ans_4[10]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul10 ;
#pragma empty_line
   Eta_ans_4[11]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul11;
#pragma empty_line
   Eta_ans_4[12]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul12;
#pragma empty_line
   Eta_ans_4[13]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[14] & est[15] & est[16] & est[17]) * mul13;
#pragma empty_line
   Eta_ans_4[14]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[15] & est[16] & est[17]) * mul14;
#pragma empty_line
   Eta_ans_4[15]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[16] & est[17]) * mul15 ;
#pragma empty_line
   Eta_ans_4[16]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[17]) * mul16;
#pragma empty_line
   Eta_ans_4[17]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[16]) * mul17;
#pragma empty_line
#pragma empty_line
 }
#pragma empty_line
void mcalcG(short num)
{
  int12 vMetric, vArg, minval, min, last, est[20], test, flag;
  tab_int jSparse, nLenNset, nSparse;
  int12 mul0 = 1, mul1 = 1, mul2 =1, mul3= 1, mul4 = 1, mul5 = 1;
  int12 mul6 = 1, mul7 = 1, mul8 =1, mul9= 1, mul10 = 1, mul11 = 1;
  int12 mul12 = 1, mul13 = 1, mul14 =1, mul15= 1, mul16 = 1, mul17 = 1;
#pragma empty_line
  bool sgn[18];
#pragma empty_line
   for(jSparse=0;jSparse<18;++jSparse)
   {
     vArg = -Lam_tabg[jSparse]
            + Peta_tabg[jSparse];
#pragma empty_line
     if (vArg >= 0)
      sgn[jSparse] = false;
     else
     {
      sgn[jSparse] = true;
      vArg = vArg *-1;
     }
#pragma empty_line
     if (vArg >= 127)
      est[jSparse] = 127;
     else if (vArg >= 63)
      est[jSparse] = 63;
     else if (vArg >= 31)
      est[jSparse] = 31;
     else if (vArg >= 15)
      est[jSparse] = 15;
     else if (vArg >= 7)
      est[jSparse] = 7;
     else if (vArg >= 3)
      est[jSparse] = 3;
     else
      est[jSparse] =1;
#pragma empty_line
   }
#pragma empty_line
   if ( !(sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul0 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul1 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul2 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul3 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[5] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul4 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[6] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul5 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[7] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul6 = -1;
#pragma empty_line
   if (!( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul7 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul8 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[10] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul9 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[11] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul10 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[12] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul11 = -1;
#pragma empty_line
   if ( !( sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[13]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul12= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[14] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul13= -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[15] ^ sgn[16] ^ sgn[17]))
    mul14 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[16] ^ sgn[17]))
    mul15 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[17]))
    mul16 = -1;
#pragma empty_line
   if ( !(sgn[0] ^ sgn[1] ^ sgn[2] ^ sgn[3] ^ sgn[4] ^ sgn[5] ^ sgn[6] ^ sgn [7] ^ sgn[8] ^ sgn[9] ^ sgn[10] ^ sgn[11] ^ sgn[12]
      ^ sgn[13] ^ sgn[14] ^ sgn[15] ^ sgn[16]))
    mul17 = -1;
#pragma empty_line
   Eta_ans_5[0]= (est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul0;
#pragma empty_line
   Eta_ans_5[1]= (est[0] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul1;
#pragma empty_line
   Eta_ans_5[2]= (est[0] & est[1] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul2;
#pragma empty_line
   Eta_ans_5[3]= (est[0] & est[1] & est[2] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul3;
#pragma empty_line
   Eta_ans_5[4]= (est[0] & est[1] & est[2] & est[3] & est[5] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul4 ;
#pragma empty_line
   Eta_ans_5[5]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[6] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul5 ;
#pragma empty_line
   Eta_ans_5[6]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[7] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul6 ;
#pragma empty_line
   Eta_ans_5[7]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[8] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul7 ;
#pragma empty_line
   Eta_ans_5[8]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[9] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul8;
#pragma empty_line
   Eta_ans_5[9]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[10]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul9;
#pragma empty_line
   Eta_ans_5[10]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[11] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul10 ;
#pragma empty_line
   Eta_ans_5[11]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[12] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul11;
#pragma empty_line
   Eta_ans_5[12]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[13] & est[14] & est[15] & est[16] & est[17]) * mul12;
#pragma empty_line
   Eta_ans_5[13]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[14] & est[15] & est[16] & est[17]) * mul13;
#pragma empty_line
   Eta_ans_5[14]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[15] & est[16] & est[17]) * mul14;
#pragma empty_line
   Eta_ans_5[15]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[16] & est[17]) * mul15 ;
#pragma empty_line
   Eta_ans_5[16]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[17]) * mul16;
#pragma empty_line
   Eta_ans_5[17]= (est[0] & est[1] & est[2] & est[3] & est[4] & est[5] & est[6] & est[7] & est[8] & est[9]
      & est[10] & est[11] & est[12] & est[13] & est[14] & est[15] & est[16]) * mul17;
 }
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
void update_lam_all(short pos)
{
#pragma empty_line
  Lam_bufAa[pos] = pest0;
  Lam_bufAb[pos] = pest0;
  Lam_bufAc[pos] = pest0;
  Lam_bufB[pos] = pest0;
#pragma empty_line
  prLamB_buf[pos] = 0;
  prLamC_buf[pos] = 0;
  prLamC_bufa[pos] = 0;
  prLamC_bufb[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf[pos] = 0;
  prLam2C_buf[pos] = 0;
  prLam2C_bufa[pos] = 0;
  prLam2C_bufb[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA1[pos] = pest1;
  Lam_bufB1a[pos] = pest1;
  Lam_bufB1b[pos] = pest1;
  Lam_bufB1c[pos] = pest1;
#pragma empty_line
  prLamB_buf1[pos] = 0;
  prLamB_buf1a[pos] = 0;
  prLamB_buf1b[pos] = 0;
  prLamC_buf1[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf1[pos] = 0;
  prLam2B_buf1a[pos] = 0;
  prLam2B_buf1b[pos] = 0;
  prLam2C_buf1[pos] = 0;
#pragma empty_line
  Lam_buf2[pos] = pest2;
  Lam_bufA2a[pos] = pest2;
  Lam_bufA2b[pos] = pest2;
  Lam_bufA2c[pos] = pest2;
  Lam_bufB2[pos] = pest2;
  prLam_buf2[pos] = 0;
  prLamB_buf2[pos] = 0;
  prLamC_buf2[pos] = 0;
  prLamC_buf2a[pos] = 0;
  prLamC_buf2b[pos] = 0;
#pragma empty_line
  prLam2_buf2[pos] = 0;
  prLam2B_buf2[pos] = 0;
  prLam2C_buf2[pos] = 0;
  prLam2C_buf2a[pos] = 0;
  prLam2C_buf2b[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA3[pos] = pest3;
  Lam_bufB3a[pos] = pest3;
  Lam_bufB3b[pos] = pest3;
  Lam_bufB3c[pos] = pest3;
#pragma empty_line
  prLamB_buf3[pos] = 0;
  prLamB_buf3a[pos] = 0;
  prLamB_buf3b[pos] = 0;
  prLamC_buf3[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf3[pos] = 0;
  prLam2B_buf3a[pos] = 0;
  prLam2B_buf3b[pos] = 0;
  prLam2C_buf3[pos] = 0;
#pragma empty_line
  Lam_buf4[pos] = pest4;
  Lam_bufA4a[pos] = pest4;
  Lam_bufA4b[pos] = pest4;
  Lam_bufA4c[pos] = pest4;
  Lam_bufB4[pos] = pest4;
  prLam_buf4[pos] = 0;
  prLamB_buf4[pos] = 0;
  prLamC_buf4[pos] = 0;
  prLamC_buf4a[pos] = 0;
  prLamC_buf4b[pos] = 0;
#pragma empty_line
#pragma empty_line
  prLam2_buf4[pos] = 0;
  prLam2B_buf4[pos] = 0;
  prLam2C_buf4[pos] = 0;
  prLam2C_buf4a[pos] = 0;
  prLam2C_buf4b[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA5[pos] = pest5;
  Lam_bufB5a[pos] = pest5;
  Lam_bufB5b[pos] = pest5;
  Lam_bufB5c[pos] = pest5;
#pragma empty_line
  prLamB_buf5[pos] = 0;
  prLamB_buf5a[pos] = 0;
  prLamB_buf5b[pos] = 0;
  prLamC_buf5[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf5[pos] = 0;
  prLam2B_buf5a[pos] = 0;
  prLam2B_buf5b[pos] = 0;
  prLam2C_buf5[pos] = 0;
#pragma empty_line
  Lam_buf6[pos] = pest6;
  Lam_buf6a[pos] = pest6;
  Lam_bufA6[pos] = pest6;
  Lam_bufA6b[pos] = pest6;
  Lam_bufA6c[pos] = pest6;
  Lam_bufB6[pos] = pest6;
#pragma empty_line
  prLam_buf4a[pos] = 0;
  prLamB_buf6[pos] = 0;
  prLamC_buf6[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf6[pos] = 0;
  prLam2C_buf6[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  Lam_bufA7[pos] = pest7;
  Lam_bufB7a[pos] = pest7;
  Lam_bufB7b[pos] = pest7;
#pragma empty_line
  prLamB_buf7[pos] = 0;
  prLamB_buf7a[pos] = 0;
  prLamC_buf7[pos] = 0;
#pragma empty_line
#pragma empty_line
  prLam2B_buf7[pos] = 0;
  prLam2B_buf7a[pos] = 0;
  prLam2C_buf7[pos] = 0;
#pragma empty_line
  Lam_buf8[pos] = pest8;
#pragma line 4557 "C:/Engineering/Triple_Demod/BS1000-FPGA/branches/LDPC_Decoder/HLS_modules/LDPC_Decoder3U/HLSLdpcLogDecScaledMin.cpp"
  Lam_bufA9[pos] = pest9;
  Lam_bufB9a[pos] = pest9;
  Lam_bufB9b[pos] = pest9;
#pragma empty_line
  prLamB_buf9[pos] = 0;
  prLamB_buf9a[pos] = 0;
  prLamC_buf9[pos] = 0;
#pragma empty_line
#pragma empty_line
  prLam2B_buf9[pos] = 0;
  prLam2B_buf9a[pos] = 0;
  prLam2C_buf9[pos] = 0;
#pragma empty_line
  Lam_buf10[pos+0] = pest10;
  Lam_buf10a[pos+0] = pest10;
  Lam_bufA10a[pos+0] = pest10;
  Lam_bufA10b[pos+0] = pest10;
  Lam_bufA10c[pos+0] = pest10;
  Lam_bufB10[pos+0] = pest10;
  prLam_buf4[pos+0] = 0;
  prLam_buf4a[pos+0] = 0;
  prLamB_buf10[pos] = 0;
  prLamC_buf10[pos] = 0;
  prLamC_buf10a[pos] = 0;
  prLamC_buf10b[pos] = 0;
#pragma empty_line
  prLam2_buf4[pos+0] = 0;
  prLam2_buf4a[pos+0] = 0;
  prLam2B_buf10[pos] = 0;
  prLam2C_buf10[pos] = 0;
  prLam2C_buf10a[pos] = 0;
  prLam2C_buf10b[pos] = 0;
}
#pragma empty_line
void update_lam_all_23(short pos)
{
#pragma empty_line
#pragma empty_line
#pragma empty_line
  Lam_bufAa[pos] = pest0;
  Lam_bufAb[pos] = pest0;
  Lam_bufAc[pos] = pest0;
  Lam_bufB[pos] = pest0;
#pragma empty_line
  prLamB_buf[pos] = 0;
  prLamC_buf[pos] = 0;
  prLamC_bufa[pos] = 0;
  prLamC_bufb[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf[pos] = 0;
  prLam2C_buf[pos] = 0;
  prLam2C_bufa[pos] = 0;
  prLam2C_bufb[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA1[pos] = pest1;
  Lam_bufB1a[pos] = pest1;
  Lam_bufB1b[pos] = pest1;
  Lam_bufB1c[pos] = pest1;
#pragma empty_line
  prLamB_buf1[pos] = 0;
  prLamB_buf1a[pos] = 0;
  prLamB_buf1b[pos] = 0;
  prLamC_buf1[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf1[pos] = 0;
  prLam2B_buf1a[pos] = 0;
  prLam2B_buf1b[pos] = 0;
  prLam2C_buf1[pos] = 0;
#pragma empty_line
  Lam_buf2[pos] = pest2;
  Lam_bufA2a[pos] = pest2;
  Lam_bufA2b[pos] = pest2;
  Lam_bufA2c[pos] = pest2;
  Lam_bufB2[pos] = pest2;
  prLam_buf2[pos] = 0;
  prLamB_buf2[pos] = 0;
  prLamC_buf2[pos] = 0;
  prLamC_buf2a[pos] = 0;
  prLamC_buf2b[pos] = 0;
#pragma empty_line
  prLam2_buf2[pos] = 0;
  prLam2B_buf2[pos] = 0;
  prLam2C_buf2[pos] = 0;
  prLam2C_buf2a[pos] = 0;
  prLam2C_buf2b[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA3[pos] = pest3;
  Lam_bufB3a[pos] = pest3;
  Lam_bufB3b[pos] = pest3;
  Lam_bufB3c[pos] = pest3;
#pragma empty_line
  prLamB_buf3[pos] = 0;
  prLamB_buf3a[pos] = 0;
  prLamB_buf3b[pos] = 0;
  prLamC_buf3[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf3[pos] = 0;
  prLam2B_buf3a[pos] = 0;
  prLam2B_buf3b[pos] = 0;
  prLam2C_buf3[pos] = 0;
#pragma empty_line
  Lam_buf4[pos] = pest4;
  Lam_bufA4a[pos] = pest4;
  Lam_bufA4b[pos] = pest4;
  Lam_bufA4c[pos] = pest4;
  Lam_bufB4[pos] = pest4;
  prLam_buf4[pos] = 0;
  prLamB_buf4[pos] = 0;
  prLamC_buf4[pos] = 0;
  prLamC_buf4a[pos] = 0;
  prLamC_buf4b[pos] = 0;
#pragma empty_line
#pragma empty_line
  prLam2_buf4[pos] = 0;
  prLam2B_buf4[pos] = 0;
  prLam2C_buf4[pos] = 0;
  prLam2C_buf4a[pos] = 0;
  prLam2C_buf4b[pos] = 0;
#pragma empty_line
#pragma empty_line
  Lam_bufA5[pos] = pest5;
  Lam_bufB5a[pos] = pest5;
  Lam_bufB5b[pos] = pest5;
  Lam_bufB5c[pos] = pest5;
#pragma empty_line
  prLamB_buf5[pos] = 0;
  prLamB_buf5a[pos] = 0;
  prLamB_buf5b[pos] = 0;
  prLamC_buf5[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2B_buf5[pos] = 0;
  prLam2B_buf5a[pos] = 0;
  prLam2B_buf5b[pos] = 0;
  prLam2C_buf5[pos] = 0;
#pragma empty_line
  Lam_buf6[pos] = pest6;
  Lam_buf6a[pos] = pest6;
  Lam_bufA6[pos] = pest6;
  Lam_bufA6b[pos] = pest6;
  Lam_bufA6c[pos] = pest6;
  Lam_bufB6[pos] = pest6;
#pragma empty_line
  prLam_buf4a[pos] = 0;
  prLamB_buf6[pos] = 0;
  prLamC_buf6[pos] = 0;
  prLamC_buf10a[pos] = 0;
  prLamC_buf10b[pos] = 0;
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prLam2_buf4a[pos] = 0;
  prLam2B_buf6[pos] = 0;
  prLam2C_buf6[pos] = 0;
  prLam2C_buf10a[pos] = 0;
  prLam2C_buf10b[pos] = 0;
}
#pragma empty_line
#pragma empty_line
void update_lam_all_12(short pos)
{
#pragma empty_line
 if (pos < 1024)
 {
#pragma empty_line
  Lam_bufAa[pos] = pest0;
  Lam_bufB[pos] = pest0;
#pragma empty_line
  Lam_bufA1[pos] = pest1;
  Lam_bufB1a[pos] = pest1;
  Lam_bufB1b[pos] = pest1;
#pragma empty_line
  Lam_buf2[pos] = pest2;
#pragma empty_line
  Lam_bufA3[pos] = pest3;
  Lam_bufB3a[pos] = pest3;
  Lam_bufB3b[pos] = pest3;
#pragma empty_line
  Lam_buf4[pos] = pest4;
  Lam_buf4a[pos] = pest4;
  Lam_bufA4a[pos] = pest4;
  Lam_bufA4b[pos] = pest4;
  Lam_bufA4c[pos] = pest4;
  Lam_bufB4[pos] = pest4;
#pragma empty_line
  prLam_buf2[pos] = 0;
  prLam_buf4[pos] = 0;
  prLam_buf4a[pos] = 0;
#pragma empty_line
  prLam2_buf2[pos] = 0;
  prLam2_buf4[pos] = 0;
  prLam2_buf4a[pos] = 0;
#pragma empty_line
  prLamB_buf[pos] = 0;
  prLamB_buf1[pos] = 0;
  prLamB_buf1a[pos] = 0;
  prLamB_buf3[pos] = 0;
  prLamB_buf3a[pos] = 0;
  prLamB_buf4[pos] = 0;
#pragma empty_line
  prLam2B_buf[pos] = 0;
  prLam2B_buf1[pos] = 0;
  prLam2B_buf1a[pos] = 0;
  prLam2B_buf3[pos] = 0;
  prLam2B_buf3a[pos] = 0;
  prLam2B_buf4[pos] = 0;
#pragma empty_line
  prLamC_buf[pos] = 0;
  prLamC_buf1[pos] = 0;
  prLamC_buf3[pos] = 0;
  prLamC_buf4[pos] = 0;
  prLamC_buf4a[pos] = 0;
  prLamC_buf4b[pos] = 0;
#pragma empty_line
  prLam2C_buf[pos] = 0;
  prLam2C_buf1[pos] = 0;
  prLam2C_buf3[pos] = 0;
  prLam2C_buf4[pos] = 0;
  prLam2C_buf4a[pos] = 0;
  prLam2C_buf4b[pos] = 0;
#pragma empty_line
 }
 else
 {
  pos = pos - 1024;
#pragma empty_line
  Lam_bufB6[pos] = pest0;
  Lam_bufAb[pos] = pest0;
#pragma empty_line
  Lam_bufAc[pos] = pest1;
  Lam_bufB7a[pos] = pest1;
  Lam_bufB7b[pos] = pest1;
#pragma empty_line
  Lam_buf8[pos] = pest2;
#pragma empty_line
  Lam_bufA2a[pos] = pest3;
  Lam_bufB9a[pos] = pest3;
  Lam_bufB9b[pos] = pest3;
#pragma empty_line
  Lam_buf6[pos] = pest4;
  Lam_buf6a[pos] = pest4;
  Lam_bufA6[pos] = pest4;
  Lam_bufA6b[pos] = pest4;
  Lam_bufA6c[pos] = pest4;
  Lam_bufB10[pos] = pest4;
#pragma empty_line
  prLamB_buf3b[pos] = 0;
  prLamB_buf5[pos] = 0;
  prLamB_buf5a[pos] = 0;
  prLamB_buf6[pos] = 0;
  prLamB_buf7[pos] = 0;
  prLamB_buf7a[pos] = 0;
  prLamB_buf9[pos] = 0;
  prLamB_buf9a[pos] = 0;
  prLamB_buf10[pos] = 0;
#pragma empty_line
  prLam2B_buf3b[pos] = 0;
  prLam2B_buf5[pos] = 0;
  prLam2B_buf5a[pos] = 0;
  prLam2B_buf6[pos] = 0;
  prLam2B_buf7[pos] = 0;
  prLam2B_buf7a[pos] = 0;
  prLam2B_buf9[pos] = 0;
  prLam2B_buf9a[pos] = 0;
  prLam2B_buf10[pos] = 0;
#pragma empty_line
#pragma empty_line
  prLamC_buf5[pos] = 0;
  prLamC_buf6[pos] = 0;
  prLamC_buf7[pos] = 0;
  prLamC_buf10[pos] = 0;
  prLamC_buf10a[pos] = 0;
  prLamC_buf10b[pos] = 0;
#pragma empty_line
  prLam2C_buf5[pos] = 0;
  prLam2C_buf6[pos] = 0;
  prLam2C_buf7[pos] = 0;
  prLam2C_buf10[pos] = 0;
  prLam2C_buf10a[pos] = 0;
  prLam2C_buf10b[pos] = 0;
#pragma empty_line
 }
#pragma empty_line
}
#pragma empty_line
#pragma empty_line
void update_hat_all(short pos)
{
#pragma empty_line
  prHat_buf[pos] = bpest0;
  prHat_bufA[pos] = bpest0;
  prHat_bufAa[pos] = bpest0;
  prHat_bufAb[pos] = bpest0;
  prHat_bufAc[pos] = bpest0;
  prHat_bufB[pos] = bpest0;
#pragma empty_line
  prHat_buf1[pos] = bpest1;
  prHat_bufA1[pos] = bpest1;
  prHat_bufB1[pos] = bpest1;
  prHat_bufB1a[pos] = bpest1;
  prHat_bufB1b[pos] = bpest1;
  prHat_bufB1c[pos] = bpest1;
#pragma empty_line
  prHat_buf2[pos] = bpest2;
  prHat_bufA2[pos] = bpest2;
  prHat_bufA2a[pos] = bpest2;
  prHat_bufA2b[pos] = bpest2;
  prHat_bufA2c[pos] = bpest2;
  prHat_bufB2[pos] = bpest2;
#pragma empty_line
  prHat_buf3[pos] = bpest3;
  prHat_bufA3[pos] = bpest3;
  prHat_bufB3[pos] = bpest3;
  prHat_bufB3a[pos] = bpest3;
  prHat_bufB3b[pos] = bpest3;
  prHat_bufB3c[pos] = bpest3;
#pragma empty_line
  prHat_buf4[pos] = bpest4;
  prHat_buf4a[pos] = bpest4;
  prHat_bufA4[pos] = bpest4;
  prHat_bufA4a[pos] = bpest4;
  prHat_bufA4b[pos] = bpest4;
  prHat_bufB4[pos] = bpest4;
#pragma empty_line
#pragma empty_line
  prHat_bufA5[pos] = bpest5;
  prHat_bufB5[pos] = bpest5;
  prHat_bufB5a[pos] = bpest5;
  prHat_bufB5b[pos] = bpest5;
  prHat_bufB5c[pos] = bpest5;
#pragma empty_line
  prHat_buf6[pos] = bpest6;
  prHat_buf6a[pos] = bpest6;
  prHat_bufA6[pos] = bpest6;
  prHat_bufA6a[pos] = bpest6;
  prHat_bufA6b[pos] = bpest6;
  prHat_bufA6c[pos] = bpest6;
  prHat_bufB6[pos] = bpest6;
#pragma empty_line
#pragma empty_line
  prHat_bufA7[pos] = bpest7;
  prHat_bufB7[pos] = bpest7;
  prHat_bufB7a[pos] = bpest7;
#pragma empty_line
  prHat_buf8[pos] = bpest8;
#pragma empty_line
#pragma empty_line
#pragma empty_line
#pragma empty_line
  prHat_bufA9[pos] = bpest9;
  prHat_bufB9[pos] = bpest9;
  prHat_bufB9a[pos] = bpest9;
#pragma empty_line
  prHat_buf10[pos] = bpest10;
  prHat_buf10a[pos] = bpest10;
  prHat_bufA10[pos] = bpest10;
  prHat_bufA10a[pos] = bpest10;
  prHat_bufA10b[pos] = bpest10;
  prHat_bufA10c[pos] = bpest10;
#pragma empty_line
  prHat_buf10b[pos] = bpest10;
  prHat_bufB10[pos] = bpest10;
}
#pragma empty_line
void update_hat_all_23(short pos)
{
#pragma empty_line
  prHat_buf[pos] = bpest0;
  prHat_bufA[pos] = bpest0;
  prHat_bufAa[pos] = bpest0;
  prHat_bufAb[pos] = bpest0;
  prHat_bufAc[pos] = bpest0;
#pragma empty_line
  prHat_bufB[pos] = bpest0;
#pragma empty_line
  prHat_buf1[pos] = bpest1;
  prHat_bufA1[pos] = bpest1;
  prHat_bufB1[pos] = bpest1;
  prHat_bufB1a[pos] = bpest1;
  prHat_bufB1b[pos] = bpest1;
  prHat_bufB1c[pos] = bpest1;
#pragma empty_line
  prHat_buf2[pos] = bpest2;
  prHat_bufA2[pos] = bpest2;
  prHat_bufA2a[pos] = bpest2;
  prHat_bufA2b[pos] = bpest2;
  prHat_bufA2c[pos] = bpest2;
  prHat_bufB2[pos] = bpest2;
#pragma empty_line
  prHat_buf3[pos] = bpest3;
  prHat_bufA3[pos] = bpest3;
  prHat_bufB3[pos] = bpest3;
  prHat_bufB3a[pos] = bpest3;
  prHat_bufB3b[pos] = bpest3;
  prHat_bufB3c[pos] = bpest3;
#pragma empty_line
  prHat_buf4[pos] = bpest4;
  prHat_buf4a[pos] = bpest4;
  prHat_bufA4[pos] = bpest4;
  prHat_bufA4a[pos] = bpest4;
  prHat_bufA4b[pos] = bpest4;
  prHat_bufB4[pos] = bpest4;
#pragma empty_line
#pragma empty_line
  prHat_bufA5[pos] = bpest5;
  prHat_bufB5[pos] = bpest5;
  prHat_bufB5a[pos] = bpest5;
  prHat_bufB5b[pos] = bpest5;
  prHat_bufB5c[pos] = bpest5;
#pragma empty_line
  prHat_buf6[pos] = bpest6;
  prHat_buf6a[pos] = bpest6;
  prHat_bufA6[pos] = bpest6;
  prHat_bufA6b[pos] = bpest6;
  prHat_bufA6c[pos] = bpest6;
  prHat_bufA6a[pos] = bpest6;
  prHat_bufB6[pos] = bpest6;
}
#pragma empty_line
void update_hat_all_12(short pos)
{
#pragma empty_line
  prHat_buf[pos] = bpest0;
  prHat_bufA[pos] = bpest0;
  prHat_bufAa[pos] = bpest0;
  prHat_bufAb[pos] = bpest0;
  prHat_bufAc[pos] = bpest0;
#pragma empty_line
  prHat_bufB[pos] = bpest0;
#pragma empty_line
  prHat_buf1[pos] = bpest1;
  prHat_bufA1[pos] = bpest1;
  prHat_bufB1[pos] = bpest1;
  prHat_bufB1a[pos] = bpest1;
  prHat_bufB1b[pos] = bpest1;
  prHat_bufB1c[pos] = bpest1;
#pragma empty_line
  prHat_buf2[pos] = bpest2;
  prHat_bufA2[pos] = bpest2;
  prHat_bufA2a[pos] = bpest2;
  prHat_bufA2b[pos] = bpest2;
  prHat_bufA2c[pos] = bpest2;
  prHat_bufB2[pos] = bpest2;
#pragma empty_line
  prHat_buf3[pos] = bpest3;
  prHat_bufA3[pos] = bpest3;
  prHat_bufB3[pos] = bpest3;
  prHat_bufB3a[pos] = bpest3;
  prHat_bufB3b[pos] = bpest3;
  prHat_bufB3c[pos] = bpest3;
#pragma empty_line
  prHat_buf4[pos] = bpest4;
  prHat_buf4a[pos] = bpest4;
  prHat_bufA4[pos] = bpest4;
  prHat_bufA4a[pos] = bpest4;
  prHat_bufA4b[pos] = bpest4;
  prHat_bufB4[pos] = bpest4;
#pragma empty_line
}
#pragma empty_line
void load_pest_all(short pos)
{
  pest0 = pLambda0[pos] + prLamB_buf[pos] + prLamC_buf[pos] + prLamC_bufa[pos]+ prLamC_bufb[pos] +
     prLam2B_buf[pos] + prLam2C_buf[pos] + prLam2C_bufa[pos]+ prLam2C_bufb[pos];
  pest1 = pLambda1[pos] + prLamB_buf1[pos] + prLamB_buf1a[pos] + prLamB_buf1b[pos] + prLamC_buf1[pos]
    + prLam2B_buf1[pos] + prLam2B_buf1a[pos] + prLam2B_buf1b[pos] + prLam2C_buf1[pos] ;
  pest2 = pLambda2[pos] + prLamB_buf2[pos] + prLamC_buf2[pos] + prLamC_buf2a[pos] + prLamC_buf2b[pos] +
     prLam2B_buf2[pos] + prLam2C_buf2[pos] + prLam2C_buf2a[pos] + prLam2C_buf2b[pos];
  pest3 = pLambda3[pos] + prLamB_buf3[pos] + prLamB_buf3a[pos] + prLamB_buf3b[pos] +
    prLamC_buf3[pos] + prLam2B_buf3[pos] + prLam2B_buf3a[pos] + prLam2B_buf3b[pos] + prLam2C_buf3[pos];
  pest4 = pLambda4[pos] + prLamB_buf4[pos] + prLamC_buf4[pos] + prLamC_buf4a[pos] + prLamC_buf4b[pos]+
     prLam2B_buf4[pos] + prLam2C_buf4[pos] + prLam2C_buf4a[pos] + prLam2C_buf4b[pos] ;
  pest5 = pLambda5[pos] + prLamB_buf5[pos] + prLamB_buf5a[pos] + prLamB_buf5b[pos] + prLamC_buf5[pos]
    + prLam2B_buf5[pos] + prLam2B_buf5a[pos] + prLam2B_buf5b[pos]+ prLam2C_buf5[pos];
  pest6 = pLambda6[pos] + prLamB_buf6[pos] + prLamC_buf6[pos] +
     prLam2B_buf6[pos] + prLam2C_buf6[pos] ;
  pest7 = pLambda7[pos] + prLamB_buf7[pos] + prLamB_buf7a[pos] + prLamC_buf7[pos] +
     prLam2B_buf7[pos] + prLam2B_buf7a[pos]+ prLam2C_buf7[pos];
  pest8 = pLambda8[pos] + prLam_buf2[pos]+ prLam2_buf2[pos];
  pest9 = pLambda9[pos] + prLamB_buf9[pos] + prLamB_buf9a[pos] + prLamC_buf9[pos] +
    prLam2B_buf9[pos] + prLam2B_buf9a[pos] + prLam2C_buf9[pos];
  pest10 = blk_val + prLam_buf4[pos] + prLam_buf4a[pos]+ prLamB_buf10[pos] + prLamC_buf10[pos] + prLamC_buf10a[pos] + prLamC_buf10b[pos]+
    prLam2_buf4[pos] + prLam2_buf4a[pos] + prLam2B_buf10[pos] + prLam2C_buf10[pos] + prLam2C_buf10a[pos] + prLam2C_buf10b[pos];
#pragma empty_line
#pragma empty_line
  bpest0 = (pest0 >= 0.0);
  bpest1 = (pest1 >= 0.0);
  bpest2 = (pest2 >= 0.0);
  bpest3 = (pest3 >= 0.0);
  bpest4 = (pest4 >= 0.0);
  bpest5 = (pest5 >= 0.0);
  bpest6 = (pest6 >= 0.0);
  bpest7 = (pest7 >= 0.0);
  bpest8 = (pest8 >= 0.0);
  bpest9 = (pest9 >= 0.0);
  bpest10 = (pest10 >= 0.0);
#pragma empty_line
}
#pragma empty_line
void load_pest_all_23(short pos)
{
#pragma empty_line
  pest0 = pLambda0[pos] + prLamB_buf[pos] + prLamC_buf[pos] + prLamC_bufa[pos]+ prLamC_bufb[pos] +
     prLam2B_buf[pos] + prLam2C_buf[pos] + prLam2C_bufa[pos]+ prLam2C_bufb[pos];
  pest1 = pLambda1[pos] + prLamB_buf1[pos] + prLamB_buf1a[pos] + prLamB_buf1b[pos] + prLamC_buf1[pos]
    + prLam2B_buf1[pos] + prLam2B_buf1a[pos] + prLam2B_buf1b[pos] + prLam2C_buf1[pos] ;
  pest2 = pLambda2[pos] + prLamB_buf2[pos] + prLamC_buf2[pos] + prLamC_buf2a[pos] + prLamC_buf2b[pos] +
     prLam2B_buf2[pos] + prLam2C_buf2[pos] + prLam2C_buf2a[pos] + prLam2C_buf2b[pos];
  pest3 = pLambda3[pos] + prLamB_buf3[pos] + prLamB_buf3a[pos] + prLamB_buf3b[pos] +
    prLamC_buf3[pos] + prLam2B_buf3[pos] + prLam2B_buf3a[pos] + prLam2B_buf3b[pos] + prLam2C_buf3[pos];
  pest4 = pLambda4[pos] + prLam_buf4[pos]+ prLamB_buf4[pos] + prLamC_buf4[pos] + prLamC_buf4a[pos] + prLamC_buf4b[pos]+
    prLam2_buf4[pos]+ prLam2B_buf4[pos] + prLam2C_buf4[pos] + prLam2C_buf4a[pos] + prLam2C_buf4b[pos] ;
  pest5 = pLambda5[pos] + prLamB_buf5[pos] + prLamB_buf5a[pos] + prLamB_buf5b[pos] + prLamC_buf5[pos]
    + prLam2B_buf5[pos] + prLam2B_buf5a[pos] + prLam2B_buf5b[pos]+ prLam2C_buf5[pos];
  pest6 = pLambda6[pos] + prLam_buf2[pos]+ prLam_buf4a[pos] + prLamB_buf6[pos] + prLamC_buf6[pos] + prLamC_buf10a[pos] + prLamC_buf10b[pos] +
    prLam2_buf2[pos]+ prLam2_buf4a[pos] + prLam2B_buf6[pos] + prLam2C_buf6[pos] + prLam2C_buf10a[pos] + prLam2C_buf10b[pos];
#pragma empty_line
  bpest0 = (pest0 >= 0.0);
  bpest1 = (pest1 >= 0.0);
  bpest2 = (pest2 >= 0.0);
  bpest3 = (pest3 >= 0.0);
  bpest4 = (pest4 >= 0.0);
  bpest5 = (pest5 >= 0.0);
  bpest6 = (pest6 >= 0.0);
}
#pragma empty_line
#pragma empty_line
void load_pest_all_12(short pos)
{
#pragma empty_line
#pragma empty_line
 if (pos < 1024)
 {
  pest0 = pLambda0[pos] + prLamB_buf[pos] + prLamC_buf[pos] +
     prLam2B_buf[pos] + prLam2C_buf[pos] ;
#pragma empty_line
  pest1 = pLambda1[pos] + prLamB_buf1[pos] + prLamB_buf1a[pos] + prLamC_buf1[pos]
    + prLam2B_buf1[pos] + prLam2B_buf1a[pos] + prLam2C_buf1[pos] ;
#pragma empty_line
  pest2 = pLambda2[pos] + prLam_buf2[pos] + prLam2_buf2[pos];
#pragma empty_line
  pest3 = pLambda3[pos] + prLamB_buf3[pos] + prLamB_buf3a[pos] +
    prLamC_buf3[pos] + prLam2B_buf3[pos] + prLam2B_buf3a[pos] + prLam2C_buf3[pos];
#pragma empty_line
  pest4 = pLambda4[pos] + prLam_buf4[pos]+ prLam_buf4a[pos] + prLamB_buf4[pos] + prLamC_buf4[pos] + prLamC_buf4a[pos] + prLamC_buf4b[pos]+
    prLam2_buf4[pos] + prLam2_buf4a[pos] + prLam2B_buf4[pos] + prLam2C_buf4[pos] + prLam2C_buf4a[pos] + prLam2C_buf4b[pos] ;
 }
 else
 {
  int inx;
  inx = pos;
  pos = pos - 1024;
#pragma empty_line
  pest0 = pLambda0[inx] + prLamB_buf3b[pos] + prLamC_buf5[pos] +
     prLam2B_buf3b[pos] + prLam2C_buf5[pos] ;
#pragma empty_line
  pest1 = pLambda1[inx] + prLamB_buf5[pos] + prLamB_buf5a[pos] + prLamC_buf6[pos]
    + prLam2B_buf5[pos] + prLam2B_buf5a[pos] + prLam2C_buf6[pos] ;
#pragma empty_line
  pest2 = pLambda2[inx] + prLamB_buf6[pos] + prLam2B_buf6[pos];
#pragma empty_line
  pest3 = pLambda3[inx] + prLamB_buf7[pos] + prLamB_buf7a[pos] +
    prLamC_buf7[pos] + prLam2B_buf7[pos] + prLam2B_buf7a[pos] + prLam2C_buf7[pos];
#pragma empty_line
  pest4 = pLambda4[inx] + prLamB_buf9a[pos]+ prLamB_buf10[pos] + prLamB_buf9[pos] +
    prLamC_buf10[pos] + prLamC_buf10a[pos] + prLamC_buf10b[pos]+ prLam2B_buf9a[pos] +
    prLam2B_buf10[pos] + prLam2B_buf9[pos] + prLam2C_buf10[pos] + prLam2C_buf10a[pos] +
    prLam2C_buf10b[pos] ;
 }
  bpest0 = (pest0 >= 0.0);
  bpest1 = (pest1 >= 0.0);
  bpest2 = (pest2 >= 0.0);
  bpest3 = (pest3 >= 0.0);
  bpest4 = (pest4 >= 0.0);
}
#pragma empty_line
#pragma empty_line
void load_pest_12_bot(short pos)
{
#pragma empty_line
  pest0 = pLambda0[pos] + prLamB_buf[pos] + prLamC_buf[pos] +
     prLam2B_buf[pos] + prLam2C_buf[pos] ;
#pragma empty_line
  pest1 = pLambda1[pos] + prLamB_buf1[pos] + prLamB_buf1a[pos] + prLamC_buf1[pos]
    + prLam2B_buf1[pos] + prLam2B_buf1a[pos] + prLam2C_buf1[pos] ;
#pragma empty_line
  pest2 = pLambda2[pos] + prLam_buf2[pos] + prLam2_buf2[pos];
#pragma empty_line
  pest3 = pLambda3[pos] + prLamB_buf3[pos] + prLamB_buf3a[pos] +
    prLamC_buf3[pos] + prLam2B_buf3[pos] + prLam2B_buf3a[pos] + prLam2C_buf3[pos];
#pragma empty_line
  pest4 = pLambda4[pos] + prLam_buf4[pos]+ prLam_buf4a[pos] + prLamB_buf4[pos] + prLamC_buf4[pos] + prLamC_buf4a[pos] + prLamC_buf4b[pos]+
    prLam2_buf4[pos] + prLam2_buf4a[pos] + prLam2B_buf4[pos] + prLam2C_buf4[pos] + prLam2C_buf4a[pos] + prLam2C_buf4b[pos] ;
#pragma empty_line
  bpest0 = (pest0 >= 0.0);
  bpest1 = (pest1 >= 0.0);
  bpest2 = (pest2 >= 0.0);
  bpest3 = (pest3 >= 0.0);
  bpest4 = (pest4 >= 0.0);
}
#pragma empty_line
void load_pest_12_top(short pos)
{
  int inx;
  inx = pos;
  pos = pos - 1024;
#pragma empty_line
  pest0 = pLambda0[inx] + prLamB_buf3b[pos] + prLamC_buf5[pos] +
     prLam2B_buf3b[pos] + prLam2C_buf5[pos] ;
#pragma empty_line
  pest1 = pLambda1[inx] + prLamB_buf5[pos] + prLamB_buf5a[pos] + prLamC_buf6[pos]
    + prLam2B_buf5[pos] + prLam2B_buf5a[pos] + prLam2C_buf6[pos] ;
#pragma empty_line
  pest2 = pLambda2[inx] + prLamB_buf6[pos] + prLam2B_buf6[pos];
#pragma empty_line
  pest3 = pLambda3[inx] + prLamB_buf7[pos] + prLamB_buf7a[pos] +
    prLamC_buf7[pos] + prLam2B_buf7[pos] + prLam2B_buf7a[pos] + prLam2C_buf7[pos];
#pragma empty_line
  pest4 = pLambda4[inx] + prLamB_buf9a[pos]+ prLamB_buf10[pos] + prLamB_buf9[pos] +
    prLamC_buf10[pos] + prLamC_buf10a[pos] + prLamC_buf10b[pos]+ prLam2B_buf9a[pos] +
    prLam2B_buf10[pos] + prLam2B_buf9[pos] + prLam2C_buf10[pos] + prLam2C_buf10a[pos] +
    prLam2C_buf10b[pos] ;
#pragma empty_line
  bpest0 = (pest0 >= 0.0);
  bpest1 = (pest1 >= 0.0);
  bpest2 = (pest2 >= 0.0);
  bpest3 = (pest3 >= 0.0);
  bpest4 = (pest4 >= 0.0);
}
#pragma empty_line
void calc_n(tab_int nCodeN11)
{
 short n, mSparse, nLenMset, nindx=0;
 short test, ptest;
#pragma empty_line
 short pos =0;
 short loop = 0;
 bool test1;
#pragma empty_line
 for(n=0;n<(nCodeN11);++n)
 {
  load_pest_all(n);
  update_lam_all(n);
  update_hat_all(n);
 }
#pragma empty_line
}
#pragma empty_line
void calc_n_23(tab_int nCodeN11)
{
 short n, mSparse, nLenMset, nindx=0;
 short test, ptest;
#pragma empty_line
 short pos =0;
 short loop = 0;
 bool test1;
#pragma empty_line
 for(n=0;n<(nCodeN11);++n)
 {
  load_pest_all_23(n);
  update_lam_all_23(n);
  update_hat_all_23(n);
 }
#pragma empty_line
}
#pragma empty_line
void calc_n_12(tab_int nCodeN11)
{
 short n, mSparse, nLenMset, nindx=0;
 short test, ptest;
#pragma empty_line
 short pos =0;
 short loop = 0;
 bool test1;
#pragma empty_line
 for(n=0;n<(nCodeN11);++n)
 {
  if (n < 1024)
   load_pest_12_bot(n);
  else
   load_pest_12_top(n);
#pragma empty_line
  update_lam_all_12(n);
  update_hat_all_12(n);
 }
#pragma empty_line
}
#pragma empty_line
void write_pcHat( bool *ppbhat0, bool *ppbhat1, bool *ppbhat2, bool *ppbhat3,
      bool *ppbhat4, bool *ppbhat5, bool *ppbhat6, bool *ppbhat7 )
{
 for (int i = 0; i < cols; i++)
 {
  ppbhat0[i] = prHat_buf[i];
  ppbhat1[i] = prHat_bufA1[i];
  if ( i < 1024)
  {
  ppbhat2[i] = prHat_bufB2[i];
  ppbhat3[i] = prHat_buf3[i];
  ppbhat4[i] = prHat_bufA4[i];
  ppbhat5[i] = prHat_bufB5[i];
  ppbhat6[i] = prHat_buf6[i];
  ppbhat7[i] = prHat_bufA7[i];
  }
 }
}
