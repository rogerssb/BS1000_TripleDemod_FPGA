// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2016.3
// Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved.
// 
// ==============================================================

#1 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
#1 "<built-in>"
#1 "<command-line>"
#1 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
#24 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_fixed.h" 1
#67 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_fixed.h"
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_int.h" 1
#74 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_int.h"
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 1
#75 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 1 3
#19 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 1 3
#32 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 3

#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/_mingw.h" 3
#20 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3






#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#212 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef unsigned int size_t;
#353 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef short unsigned int wint_t;
#27 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdarg.h" 1 3 4
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
#29 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3
#129 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
typedef struct _iobuf
{
 char* _ptr;
 int _cnt;
 char* _base;
 int _flag;
 int _file;
 int _charbuf;
 int _bufsiz;
 char* _tmpfname;
} FILE;
#154 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern __attribute__ ((__dllimport__)) FILE _iob[];
#163 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern "C" {





 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) freopen (const char*, const char*, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fflush (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fclose (FILE*);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) remove (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rename (const char*, const char*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpfile (void);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tmpnam (char*);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _unlink (const char*);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tempnam (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rmtmp(void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) unlink (const char*);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setvbuf (FILE*, char*, int, size_t);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setbuf (FILE*, char*);
#204 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_fprintf(FILE*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_printf(const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_sprintf(char*, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_snprintf(char*, size_t, const char*, ...);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vfprintf(FILE*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vprintf(const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsprintf(char*, const char*, __gnuc_va_list);
extern int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __mingw_vsnprintf(char*, size_t, const char*, __gnuc_va_list);
#293 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fprintf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) printf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sprintf (char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfprintf (FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vprintf (const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsprintf (char*, const char*, __gnuc_va_list);
#308 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_fprintf(FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_printf(const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_sprintf(char*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vfprintf(FILE*, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vprintf(const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __msvcrt_vsprintf(char*, const char*, __gnuc_va_list);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snprintf (char*, size_t, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnprintf (char*, size_t, const char*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscprintf (const char*, __gnuc_va_list);
#331 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snprintf (char *, size_t, const char *, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnprintf (char *, size_t, const char *, __gnuc_va_list);

int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vscanf (const char * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfscanf (FILE * __restrict__, const char * __restrict__,
       __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsscanf (const char * __restrict__,
       const char * __restrict__, __gnuc_va_list);







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fscanf (FILE*, const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) scanf (const char*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) sscanf (const char*, const char*, ...);




 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetc (FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgets (char*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputc (int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputs (const char*, FILE*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gets (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) puts (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetc (int, FILE*);







 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _filbuf (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flsbuf (int, FILE*);



inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getc (FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) *__F->_ptr++
    : _filbuf (__F);
}

inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putc (int __c, FILE* __F)
{
  return (--__F->_cnt >= 0)
    ? (int) (unsigned char) (*__F->_ptr++ = (char)__c)
    : _flsbuf (__c, __F);
}

inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getchar (void)
{
  return (--(&_iob[0])->_cnt >= 0)
    ? (int) (unsigned char) *(&_iob[0])->_ptr++
    : _filbuf ((&_iob[0]));
}

inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putchar(int __c)
{
  return (--(&_iob[1])->_cnt >= 0)
    ? (int) (unsigned char) (*(&_iob[1])->_ptr++ = (char)__c)
    : _flsbuf (__c, (&_iob[1]));}
#412 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fread (void*, size_t, size_t, FILE*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwrite (const void*, size_t, size_t, FILE*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseek (FILE*, long, int);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftell (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rewind (FILE*);
#455 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
typedef long long fpos_t;




 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetpos (FILE*, fpos_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fsetpos (FILE*, const fpos_t*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE*);


inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) feof (FILE* __F)
  { return __F->_flag & 0x0010; }
inline int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ferror (FILE* __F)
  { return __F->_flag & 0x0020; }





 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) clearerr (FILE*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) perror (const char*);






 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _pclose (FILE*);


 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) popen (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) pclose (FILE*);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _flushall (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fileno (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcloseall (void);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fsopen (const char*, const char*, int);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getmaxstdio (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _setmaxstdio (int);
#522 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetchar (void);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputchar (int);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fdopen (int, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fileno (FILE*);
#534 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 1 3
#21 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#150 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 3 4
typedef int ptrdiff_t;
#22 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 2 3





typedef long __time32_t;




typedef long long __time64_t;
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/sys/types.h" 3
typedef __time32_t time_t;






typedef long _off_t;


typedef _off_t off_t;







typedef unsigned int _dev_t;





typedef _dev_t dev_t;






typedef short _ino_t;


typedef _ino_t ino_t;






typedef int _pid_t;


typedef _pid_t pid_t;






typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef int _sigset_t;


typedef _sigset_t sigset_t;





typedef int _ssize_t;


typedef _ssize_t ssize_t;





typedef long long fpos64_t;




typedef long long off64_t;



typedef unsigned int useconds_t;
#535 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 2 3
inline FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fopen64 (const char* filename, const char* mode)
{
  return fopen (filename, mode);
}

int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fseeko64 (FILE*, off64_t, int);






inline off64_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ftello64 (FILE * stream)
{
  fpos_t pos;
  if (fgetpos(stream, &pos))
    return -1LL;
  else
   return ((off64_t) pos);
}
#563 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwprintf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wprintf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _snwprintf (wchar_t*, size_t, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwprintf (FILE*, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vsnwprintf (wchar_t*, size_t, const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _vscwprintf (const wchar_t*, __gnuc_va_list);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwscanf (FILE*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wscanf (const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swscanf (const wchar_t*, const wchar_t*, ...);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwc (wchar_t, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ungetwc (wchar_t, FILE*);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swprintf (wchar_t*, const wchar_t*, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswprintf (wchar_t*, const wchar_t*, __gnuc_va_list);



 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetws (wchar_t*, int, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputws (const wchar_t*, FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwc (FILE*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getwchar (void);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getws (wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwc (wint_t, FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putws (const wchar_t*);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putwchar (wint_t);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfdopen(int, const wchar_t *);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfopen (const wchar_t*, const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfreopen (const wchar_t*, const wchar_t*, FILE*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfsopen (const wchar_t*, const wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtmpnam (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtempnam (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrename (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wremove (const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wperror (const wchar_t*);
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wpopen (const wchar_t*, const wchar_t*);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) snwprintf (wchar_t* s, size_t n, const wchar_t* format, ...);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vsnwprintf (wchar_t* s, size_t n, const wchar_t* format, __gnuc_va_list arg);





int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vwscanf (const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vfwscanf (FILE * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) vswscanf (const wchar_t * __restrict__,
         const wchar_t * __restrict__, __gnuc_va_list);
#625 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdio.h" 3
 FILE* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wpopen (const wchar_t*, const wchar_t*);






 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putw (int, FILE*);


 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fgetwchar (void);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fputwchar (wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getw (FILE*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putw (int, FILE*);





}
#76 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3

#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 1 3
#153 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}
#393 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/os_defines.h" 1 3
#394 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 2 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/cpu_defines.h" 1 3
#397 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++config.h" 2 3
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 3

#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3



namespace std
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
#85 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stringfwd.h" 3

}
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 1 3
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3

#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3




#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 1 3
#26 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#27 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 2 3
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 1 3
#32 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 2 3
#54 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
extern "C" {







typedef wchar_t wctype_t;




 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);





 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);





  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];


  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#148 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
typedef wchar_t wctrans_t;
#157 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wctype.h" 3
wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towctrans(wint_t, wctrans_t);
wctrans_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctrans(const char*);
wctype_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctype(const char*);


}
#46 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 2 3
#63 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
extern "C" {
#87 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        };
#164 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstol (const wchar_t*, wchar_t**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoul (const wchar_t*, wchar_t**, int);
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstod (const wchar_t*, wchar_t**);

float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstof (const wchar_t * __restrict__, wchar_t ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);


 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetenv(const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wputenv(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsystem(const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfullpath (wchar_t*, const wchar_t*, size_t);
#187 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wasctime (const struct tm*);

 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wctime (const time_t*);

 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrdate (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstrtime (wchar_t*);
#207 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsftime (wchar_t*, size_t, const wchar_t*, const struct tm*);
#217 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscat (wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcschr (const wchar_t*, wchar_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscpy (wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscspn (const wchar_t*, const wchar_t*);

 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslen (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncat (wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncmp(const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsncpy(wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcspbrk(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrchr(const wchar_t*, wchar_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsspn(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsstr(const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstok(wchar_t*, const wchar_t*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsxfrm(wchar_t*, const wchar_t*, size_t);
#243 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsupr (wchar_t*);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsncoll(const wchar_t*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcsnicoll(const wchar_t*, const wchar_t*, size_t);
#264 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcscmpi (const wchar_t *, const wchar_t *);





 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsdup (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicmp (const wchar_t*, const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsicoll (const wchar_t*, const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcslwr (wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnicmp (const wchar_t*, const wchar_t*, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsnset (wchar_t*, wchar_t, size_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrev (wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsset (wchar_t*, wchar_t);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsupr (wchar_t*);
#292 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
typedef wchar_t _Wint_t;


typedef int mbstate_t;

wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) btowc(int);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrlen(const char * __restrict__, size_t,
        mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbrtowc(wchar_t * __restrict__, const char * __restrict__,
         size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsrtowcs(wchar_t * __restrict__, const char ** __restrict__,
    size_t, mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcrtomb(char * __restrict__, wchar_t,
         mbstate_t * __restrict__);
size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcsrtombs(char * __restrict__, const wchar_t ** __restrict__,
    size_t, mbstate_t * __restrict__);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctob(wint_t);


int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fwide(FILE*, int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbsinit(const mbstate_t*);







wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemset(wchar_t *, wchar_t, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemchr(const wchar_t*, wchar_t, size_t);
int wmemcmp(const wchar_t*, const wchar_t *, size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemcpy(wchar_t* __restrict__,
           const wchar_t* __restrict__,
    size_t);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wmemmove(wchar_t* s1, const wchar_t *, size_t);
long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoll(const wchar_t * __restrict__,
     wchar_t** __restrict__, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstoull(const wchar_t * __restrict__,
       wchar_t ** __restrict__, int);






typedef unsigned long _fsize_t;




struct _wfinddata_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 _fsize_t size;
 wchar_t name[260];
};
struct _wfinddatai64_t {
 unsigned attrib;
 time_t time_create;
 time_t time_access;
 time_t time_write;
 long long size;
 wchar_t name[260];
};
#406 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdint.h" 1 3 4


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 1 3 4
#24 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#25 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;
#66 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
  typedef int intptr_t;
#75 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdint.h" 3 4
  typedef unsigned int uintptr_t;




typedef long long intmax_t;
typedef unsigned long long uintmax_t;
#4 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stdint.h" 2 3 4
#407 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 2 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _waccess (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchmod (const wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wcreat (const wchar_t*, int);

 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirst (const wchar_t*, struct _wfinddata_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnext (long, struct _wfinddata_t *);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wunlink (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wopen (const wchar_t*, int, ...);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsopen (const wchar_t*, int, int, ...);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmktemp (wchar_t*);

 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindfirsti64 (const wchar_t*, struct _wfinddatai64_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wfindnexti64 (long, struct _wfinddatai64_t*);
#454 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wchdir (const wchar_t*);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetcwd (wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wgetdcwd (int, wchar_t*, int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wmkdir (const wchar_t*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wrmdir (const wchar_t*);
#471 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
struct _stat
{
 _dev_t st_dev;
 _ino_t st_ino;
 _mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 _dev_t st_rdev;
 _off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct stat
{
 dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 short st_nlink;
 short st_uid;
 short st_gid;
 dev_t st_rdev;
 off_t st_size;
 time_t st_atime;

 time_t st_mtime;
 time_t st_ctime;
};



struct _stati64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    long long st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
};
#589 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstat (const wchar_t*, struct _stat*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wstati64 (const wchar_t*, struct _stati64*);
#612 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/wchar.h" 3
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wsetlocale (int, const wchar_t*);





 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecl (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecle (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclp (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexeclpe (const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecv (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecve (const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvp (const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wexecvpe (const wchar_t*, const wchar_t* const*, const wchar_t* const*);

 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnl (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnle (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlp (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnlpe (int, const wchar_t*, const wchar_t*, ...);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnv (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnve (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvp (int, const wchar_t*, const wchar_t* const*);
 intptr_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wspawnvpe (int, const wchar_t*, const wchar_t* const*, const wchar_t* const*);






}
#47 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 2 3
#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
#137 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;



  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;





  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
#259 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 2 3
#70 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
namespace std
{

#92 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
#113 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
#135 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
#241 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/postypes.h" 3

}
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 2 3

namespace std
{

#76 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 1 3
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3

#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
#61 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
#118 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

#143 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 1 3
#61 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/exception_defines.h" 1 3
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/functexcept.h" 2 3

namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
#62 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 1 3
#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3

#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
#69 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
namespace __gnu_cxx
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#199 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
#422 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cpp_type_traits.h" 3

}
#63 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 1 3
#32 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 3

#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/type_traits.h" 3




namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };


}
#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 1 3
#32 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3

#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

#54 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
#99 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
#65 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 1 3
#60 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 1 3
#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 3

#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/concept_check.h" 3
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 2 3

namespace std
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
#109 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
namespace std
{

#120 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}
#61 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 2 3





namespace std
{

#86 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
#196 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
#270 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



}
#66 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 1 3
#63 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3

#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3







namespace std
{

#90 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
#117 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
#163 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
#67 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 1 3
#63 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3

#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3



namespace std
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
#111 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
#169 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
#200 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator_base_funcs.h" 3

}
#68 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 1 3
#68 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
namespace std
{

#96 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
#283 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
#395 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
#422 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
#445 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
#471 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
#486 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
#512 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
#535 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
#561 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
#580 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
#623 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
#649 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
#675 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{

#699 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
#797 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
#69 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/debug/debug.h" 1 3
#47 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
#71 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 2 3


namespace std
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
#116 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;











      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
#157 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
#185 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
#208 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
#231 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
#252 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
#319 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
#357 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
#442 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#494 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
#522 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
#552 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
#611 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#669 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
#713 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
#773 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
#934 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




#1008 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
#1040 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
#1071 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
#1105 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
#1145 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#1182 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 2 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwchar" 3
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 2 3

namespace __gnu_cxx
{

#59 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
#84 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{

#228 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((wchar_t)(0xFFFF)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 1 3
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 3

#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 1 3
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 2 3




struct lconv
{
 char* decimal_point;
 char* thousands_sep;
 char* grouping;
 char* int_curr_symbol;
 char* currency_symbol;
 char* mon_decimal_point;
 char* mon_thousands_sep;
 char* mon_grouping;
 char* positive_sign;
 char* negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
};


extern "C" {


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) setlocale (int, const char*);
 struct lconv* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) localeconv (void);
#82 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/locale.h" 3
}
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 2 3
#53 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 2 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 1 3
#20 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#21 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 2 3
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
extern "C" {


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalnum(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isalpha(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscntrl(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isdigit(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isgraph(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) islower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isprint(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ispunct(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isspace(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isupper(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isxdigit(int);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isblank (int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _isctype (int, int);



 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toupper(int);
#83 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _tolower(int);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _toupper(int);







   extern __attribute__ ((__dllimport__)) int __mb_cur_max;
#112 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
  extern __attribute__ ((__dllimport__)) unsigned short _ctype[];


  extern __attribute__ ((__dllimport__)) unsigned short* _pctype;
#192 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalnum(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswalpha(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswascii(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswcntrl(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) is_wctype(wint_t, wctype_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswdigit(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswgraph(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswlower(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswprint(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswpunct(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswspace(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswupper(wint_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswxdigit(wint_t);



int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iswblank (wint_t);





 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towlower (wint_t);
 wint_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) towupper (wint_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isleadbyte (int);
#246 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __iscsym (int);
#260 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/ctype.h" 3
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) isascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) toascii (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsymf (int);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) iscsym (int);





}
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 2 3
#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 2 3

namespace std
{

#57 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 1 3
#30 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
#162 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 1 3
#70 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 1 3
#80 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 3
extern "C" {
#91 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/errno.h" 3
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);




}
#71 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 2 3
#340 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
extern "C" {


typedef unsigned long __gthread_key_t;

typedef struct {
  int done;
  long started;
} __gthread_once_t;

typedef struct {
  long counter;
  void *sema;
} __gthread_mutex_t;

typedef struct {
  long counter;
  long depth;
  unsigned long owner;
  void *sema;
} __gthread_recursive_mutex_t;
#374 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
extern int _CRT_MT;
extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));
#401 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{

  return _CRT_MT;



}







extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));
extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));
extern int __gthr_win32_key_delete (__gthread_key_t);
extern void * __gthr_win32_getspecific (__gthread_key_t);
extern int __gthr_win32_setspecific (__gthread_key_t, const void *);
extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);
extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);
extern void
  __gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *);
extern int
  __gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *);
extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthr_win32_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthr_win32_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthr_win32_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthr_win32_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthr_win32_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_init_function (__mutex);
}

static inline void
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_destroy (__mutex);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_trylock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_unlock (__mutex);
  else
    return 0;
}

static inline void
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
   __gthr_win32_recursive_mutex_init_function (__mutex);
}

static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_trylock (__mutex);
  else
    return 0;
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_unlock (__mutex);
  else
    return 0;
}
#767 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr-default.h" 3
}
#163 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/gthr.h" 2 3







#pragma GCC visibility pop
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/atomic_word.h" 1 3
#32 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 2 3

namespace __gnu_cxx
{

#54 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/atomicity.h" 3
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word*, int) throw ();

  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word*, int) throw ();


  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 2 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 3




#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 1 3
#48 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
#93 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 2 3



namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
#53 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
#117 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/c++allocator.h" 2 3
#49 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 2 3





namespace std
{

#65 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
#91 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
#236 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/allocator.h" 3

}
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 1 3
#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 3

#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 3

#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
#47 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3



#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 1 3
#60 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
namespace std
{

#101 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
#140 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#204 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
#268 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
#351 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
#422 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
#508 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
#541 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 1 3
#60 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 3
namespace std
{

#99 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
#732 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/stl_function.h" 2 3
#51 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 1 3
#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 3

#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/range_access.h" 3
#54 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3



#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 1 3
#33 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 3

#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/initializer_list" 3
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 2 3

namespace std
{

#106 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
#143 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
#168 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
#478 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
#526 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
#559 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
#599 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
#705 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
#734 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
#747 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
#767 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
#788 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
#817 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
#834 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
#855 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
#908 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
#964 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
#979 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
#1011 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
#1033 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
#1089 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
#1105 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
#1117 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
#1133 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
#1145 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
#1173 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
#1188 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
#1219 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
#1241 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
#1264 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
#1282 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
#1305 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
#1322 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#1346 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
#1362 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
#1382 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
#1401 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
#1423 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
#1447 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
#1466 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
#1489 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
#1507 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
#1525 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
#1546 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
#1567 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
#1589 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#1664 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
#1745 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
#1755 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
#1765 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
#1797 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
#1810 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
#1824 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
#1841 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
#1854 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
#1869 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
#1882 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
#1899 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
#1912 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
#1927 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
#1940 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
#1959 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
#1973 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
#1988 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
#2001 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
#2020 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
#2034 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
#2049 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
#2063 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
#2080 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
#2093 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
#2109 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
#2122 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
#2139 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
#2154 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
#2172 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
#2202 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
#2226 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
#2244 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
#2267 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
#2292 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
#2304 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
#2425 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
#2471 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
#2508 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
#2545 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
#2582 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
#2619 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
#2656 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
#2673 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
#2691 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
#2714 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
#2732 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
#55 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 1 3
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3

#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
#242 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
#579 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
#56 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/string" 2 3
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 2 3


namespace std
{

#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
#100 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
#119 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale() throw();
#128 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
#138 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
#153 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
#166 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
#178 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
#192 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
#207 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
#226 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
#254 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
#270 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
#305 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
#339 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
#370 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
#437 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
#583 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
#600 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
#617 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
#644 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
#658 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
#675 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
#694 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
#708 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
#737 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
#753 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
#766 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 3

#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
#824 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_classes.h" 2 3
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 2 3

namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
#201 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
#257 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
#332 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
#363 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
#395 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
#421 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
#438 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
#450 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
#563 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
#579 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
#596 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
#622 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
#673 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
#685 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
#696 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
#707 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
#726 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    static int
    xalloc() throw();
#742 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
#763 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
#780 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3

#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
#46 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
#116 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
#182 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
#206 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
#223 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
#236 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
#263 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
#277 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
#295 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
#317 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
#336 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
#351 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
#376 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
#403 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
#429 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
#443 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
#461 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
#477 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
#488 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
#508 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
#524 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
#534 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
#555 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
#570 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
#581 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#593 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#606 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int
      sync() { return 0; }
#628 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
#644 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
#666 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
#679 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
#703 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
#721 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
#747 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
#762 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
#809 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/streambuf" 2 3
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 1 3
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3

#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3



#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3
#82 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cctype" 3
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_base.h" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);
  };


}
#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3






#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 1 3
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3

#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3




namespace std
{

#51 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
#51 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3

namespace std
{

#66 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
#144 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
#162 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
#179 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
#195 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
#211 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
#225 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#240 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#254 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#269 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#286 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
#305 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
#324 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
#346 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
#371 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
#390 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
#409 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
#428 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
#446 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
#463 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
#479 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
#496 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
#515 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
#536 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
#558 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
#582 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
#605 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
#674 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
#711 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
#724 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
#737 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
#752 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
#766 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
#780 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
#795 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#812 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#828 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#845 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#865 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
#892 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
#923 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
#956 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
#1005 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#1022 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1038 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#1055 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1075 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
#1098 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
#1124 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
#1150 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
#1175 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
#1208 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
#1219 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
#1243 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
#1262 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#1280 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#1298 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#1315 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
#1332 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1348 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
#1365 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1385 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
#1407 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
#1430 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
#1456 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_inline.h" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/mingw32/bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
#1513 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
#1641 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
#1679 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
#1693 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
#1707 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#1720 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#1751 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
#1764 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
#1777 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
#1794 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#1806 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#1819 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#1832 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
#1845 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


#1915 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
#1936 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
#1962 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#1998 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2057 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2099 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
#2170 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
#2235 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
#2253 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
#2274 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
#2292 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2334 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2397 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
#2422 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
#2470 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 1 3
#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3

#36 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
#138 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#732 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
#968 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
#1029 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#1154 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


#1191 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
#2609 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/locale_facets.h" 2 3
#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 2 3


namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
#63 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
#128 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
#139 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
#192 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
#213 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
#248 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
#286 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
#298 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
#338 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
#352 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
#381 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
#401 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
#421 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
#440 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 1 3
#34 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3

#35 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
#147 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
#474 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/basic_ios.h" 2 3
#46 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ios" 2 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 2 3


namespace std
{

#56 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
#83 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
#109 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
#166 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
#251 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
#284 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
#312 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
#325 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      flush();
#336 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      pos_type
      tellp();
#347 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      __ostream_type&
      seekp(pos_type);
#359 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
#378 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
#397 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
#407 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#428 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
#449 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
#491 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#541 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
#585 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 3

}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
#589 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/ostream" 2 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3




namespace std
{

#56 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
#92 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
#121 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
#168 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
#240 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
#250 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
#282 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int_type
      get();
#296 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type& __c);
#323 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
#334 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
#357 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
#367 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
#396 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
#407 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
#431 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
#448 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int_type
      peek();
#466 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
#485 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
#502 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      putback(char_type __c);
#518 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      unget();
#536 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      int
      sync();
#551 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      pos_type
      tellg();
#566 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      seekg(pos_type);
#582 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#637 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
#673 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
#686 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
      operator bool() const
      { return _M_ok; }
    };
#703 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#745 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#773 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
#834 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
#856 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 3

}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#515 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
#860 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/istream" 2 3
#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 2 3

namespace std
{

#61 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
#77 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 2
#97 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/limits.h" 1 3
#98 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 2
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 1
#103 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
namespace AESL_std {
    template <class DataType>
    DataType inline min(DataType a, DataType b) {


        return (a>=b) ? b : a;
    }

    template <class DataType>
    DataType inline max(DataType a, DataType b) {


        return (a>=b) ? a : b;
    }
}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 1 3
#43 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 3

#44 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 3

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 1 3
#23 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
extern "C" {
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _assert (const char*, const char*, int) __attribute__ ((__noreturn__));
#48 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/assert.h" 3
}
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cassert" 2 3
#120 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 1 3
#16 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3

#17 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
#90 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern "C" {
#134 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
struct _exception
{
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};

 double __attribute__((__cdecl__)) sin (double);
 double __attribute__((__cdecl__)) cos (double);
 double __attribute__((__cdecl__)) tan (double);
 double __attribute__((__cdecl__)) sinh (double);
 double __attribute__((__cdecl__)) cosh (double);
 double __attribute__((__cdecl__)) tanh (double);
 double __attribute__((__cdecl__)) asin (double);
 double __attribute__((__cdecl__)) acos (double);
 double __attribute__((__cdecl__)) atan (double);
 double __attribute__((__cdecl__)) atan2 (double, double);
 double __attribute__((__cdecl__)) exp (double);
 double __attribute__((__cdecl__)) log (double);
 double __attribute__((__cdecl__)) log10 (double);
 double __attribute__((__cdecl__)) pow (double, double);
 double __attribute__((__cdecl__)) sqrt (double);
 double __attribute__((__cdecl__)) ceil (double);
 double __attribute__((__cdecl__)) floor (double);
 double __attribute__((__cdecl__)) fabs (double);
 double __attribute__((__cdecl__)) ldexp (double, int);
 double __attribute__((__cdecl__)) frexp (double, int*);
 double __attribute__((__cdecl__)) modf (double, double*);
 double __attribute__((__cdecl__)) fmod (double, double);
#210 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
struct _complex
{
 double x;
 double y;
};

 double __attribute__((__cdecl__)) _cabs (struct _complex);

 double __attribute__((__cdecl__)) _hypot (double, double);
 double __attribute__((__cdecl__)) _j0 (double);
 double __attribute__((__cdecl__)) _j1 (double);
 double __attribute__((__cdecl__)) _jn (int, double);
 double __attribute__((__cdecl__)) _y0 (double);
 double __attribute__((__cdecl__)) _y1 (double);
 double __attribute__((__cdecl__)) _yn (int, double);
 int __attribute__((__cdecl__)) _matherr (struct _exception *);
#234 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 double __attribute__((__cdecl__)) _chgsign (double);
 double __attribute__((__cdecl__)) _copysign (double, double);
 double __attribute__((__cdecl__)) _logb (double);
 double __attribute__((__cdecl__)) _nextafter (double, double);
 double __attribute__((__cdecl__)) _scalb (double, long);

 int __attribute__((__cdecl__)) _finite (double);
 int __attribute__((__cdecl__)) _fpclass (double);
 int __attribute__((__cdecl__)) _isnan (double);
#254 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 double __attribute__((__cdecl__)) j0 (double);
 double __attribute__((__cdecl__)) j1 (double);
 double __attribute__((__cdecl__)) jn (int, double);
 double __attribute__((__cdecl__)) y0 (double);
 double __attribute__((__cdecl__)) y1 (double);
 double __attribute__((__cdecl__)) yn (int, double);

 double __attribute__((__cdecl__)) chgsign (double);
#270 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
 int __attribute__((__cdecl__)) finite (double);
 int __attribute__((__cdecl__)) fpclass (double);
#324 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
typedef long double float_t;
typedef long double double_t;
#354 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __fpclassifyf (float);
extern int __attribute__((__cdecl__)) __fpclassify (double);
extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
#379 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __isnan (double);
extern int __attribute__((__cdecl__)) __isnanf (float);
extern int __attribute__((__cdecl__)) __isnanl (long double);
#419 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern int __attribute__((__cdecl__)) __signbit (double);
extern int __attribute__((__cdecl__)) __signbitf (float);
extern int __attribute__((__cdecl__)) __signbitl (long double);
#447 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern float __attribute__((__cdecl__)) sinf (float);
extern long double __attribute__((__cdecl__)) sinl (long double);

extern float __attribute__((__cdecl__)) cosf (float);
extern long double __attribute__((__cdecl__)) cosl (long double);

extern float __attribute__((__cdecl__)) tanf (float);
extern long double __attribute__((__cdecl__)) tanl (long double);

extern float __attribute__((__cdecl__)) asinf (float);
extern long double __attribute__((__cdecl__)) asinl (long double);

extern float __attribute__((__cdecl__)) acosf (float);
extern long double __attribute__((__cdecl__)) acosl (long double);

extern float __attribute__((__cdecl__)) atanf (float);
extern long double __attribute__((__cdecl__)) atanl (long double);

extern float __attribute__((__cdecl__)) atan2f (float, float);
extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


extern float __attribute__((__cdecl__)) sinhf (float);




extern long double __attribute__((__cdecl__)) sinhl (long double);

extern float __attribute__((__cdecl__)) coshf (float);




extern long double __attribute__((__cdecl__)) coshl (long double);

extern float __attribute__((__cdecl__)) tanhf (float);




extern long double __attribute__((__cdecl__)) tanhl (long double);



extern double __attribute__((__cdecl__)) acosh (double);
extern float __attribute__((__cdecl__)) acoshf (float);
extern long double __attribute__((__cdecl__)) acoshl (long double);


extern double __attribute__((__cdecl__)) asinh (double);
extern float __attribute__((__cdecl__)) asinhf (float);
extern long double __attribute__((__cdecl__)) asinhl (long double);


extern double __attribute__((__cdecl__)) atanh (double);
extern float __attribute__((__cdecl__)) atanhf (float);
extern long double __attribute__((__cdecl__)) atanhl (long double);



extern float __attribute__((__cdecl__)) expf (float);




extern long double __attribute__((__cdecl__)) expl (long double);


extern double __attribute__((__cdecl__)) exp2(double);
extern float __attribute__((__cdecl__)) exp2f(float);
extern long double __attribute__((__cdecl__)) exp2l(long double);



extern double __attribute__((__cdecl__)) expm1(double);
extern float __attribute__((__cdecl__)) expm1f(float);
extern long double __attribute__((__cdecl__)) expm1l(long double);


extern float __attribute__((__cdecl__)) frexpf (float, int*);




extern long double __attribute__((__cdecl__)) frexpl (long double, int*);




extern int __attribute__((__cdecl__)) ilogb (double);
extern int __attribute__((__cdecl__)) ilogbf (float);
extern int __attribute__((__cdecl__)) ilogbl (long double);


extern float __attribute__((__cdecl__)) ldexpf (float, int);




extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


extern float __attribute__((__cdecl__)) logf (float);
extern long double __attribute__((__cdecl__)) logl (long double);


extern float __attribute__((__cdecl__)) log10f (float);
extern long double __attribute__((__cdecl__)) log10l (long double);


extern double __attribute__((__cdecl__)) log1p(double);
extern float __attribute__((__cdecl__)) log1pf(float);
extern long double __attribute__((__cdecl__)) log1pl(long double);


extern double __attribute__((__cdecl__)) log2 (double);
extern float __attribute__((__cdecl__)) log2f (float);
extern long double __attribute__((__cdecl__)) log2l (long double);


extern double __attribute__((__cdecl__)) logb (double);
extern float __attribute__((__cdecl__)) logbf (float);
extern long double __attribute__((__cdecl__)) logbl (long double);
#603 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern float __attribute__((__cdecl__)) modff (float, float*);
extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


extern double __attribute__((__cdecl__)) scalbn (double, int);
extern float __attribute__((__cdecl__)) scalbnf (float, int);
extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

extern double __attribute__((__cdecl__)) scalbln (double, long);
extern float __attribute__((__cdecl__)) scalblnf (float, long);
extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



extern double __attribute__((__cdecl__)) cbrt (double);
extern float __attribute__((__cdecl__)) cbrtf (float);
extern long double __attribute__((__cdecl__)) cbrtl (long double);


extern float __attribute__((__cdecl__)) fabsf (float x);
extern long double __attribute__((__cdecl__)) fabsl (long double x);


extern double __attribute__((__cdecl__)) hypot (double, double);
extern float __attribute__((__cdecl__)) hypotf (float, float);




extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


extern float __attribute__((__cdecl__)) powf (float, float);




extern long double __attribute__((__cdecl__)) powl (long double, long double);


extern float __attribute__((__cdecl__)) sqrtf (float);
extern long double __attribute__((__cdecl__)) sqrtl (long double);


extern double __attribute__((__cdecl__)) erf (double);
extern float __attribute__((__cdecl__)) erff (float);
extern long double __attribute__((__cdecl__)) erfl (long double);


extern double __attribute__((__cdecl__)) erfc (double);
extern float __attribute__((__cdecl__)) erfcf (float);
extern long double __attribute__((__cdecl__)) erfcl (long double);


extern double __attribute__((__cdecl__)) lgamma (double);
extern float __attribute__((__cdecl__)) lgammaf (float);
extern long double __attribute__((__cdecl__)) lgammal (long double);


extern double __attribute__((__cdecl__)) tgamma (double);
extern float __attribute__((__cdecl__)) tgammaf (float);
extern long double __attribute__((__cdecl__)) tgammal (long double);


extern float __attribute__((__cdecl__)) ceilf (float);
extern long double __attribute__((__cdecl__)) ceill (long double);


extern float __attribute__((__cdecl__)) floorf (float);
extern long double __attribute__((__cdecl__)) floorl (long double);


extern double __attribute__((__cdecl__)) nearbyint ( double);
extern float __attribute__((__cdecl__)) nearbyintf (float);
extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

extern long long __attribute__((__cdecl__)) llrint (double);
extern long long __attribute__((__cdecl__)) llrintf (float);
extern long long __attribute__((__cdecl__)) llrintl (long double);
#771 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern double __attribute__((__cdecl__)) round (double);
extern float __attribute__((__cdecl__)) roundf (float);
extern long double __attribute__((__cdecl__)) roundl (long double);


extern long __attribute__((__cdecl__)) lround (double);
extern long __attribute__((__cdecl__)) lroundf (float);
extern long __attribute__((__cdecl__)) lroundl (long double);

extern long long __attribute__((__cdecl__)) llround (double);
extern long long __attribute__((__cdecl__)) llroundf (float);
extern long long __attribute__((__cdecl__)) llroundl (long double);



extern double __attribute__((__cdecl__)) trunc (double);
extern float __attribute__((__cdecl__)) truncf (float);
extern long double __attribute__((__cdecl__)) truncl (long double);


extern float __attribute__((__cdecl__)) fmodf (float, float);
extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


extern double __attribute__((__cdecl__)) remainder (double, double);
extern float __attribute__((__cdecl__)) remainderf (float, float);
extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


extern double __attribute__((__cdecl__)) remquo(double, double, int *);
extern float __attribute__((__cdecl__)) remquof(float, float, int *);
extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


extern double __attribute__((__cdecl__)) copysign (double, double);
extern float __attribute__((__cdecl__)) copysignf (float, float);
extern long double __attribute__((__cdecl__)) copysignl (long double, long double);


extern double __attribute__((__cdecl__)) nan(const char *tagp);
extern float __attribute__((__cdecl__)) nanf(const char *tagp);
extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
#821 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
extern double __attribute__((__cdecl__)) nextafter (double, double);
extern float __attribute__((__cdecl__)) nextafterf (float, float);
extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


extern double __attribute__((__cdecl__)) nexttoward (double, long double);
extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



extern double __attribute__((__cdecl__)) fdim (double x, double y);
extern float __attribute__((__cdecl__)) fdimf (float x, float y);
extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







extern double __attribute__((__cdecl__)) fmax (double, double);
extern float __attribute__((__cdecl__)) fmaxf (float, float);
extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


extern double __attribute__((__cdecl__)) fmin (double, double);
extern float __attribute__((__cdecl__)) fminf (float, float);
extern long double __attribute__((__cdecl__)) fminl (long double, long double);



extern double __attribute__((__cdecl__)) fma (double, double, double);
extern float __attribute__((__cdecl__)) fmaf (float, float, float);
extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
#910 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/math.h" 3
}
#123 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
#148 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
#192 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
#213 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
    static const bool is_signed = false;



    static const bool is_integer = false;





    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;





    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
#303 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return static_cast<_Tp>(0); }


      static _Tp
      max() throw() { return static_cast<_Tp>(0); }
#324 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
      static _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }


      static _Tp
      round_error() throw() { return static_cast<_Tp>(0); }


      static _Tp
      infinity() throw() { return static_cast<_Tp>(0); }



      static _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }




      static _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };
#370 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw() { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#852 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -2147483647L - 1; }

      static long
      max() throw() { return 2147483647L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 2147483647L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw() { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435082228750797e-38F; }

      static float
      max() throw() { return 3.40282346638528859812e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209289550781250000e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf (); }

      static float
      quiet_NaN() throw() { return __builtin_nanf (""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf (""); }

      static float
      denorm_min() throw() { return 1.40129846432481707092e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return double(2.22507385850720138309e-308L); }

      static double
      max() throw() { return double(1.79769313486231570815e+308L); }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return double(2.22044604925031308085e-16L); }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan (""); }

      static double
      signaling_NaN() throw() { return __builtin_nans (""); }

      static double
      denorm_min() throw() { return double(4.94065645841246544177e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall (); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl (""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl (""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
#124 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3


#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 1 3
#24 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#25 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 2 3





extern "C" {





 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memchr (const void*, int, size_t) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcmp (const void*, const void*, size_t) __attribute__ ((__pure__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memcpy (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memmove (void*, const void*, size_t);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memset (void*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcat (char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strchr (const char*, int) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmp (const char*, const char*) __attribute__ ((__pure__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcpy (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strerror (int);

 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlen (const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncat (char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncmp (const char*, const char*, size_t) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncpy (char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strpbrk (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrchr (const char*, int) __attribute__ ((__pure__));
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strspn (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strstr (const char*, const char*) __attribute__ ((__pure__));
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtok (char*, const char*);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strxfrm (char*, const char*, size_t);





 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strerror (const char *);
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricmp (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicmp (const char*, const char*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strupr (char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _swab (const char*, char*, size_t);


 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strncoll(const char*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _strnicoll(const char*, const char*, size_t);
#90 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memccpy (void*, const void*, int, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) memicmp (const void*, const void*, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strdup (const char*) __attribute__ ((__malloc__));
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcmpi (const char*, const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricmp (const char*, const char*);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strcasecmp (const char*, const char *);





 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) stricoll (const char*, const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strlwr (char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnicmp (const char*, const char*, size_t);
int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strncasecmp (const char *, const char *, size_t);





 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strnset (char*, int, size_t);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strrev (char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strset (char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strupr (char*);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) swab (const char*, char*, size_t);
#196 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/string.h" 3
}
#45 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 2 3
#73 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstring" 3
namespace std
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
#125 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 1 3
#41 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3

#42 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
#66 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 1 3
#21 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/stddef.h" 1 3 4
#22 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 2 3
#60 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern "C" {
#71 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern int _argc;
extern char** _argv;




extern int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argc(void);
extern char*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___argv(void);
extern wchar_t*** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p___wargv(void);
#137 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _errno(void);


 int* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __doserrno(void);
#149 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
  extern char *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__environ(void);
  extern wchar_t *** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wenviron(void);
#172 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
  extern __attribute__ ((__dllimport__)) int _sys_nerr;
#196 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) char* _sys_errlist[];
#209 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__osver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winver(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winmajor(void);
extern unsigned __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) int* __p__winminor(void);







extern __attribute__ ((__dllimport__)) unsigned int _osver;
extern __attribute__ ((__dllimport__)) unsigned int _winver;
extern __attribute__ ((__dllimport__)) unsigned int _winmajor;
extern __attribute__ ((__dllimport__)) unsigned int _winminor;
#260 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 char** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__pgmptr(void);

 wchar_t** __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __p__wpgmptr(void);
#293 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
extern __attribute__ ((__dllimport__)) int _fmode;
#303 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atof (const char*);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoi (const char*);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atol (const char*);

 double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtof (const wchar_t *);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi (const wchar_t *);
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtol (const wchar_t *);


double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) __strtod (const char*, char**);
extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
strtod (const char* __restrict__ __nptr, char** __restrict__ __endptr);
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof (const char * __restrict__, char ** __restrict__);
long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold (const char * __restrict__, char ** __restrict__);




 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtol (const char*, char**, int);
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoul (const char*, char**, int);
#345 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wcstombs (char*, const wchar_t*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wctomb (char*, wchar_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mblen (const char*, size_t);
 size_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbstowcs (wchar_t*, const char*, size_t);
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) mbtowc (wchar_t*, const char*, size_t);

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) rand (void);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) srand (unsigned int);

 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) calloc (size_t, size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) malloc (size_t) __attribute__ ((__malloc__));
 void* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) realloc (void*, size_t);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) free (void*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abort (void) __attribute__ ((__noreturn__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit (int) __attribute__ ((__noreturn__));


int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atexit (void (*)(void));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) system (const char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) getenv (const char*);


 void* __attribute__((__cdecl__)) bsearch (const void*, const void*, size_t, size_t,
          int (*)(const void*, const void*));
 void __attribute__((__cdecl__)) qsort(void*, size_t, size_t,
      int (*)(const void*, const void*));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) abs (int) __attribute__ ((__const__));
 long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) labs (long) __attribute__ ((__const__));
#385 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;

 div_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) div (int, int) __attribute__ ((__const__));
 ldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ldiv (long, long) __attribute__ ((__const__));







 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _beep (unsigned int, unsigned int) __attribute__ ((__deprecated__));

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _seterrormode (int) __attribute__ ((__deprecated__));
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _sleep (unsigned long) __attribute__ ((__deprecated__));

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit (int) __attribute__ ((__noreturn__));



typedef int (* _onexit_t)(void);
_onexit_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _onexit( _onexit_t );

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _searchenv (const char*, const char*, char*);

 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _gcvt (double, int, char*);

 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _makepath (char*, const char*, const char*, const char*, const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _splitpath (const char*, char*, char*, char*, char*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _fullpath (char*, const char*, size_t);

 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltoa (long, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultoa(unsigned long, char*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _itow (int, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ltow (long, wchar_t*, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ultow (unsigned long, wchar_t*, int);


 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _atoi64(const char *);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64toa(long long, char *, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64toa(unsigned long long, char *, int);
 long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _wtoi64(const wchar_t *);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _i64tow(long long, wchar_t *, int);
 wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _ui64tow(unsigned long long, wchar_t *, int);

 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_rotl)(unsigned int, int) __attribute__ ((__const__));
 unsigned int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_rotr)(unsigned int, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_lrotl)(unsigned long, int) __attribute__ ((__const__));
 unsigned long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) (_lrotr)(unsigned long, int) __attribute__ ((__const__));

 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _set_error_mode (int);
#477 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
 int __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) putenv (const char*);
 void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) searchenv (const char*, const char*, char*);

 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) itoa (int, char*, int);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ltoa (long, char*, int);


 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ecvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) fcvt (double, int, int*, int*);
 char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) gcvt (double, int, char*);
#497 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _Exit(int) __attribute__ ((__noreturn__));





typedef struct { long long quot, rem; } lldiv_t;

lldiv_t __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lldiv (long long, long long) __attribute__ ((__const__));

long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) llabs(long long);





long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoll (const char* __restrict__, char** __restrict, int);
unsigned long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtoull (const char* __restrict__, char** __restrict__, int);


long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) atoll (const char *);


long long __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) wtoll (const wchar_t *);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltoa (long long, char *, int);
char* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltoa (unsigned long long , char *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) lltow (long long, wchar_t *, int);
wchar_t* __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) ulltow (unsigned long long, wchar_t *, int);
#549 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/../../../../include/stdlib.h" 3
}
#67 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 2 3
#98 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


}
#158 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
#193 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
#126 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 1 3
#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3

#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
#48 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
namespace std
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
#64 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
#94 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
#125 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
#162 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
#193 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
#223 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
#320 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
#127 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2
#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 1 3
#37 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3

#38 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3




namespace std
{

#59 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
#93 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
#106 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
#121 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
#145 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
#197 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
#262 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#298 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
#316 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
#338 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#372 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#408 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
#426 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
#448 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#482 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#516 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
#532 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
#554 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}

#1 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 1 3
#39 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3

#40 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3

namespace std
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
#112 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
#581 "c:\\xilinx\\vivado_hls\\2016.3\\msys\\bin\\../lib/gcc/mingw32/4.6.2/include/c++/sstream" 2 3
#128 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h" 2

template<int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64> class ap_private;
namespace ap_private_ops {

inline uint32_t Hi_32(uint64_t Value) {
    return static_cast<uint32_t>(Value >> 32);
}


inline uint32_t Lo_32(uint64_t Value) {
    return static_cast<uint32_t>(Value);
}

template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
    return false;
}


template<int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
    enum {APINT_BITS_PER_WORD=64,_AP_N=(_AP_W+APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD};
    static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) %APINT_BITS_PER_WORD);
 return (sign_mask & a.get_pVal(_AP_N-1)) != 0;
}





inline unsigned CountLeadingZeros_32(uint32_t Value) {
    unsigned Count;



    if (Value == 0) return 32;

    Count = __builtin_clz(Value);
#179 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    return Count;
}





inline unsigned CountLeadingZeros_64(uint64_t Value) {
    unsigned Count;



    if (!Value) return 64;

    Count = __builtin_clzll(Value);
#223 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    return Count;
}





inline unsigned CountTrailingZeros_64(uint64_t Value) {

    return (Value != 0) ? __builtin_ctzll(Value) : 64;
#243 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
}



inline unsigned CountPopulation_64(uint64_t Value) {

    return __builtin_popcountll(Value);






}

static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
    uint32_t Count = 0;
    if (skip)
        (__V) <<= (skip);
    while (__V && (__V & (1ULL << 63))) {
        Count++;
        (__V) <<= 1;
    }
    return Count;
}

static inline std::string oct2Bin(char oct) {
    switch (oct) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "000";
        }
        case '1': {
            return "001";
        }
        case '2': {
            return "010";
        }
        case '3': {
            return "011";
        }
        case '4': {
            return "100";
        }
        case '5': {
            return "101";
        }
        case '6': {
            return "110";
        }
        case '7': {
            return "111";
        }
    }

    ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 303));
    return "";
}

static inline std::string hex2Bin(char hex) {
    switch (hex) {
        case '\0': {
            return "";
        }
        case '.': {
            return ".";
        }
        case '0': {
            return "0000";
        }
        case '1': {
            return "0001";
        }
        case '2': {
            return "0010";
        }
        case '3': {
            return "0011";
        }
        case '4': {
            return "0100";
        }
        case '5': {
            return "0101";
        }
        case '6': {
            return "0110";
        }
        case '7': {
            return "0111";
        }
        case '8': {
            return "1000";
        }
        case '9': {
            return "1001";
        }
        case 'A':
        case 'a': {
            return "1010";
        }
        case 'B':
        case 'b': {
            return "1011";
        }
        case 'C':
        case 'c': {
            return "1100";
        }
        case 'D':
        case 'd': {
            return "1101";
        }
        case 'E':
        case 'e': {
            return "1110";
        }
        case 'F':
        case 'f': {
            return "1111";
        }
    }
    ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 370));
    return "";
}

static inline uint32_t decode_digit(char cdigit, int radix) {
    uint32_t digit = 0;
    if (radix == 16) {


            if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                ((0 && "Invalid hex digit in string") ? (void)0 : _assert("0 && \"Invalid hex digit in string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 380));
            if (((cdigit) >= '0' && (cdigit) <= '9'))
                digit = cdigit - '0';
            else if (cdigit >= 'a')
                digit = cdigit - 'a' + 10;
            else if (cdigit >= 'A')
                digit = cdigit - 'A' + 10;
            else
                ((0 && "huh? we shouldn't get here") ? (void)0 : _assert("0 && \"huh? we shouldn't get here\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 388));
        } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
            digit = cdigit - '0';
        } else {
            ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 392));
        }


        return digit;
}


static inline std::string parseString(const std::string& input, int& radix) {

    size_t len = input.length();
    if(len == 0) return input;

    size_t startPos = 0;

    while(input[startPos] == ' ' && startPos < len) startPos++;
    while(input[len-1] == ' ' && startPos < len) len--;

    std::string val = input.substr(startPos, len-startPos);

    len = val.length();
    startPos = 0;



    if (len < 2)
        return val;

    bool isNegative = false;
    std::string ans;


    if (val[0] == '-') {
        ans = "-";
        ++startPos;
        isNegative = true;
    } else if (val[0] == '+')
        ++startPos;

    if (len - startPos < 2)
        return val;

    if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {

        radix = 16;
        startPos += 2;
    } else if (val.substr(startPos, 2) == "0b" || val.substr(startPos, 2) == "0B") {

        radix = 2;
        startPos += 2;
    } if (val.substr(startPos, 2) == "0o" || val.substr(startPos, 2) == "0O") {

        radix = 8;
        startPos += 2;
    }

    int exp = 0;
    if (radix == 10) {


        size_t expPos = val.find('e');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('E');
        if (expPos == std::string::npos) {

            expPos = len;
            has_exponent = false;
        }


        ans += val.substr(startPos, expPos-startPos);
        if(has_exponent) {

            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    } else {

        size_t expPos = val.find('p');
        bool has_exponent = true;
        if (expPos == std::string::npos)
            expPos = val.find('P');
        if (expPos == std::string::npos) {

            expPos = len;
            has_exponent = false;
        }



        ((startPos <= expPos) ? (void)0 : _assert("startPos <= expPos", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 483));

        for (size_t i=startPos; i<expPos; ++i) {
            if(radix == 16) {
                ans += hex2Bin(val[i]);
            } else if(radix == 8) {
                ans += oct2Bin(val[i]);
            } else {
                ans += val[i];
            }
        }

        radix = 2;
        if (has_exponent) {

            std::istringstream iss(val.substr(expPos+1, len-expPos-1));
            iss >> exp;
        }
    }
    if (exp == 0)
        return ans;

    size_t decPos = ans.find('.');
    if (decPos == std::string::npos)
        decPos = ans.length();
    if ((int) decPos + exp >= (int) ans.length()) {
        int i = decPos;
        for (; i< (int) ans.length()-1; ++i)
            ans[i] = ans[i+1];
        for (; i< (int) ans.length(); ++i)
            ans[i] = '0';
        for (; i< (int) decPos + exp; ++i)
            ans += '0';
        return ans;
    } else if ((int) decPos + exp < (int) isNegative) {
        std::string dupAns = "0.";
        if (ans[0] == '-')
            dupAns = "-0.";
        for (int i=0; i<isNegative-(int)decPos-exp; ++i)
            dupAns += '0';
        for (size_t i=isNegative; i< ans.length(); ++i)
            if (ans[i] != '.')
                dupAns += ans[i];
        return dupAns;
    }

    if (exp > 0)
        for (size_t i=decPos; i<decPos+exp; ++i)
            ans[i] = ans[i+1];
    else {
        if (decPos == ans.length())
            ans += ' ';
        for (int i=decPos; i>(int)decPos+exp; --i)
            ans[i] = ans[i-1];
    }
    ans[decPos+exp] = '.';
    return ans;
}







inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        uint64_t __X = x[i];
        x[i] -= y;
        if (y > __X)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}





static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len, uint64_t y) {
    for (uint32_t i = 0; i < len; ++i) {
        dest[i] = y + x[i];
        if (dest[i] < y)
            y = 1;
        else {
            y = 0;
            break;
        }
    }
    return (y != 0);
}





static inline bool add(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool carry = false;
    uint32_t len = AESL_std::min(xlen, ylen);
    uint32_t i;
    for (i = 0; i< len && i < destlen; ++i) {
        uint64_t limit = AESL_std::min(x[i],y[i]);
        dest[i] = x[i] + y[i] + carry;
        carry = dest[i] < limit || (carry && dest[i] == limit);
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(x[i], yext);
            dest[i] = x[i] + yext + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == x[i]);
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t limit = AESL_std::min(xext, y[i]);
            dest[i] = xext + y[i] + carry;
            carry = (dest[i] < limit)||(carry && dest[i] == y[i]);
        }
    }
    return carry;
}



static inline bool sub(uint64_t *dest, const uint64_t *x, const uint64_t *y,
                uint32_t destlen, uint32_t xlen, uint32_t ylen, bool xsigned, bool ysigned) {
    bool borrow = false;
    uint32_t i;
    uint32_t len = AESL_std::min(xlen, ylen);
    for (i = 0; i < len && i < destlen; ++i) {
        uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
        borrow = y[i] > x_tmp || (borrow && x[i] == 0);
        dest[i] = x_tmp - y[i];
    }
    if (xlen > ylen) {
        const uint64_t yext = ysigned && int64_t(y[ylen-1])<0 ? -1 : 0;
        for (i=ylen; i< xlen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
            borrow = yext > x_tmp || (borrow && x[i] == 0);
            dest[i] = x_tmp - yext;
        }
    } else if (ylen> xlen) {
        const uint64_t xext = xsigned && int64_t(x[xlen-1])<0 ? -1 : 0;
        for (i=xlen; i< ylen && i < destlen; i++) {
            uint64_t x_tmp = borrow ? xext - 1 : xext;
            borrow = y[i] > x_tmp || (borrow && xext==0);
            dest[i] = x_tmp - y[i];
        }
    }
    return borrow;
}
#649 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len, uint64_t y) {

    uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
    uint64_t carry = 0;
    static const uint64_t two_power_32 = 1ULL << 32;

    for (uint32_t i = 0; i < len; ++i) {

        uint64_t lx = x[i] & 0xffffffffULL;
        uint64_t hx = (x[i]) >> 32;




        uint8_t hasCarry = 0;
        dest[i] = carry + lx * ly;

        hasCarry = (dest[i] < carry) ? 1 : 0;
        carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);


        hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);

        carry += (lx * hy) & 0xffffffffULL;
        dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
        carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
    }
    return carry;
}






static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen, const uint64_t y[],
                uint32_t ylen, uint32_t destlen) {
    ((xlen > 0) ? (void)0 : _assert("xlen > 0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 687));
    ((ylen > 0) ? (void)0 : _assert("ylen > 0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 688));
    ((destlen >= xlen + ylen) ? (void)0 : _assert("destlen >= xlen + ylen", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 689));
    if(xlen < destlen)
        dest[xlen] = mul_1(dest, x, xlen, y[0]);
    for (uint32_t i = 1; i < ylen; ++i) {
        uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
        uint64_t carry = 0, lx = 0, hx = 0;
        for (uint32_t j = 0; j < xlen; ++j) {
            lx = x[j] & 0xffffffffULL;
            hx = (x[j]) >> 32;




            uint8_t hasCarry = 0;
            uint64_t resul = carry + lx * ly;
            hasCarry = (resul < carry) ? 1 : 0;
            carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
            hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
            carry += (lx * hy) & 0xffffffffULL;
            resul = ((carry) << 32) | (resul & 0xffffffffULL);
            if(i+j < destlen)
                dest[i+j] += resul;
            carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0)+
                ((carry) >> 32) + (dest[i+j] < resul ? 1 : 0) +
                ((lx * hy) >> 32) + hx * hy;
        }
        if (i+xlen < destlen)
            dest[i+xlen] = carry;
    }
}





static inline void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,
                     uint32_t m, uint32_t n) {
    ((u && "Must provide dividend") ? (void)0 : _assert("u && \"Must provide dividend\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 726));
    ((v && "Must provide divisor") ? (void)0 : _assert("v && \"Must provide divisor\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 727));
    ((q && "Must provide quotient") ? (void)0 : _assert("q && \"Must provide quotient\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 728));
    ((u != v && u != q && v != q && "Must us different memory") ? (void)0 : _assert("u != v && u != q && v != q && \"Must us different memory\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 729));
    ((n>1 && "n must be > 1") ? (void)0 : _assert("n>1 && \"n must be > 1\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 730));



    uint64_t b = uint64_t(1) << 32;
#750 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    uint32_t shift = CountLeadingZeros_32(v[n-1]);
    uint32_t v_carry = 0;
    uint32_t u_carry = 0;
    if (shift) {
        for (uint32_t i = 0; i < m+n; ++i) {
            uint32_t u_tmp = (u[i]) >> (32 - shift);
            u[i] = ((u[i]) << (shift)) | u_carry;
            u_carry = u_tmp;
        }
        for (uint32_t i = 0; i < n; ++i) {
            uint32_t v_tmp = (v[i]) >> (32 - shift);
            v[i] = ((v[i]) << (shift)) | v_carry;
            v_carry = v_tmp;
        }
    }
    u[m+n] = u_carry;







    int j = m;
    do {
#784 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        uint64_t dividend = ((uint64_t(u[j+n]) << 32) + u[j+n-1]);

        uint64_t qp = dividend / v[n-1];
        uint64_t rp = dividend % v[n-1];
        if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {
            qp--;
            rp += v[n-1];
            if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))
                qp--;
        }






        bool isNeg = false;
        for (uint32_t i = 0; i < n; ++i) {
            uint64_t u_tmp = uint64_t(u[j+i]) | ((uint64_t(u[j+i+1])) << 32);
            uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
            bool borrow = subtrahend > u_tmp;




            uint64_t result = u_tmp - subtrahend;
            uint32_t k = j + i;
            u[k++] = (uint32_t)(result & (b-1));
            u[k++] = (uint32_t)((result) >> 32);
            while (borrow && k <= m+n) {
                borrow = u[k] == 0;
                u[k]--;
                k++;
            }
            isNeg |= borrow;


        }
#830 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        if (isNeg) {
            bool carry = true;
            for (uint32_t i = 0; i <= m+n; ++i) {
                u[i] = ~u[i] + carry;
                carry = carry && u[i] == 0;
            }
        }






        q[j] = (uint32_t)qp;
        if (isNeg) {



            q[j]--;



            bool carry = false;
            for (uint32_t i = 0; i < n; i++) {
                uint32_t limit = AESL_std::min(u[j+i],v[i]);
                u[j+i] += v[i] + carry;
                carry = u[j+i] < limit || (carry && u[j+i] == limit);
            }
            u[j+n] += carry;
        }





    } while (--j >= 0);
#874 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    if (r) {



        if (shift) {
            uint32_t carry = 0;

            for (int i = n-1; i >= 0; i--) {
                r[i] = ((u[i]) >> (shift)) | carry;
                carry = (u[i]) << (32 - shift);

            }
        } else {
            for (int i = n-1; i >= 0; i--) {
                r[i] = u[i];

            }
        }

    }

}

template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    ((lhsWords >= rhsWords && "Fractional result") ? (void)0 : _assert("lhsWords >= rhsWords && \"Fractional result\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 901));
    enum {APINT_BITS_PER_WORD=64};







    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = rhsWords * 2;
    uint32_t m = (lhsWords * 2) - n;



    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }


    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = (uint32_t)(tmp & mask);
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;


    memset(__V, 0, (n)*sizeof(uint32_t));
    for (unsigned i = 0; i < rhsWords; ++i) {
        uint64_t tmp = RHS.get_pVal(i);
        __V[i * 2] = (uint32_t)(tmp & mask);
        __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }


    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));





    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;







    ((n != 0 && "Divide by zero?") ? (void)0 : _assert("n != 0 && \"Divide by zero?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 974));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = (uint32_t)partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = (uint32_t)(partial_dividend / divisor);
                remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {


        KnuthDiv(__U, __V, __Q, __R, m, n);
    }


    if (Quotient) {

        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();



        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? (void)0 : _assert("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1018));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }


    if (Remainder) {

        if (Remainder->BitWidth != RHS.BitWidth) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();



        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? (void)0 : _assert("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1042));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }


    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}

template<int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS,
            ap_private<_AP_W, _AP_S> *Quotient, ap_private<_AP_W, _AP_S> *Remainder) {
    uint32_t rhsWords=1;
    ((lhsWords >= rhsWords && "Fractional result") ? (void)0 : _assert("lhsWords >= rhsWords && \"Fractional result\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1064));
    enum {APINT_BITS_PER_WORD=64};







    uint64_t mask = ~0ull >> (sizeof(uint32_t)*8);
    uint32_t n = 2;
    uint32_t m = (lhsWords * 2) - n;



    uint32_t SPACE[128];
    uint32_t *__U = 0;
    uint32_t *__V = 0;
    uint32_t *__Q = 0;
    uint32_t *__R = 0;
    if ((Remainder?4:3)*n+2*m+1 <= 128) {
        __U = &SPACE[0];
        __V = &SPACE[m+n+1];
        __Q = &SPACE[(m+n+1) + n];
        if (Remainder)
            __R = &SPACE[(m+n+1) + n + (m+n)];
    } else {
        __U = new uint32_t[m + n + 1];
        __V = new uint32_t[n];
        __Q = new uint32_t[m+n];
        if (Remainder)
            __R = new uint32_t[n];
    }


    memset(__U, 0, (m+n+1)*sizeof(uint32_t));
    for (unsigned i = 0; i < lhsWords; ++i) {
        uint64_t tmp = LHS.get_pVal(i);
        __U[i * 2] = tmp & mask;
        __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t)*8);
    }
    __U[m+n] = 0;


    memset(__V, 0, (n)*sizeof(uint32_t));
    __V[0] = RHS & mask;
    __V[1] = (RHS) >> (sizeof(uint32_t)*8);


    memset(__Q, 0, (m+n) * sizeof(uint32_t));
    if (Remainder)
        memset(__R, 0, n * sizeof(uint32_t));





    for (unsigned i = n; i > 0 && __V[i-1] == 0; i--) {
        n--;
        m++;
    }
    for (unsigned i = m+n; i > 0 && __U[i-1] == 0; i--)
        m--;







    ((n != 0 && "Divide by zero?") ? (void)0 : _assert("n != 0 && \"Divide by zero?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1134));
    if (n == 1) {
        uint32_t divisor = __V[0];
        uint32_t remainder = 0;
        for (int i = m+n-1; i >= 0; i--) {
            uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
            if (partial_dividend == 0) {
                __Q[i] = 0;
                remainder = 0;
            } else if (partial_dividend < divisor) {
                __Q[i] = 0;
                remainder = partial_dividend;
            } else if (partial_dividend == divisor) {
                __Q[i] = 1;
                remainder = 0;
            } else {
                __Q[i] = partial_dividend / divisor;
                remainder = partial_dividend - (__Q[i] * divisor);
            }
        }
        if (__R)
            __R[0] = remainder;
    } else {


        KnuthDiv(__U, __V, __Q, __R, m, n);
    }


    if (Quotient) {

        if (Quotient->BitWidth != LHS.BitWidth) {
            if (Quotient->isSingleWord())
                Quotient->set_VAL(0);
        } else
            Quotient->clear();



        if (lhsWords == 1) {
            uint64_t tmp =
                uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
            Quotient->set_VAL(tmp);
        } else {
            ((!Quotient->isSingleWord() && "Quotient ap_private not large enough") ? (void)0 : _assert("!Quotient->isSingleWord() && \"Quotient ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1178));
            for (unsigned i = 0; i < lhsWords; ++i)
                Quotient->set_pVal(i,
                    uint64_t(__Q[i*2]) | ((uint64_t(__Q[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Quotient->clearUnusedBits();
    }


    if (Remainder) {

        if (Remainder->BitWidth != 64 ) {
            if (Remainder->isSingleWord())
                Remainder->set_VAL(0);
        } else
            Remainder->clear();



        if (rhsWords == 1) {
            uint64_t tmp =
                uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
            Remainder->set_VAL(tmp);
        } else {
            ((!Remainder->isSingleWord() && "Remainder ap_private not large enough") ? (void)0 : _assert("!Remainder->isSingleWord() && \"Remainder ap_private not large enough\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1202));
            for (unsigned i = 0; i < rhsWords; ++i)
                Remainder->set_pVal(i,
                    uint64_t(__R[i*2]) | ((uint64_t(__R[i*2+1])) << (APINT_BITS_PER_WORD / 2)));
        }
        Remainder->clearUnusedBits();
    }


    if (__U != &SPACE[0]) {
        delete [] __U;
        delete [] __V;
        delete [] __Q;
        delete [] __R;
    }
}


template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> lshr(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.lshr(shiftAmt);
}



template<int _AP_W, bool _AP_S, bool _AP_C> inline ap_private<_AP_W, _AP_S, _AP_C> shl(const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
    return LHS.shl(shiftAmt);
}

}







enum ap_q_mode {
    AP_RND,
    AP_RND_ZERO,
    AP_RND_MIN_INF,
    AP_RND_INF,
    AP_RND_CONV,
    AP_TRN,
    AP_TRN_ZERO

};
enum ap_o_mode {
    AP_SAT,
    AP_SAT_ZERO,
    AP_SAT_SYM,
    AP_WRAP,
    AP_WRAP_SM
};

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
    ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
    ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;

template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2> struct ap_concat_ref;


    enum {
        MIN_INT_BITS = 1,

        MAX_INT_BITS = (1<<23)-1

    };
#1313 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    typedef unsigned long long ap_ulong;
    typedef signed long long ap_slong;

template <int _AP_N8, bool _AP_S> struct valtype;

template<int _AP_N8> struct valtype<_AP_N8, false> {
    typedef uint64_t Type;
};

template<int _AP_N8> struct valtype<_AP_N8, true> {
    typedef int64_t Type;
};

template<> struct valtype<1, false> {
    typedef unsigned char Type;
};
template<> struct valtype<2, false> {
    typedef unsigned short Type;
};
template<> struct valtype<3, false> {
    typedef unsigned int Type;
};
template<> struct valtype<4, false> {
    typedef unsigned int Type;
};
template<> struct valtype<1, true> {
    typedef signed char Type;
};
template<> struct valtype<2, true> {
    typedef short Type;
};
template<> struct valtype<3, true> {
    typedef int Type;
};
template<> struct valtype<4, true> {
    typedef int Type;
};


template<int _AP_W, bool _AP_S> class ap_private <_AP_W, _AP_S, true> {



public:
  typedef typename valtype<(_AP_W+7)/8, _AP_S>::Type ValType;
    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };
    enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
    static const uint64_t not_mask = ~mask;
    static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD-1);
    template<int _AP_W1> struct sign_ext_mask { static const uint64_t mask=~0ULL<<_AP_W1;};
    static const int width = _AP_W;


    enum { BitWidth=_AP_W, _AP_N = 1, };
    ValType VAL;
#1403 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    void check_canary() {}
    void set_canary() {}


    inline ValType& get_VAL(void) {
        return VAL;
    }
    inline ValType get_VAL(void) const{
        return VAL;
    }
    inline ValType get_VAL(void) const volatile{
        return VAL;
    }
    inline void set_VAL(uint64_t value) {
        VAL = (ValType)value;
    }
    inline ValType& get_pVal(int i) {
        return VAL;
    }
    inline ValType get_pVal(int i) const{
        return VAL;
    }
    inline const uint64_t* get_pVal() const{
        ((0 && "invalid usage") ? (void)0 : _assert("0 && \"invalid usage\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1426));
        return 0;
    }
    inline ValType get_pVal(int i) const volatile {
        return VAL;
    }
    inline uint64_t* get_pVal() const volatile {
        ((0 && "invalid usage") ? (void)0 : _assert("0 && \"invalid usage\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1433));
        return 0;
    }
    inline void set_pVal(int i, uint64_t value) {
        VAL = (ValType)value;
    }

    inline uint32_t getBitWidth() const {
        return BitWidth;
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private<_AP_W, _AP_S>& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }


    void operator=(const ap_private& RHS) volatile {

        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const ap_private& RHS) {

        VAL = RHS.get_VAL();
        return *this;
    }

    void operator=(const volatile ap_private& RHS) volatile {

        VAL = RHS.get_VAL();
    }
    ap_private& operator=(const volatile ap_private& RHS) {

        VAL = RHS.get_VAL();
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        *this = ap_private<_AP_W2, false>(op2);
        return *this;
    }

private:
    explicit inline ap_private(uint64_t* val):VAL(val[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    inline bool isSingleWord() const { return true; }

    inline void fromString(const char *strStart, uint32_t slen,
                           uint8_t radix) {

        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
#1497 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        ,
 1498
#1497 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        ))
                                                   ;
        ((strStart && "String is null?") ? (void)0 : _assert("strStart && \"String is null?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1499));
        uint64_t tmpVAL = VAL;
        bool isNeg = false;
        if (*strStart == '-') {
            isNeg = true;
            strStart++;
        }
        switch(radix) {
            case 2:


                for (;*strStart; ++strStart) {
                    (((*strStart=='0'|| *strStart=='1')&&("Wrong binary number")) ? (void)0 : _assert("(*strStart=='0'|| *strStart=='1')&&(\"Wrong binary number\")", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1511));
                    tmpVAL <<=1;
                    tmpVAL |= (*strStart-'0');
                }
                break;
            case 8:




                sscanf(strStart,"%I64o",&tmpVAL);
#1533 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
                break;
            case 10:




                sscanf(strStart,"%I64u",&tmpVAL);
#1551 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
                break;
            case 16:




                sscanf(strStart,"%I64x",&tmpVAL);
#1569 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
                break;
            default:
                ((true && "Unknown radix") ? (void)0 : _assert("true && \"Unknown radix\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1571));

        }
        VAL = isNeg ? (ValType)(-tmpVAL) : (ValType) (tmpVAL);

        clearUnusedBits();
    }


    ap_private(const std::string& val, uint8_t radix=2): VAL(0) {
        ((!val.empty() && "String empty?") ? (void)0 : _assert("!val.empty() && \"String empty?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 1581));
        set_canary();
        fromString(val.c_str(), val.size(), radix);
        check_canary();
    }

    ap_private(const char strStart[], uint32_t slen, uint8_t radix) : VAL(0) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }

    ap_private(uint32_t numWords, const uint64_t bigVal[]): VAL(bigVal[0]) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }


public:
    inline ap_private() {
        set_canary();
        clearUnusedBits();
        check_canary();
    }







    inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(unsigned long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(long long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
    inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }

    ap_private(const ap_private& that) : VAL(that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    ap_private(const ap_private<_AP_W, !_AP_S>& that) : VAL(that.get_VAL()) {
        set_canary();
     clearUnusedBits();
        check_canary();
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private(const ap_private<_AP_W1, _AP_S1>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }


    template<int _AP_W1, bool _AP_S1>
    ap_private(const volatile ap_private<_AP_W1, _AP_S1>& that) : VAL((ValType)that.get_VAL()) {
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    explicit ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');

        if (pos != std::string::npos)
            str = str.substr(pos);

        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }

    ap_private(const char* val, signed char rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');

        if (pos != std::string::npos)
            str = str.substr(pos);

        ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
        operator = (ap_private_val);
        check_canary();
    }

    ~ap_private() {check_canary();}

    inline bool isNegative() const {
        static const uint64_t sign_mask = 1ULL << (_AP_W-1);
        return _AP_S && (sign_mask & VAL);
    }

    inline bool isPositive() const {
        return !isNegative();
    }

    inline bool isStrictlyPositive() const {
        return !isNegative() && VAL!=0;
    }

    inline bool isAllOnesValue() const {
        return (mask & VAL) == mask;
    }

    inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL == RHS.get_VAL(); }
    inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL == (uint64_t)RHS.get_VAL(); }

    inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
    inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
    inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const { return VAL != RHS.get_VAL(); }
    inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const { return (uint64_t)VAL != (uint64_t)RHS.get_VAL(); }
    const ap_private operator++() { ++VAL; clearUnusedBits(); return *this; }
    const ap_private operator--(int) {
           ap_private orig(*this);
           --VAL; clearUnusedBits();
           return orig;
    }
    const ap_private operator--() { --VAL; clearUnusedBits(); return *this;}
    inline bool operator !() const { return !VAL;}

    const ap_private operator++(int) {
        ap_private orig(*this);
        VAL++; clearUnusedBits();
        return orig;
    }

    inline ap_private<((64) < (_AP_W + 1) ? (64) : (_AP_W + 1)), true>
                          operator-() const {
        return ap_private<1,false>(0) - (*this);
    }

    inline std::string toString(uint8_t radix, bool wantSigned) const ;
    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }
    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }
    inline void clear() {
        VAL=0;
    }
    inline ap_private& clear(uint32_t bitPosition) { VAL &= ~(1ULL<<(bitPosition)); clearUnusedBits(); return *this;}

    inline ap_private ashr(uint32_t shiftAmt) const {
        if (_AP_S)
            return ap_private((shiftAmt == BitWidth) ? 0 : ((int64_t)VAL) >> (shiftAmt));
        else
            return ap_private((shiftAmt == BitWidth) ? 0 : ((uint64_t)VAL) >> (shiftAmt));
    }

    inline ap_private lshr(uint32_t shiftAmt) const {
        return ap_private((shiftAmt == BitWidth) ? ap_private(0) : ap_private((VAL&mask) >> (shiftAmt)));
    }

    inline ap_private shl(uint32_t shiftAmt) const




    {
        if (shiftAmt > BitWidth) {
            if (!isNegative())
                return ap_private(0);
            else return ap_private(-1);
        }
        if (shiftAmt == BitWidth) return ap_private(0);
        else return ap_private((VAL) << (shiftAmt));

    }

    inline int64_t getSExtValue() const {
        return VAL;
    }

    inline uint64_t getZExtValue() const {
        return VAL & mask;
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        check_canary();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = ((val.operator ap_private<_AP_W2, false> ()));
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        check_canary();
    }

    inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
        *this = (op2);
    }



    operator ValType () const {
        return get_VAL();
    }

    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }

    inline int to_char() const {
        return (signed char) get_VAL();
    }

    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }

    inline int to_short() const {
        return (short) get_VAL();
    }

    inline int to_int() const {

        return (int) get_VAL();
    }

    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }

    inline long to_long() const {
        return (long) get_VAL();
    }

    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }

    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }

    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }

    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }

    inline unsigned length() const { return _AP_W; }

    inline bool isMinValue() const { return VAL == 0;}
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)&RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        VAL = (ValType)(((uint64_t)VAL)|RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)^RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)*RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)+RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1> inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS){
        VAL = (ValType)(((uint64_t)VAL)-RHS.get_VAL());
        clearUnusedBits();
        return *this;
    }
    inline const ap_private& operator<<=(uint32_t shiftAmt) { VAL<<=shiftAmt; clearUnusedBits(); return *this; }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator&(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) & RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret & RHS;
        }
    }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator^(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^ RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret ^ RHS;
        }
    }

    template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator|(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) | RHS.get_VAL());
            return Ret;
        } else {
            typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
            return Ret | RHS;
        }
    }

    inline ap_private And(const ap_private& RHS) const {
        return ap_private(VAL & RHS.get_VAL());
    }

    inline ap_private Or(const ap_private& RHS) const {
        return ap_private(VAL | RHS.get_VAL());
    }

    inline ap_private Xor(const ap_private& RHS) const {
        return ap_private(VAL ^ RHS.get_VAL());
    }

    template <int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
            typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) * RHS.get_VAL());
            return Result;
        } else {
            typename RType<_AP_W1, _AP_S1>::mult Result(*this);
            Result *= RHS;
            return Result;
        }
    }

    inline ap_private Mul(const ap_private& RHS) const {
        return ap_private(VAL * RHS.get_VAL());
    }

    inline ap_private Add(const ap_private& RHS) const {
        return ap_private(VAL + RHS.get_VAL());
    }

    inline ap_private Sub(const ap_private& RHS) const {
        return ap_private(VAL - RHS.get_VAL());
    }


    inline ap_private& operator&=(uint64_t RHS) { VAL &= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator|=(uint64_t RHS) { VAL |= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator^=(uint64_t RHS){ VAL ^= (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator*=(uint64_t RHS){ VAL *= (ValType)RHS; clearUnusedBits(); return *this; }
    inline ap_private& operator+=(uint64_t RHS){ VAL += (ValType)RHS; clearUnusedBits(); return *this;}
    inline ap_private& operator-=(uint64_t RHS){ VAL -= (ValType)RHS; clearUnusedBits(); return *this; }
#1994 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline bool isMinSignedValue() const {
        static const uint64_t min_mask = ~(~0ULL << (_AP_W-1));
        return BitWidth == 1 ? VAL == 1 :
           (ap_private_ops::isNegative<_AP_W>(*this) && ((min_mask & VAL)==0));
    }


    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::plus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::plus(RType<_AP_W1,_AP_S1>::plus_s ? int64_t(((uint64_t)VAL)+RHS.get_VAL()):uint64_t(((uint64_t)VAL)+RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::plus Result=RHS;
        Result += ((uint64_t)VAL);
        return Result;
    }

    template<int _AP_W1, bool _AP_S1> inline
    typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (RType<_AP_W1,_AP_S1>::minus_w <=64)
            return typename RType<_AP_W1,_AP_S1>::minus(int64_t(((uint64_t)VAL)-RHS.get_VAL()));
        typename RType<_AP_W1,_AP_S1>::minus Result=*this;
        Result -= RHS;
        return Result;
    }

    inline ap_private& flip() {
        VAL = (ValType)((~0ULL^VAL)&mask);
        clearUnusedBits();
        return *this;
    }

    uint32_t countPopulation() const { return ap_private_ops::CountPopulation_64(VAL);}
    uint32_t countLeadingZeros() const {
        int remainder = BitWidth % 64;
        int excessBits = (64 - remainder) % 64;
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
        if (Count)
            Count-=excessBits;
        return AESL_std::min(Count, (uint32_t)_AP_W);
    }


    ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(*this);
        ret = (ret)>>(BitWidth - numBits);
        return ret;
    }


    ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
        ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
        ret = (ret)>>(BitWidth - numBits);
        return ret;

    }

    ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
        VAL |= (1ULL << (bitPosition));
        clearUnusedBits();
        return *this;
    }

    void set() {
        VAL = (ValType)~0ULL;
        clearUnusedBits();
    }

    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }

    inline void set(const ap_private & val) {
        operator = (val);
    }

    bool operator[](uint32_t bitPosition) const {
        return (((1ULL << (bitPosition)) & VAL) != 0);
    }

    inline void clearUnusedBits(void)




    {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        VAL = (ValType)(_AP_S ? ((((int64_t)VAL)<<(excess_bits))>> (excess_bits)) : (excess_bits ? (((uint64_t)VAL)<<(excess_bits))>>(excess_bits) : (uint64_t)VAL));
    }

    inline void clearUnusedBitsToZero(void) {
        enum { excess_bits = (_AP_W%64) ? 64 -_AP_W%64 : 0};
        static uint64_t mask = ~0ULL >> (excess_bits);
        VAL &= mask;
    }

    inline ap_private udiv(const ap_private& RHS) const {
        return ap_private((uint64_t)VAL / RHS.get_VAL());
    }



    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return ((uint64_t)(0 -(*this))) / (uint64_t) (0-RHS);
            else
                return 0 -((uint64_t)(0-(*this)) / (uint64_t)(RHS));
        else if (RHS.isNegative())
            return 0 -(this->udiv((ap_private)(0-RHS)));
        return this->udiv(RHS);
    }

    template<bool _AP_S2>
    inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        ((RHS.get_VAL() != 0 && "Divide by 0") ? (void)0 : _assert("RHS.get_VAL() != 0 && \"Divide by 0\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2109));
        return ap_private(((uint64_t)VAL)%((uint64_t)RHS.get_VAL()));
    }



    template<bool _AP_S2>
    inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
        if (isNegative()) {
            ap_private lhs = 0 -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = 0 -RHS;
                return 0 -(lhs.urem(rhs));
            } else
                return 0 -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = 0-RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }

    template <int _AP_W1, bool _AP_S1> inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }

    template <int _AP_W1, bool _AP_S1> inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        if (_AP_W1 <= 64) {
            uint64_t lhsZext = ((uint64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            uint64_t rhsZext = ((uint64_t(RHS.get_VAL())) <<
                                 (64-_AP_W1)) >> (64-_AP_W1);
            return lhsZext < rhsZext;
        } else
            return RHS.uge(*this);
    }





    template <int _AP_W1, bool _AP_S1> inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const




    {
        if (_AP_W1 <= 64) {
            int64_t lhsSext = ((int64_t(VAL)) << (64-_AP_W)) >> (64-_AP_W);
            int64_t rhsSext = ((int64_t(RHS.get_VAL())) << (64-_AP_W1))
                                >> (64-_AP_W1);
            return lhsSext < rhsSext;
        } else
            return RHS.sge(*this);
    }






    template <int _AP_W1, bool _AP_S1> inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !ult(RHS);
    }





    template <int _AP_W1, bool _AP_S1> inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        return !slt(RHS);
    }

    inline ap_private abs() const {
        if (isNegative())
            return -(*this);
        return *this;
    }

    ap_private<_AP_W, false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }

    inline static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        return _AP_W;
    }

    inline uint32_t getActiveBits() const {
        uint32_t bits=_AP_W - countLeadingZeros();
        return bits?bits:1;
    }

    inline double roundToDouble(bool isSigned=false) const {
        return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
    }


    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }


    inline bool iszero () const {
        return isMinValue();
    }

    inline bool to_bool() const {
        return !iszero();
    }


    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }


    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2280));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2281));
        flip(i);
    }


    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2287));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2288));
        return operator[](i);
    }



    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2295));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2296));
        operator = (shl(n) | lshr(_AP_W - n));
    }



    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2303));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2304));
        operator = (lshr(n) | shl(_AP_W - n));
    }


    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2310));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2311));
        v ? set(i) : clear(i);
    }


    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2317));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2318));
        v ? set(i) : clear(i);
    }


    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2324));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2325));
        return operator [](i);
    }


    inline void b_not() {
        flip();
    }
#2352 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }


    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>&op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod (_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#2378 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#2397 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const bool op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#2439 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const bool op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#2473 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator >> (op.get_VAL()); return *this; }




    template<int _AP_W1, bool _AP_S1>
    inline bool operator == (const ap_private<_AP_W1, _AP_S1>& op) const {
        enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32))};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        if (_AP_MAX_W <= 64) {
            return (uint64_t) lhs.get_VAL() ==
                   (uint64_t) rhs.get_VAL();
        } else
            return lhs == rhs;

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);


        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)

            return lhs.sgt(rhs);
        else


            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this>op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else if (_AP_W < 32 && _AP_W2 < 32)
            return lhs.slt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this<op);
    }




    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }


    inline ap_bit_ref<_AP_W,_AP_S> operator [] (uint32_t index) {
        return ap_bit_ref<_AP_W,_AP_S> (*this, (int)index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br =operator [] (index);
        return br.to_bool();
    }

    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    inline bool bit (int index) const {
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_private<_AP_W, _AP_S>*>(this), index);
        return br.to_bool();
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }




    inline bool and_reduce() const {
        return (VAL & mask) == mask;
    }

    inline bool nand_reduce() const {
        return (VAL & mask) != mask;
    }

    inline bool or_reduce() const {
        return (bool)VAL;
    }

    inline bool nor_reduce() const {
        return VAL==0;
    }

    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }

    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }

    inline std::string to_string(uint8_t radix=2, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};

template<int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
#2791 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ,
 2792
#2791 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"
    };
    std::string result;
    if (radix != 10) {





        if (*this == (uint64_t)(0)) {


            switch (radix) {
                case 2: result = "0b0"; break;
                case 8: result = "0o0"; break;
                case 16: result = "0x0"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2810));
            }
        } else {
            ap_private<_AP_W, false, true> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {



                tmp.flip();
                tmp++;
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2830));
            }
            insert_at += 2;


            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false, true> zero(0);
            unsigned bits = 0;
            bool msb = false;
            while (tmp.ne(zero)) {
                unsigned digit = (unsigned)(tmp.get_VAL() & mask);
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                bits++;
                msb = (digit >> (shift - 1)) == 1;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero && msb)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }

    ap_private<_AP_W, false, true> tmp(*this);
    ap_private<6, false, true> divisor(radix);
    ap_private<_AP_W, _AP_S, true> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false, true>(0ULL))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false, true> APdigit = tmp%divisor;
        ap_private<_AP_W, false, true> tmp2 = tmp/divisor;
        uint32_t digit = (uint32_t)(APdigit.getZExtValue());
        ((digit < radix && "divide failed") ? (void)0 : _assert("digit < radix && \"divide failed\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2873));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }
    return result;

}

template<int _AP_W, bool _AP_S>
class ap_private <_AP_W, _AP_S, false> {



public:
    enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
    static const int width = _AP_W;

private:
#2900 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private(uint32_t numWords, const uint64_t bigVal[]) {
        set_canary();
        ((bigVal && "Null pointer detected!") ? (void)0 : _assert("bigVal && \"Null pointer detected!\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2902));
        {

            memset(pVal, 0, _AP_N * sizeof(uint64_t));


            uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);

            memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
            if (words >= _AP_W)
                clearUnusedBits();

        }
        check_canary();
    }
#2927 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private(const std::string& val, uint8_t radix=2) {
        set_canary();
        ((!val.empty() && "The input string is empty.") ? (void)0 : _assert("!val.empty() && \"The input string is empty.\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 2929));
        const char *c_str = val.c_str();
        fromString(c_str, val.size(), radix);
        check_canary();
    }
#2946 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
        set_canary();
        fromString(strStart, slen, radix);
        check_canary();
    }

    inline void report() {







            if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
                fprintf((&_iob[2]), "[E] ap_%sint<%d>: Bitwidth exceeds the "
                        "default max value %d. Please use macro "
                        "AP_INT_MAX_W to set a larger max value.\n",
                        _AP_S?"":"u", _AP_W,
                        ((1024 + 1023) / 1024) * 1024);
                exit(1);
            }
    }





    uint64_t pVal[_AP_N];
#2984 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    void check_canary() {}
    void set_canary() {}


public:
    typedef typename valtype<8, _AP_S>::Type ValType;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct ap_fixed_base;


    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };
        typedef ap_private<mult_w, mult_s> mult;
        typedef ap_private<plus_w, plus_s> plus;
        typedef ap_private<minus_w, minus_s> minus;
        typedef ap_private<logic_w, logic_s> logic;
        typedef ap_private<div_w, div_s> div;
        typedef ap_private<mod_w, mod_s> mod;
        typedef ap_private<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };


   inline uint64_t& get_VAL(void) {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const {
        return pVal[0];
    }
    inline uint64_t get_VAL(void) const volatile{
        return pVal[0];
    }
    inline void set_VAL(uint64_t value) {
        pVal[0] = value;
    }
    inline uint64_t& get_pVal(int index) {
        return pVal[index];
    }
    inline uint64_t* get_pVal() {
        return pVal;
    }
    inline const uint64_t* get_pVal() const{
        return pVal;
    }
    inline uint64_t get_pVal(int index) const{
        return pVal[index];
    }
    inline uint64_t* get_pVal() const volatile {
        return pVal;
    }
    inline uint64_t get_pVal(int index) const volatile {
        return pVal[index];
    }
    inline void set_pVal(int i, uint64_t value) {
        pVal[i] = value;
    }


    enum {
        APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
        APINT_WORD_SIZE = sizeof(uint64_t)
    };

    enum { excess_bits = (_AP_W%APINT_BITS_PER_WORD) ? APINT_BITS_PER_WORD -(_AP_W%APINT_BITS_PER_WORD) : 0};
    static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));

public:

    ap_private(const char* val) {
        set_canary();
        int radix = 10;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();
        check_canary();
    }

    ap_private(const char* val, int rd) {
        set_canary();
        int radix = rd;
        std::string str = ap_private_ops::parseString(val, radix);
        std::string::size_type pos = str.find('.');
        if (pos != std::string::npos)
            str = str.substr(pos);
        ap_private ap_private_val(str, radix);
        operator = (ap_private_val);
        report();

        report();
        check_canary();
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_private(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        set_canary();
        *this = ((uint64_t)(bool)ref);
        report();
        check_canary();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private(const ap_concat_ref<_AP_W2, _AP_T2,_AP_W3, _AP_T3>& ref) {
        set_canary();
        *this=ref.get();
        report();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
       *this = ((val.operator ap_private<_AP_W2, false> ()));
        report();
        check_canary();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
        ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_private(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
            _AP_Q2, _AP_O2, _AP_N2> &val) {
        set_canary();
        *this = (uint64_t)(bool)val;
        report();
        check_canary();
    }



    template<int _AP_W1, bool _AP_S1>
    ap_private(const volatile ap_private<_AP_W1, _AP_S1>& that) {
        set_canary();
        operator = (const_cast<const ap_private<_AP_W1, _AP_S1>& >(that));
        check_canary();
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private(const ap_private<_AP_W1, _AP_S1>& that) {
        set_canary();
        operator = (that);
        check_canary();
    }

    template<int _AP_W1, bool _AP_S1>
    explicit ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
        set_canary();
        static const uint64_t that_sign_ext_mask = (_AP_W1==APINT_BITS_PER_WORD)?0:~0ULL>>(_AP_W1%APINT_BITS_PER_WORD)<<(_AP_W1%APINT_BITS_PER_WORD);
        if (that.isNegative()) {
            pVal[0] = that.get_VAL()|that_sign_ext_mask;
            memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1));
        } else {
            pVal[0] = that.get_VAL();
            memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1));
        }
        clearUnusedBits();
        check_canary();
    }

    ap_private(const ap_private& that) {
        set_canary();
        memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);
        clearUnusedBits();
        check_canary();
    }



    ~ap_private() {check_canary();}



    ap_private(){
        set_canary();
        clearUnusedBits();
        check_canary();
    }

    ap_private(uint64_t* val, uint32_t bits=_AP_W) {((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3188));}
    ap_private(const uint64_t *const val, uint32_t bits) {((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3189));}
#3214 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private(int val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(bool val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(signed char val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned char val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(short val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned short val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned int val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(unsigned long long val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(long long val, bool isSigned=true) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(float val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
    ap_private(double val, bool isSigned=false) { set_canary(); pVal[0] = (ValType) val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal+1, ~0, sizeof(uint64_t)*(_AP_N-1)); } else { memset(pVal+1, 0, sizeof(uint64_t)*(_AP_N-1)); } clearUnusedBits(); check_canary(); }
#3236 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline bool isSingleWord() const {
        return false;
    }



    static uint32_t whichWord(uint32_t bitPosition) {

        return (bitPosition) >> 6;
    }




    static uint32_t whichBit(uint32_t bitPosition) {

        return bitPosition & 0x3f;
    }





    static uint64_t maskBit(uint32_t bitPosition) {
        return 1ULL << (whichBit(bitPosition));
    }



    inline uint64_t getWord(uint32_t bitPosition) const {
        return pVal[whichWord(bitPosition)];
    }






    inline void clearUnusedBits(void)




    {
        pVal[_AP_N-1] = _AP_S ? ((((int64_t)pVal[_AP_N-1])<<(excess_bits))>> excess_bits) : (excess_bits ? ((pVal[_AP_N-1])<<(excess_bits))>>(excess_bits) : pVal[_AP_N-1]);
    }

    inline void clearUnusedBitsToZero(void) {
        pVal[_AP_N-1] &= mask;
    }

    inline void clearUnusedBitsToOne(void) {
        pVal[_AP_N-1] |= mask;
    }



    inline void fromString(const char *str, uint32_t slen,
            uint8_t radix) {
        enum { numbits=_AP_W};

        (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
#3297 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        ,
 3298
#3297 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
        ))
                                                   ;
        ((str && "String is null?") ? (void)0 : _assert("str && \"String is null?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3299));
        bool isNeg = str[0] == '-';
        if (isNeg)
            str++, slen--;


        while(*str == '0' && *(str+1) != '\0') {str++; slen--;}
        (((slen <= numbits || radix != 2) && "Insufficient bit width") ? (void)0 : _assert("(slen <= numbits || radix != 2) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3306));
        ((((slen - 1)*3 <= numbits || radix != 8) && "Insufficient bit width") ? (void)0 : _assert("((slen - 1)*3 <= numbits || radix != 8) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3307));
        ((((slen - 1)*4 <= numbits || radix != 16) && "Insufficient bit width") ? (void)0 : _assert("((slen - 1)*4 <= numbits || radix != 16) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3308));
        (((((slen -1)*64)/22 <= numbits || radix != 10) && "Insufficient bit width") ? (void)0 : _assert("(((slen -1)*64)/22 <= numbits || radix != 10) && \"Insufficient bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3309));

        memset(pVal, 0, _AP_N * sizeof(uint64_t));


        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);



        uint64_t bigVal[_AP_N];
        memset(bigVal, 0, _AP_N * sizeof(uint64_t));
        ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
        ap_private<_AP_W, _AP_S> apradix(radix);


        for (unsigned i = 0; i < slen; i++) {

            uint32_t digit = 0;
            char cdigit = str[i];
            if (radix == 16) {


                if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F')))
                    ((0 && "Invalid hex digit in string") ? (void)0 : _assert("0 && \"Invalid hex digit in string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3332));
                if (((cdigit) >= '0' && (cdigit) <= '9'))
                    digit = cdigit - '0';
                else if (cdigit >= 'a')
                    digit = cdigit - 'a' + 10;
                else if (cdigit >= 'A')
                    digit = cdigit - 'A' + 10;
                else
                    ((0 && "huh? we shouldn't get here") ? (void)0 : _assert("0 && \"huh? we shouldn't get here\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3340));
            } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
                digit = cdigit - '0';
            } else if (cdigit != '\0'){
                ((0 && "Invalid character in digit string") ? (void)0 : _assert("0 && \"Invalid character in digit string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3344));
            }



            if (shift)
                *this <<= shift;
            else
                *this *= apradix;


            apdigit.set_VAL(digit);
            *this += apdigit;
        }

        if (isNeg) {
            (*this)--;
            this->flip();
        }
        clearUnusedBits();
    }

    inline ap_private read() volatile {
        return *this;
    }

    inline void write(const ap_private& op2) volatile {
        *this = (op2);
    }

    operator ValType () const {
        return get_VAL();
    }

    inline int to_uchar() const {
        return (unsigned char) get_VAL();
    }

    inline int to_char() const {
        return (signed char) get_VAL();
    }

    inline int to_ushort() const {
        return (unsigned short) get_VAL();
    }

    inline int to_short() const {
        return (short) get_VAL();
    }

    inline int to_int() const {
        return (int) get_VAL();
    }

    inline unsigned to_uint() const {
        return (unsigned) get_VAL();
    }

    inline long to_long() const {
        return (long) get_VAL();
    }

    inline unsigned long to_ulong() const {
        return (unsigned long) get_VAL();
    }

    inline ap_slong to_int64() const {
        return (ap_slong) get_VAL();
    }

    inline ap_ulong to_uint64() const {
        return (ap_ulong) get_VAL();
    }

    inline double to_double() const {
        if (isNegative())
            return roundToDouble(true);
        else
            return roundToDouble(false);
    }

    inline unsigned length() const { return _AP_W; }


    inline ap_private& reverse () {
        for (int i = 0; i < _AP_W/2; ++i) {
            bool tmp = operator[](i);
            if (operator[](_AP_W - 1 - i))
                set(i);
            else
                clear(i);
            if (tmp)
                set(_AP_W - 1 - i);
            else
                clear(_AP_W - 1 - i);
        }
        clearUnusedBits();
        return *this;
    }


    inline bool iszero () const {
        return isMinValue();
    }

    inline bool to_bool() const {
        return !iszero();
    }


    inline bool sign () const {
        if (isNegative())
            return true;
        return false;
    }


    inline void invert (int i) {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3462));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3463));
        flip(i);
    }


    inline bool test (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3469));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3470));
        return operator[](i);
    }


    inline void set (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3476));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3477));
        v ? set(i) : clear(i);
    }


    inline void set_bit (int i, bool v) {
        ((i >= 0 && "Attempting to write bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to write bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3483));
        ((i < _AP_W && "Attempting to write bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to write bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3484));
        v ? set(i) : clear(i);
    }

    inline ap_private& set(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }

    inline void set() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] = ~0ULL;
        clearUnusedBits();
    }


    inline bool get (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3502));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3503));
        return operator [](i);
    }


    inline bool get_bit (int i) const {
        ((i >= 0 && "Attempting to read bit with negative index") ? (void)0 : _assert("i >= 0 && \"Attempting to read bit with negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3509));
        ((i < _AP_W && "Attempting to read bit beyond MSB") ? (void)0 : _assert("i < _AP_W && \"Attempting to read bit beyond MSB\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3510));
        return operator [](i);
    }



    inline void lrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3517));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3518));
        operator = (shl(n) | lshr(_AP_W - n));
    }



    inline void rrotate(int n) {
        ((n >= 0 && "Attempting to shift negative index") ? (void)0 : _assert("n >= 0 && \"Attempting to shift negative index\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3525));
        ((n < _AP_W && "Shift value larger than bit width") ? (void)0 : _assert("n < _AP_W && \"Shift value larger than bit width\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3526));
        operator = (lshr(n) | shl(_AP_W - n));
    }



    ap_private& clear(uint32_t bitPosition) {
        pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
        clearUnusedBits();
        return *this;
    }


    void clear() {
        memset(pVal, 0, _AP_N * APINT_WORD_SIZE);
    }


    ap_private& flip() {
        for (int i = 0; i < _AP_N; ++i)
            pVal[i] ^= ~0ULL;
        clearUnusedBits();
        return *this;
    }




    ap_private& flip(uint32_t bitPosition) {
        ((bitPosition < BitWidth && "Out of the bit-width range!") ? (void)0 : _assert("bitPosition < BitWidth && \"Out of the bit-width range!\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 3555));
        if ((*this)[bitPosition]) clear(bitPosition);
        else set(bitPosition);
        return *this;
    }


    inline void b_not() {
        flip();
    }

    ap_private getLoBits(uint32_t numBits) const {
        return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
               _AP_W - numBits);
    }

    ap_private getHiBits(uint32_t numBits) const {
        return ap_private_ops::lshr(*this, _AP_W - numBits);
    }




    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_private<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
        return *this ^ a2.get();
    }
#3617 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
    template<int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative()?~0ULL:0; for (;i<_AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };





    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S, _AP_S1);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
        if (!lhsWords) {

            return *this;
        }

        ap_private dupRHS = RHS;

        uint32_t rhsBits = dupRHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
        if (!rhsWords) {

            clear();
            return *this;
        }


        uint32_t destWords = rhsWords + lhsWords;
        uint64_t *dest = (uint64_t*) malloc(destWords*sizeof(uint64_t));


        ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords, destWords);


        clear();
        uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;

        memcpy(pVal, dest, wordsToCopy* APINT_WORD_SIZE);

        uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
        for (int i=wordsToCopy; i<_AP_N; i++)
            pVal[i]=ext;
        clearUnusedBits();

        free(dest);
        return *this;
    }
#3697 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator / (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2,_AP_S2>& op) { *this=operator % (op); return *this; }
#3731 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator | (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] | ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator & (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] & ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
    template<int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^ (const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w +APINT_BITS_PER_WORD-1)/APINT_BITS_PER_WORD}; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N<_AP_N1 && isNegative() )||(_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N>_AP_N1) for (;i<max_N;i++) Result.set_pVal(i, pVal[i] ^ ext); else for (;i<max_N;i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N>_AP_N1 && isNegative() )||(_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };



    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::plus operator+(const ap_private<_AP_W1, _AP_S1>& RHS) const {

        typename RType<_AP_W1,_AP_S1>::plus Result;
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        bool carry = ap_private_ops::add(Result.get_pVal(), pVal, RHSpVal, (RType<_AP_W1,_AP_S1>::plus_w + 63) / 64, _AP_N, _AP_N1, _AP_S, _AP_S1);
        if ((RType<_AP_W1,_AP_S1>::plus_w + 63) / 64 > std::max((int)_AP_N, _AP_N1) )
            Result.get_pVal((RType<_AP_W1,_AP_S1>::plus_w + 63)/64 - 1) = carry;
        Result.clearUnusedBits();
        return Result;
    }

    template<int _AP_W1, bool _AP_S1>
    inline typename RType<_AP_W1,_AP_S1>::minus operator-(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1,_AP_S1>::minus Result;
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        uint64_t RHSpVal[_AP_N1];
        for (int i=0; i<_AP_N1; ++i)
            RHSpVal[i] = RHS.get_pVal(i);
        bool borrow = ap_private_ops::sub(Result.get_pVal(), pVal, RHSpVal, (RType<_AP_W1,_AP_S1>::minus_w + 63) / 64, _AP_N, _AP_N1, _AP_S, _AP_S1);
        if ((RType<_AP_W1,_AP_S1>::minus_w + 63) / 64 > AESL_std::max((int)_AP_N, _AP_N1) ) {
            Result.get_pVal((RType<_AP_W1,_AP_S1>::minus_w+63)/64 - 1) = borrow;
        }
        Result.clearUnusedBits();
        return Result;
    }

    template<int _AP_W1, bool _AP_S1>
    typename RType<_AP_W1, _AP_S1>::mult operator*(const ap_private<_AP_W1, _AP_S1>& RHS) const {
        typename RType<_AP_W1, _AP_S1>::mult temp = *this;
        temp *= RHS;
        return temp;
    }

    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::div
    operator / (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs=op;
        return typename RType<_AP_W2,_AP_S2>::div((_AP_S||_AP_S2)?lhs.sdiv(rhs):lhs.udiv(rhs));
    }

    template<int _AP_W2, bool _AP_S2>
    inline typename RType<_AP_W2,_AP_S2>::mod
    operator % (const ap_private<_AP_W2,_AP_S2>& op) const {
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> lhs=*this;
        ap_private<((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2))), (_AP_W>_AP_W2?_AP_S:(_AP_W2>_AP_W?_AP_S2:_AP_S||_AP_S2))> rhs= op;
        typename RType<_AP_W2,_AP_S2>::mod res = typename RType<_AP_W2,_AP_S2>::mod(_AP_S?lhs.srem(rhs):lhs.urem(rhs));
        return res;
    }
#3801 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline ap_private operator << (const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const bool op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }
    inline ap_private operator << (const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0-op); return shl(op); }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator << (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this << sh;
        } else {
            int sh = op2.to_int();
            return *this << sh;
        }
    }
#3845 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline ap_private operator >> (const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const bool op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (true && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }
    inline ap_private operator >> (const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if (false && op < 0) return *this << (0-op); if (_AP_S) return ashr(op) ; else return lshr(op); }


    template<int _AP_W2, bool _AP_S2>
    inline ap_private
    operator >> (const ap_private<_AP_W2, _AP_S2>& op2) const {
        if (_AP_S2 == false) {
            uint32_t sh = op2.to_uint();
            return *this >> sh;
        } else {
            int sh = op2.to_int();
            return *this >> sh;
        }
    }
#3892 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >> (op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >> (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator >> (op); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator << (op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator << (op); return *this; } template<int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2,_AP_S2>& op) { *this = operator << (op); return *this; }



    bool operator==(const ap_private& RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();


        if (n1 != n2)
            return false;


        if (n1 <= APINT_BITS_PER_WORD)
            return pVal[0] == RHS.get_pVal(0);


        for (int i = whichWord(n1 - 1); i >= 0; --i)
            if (pVal[i] != RHS.get_pVal(i))
                return false;
        return true;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),};
        ap_private<_AP_MAX_W, false> lhs(*this);
        ap_private<_AP_MAX_W, false> rhs(op);
        return lhs==rhs;
    }

    bool operator==(uint64_t Val) const {
        uint32_t n = getActiveBits();
        if (n <= APINT_BITS_PER_WORD)
            return pVal[0] == Val;
        else
            return false;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_private<_AP_W2, _AP_S2>& op) const {
        return !(*this==op);
    }

    template<bool _AP_S1>
    inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !((*this) == RHS);
    }

    inline bool operator!=(uint64_t Val) const {
        return !((*this) == Val);
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this>op);
    }

    inline bool operator <(const ap_private& op) const {
        return _AP_S ? slt(op):ult(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.slt(rhs):lhs.ult(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ult(rhs);
                else
                    return lhs.slt(rhs);

    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >=(const ap_private<_AP_W2,_AP_S2>& op) const {
        return !(*this<op);
    }

    inline bool operator >(const ap_private& op) const {
        return _AP_S ? sgt(op):ugt(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_private<_AP_W2, _AP_S2>& op) const {
        enum { _AP_MAX_W = ((_AP_W+(_AP_S||_AP_S2)) > (_AP_W2+(_AP_S||_AP_S2)) ? (_AP_W+(_AP_S||_AP_S2)) : (_AP_W2+(_AP_S||_AP_S2)))};
        ap_private<_AP_MAX_W, _AP_S> lhs(*this);
        ap_private<_AP_MAX_W, _AP_S2> rhs(op);
        if (_AP_S == _AP_S2)
            return _AP_S?lhs.sgt(rhs):lhs.ugt(rhs);
        else
            if (_AP_S)
                if (_AP_W2 >= _AP_W)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);
            else
                if (_AP_W >= _AP_W2)
                    return lhs.ugt(rhs);
                else
                    return lhs.sgt(rhs);

    }



    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private<_AP_W,
                _AP_S>*>(this), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
        return ap_range_ref<_AP_W,_AP_S>((const_cast<ap_private<_AP_W,
                    _AP_S>*> (this)), Hi, Lo);
    }

    inline ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    range (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_private*>(this), Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline ap_range_ref<_AP_W,_AP_S>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
            const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }

    inline ap_bit_ref<_AP_W,_AP_S> operator [] (uint32_t index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br =operator [] (index);
        return br.to_bool();
    }

    inline bool operator [](uint32_t bitPosition) const {
      return (maskBit(bitPosition) & (pVal[whichWord(bitPosition)])) != 0;
    }

    inline ap_bit_ref<_AP_W,_AP_S> bit (int index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index );
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref<_AP_W,_AP_S> bit (const ap_private<_AP_W2,_AP_S2> &index) {
        return ap_bit_ref<_AP_W,_AP_S>( *this, index.to_int() );
    }

    inline bool bit (int index) const {
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_private<_AP_W, _AP_S>*>(this), index);
        return br.to_bool();
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2,_AP_S2>& index) const {
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(ap_private<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_private<_AP_W, _AP_S>,_AP_W2,ap_private<_AP_W2,_AP_S2> > concat(const ap_private<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_private<_AP_W2,_AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                                                                                                  const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(*this, const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (const ap_private<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, ap_private<_AP_W2,
                 _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this), const_cast<ap_private<_AP_W2,_AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                             const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2,
                             ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                  const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, 1,
                  ap_bit_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) const {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                      const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_private<_AP_W, _AP_S>, _AP_W2+_AP_W3,
                             ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_private<_AP_W,_AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_private, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    inline ap_private<_AP_W,false> get() const {
        ap_private<_AP_W,false> ret(*this);
        return ret;
    }

    template<int _AP_W3>
    inline void set(const ap_private<_AP_W3, false> & val) {
        operator = (ap_private<_AP_W3, _AP_S>(val));
    }







    inline bool isNegative() const {

        enum {shift = (_AP_W-APINT_BITS_PER_WORD*(_AP_N-1)-1)};
        static const uint64_t mask = 1ULL << (shift);
        return _AP_S && (pVal[_AP_N-1]&mask);
    }



    inline bool isPositive() const {
        return !isNegative();
    }




    inline bool isStrictlyPositive() const {
        return isPositive() && (*this) != 0;
    }



    inline bool isAllOnesValue() const {
        return countPopulation() == _AP_W;
    }




    inline bool isMaxValue() const {
        return countPopulation() == _AP_W;
    }




    inline bool isMaxSignedValue() const {
        return !isNegative() && countPopulation() == _AP_W - 1;
    }




    inline bool isMinValue() const {
        return countPopulation() == 0;
    }




    inline bool isMinSignedValue() const {
        return isNegative() && countPopulation() == 1;
    }




    inline const uint64_t* getRawData() const {
        return &pVal[0];
    }
#4313 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private sqrt() const {


        uint32_t magnitude = getActiveBits();



        if (magnitude <= 5) {
            static const uint8_t results[32] = {
                            0,
                            1, 1,
                            2, 2, 2, 2,
                            3, 3, 3, 3, 3, 3,
                            4, 4, 4, 4, 4, 4, 4, 4,
                            5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                            6
            };
            return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
        }





        if (magnitude < 52) {





            return ap_private<_AP_W, _AP_S>(
                    uint64_t(::round(::sqrt(double(get_VAL())))));

        }






        uint32_t nbits = BitWidth, i = 4;
        ap_private<_AP_W, _AP_S> testy(16);
        ap_private<_AP_W, _AP_S> x_old( 1);
        ap_private<_AP_W, _AP_S> x_new(0);
        ap_private<_AP_W, _AP_S> two( 2);


        for ( ; ; i += 2, testy = testy.shl(2))
            if (i >= nbits || this->ule(testy)) {
                x_old = x_old.shl(i / 2);
                break;
            }


        for ( ; ; ) {
            x_new = (this->udiv(x_old) + x_old).udiv(two);
            if (x_old.ule(x_new))
                break;
            x_old = x_new;
        }







        ap_private<_AP_W, _AP_S> square(x_old * x_old);
        ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old +1));
        if (this->ult(square))
            return x_old;
        else if (this->ule(nextSquare)) {
            ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
            ap_private<_AP_W, _AP_S> offset(*this - square);
            if (offset.ult(midpoint))
                return x_old;
            else
                return x_old + 1;
        } else
            ((0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation") ? (void)0 : _assert("0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4392));
        return x_old + 1;
    }






    inline ap_private& operator=(const ap_private& RHS) {
        if (this != &RHS)
            memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
        return *this;
    }
    inline ap_private& operator=(const volatile ap_private& RHS) {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
        return *this;
    }
    inline void operator=(const ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }
    inline void operator=(const volatile ap_private& RHS) volatile {
        if (this != &RHS)
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = RHS.get_pVal(i);
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }

    template<int _AP_W1, bool _AP_S1>
    inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
        if (_AP_S1)
            cpSextOrTrunc(RHS);
        else
            cpZextOrTrunc(RHS);
        clearUnusedBits();
        return *this;
    }
#4476 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline const ap_private operator++(int) {
        ap_private API(*this);
        ++(*this);
        return API;
    }



    inline ap_private& operator++() {
        ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }



    inline const ap_private operator--(int) {
        ap_private API(*this);
        --(*this);
        return API;
    }



    inline ap_private& operator--() {
        ap_private_ops::sub_1(pVal, _AP_N, 1);
        clearUnusedBits();
        return *this;
    }




    inline ap_private<_AP_W + !_AP_S, true> operator~() const {
        ap_private<_AP_W + !_AP_S, true> Result(*this);
        Result.flip();
        return Result;
    }




    inline typename RType<1,false>::minus operator-() const {
        return ap_private<1,false>(0) - (*this);
    }




    inline bool operator !() const {
        for (int i = 0; i < _AP_N; ++i)
            if (pVal[i])
                return false;
        return true;
    }

    template<bool _AP_S1>
    inline ap_private<_AP_W, _AP_S||_AP_S1> And(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator&(RHS);
    }
    template<bool _AP_S1>
    inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator|(RHS);
    }
    template<bool _AP_S1>
    ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return this->operator^(RHS);
    }

    ap_private Mul(const ap_private& RHS) const {
        ap_private Result(*this);
        Result *= RHS;
        return Result;
    }

    ap_private Add(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }

    ap_private Sub(const ap_private& RHS) const {
        ap_private Result(0);
        ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N, _AP_N, _AP_S, _AP_S);
        Result.clearUnusedBits();
        return Result;
    }



    ap_private ashr(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? (void)0 : _assert("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4568));

        if (shiftAmt == 0)
            return *this;




        if (shiftAmt == BitWidth) {
            if (isNegative())
                return ap_private(-1);
            else
                return ap_private(0);
        }


        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
        uint32_t breakWord = _AP_N - 1 - offset;
        uint32_t bitsInWord = whichBit(BitWidth);
        if (bitsInWord == 0)
            bitsInWord = APINT_BITS_PER_WORD;


        if (wordShift == 0) {

            for (uint32_t i = 0; i <= breakWord; ++i)
                val[i] = pVal[i+offset];


            if (isNegative())
                if (bitsInWord < APINT_BITS_PER_WORD)
                    val[breakWord] |= ~0ULL << (bitsInWord);
        } else {

            for (uint32_t i = 0; i < breakWord; ++i) {


                val[i] = ((pVal[i+offset]) >> (wordShift));
                val[i] |= ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));
            }



            val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);



            if (isNegative()) {
                if (wordShift > bitsInWord) {
                    if (breakWord > 0)
                        val[breakWord-1] |=
                            ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
                    val[breakWord] |= ~0ULL;
                } else
                    val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
            }
        }


        uint64_t fillValue = (isNegative() ? ~0ULL : 0);
        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = fillValue;
        Retval.clearUnusedBits();
        return Retval;
    }



    ap_private lshr(uint32_t shiftAmt) const {



        if (shiftAmt == BitWidth)
            return ap_private(0);




        if (shiftAmt == 0)
            return *this;


        ap_private Retval(0);
        uint64_t * val = Retval.get_pVal();


        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = _AP_N-1; i >= 0; --i) {
                val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
                carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


        if (wordShift == 0) {
            for (uint32_t i = 0; i < _AP_N - offset; ++i)
                val[i] = pVal[i+offset];
            for (uint32_t i = _AP_N-offset; i < _AP_N; i++)
                val[i] = 0;
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t breakWord = _AP_N - offset -1;
        for (uint32_t i = 0; i < breakWord; ++i)
            val[i] = ((pVal[i+offset]) >> (wordShift)) |
                ((pVal[i+offset+1]) << (APINT_BITS_PER_WORD - wordShift));

        val[breakWord] = (pVal[breakWord+offset]) >> (wordShift);


        for (int i = breakWord+1; i < _AP_N; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }



    ap_private shl(uint32_t shiftAmt) const {
        ((shiftAmt <= BitWidth && "Invalid shift amount, too big") ? (void)0 : _assert("shiftAmt <= BitWidth && \"Invalid shift amount, too big\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4701));



        if (shiftAmt == BitWidth)
            return ap_private(0);




        if (shiftAmt == 0)
            return *this;


        ap_private Retval(0);
        uint64_t* val = Retval.get_pVal();

        if (shiftAmt < APINT_BITS_PER_WORD) {
            uint64_t carry = 0;
            for (int i = 0; i < _AP_N; i++) {
                val[i] = ((pVal[i]) << (shiftAmt)) | carry;
                carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
            }
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
        uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


        if (wordShift == 0) {
            for (uint32_t i = 0; i < offset; i++)
                val[i] = 0;
            for (int i = offset; i < _AP_N; i++)
                val[i] = pVal[i-offset];
            Retval.clearUnusedBits();
            return Retval;
        }


        uint32_t i = _AP_N - 1;
        for (; i > offset; --i)
            val[i] = (pVal[i-offset]) << (wordShift) |
                (pVal[i-offset-1]) >> (APINT_BITS_PER_WORD - wordShift);
        val[offset] = (pVal[0]) << (wordShift);
        for (i = 0; i < offset; ++i)
            val[i] = 0;
        Retval.clearUnusedBits();
        return Retval;
    }

    inline ap_private rotl(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;

        ap_private hi(*this);
        ap_private lo(*this);
        hi.shl(rotateAmt);
        lo.lshr(BitWidth - rotateAmt);
        return hi | lo;
    }

    inline ap_private rotr(uint32_t rotateAmt) const {
        if (rotateAmt == 0)
            return *this;

        ap_private hi(*this);
        ap_private lo(*this);
        lo.lshr(rotateAmt);
        hi.shl(BitWidth - rotateAmt);
        return hi | lo;
    }





    ap_private udiv(const ap_private& RHS) const {

        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Divided by zero???") ? (void)0 : _assert("rhsWords && \"Divided by zero???\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4784));
        uint32_t lhsBits = this->getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


        if (!lhsWords)

            return ap_private(0);
        else if (lhsWords < rhsWords || this->ult(RHS)) {

            return ap_private(0);
        } else if (*this == RHS) {

            return ap_private(1);
        } else if (lhsWords == 1 && rhsWords == 1) {

            return ap_private(this->pVal[0] / RHS.get_pVal(0));
        }


        ap_private Quotient(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient, (ap_private*)0);
        return Quotient;
    }



    inline ap_private sdiv(const ap_private& RHS) const {
        if (isNegative())
            if (RHS.isNegative())
                return (-(*this)).udiv(-RHS);
            else
                return -((-(*this)).udiv(RHS));
        else if (RHS.isNegative())
            return -(this->udiv((ap_private)(-RHS)));
        return this->udiv(RHS);
    }
#4829 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ap_private urem(const ap_private& RHS) const {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


        uint32_t rhsBits = RHS.getActiveBits();
        uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
        ((rhsWords && "Performing remainder operation by zero ???") ? (void)0 : _assert("rhsWords && \"Performing remainder operation by zero ???\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4837));


        if (lhsWords == 0) {

            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {

            return *this;
        } else if (*this == RHS) {

            return ap_private(0);
        } else if (lhsWords == 1) {

            return ap_private(pVal[0] % RHS.get_pVal(0));
        }


        ap_private Remainder(0);
        ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0), &Remainder);
        return Remainder;
    }

    ap_private urem(uint64_t RHS) const {

        uint32_t lhsBits = getActiveBits();
        uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);

        uint32_t rhsWords = 1;
        ((rhsWords && "Performing remainder operation by zero ???") ? (void)0 : _assert("rhsWords && \"Performing remainder operation by zero ???\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4866));

        if (lhsWords == 0) {

            return ap_private(0);
        } else if (lhsWords < rhsWords || this->ult(RHS)) {

            return *this;
        } else if (*this == RHS) {

            return ap_private(0);
        } else if (lhsWords == 1) {

            return ap_private(pVal[0] % RHS);
        }


        ap_private Remainder(0);
        divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
        return Remainder;
    }



    inline ap_private srem(const ap_private& RHS) const {
        if (isNegative()) {
            ap_private lhs = -(*this);
            if (RHS.isNegative()) {
                ap_private rhs = -RHS;
                return -(lhs.urem(rhs));
            } else
                return -(lhs.urem(RHS));
        } else if (RHS.isNegative()) {
            ap_private rhs = -RHS;
            return this->urem(rhs);
        }
        return this->urem(RHS);
    }



    inline ap_private srem(int64_t RHS) const {
        if (isNegative())
            if (RHS<0)
                return -((-(*this)).urem(-RHS));
            else
                return -((-(*this)).urem(RHS));
        else if (RHS<0)
            return this->urem(-RHS);
        return this->urem(RHS);
    }





    template<bool _AP_S1>
    inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return (*this) == RHS;
    }





    template<bool _AP_S1>
    inline bool ne(const ap_private<_AP_W, _AP_S1> &RHS) const {
        return !((*this) == RHS);
    }





    template<bool _AP_S1>
    inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = RHS.getActiveBits();


        if (n1 < n2)
            return true;


        if (n2 < n1)
            return false;


        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS.get_pVal(0);


        uint32_t topWord = whichWord(AESL_std::max(n1,n2)-1);
        for (int i = topWord; i >= 0; --i) {
            if (pVal[i] > RHS.get_pVal(i))
                return false;
            if (pVal[i] < RHS.get_pVal(i))
                return true;
        }
        return false;
    }

    inline bool ult(uint64_t RHS) const {

        uint32_t n1 = getActiveBits();
        uint32_t n2 = 64 - ap_private_ops::CountLeadingZeros_64(RHS);


        if (n1 < n2)
            return true;


        if (n2 < n1)
            return false;


        if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
            return pVal[0] < RHS;
        ((0) ? (void)0 : _assert("0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 4985));
    }

    template<bool _AP_S1>
    inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        ap_private lhs(*this);
        ap_private<_AP_W, _AP_S1> rhs(RHS);
        bool lhsNeg = isNegative();
        bool rhsNeg = rhs.isNegative();
        if (lhsNeg) {

            lhs.flip();
            lhs++;
        }
        if (rhsNeg) {

            rhs.flip();
            rhs++;
        }



        if (lhsNeg)
            if (rhsNeg)
                return lhs.ugt(rhs);
            else
                return true;
        else if (rhsNeg)
            return false;
        else
            return lhs.ult(rhs);
    }





    template<bool _AP_S1>
    inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return ult(RHS) || eq(RHS);
    }





    template<bool _AP_S1>
    inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return slt(RHS) || eq(RHS);
    }





    template<bool _AP_S1>
    inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !ult(RHS) && !eq(RHS);
    }





    template<bool _AP_S1>
    inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS) && !eq(RHS);
    }





    template<bool _AP_S1>
    inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
        return !ult(RHS);
    }





    template<bool _AP_S1>
    inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
        return !slt(RHS);
    }


    template<int _AP_W1, bool _AP_S1>
    void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private SignExtend request") ? (void)0 : _assert("_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5075));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? (void)0 : _assert("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5076));

        if (!that.isNegative()) {
            cpZext(that);
            return;
        }


        enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD};
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;

        if (_AP_N1 == _AP_N) {
            enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};

            static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
            for (int i = 0; i < _AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            pVal[_AP_N-1] |= mask;
            return;
        }

        enum { newWordBits = _AP_W % APINT_BITS_PER_WORD};

        static const uint64_t mask = wordBits?(~0ULL<<(wordBits)):0ULL;
        int i;
        for (i = 0; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        pVal[i - 1] |= mask;
        for (; i < _AP_N-1; i++)
            pVal[i] = ~0ULL;
        pVal[i] = ~0ULL;
        clearUnusedBits();
        return;
    }


    template <int _AP_W1, bool _AP_S1>
    void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {
        ((_AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request") ? (void)0 : _assert("_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5114));
        ((_AP_W1 <= MAX_INT_BITS && "Too many bits") ? (void)0 : _assert("_AP_W1 <= MAX_INT_BITS && \"Too many bits\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5115));
        const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
        int i = 0;
        for (; i < _AP_N1; ++i)
            pVal[i] = that.get_pVal(i);
        for (; i < _AP_N; ++i)
            pVal[i] = 0;
        clearUnusedBits();
    }

    template<int _AP_W1, bool _AP_S1>
    void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpZext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i]=that.get_pVal(i);
            clearUnusedBits();
        }
    }

    template<int _AP_W1, bool _AP_S1>
    void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
        if (BitWidth > _AP_W1)
            cpSext(that);
        else {
            for (int i=0; i<_AP_N; ++i)
                pVal[i] = that.get_pVal(i);
            clearUnusedBits();
        }
    }





    inline uint32_t getBitWidth() const {
        return BitWidth;
    }




    inline uint32_t getNumWords() const {
        return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
    }





    inline uint32_t getActiveBits() const {
        uint32_t bits=BitWidth - countLeadingZeros();
        return bits?bits:1;
    }






    inline uint64_t getZExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for uint64_t") ? (void)0 : _assert("getActiveBits() <= 64 && \"Too many bits for uint64_t\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5177));
        return *pVal;
    }





    inline int64_t getSExtValue() const {
        ((getActiveBits() <= 64 && "Too many bits for int64_t") ? (void)0 : _assert("getActiveBits() <= 64 && \"Too many bits for int64_t\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5186));
        return int64_t(pVal[0]);
    }




    static uint32_t getBitsNeeded(const char* str, uint32_t slen, uint8_t radix) {
        ((str != 0 && "Invalid value string") ? (void)0 : _assert("str != 0 && \"Invalid value string\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5194));
        ((slen > 0 && "Invalid string length") ? (void)0 : _assert("slen > 0 && \"Invalid string length\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5195));


        uint32_t isNegative = str[0] == '-';
        if (isNegative) {
            slen--;
            str++;
        }


        if (radix == 2)
            return slen + isNegative;
        if (radix == 8)
            return slen * 3 + isNegative;
        if (radix == 16)
            return slen * 4 + isNegative;


        ((radix == 10 && "Invalid radix") ? (void)0 : _assert("radix == 10 && \"Invalid radix\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5213));






        return isNegative + slen * 4;
    }







    inline uint32_t countLeadingZeros() const {
        enum { msw_bits = (BitWidth % APINT_BITS_PER_WORD)?(BitWidth % APINT_BITS_PER_WORD):APINT_BITS_PER_WORD,
            excessBits = APINT_BITS_PER_WORD - msw_bits };
        uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N-1]);
        if (Count>=excessBits)
            Count -= excessBits;
        if (!pVal[_AP_N-1]) {
            for (int i = _AP_N-1 ; i ; --i) {
                if (!pVal[i-1])
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += ap_private_ops::CountLeadingZeros_64(pVal[i-1]);
                    break;
                }
            }
        }
        return Count;
    }






    inline uint32_t countLeadingOnes() const {
        if (isSingleWord())
            return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);

        uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
        uint32_t shift = (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
        int i = _AP_N - 1;
        uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
        if (Count == highWordBits) {
            for (i--; i >= 0; --i) {
                if (get_pVal(i) == ~0ULL)
                    Count += APINT_BITS_PER_WORD;
                else {
                    Count += countLeadingOnes_64(get_pVal(i), 0);
                    break;
                }
            }
        }
        return Count;
    }
#5281 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    inline uint32_t countTrailingZeros() const {
        uint32_t Count = 0;
        uint32_t i = 0;
        for (; i < _AP_N && get_pVal(i) == 0; ++i)
            Count += APINT_BITS_PER_WORD;
        if (i < _AP_N)
            Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
        return AESL_std::min(Count, BitWidth);
    }






    inline uint32_t countPopulation() const {
        uint32_t Count = 0;
        for (int i = 0; i<_AP_N-1 ; ++i)
            Count += ap_private_ops::CountPopulation_64(pVal[i]);
        Count += ap_private_ops::CountPopulation_64(pVal[_AP_N-1]&mask);
        return Count;
    }







    inline std::string toString(uint8_t radix, bool wantSigned) const
        ;





    inline std::string toStringUnsigned(uint8_t radix = 10) const {
        return toString(radix, false);
    }





    inline std::string toStringSigned(uint8_t radix = 10) const {
        return toString(radix, true);
    }


    inline double roundToDouble(bool isSigned) const {


        if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
            uint64_t val = pVal[0];
            if (isSigned) {
                int64_t sext = ((int64_t(val)) << (64-BitWidth)) >> (64-BitWidth);
                return double(sext);
            } else
                return double(val);
        }


        bool isNeg = isSigned ? (*this)[BitWidth-1] : false;


        ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));


        uint32_t n = Tmp.getActiveBits();




        uint64_t exp = n;


        if (exp > 1023) {
            if (!isSigned || !isNeg)
                return std::numeric_limits<double>::infinity();
            else
                return -std::numeric_limits<double>::infinity();
        }
        exp += 1023;



        uint64_t mantissa;
        unsigned hiWord = whichWord(n-1);
        if (hiWord == 0) {
            mantissa = Tmp.get_pVal(0);
            if (n > 52)
                (mantissa) >>= (n - 52);
        } else {
            ((hiWord > 0 && "High word is negative?") ? (void)0 : _assert("hiWord > 0 && \"High word is negative?\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5374));
            uint64_t hibits = (Tmp.get_pVal(hiWord)) << (52 - n % APINT_BITS_PER_WORD);
            uint64_t lobits = (Tmp.get_pVal(hiWord-1)) >> (11 + n % APINT_BITS_PER_WORD);
            mantissa = hibits | lobits;
        }


        uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
        union {
            double __D;
            uint64_t __I;
        } __T;
        __T.__I = sign | ((exp) << 52) | mantissa;
        return __T.__D;
    }


    inline double roundToDouble() const {
        return roundToDouble(false);
    }


    inline double signedRoundToDouble() const {
        return roundToDouble(true);
    }





    inline double bitsToDouble() const {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__I = pVal[0];
        return __T.__D;
    }





    inline float bitsToFloat() const {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__I = uint32_t(pVal[0]);
        return __T.__F;
    }





    inline ap_private& doubleToBits(double __V) {
        union {
            uint64_t __I;
            double __D;
        } __T;
        __T.__D = __V;
        pVal[0] = __T.__I;
        return *this;
    }





    inline ap_private& floatToBits(float __V) {
        union {
            uint32_t __I;
            float __F;
        } __T;
        __T.__F = __V;
        pVal[0] = __T.__I;
    }



    inline bool and_reduce() const {
        return isMaxValue();
    }

    inline bool nand_reduce() const {
        return isMinValue();
    }

    inline bool or_reduce() const {
        return (bool)countPopulation();
    }

    inline bool nor_reduce() const {
        return countPopulation()==0;
    }

    inline bool xor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?true:false;
    }

    inline bool xnor_reduce() const {
        unsigned int i=countPopulation();
        return (i%2)?false:true;
    }
    inline std::string to_string(uint8_t radix=16, bool sign=false) const {
        return toString(radix, radix==10?_AP_S:sign);
    }
};

namespace ap_private_ops {
    enum {APINT_BITS_PER_WORD=64};
    template<int _AP_W, bool _AP_S>
    inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 == V1;
    }

    template<int _AP_W, bool _AP_S>
    inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
        return V2 != V1;
    }


    template<int _AP_W, bool _AP_S, int index>
    inline bool get(const ap_private<_AP_W, _AP_S>& a) {
        static const uint64_t mask=1ULL << (index&0x3f);
        return ((mask & a.get_pVal((index)>>6)) != 0);
    }

    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word==lsb_word) {
            const uint64_t mask = ~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1);

            a.get_pVal(msb_word) |= mask;
        } else {
            const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
            const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1);

            a.get_pVal(lsb_word) |=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {
                a.set_pVal(i, ~0ULL);

            }


            a.get_pVal(msb_word) |= msb_mask;
        }
        a.clearUnusedBits();
    }

    template<int _AP_W, bool _AP_S, int msb_index, int lsb_index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                    const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
        enum { APINT_BITS_PER_WORD=64,
            lsb_word = lsb_index /APINT_BITS_PER_WORD,
            msb_word = msb_index / APINT_BITS_PER_WORD,
            msb = msb_index % APINT_BITS_PER_WORD,
            lsb=lsb_index % APINT_BITS_PER_WORD};
        if (msb_word == lsb_word) {
            const uint64_t mask = ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD-msb+lsb-1)>>(APINT_BITS_PER_WORD-msb-1));

            a.get_pVal(msb_word) &= mask;
        } else {
            const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
            const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD-msb-1)>>(APINT_BITS_PER_WORD-msb-1));

            a.get_pVal(lsb_word) &=lsb_mask;
            for (int i=lsb_word+1; i<msb_word; i++) {

                a.get_pVal(i)=0;
            }

            a.get_pVal(msb_word) &= msb_mask;
        }
        a.clearUnusedBits();
    }


    template<int _AP_W, bool _AP_S, int index>
    inline void set(ap_private<_AP_W, _AP_S>& a,
                    const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=1ULL << (index%APINT_BITS_PER_WORD);

        a.get_pVal(word) |= mask;
        a.clearUnusedBits();
    }

    template<int _AP_W, bool _AP_S, int index>
    inline void clear(ap_private<_AP_W, _AP_S>& a,
                      const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
        enum { APINT_BITS_PER_WORD=64, word = index/APINT_BITS_PER_WORD};
        static const uint64_t mask=~(1ULL << (index%APINT_BITS_PER_WORD));

        a.get_pVal(word) &= mask;
        a.clearUnusedBits();
    }

}

template<int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, false>::toString(uint8_t radix, bool wantSigned) const {
    (((radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!") ? (void)0 : _assert("(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\"",
 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
#5586 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ,
 5587
#5586 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h"
    ))
                                               ;
    static const char *digits[] = {
        "0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"
    };
    std::string result;

    if (radix != 10) {





        if (*this == (uint64_t)(0))
            result = "0";
        else {
            ap_private<_AP_W, false> tmp(*this);
            size_t insert_at = 0;
            bool leading_zero = true;
            if (wantSigned && isNegative()) {



                tmp.flip();
                tmp++;
                tmp.clearUnusedBitsToZero();
                result = "-";
                insert_at = 1;
                leading_zero = false;
            }
            switch (radix) {
                case 2: result += "0b"; break;
                case 8: result += "0o"; break;
                case 16: result += "0x"; break;
                default: (("invalid radix" && 0) ? (void)0 : _assert("\"invalid radix\" && 0", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5620));
            }
            insert_at += 2;

            uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
            uint64_t mask = radix - 1;
            ap_private<_AP_W, false> zero(0);
            unsigned bits = 0;
            while (tmp.ne(zero)) {
                uint64_t digit = tmp.get_VAL() & mask;
                result.insert(insert_at, digits[digit]);
                tmp = tmp.lshr(shift);
                ++bits;
            }
            bits *= shift;
            if (bits < _AP_W && leading_zero)
                result.insert(insert_at, digits[0]);
        }
        return result;
    }

    ap_private<_AP_W, false> tmp(*this);
    ap_private<_AP_W, false> divisor(radix);
    ap_private<_AP_W, false> zero(0);
    size_t insert_at = 0;
    if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
    }
    if (tmp == ap_private<_AP_W, false>(0))
        result = "0";
    else while (tmp.ne(zero)) {
        ap_private<_AP_W, false> APdigit(0);
        ap_private<_AP_W, false> tmp2(0);
        ap_private_ops::divide(tmp, tmp.getNumWords(), divisor, divisor.getNumWords(), &tmp2,
                &APdigit);
        uint64_t digit = APdigit.getZExtValue();
        ((digit < radix && "divide failed") ? (void)0 : _assert("digit < radix && \"divide failed\"", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_private.h", 5663));
        result.insert(insert_at,digits[digit]);
        tmp = tmp2;
    }

    return result;
}
#99 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 2
#170 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;
template<int _AP_W> class ap_uint;

enum {AP_BIN=2,AP_OCT=8,AP_DEC=10,AP_HEX=16};
#193 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {



    enum {_AP_WR=_AP_W1+_AP_W2,};
    _AP_T1& mbv1;
    _AP_T2& mbv2;

    inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1,
          _AP_W2, _AP_T2>& ref):
           mbv1(ref.mbv1), mbv2(ref.mbv2) {}

    inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2):mbv1(bv1),mbv2(bv2) {}


    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator = (const ap_private<_AP_W3,_AP_S3>& val) {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
        return *this;
    }


    inline ap_concat_ref& operator = (unsigned long long val) {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    inline ap_concat_ref& operator =
        (const ap_concat_ref <_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }



    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }


    template <int _AP_W3, bool _AP_S3>
    inline ap_concat_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        ap_private<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_range_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = ((const ap_private<_AP_W3, false>)(val));
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = (val.to_ap_private());
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline ap_concat_ref& operator= (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator=((unsigned long long)(bool)(val));
     }


    inline operator ap_private<_AP_WR, false> () const
    {
        return get();
    }

    inline operator unsigned long long () const
    {
         return get().to_uint64();
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >
        operator, (const ap_range_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_range_ref<_AP_W3, _AP_S3> &>(a2));
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this, a2);
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_private<_AP_W3, _AP_S3> >
        operator, (const ap_private<_AP_W3, _AP_S3> &a2)
    {
          return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3, ap_private<_AP_W3, _AP_S3> >(*this,
                               const_cast<ap_private<_AP_W3, _AP_S3>&>(a2));
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
        operator, (const ap_bit_ref<_AP_W3, _AP_S3> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               1, ap_bit_ref<_AP_W3, _AP_S3> >(*this,
                          const_cast<ap_bit_ref<_AP_W3, _AP_S3> &>(a2));
    }

    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >
        operator, (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> &a2)
    {
        return ap_concat_ref<_AP_WR, ap_concat_ref,
                               _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,
                               _AP_T4> >(*this, const_cast<ap_concat_ref<_AP_W3,
                               _AP_T3,_AP_W4, _AP_T4>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_range_ref<_AP_W3,_AP_I3, _AP_S3, _AP_Q3,
                _AP_O3, _AP_N3>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline
    ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_bit_ref<_AP_W3,_AP_I3, _AP_S3,
                _AP_Q3, _AP_O3, _AP_N3>& >(a2));
    }

    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator & (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() & a2;
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator | (const ap_private<_AP_W3,_AP_S3>& a2)
    {
        return get() | a2;
    }


    template<int _AP_W3, bool _AP_S3>
    inline ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
        operator ^ (const ap_private<_AP_W3,_AP_S3>& a2)
    {
      return ap_private<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>(get() ^ a2);
    }


    inline const ap_private<_AP_WR, false> get() const
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal = ap_private<_AP_W1+_AP_W2, false> (mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }


    inline const ap_private<_AP_WR, false> get()
    {
      ap_private<_AP_W1+_AP_W2, false> tmpVal =ap_private<_AP_W1+_AP_W2, false> ( mbv1.get());
      ap_private<_AP_W1+_AP_W2, false> tmpVal2 = ap_private<_AP_W1+_AP_W2, false> (mbv2.get());
        int W_ref2 = mbv2.length();
        tmpVal <<= W_ref2;
        tmpVal |= tmpVal2;
        return tmpVal;
    }


    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3,false> & val)
    {
        ap_private<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1=mbv1.length();
        int W_ref2=mbv2.length();
        ap_private<_AP_W1,false> mask1(-1);
        mask1>>=_AP_W1-W_ref1;
        ap_private<_AP_W2,false> mask2(-1);
        mask2>>=_AP_W2-W_ref2;
        mbv1.set(ap_private<_AP_W1,false>((vval>>W_ref2)&mask1));
        mbv2.set(ap_private<_AP_W2,false>(vval&mask2));
    }


    inline int length() const {
        return mbv1.length()+mbv2.length();
    }

    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }
};






template<int _AP_W, bool _AP_S>
struct ap_range_ref {



    ap_private<_AP_W,_AP_S> &d_bv;
    int l_index;
    int h_index;

public:
    inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref):
         d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline ap_range_ref(ap_private<_AP_W,_AP_S>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h)
    {
        if (h < 0 || l < 0)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);





    }


    inline operator ap_private<_AP_W, false> () const
    {
        ap_private<_AP_W, false> val(0);
        if(h_index>=l_index) {
   if (_AP_W > 64) {
            val=d_bv;
            ap_private<_AP_W,false> mask(-1);
            mask>>=_AP_W-(h_index-l_index+1);
            val>>=l_index;
            val&=mask;
   } else {
     const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
     val = (d_bv >> l_index) & (mask >>(_AP_W-(h_index-l_index+1)));
   }
        } else {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    if((d_bv)[j]) val.set(i);
        }
        return val;
    }

    inline operator unsigned long long () const
    {
        return to_uint64();
    }

    template<int _AP_W2,bool _AP_S2>
    inline ap_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
      ap_private<_AP_W,false> vval=ap_private<_AP_W,false>(val);
      if(l_index>h_index)
 {
   for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
     (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
 if (_AP_W > 64) {
   ap_private<_AP_W,false> mask(-1);
   if(l_index>0)
     {
       mask<<=l_index;
       vval<<=l_index;
     }
   if(h_index<_AP_W-1)
     {
       ap_private<_AP_W,false> mask2(-1);
       mask2>>=_AP_W-h_index-1;
       mask&=mask2;
       vval&=mask2;
     }
   mask.flip();
   d_bv&=mask;
   d_bv|=vval;
 } else {
   unsigned shift = 64-_AP_W;
   uint64_t mask = ~0ULL>>(shift);
   if(l_index>0)
     {
       vval = mask & vval << l_index;
       mask = mask & mask << l_index;
     }
   if(h_index<_AP_W-1)
     {
       uint64_t mask2 = mask;
       mask2 >>= (_AP_W-h_index-1);
       mask&=mask2;
       vval&=mask2;
     }
   mask = ~mask;
   d_bv&=mask;
   d_bv|=vval;
 }
      }
      return *this;
    }

  inline ap_range_ref& operator = (unsigned long long val)
    {
        const ap_private<_AP_W,_AP_S> vval=val;
        return operator = (vval);
    }


    inline ap_range_ref& operator =(const ap_range_ref<_AP_W, _AP_S>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }



    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline ap_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline ap_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val)
    {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, _AP_S2>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                   ap_range_ref<_AP_W2,_AP_S2> >(*this,
                   const_cast<ap_range_ref<_AP_W2,_AP_S2>& >(a2));
    }


    template <int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2,_AP_S2>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    inline ap_concat_ref<_AP_W,ap_range_ref,_AP_W,ap_private<_AP_W,_AP_S> >
    operator , (ap_private<_AP_W, _AP_S>& a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                          ap_private<_AP_W,_AP_S> >(*this, a2);
    }



    template <int _AP_W2, bool _AP_S2>
    inline
    ap_concat_ref<_AP_W,ap_range_ref,1,ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2,_AP_S2> &a2)
    {
        return
            ap_concat_ref<_AP_W, ap_range_ref, 1,
                      ap_bit_ref<_AP_W2,_AP_S2> >(*this, const_cast<ap_bit_ref<
                      _AP_W2,_AP_S2>& >(a2));
    }


    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2)
    {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                       const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                       _AP_T3>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }


    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2)
    {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }


    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val)
    {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index)
        {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    (vval)[i]? d_bv.set(j):d_bv.clear(j);
        } else {
   if (_AP_W>64 ) {
            ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0)
       {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;

                vval<<=l_index;
       }
            if(h_index<_AP_W-1)
       {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
       }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
   } else {
     uint64_t mask = ~0ULL >> (64-_AP_W);
            if(l_index>0)
       {
  uint64_t mask1 = mask;
  mask1=mask & (mask1>>(_AP_W-l_index));
  vval =mask&( vval <<l_index);
  mask=~mask1&mask;

       }
            if(h_index<_AP_W-1) {
  uint64_t mask2 = ~0ULL >> (64-_AP_W);
  mask2 = mask &(mask2<<(h_index+1));
  mask&=~mask2;
  vval&=~mask2;
       }
            d_bv&=(~mask&(~0ULL >> (64-_AP_W)));
            d_bv|=vval;
   }
 }
    }


    inline ap_private<_AP_W,false> get() const
    {
      ap_private<_AP_W,false> val(0);
      if(h_index<l_index) {
 for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
   if((d_bv)[j]) val.set(i);
      } else {
 val=d_bv;
 val>>=l_index;
 if(h_index<_AP_W-1)
   {
     if (_AP_W <= 64) {
       const static uint64_t mask = (~0ULL>> (64>_AP_W ? (64-_AP_W):0));
       val &= (mask>> (_AP_W-(h_index-l_index+1)));
     } else {
       ap_private<_AP_W,false> mask(-1);
       mask>>=_AP_W-(h_index-l_index+1);
       val&=mask;
     }
   }
      }
      return val;
    }


  inline ap_private<_AP_W,false> get()
  {
    ap_private<_AP_W,false> val(0);
    if(h_index<l_index) {
      for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
 if((d_bv)[j]) val.set(i);
    } else {
      val=d_bv;
      val>>=l_index;
      if(h_index<_AP_W-1)
 {
   if (_AP_W <= 64 ) {
     static const uint64_t mask = ~0ULL>> (64>_AP_W ? (64-_AP_W):0);
     return val &= ( (mask) >> (_AP_W - (h_index-l_index+1)));
   } else {
     ap_private<_AP_W,false> mask(-1);
     mask>>=_AP_W-(h_index-l_index+1);
     val&=mask;
   }
 }
    }
    return val;
  }


    inline int length() const
    {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }


    inline int to_int() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }


    inline unsigned int to_uint() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }


    inline long to_long() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }


    inline unsigned long to_ulong() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }


    inline ap_slong to_int64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }


    inline ap_ulong to_uint64() const
    {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }

    inline std::string to_string(uint8_t radix=2) const {
        return get().to_string(radix);
    }

    inline bool and_reduce() {
        bool ret = true;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret &= d_bv[i];
        return ret;
    }

    inline bool or_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret |= d_bv[i];
        return ret;
    }

    inline bool xor_reduce() {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i)
            ret ^= d_bv[i];
        return ret;
    }
};






template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



    ap_private<_AP_W,_AP_S>& d_bv;
    int d_index;

public:
    inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref):
            d_bv(ref.d_bv), d_index(ref.d_index) {}

    inline ap_bit_ref(ap_private<_AP_W,_AP_S>& bv, int index=0):
        d_bv(bv),d_index(index)
    {
        if (d_index < 0 )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);


    }


    inline operator bool () const
    {
      return d_bv.get_bit(d_index);
    }


    inline bool to_bool() const
    {
        return operator bool ();
    }


    inline ap_bit_ref& operator = (unsigned long long val)
    {
        if(val)
            d_bv.set(d_index);
        else
            d_bv.clear(d_index);
        return *this;
    }
#972 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(val != 0));
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }

    inline ap_bit_ref& operator =(const ap_bit_ref<_AP_W,_AP_S>& val)
    {
        return operator =((unsigned long long)(bool)val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_bit_ref& operator =(const ap_range_ref<_AP_W2,_AP_S2>& val)
    {
        return operator =((unsigned long long)(bool) val);
    }


    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_bit_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }



    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >
    operator , (ap_private<_AP_W2, _AP_S2>& a2)
     {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_private<_AP_W2,_AP_S2> >(*this, a2);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >(*this,
                    const_cast<ap_range_ref<_AP_W2, _AP_S2> &>(a2));
    }


    template<int _AP_W2, bool _AP_S2>
    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
                    const_cast<ap_bit_ref<_AP_W2, _AP_S2> &>(a2));
    }


    inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >
    operator, (const ap_bit_ref &a2)
    {
        return
            ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref >(*this,
                const_cast<ap_bit_ref&>(a2));
    }


    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, ap_bit_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >
    operator, (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &a2)
    {
        return
            ap_concat_ref<1,ap_bit_ref,_AP_W2+_AP_W3,
                    ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >(*this,
                    const_cast<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline
    ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() == op.get();
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() != op.get();
    }


    inline bool get() const
    {
        return operator bool ();
    }


    inline bool get()
    {
        return operator bool ();
    }


    template <int _AP_W3>
    inline void set(const ap_private<_AP_W3, false>& val)
    {
        operator = (val);
    }

    inline bool operator ~ () const {
        bool bit = (d_bv)[d_index];
        return bit ? false : true;
    }

    inline int length() const { return 1; }

    inline std::string to_string() const {
        bool val = get();
        return val ? "1" : "0";
    }
};
#1147 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator + (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; }
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (PTR_TYPE* i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator - (const ap_private<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#1172 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline float operator * (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline float operator * (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline float operator / (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline float operator / (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline float operator + (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline float operator + (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline float operator - (float i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline float operator - (const ap_private<_AP_W,_AP_S> &op, float i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
template<int _AP_W, bool _AP_S> inline double operator * (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline double operator * (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 * i_op; } template<int _AP_W, bool _AP_S> inline double operator / (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline double operator / (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 / i_op; } template<int _AP_W, bool _AP_S> inline double operator + (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline double operator + (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 + i_op; } template<int _AP_W, bool _AP_S> inline double operator - (double i_op, const ap_private<_AP_W,_AP_S> &op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline double operator - (const ap_private<_AP_W,_AP_S> &op, double i_op) { typename ap_private<_AP_W,_AP_S>::ValType op2 = op; return op2 - i_op; }
#1271 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mult operator * ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator * (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::plus operator + ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator + (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::minus operator - ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator - (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::div operator / ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator / (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::mod operator % ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator % (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator & ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator & (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator | ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator | (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( bool i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<1,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator ^ (ap_private<1,false>(i_op)); } template<int _AP_W, bool _AP_S> bool operator >> ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> bool operator << ( bool i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, bool i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator == (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator != (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator > (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator >= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator < (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator <= (ap_private<1, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<1,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator += (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator -= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator *= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator /= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator %= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator &= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator |= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, bool op2) { return op.operator ^= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, bool op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::mult operator * ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator * (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::plus operator + ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator + (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::minus operator - ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator - (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::div operator / ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::div operator / ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator / (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::mod operator % ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator % (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator & ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator & (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator | ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator | (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,(-128) != 0>::template RType<_AP_W,_AP_S>::logic operator ^ ( char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator ^ (ap_private<8,(-128) != 0>(i_op)); } template<int _AP_W, bool _AP_S> char operator >> ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> char operator << ( char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,(-128) != 0>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator == (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator != (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator > (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator >= (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator < (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator <= (ap_private<8, (-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator += (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator -= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator *= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator /= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator %= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator &= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator |= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, char op2) { return op.operator ^= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mult operator * ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator * (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::plus operator + ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator + (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::minus operator - ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator - (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::div operator / ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator / (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::mod operator % ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator % (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator & ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator & (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator | ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator | (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( signed char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator ^ (ap_private<8,true>(i_op)); } template<int _AP_W, bool _AP_S> signed char operator >> ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> signed char operator << ( signed char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, signed char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator == (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator != (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator > (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator >= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator < (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator <= (ap_private<8, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator += (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator -= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator *= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator /= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator %= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator &= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator |= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { return op.operator ^= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, signed char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator * (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator + (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator - (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator / (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator % (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator & (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator | (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned char i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<8,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator ^ (ap_private<8,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned char operator >> ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned char operator << ( unsigned char i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<8,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned char i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator == (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator != (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator > (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator < (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <= (ap_private<8, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<8,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator += (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator -= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator *= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator /= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator %= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator &= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator |= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator ^= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned char op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mult operator * ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator * (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::plus operator + ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator + (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::minus operator - ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator - (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::div operator / ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator / (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::mod operator % ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator % (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator & ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator & (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator | ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator | (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator ^ (ap_private<16,true>(i_op)); } template<int _AP_W, bool _AP_S> short operator >> ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> short operator << ( short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator == (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator != (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator > (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator >= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator < (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator <= (ap_private<16, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator += (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator -= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator *= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator /= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator %= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator &= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator |= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, short op2) { return op.operator ^= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator * (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator + (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator - (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator / (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator % (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator & (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator | (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned short i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<16,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator ^ (ap_private<16,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned short operator >> ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned short operator << ( unsigned short i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<16,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned short i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator == (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator != (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator > (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator < (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <= (ap_private<16, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<16,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator += (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator -= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator *= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator /= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator %= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator &= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator |= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator ^= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned short op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator * (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator + (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator - (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::div operator / ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator / (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator % (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator & (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator | (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator ^ (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> int operator >> ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> int operator << ( int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator == (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator != (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator > (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator >= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator < (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator <= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator += (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator -= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator *= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator /= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator %= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator &= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator |= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, int op2) { return op.operator ^= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, int op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator * (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator + (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator - (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator / (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator % (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator & (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator | (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned int i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator ^ (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned int operator >> ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned int operator << ( unsigned int i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned int i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator == (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator != (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator > (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator < (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator += (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator -= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator *= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator /= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator %= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator &= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator |= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator ^= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned int op2) { op = op.operator << (op2); return op; }




template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mult operator * ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator * (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::plus operator + ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator + (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::minus operator - ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator - (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::div operator / ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator / (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::mod operator % ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator % (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator & ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator & (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator | ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator | (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator ^ (ap_private<32,true>(i_op)); } template<int _AP_W, bool _AP_S> long operator >> ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> long operator << ( long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator == (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator != (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator > (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator >= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator < (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator <= (ap_private<32, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator += (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator -= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator *= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator /= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator %= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator &= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator |= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, long op2) { return op.operator ^= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, long op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mult operator * ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator * (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::plus operator + ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator + (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::minus operator - ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator - (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::div operator / ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator / (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::mod operator % ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator % (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator & ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator & (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator | ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator | (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( unsigned long i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<32,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator ^ (ap_private<32,false>(i_op)); } template<int _AP_W, bool _AP_S> unsigned long operator >> ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> unsigned long operator << ( unsigned long i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<32,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, unsigned long i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator == (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator != (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator > (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator < (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <= (ap_private<32, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<32,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator += (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator -= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator *= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator /= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator %= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator &= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator |= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator ^= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, unsigned long op2) { op = op.operator << (op2); return op; }

template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mult operator * ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator * (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::plus operator + ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator + (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::minus operator - ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator - (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::div operator / ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator / (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::mod operator % ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator % (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator & ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator & (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator | ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator | (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,true>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_slong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,true>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator ^ (ap_private<64,true>(i_op)); } template<int _AP_W, bool _AP_S> ap_slong operator >> ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_slong operator << ( ap_slong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,true>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_slong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator == (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator != (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator > (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator < (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <= (ap_private<64, true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,true>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator += (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator -= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator *= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator /= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator %= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator &= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator |= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator ^= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_slong op2) { op = op.operator << (op2); return op; }
template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mult operator * ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator * (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator * (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::plus operator + ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator + (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator + (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::minus operator - ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator - (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator - (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::div operator / ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator / (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator / (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::mod operator % ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator % (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator % (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator & ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator & (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator & (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator | ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator | (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator | (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64,false>::template RType<_AP_W,_AP_S>::logic operator ^ ( ap_ulong i_op, const ap_private<_AP_W,_AP_S> &op) { return ap_private<64,false>(i_op).operator ^ (op); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator ^ (ap_private<64,false>(i_op)); } template<int _AP_W, bool _AP_S> ap_ulong operator >> ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op >> (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator >> ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator >> (i_op); } template<int _AP_W, bool _AP_S> ap_ulong operator << ( ap_ulong i_op, const ap_private<_AP_W,_AP_S, false> &op) { return i_op << (op.get_VAL()); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W,_AP_S>::template RType<64,false>::arg1 operator << ( const ap_private<_AP_W,_AP_S> &op, ap_ulong i_op) { return op.operator << (i_op); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator == (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator == (op); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator != (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator != (op); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator > (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator > (op); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator >= (op); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator < (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator < (op); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <= (ap_private<64, false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_private<_AP_W,_AP_S, false> &op) { return ap_private<64,false>(op2).operator <= (op); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator += ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator += (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator -= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator -= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator *= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator *= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator /= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator /= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator %= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator %= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator &= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator &= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator |= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator |= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator ^= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator ^= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator >>= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator >> (op2); return op; } template<int _AP_W, bool _AP_S> inline ap_private<_AP_W,_AP_S> &operator <<= ( ap_private<_AP_W,_AP_S> &op, ap_ulong op2) { op = op.operator << (op2); return op; }
#1325 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator += (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator -= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator *= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator /= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator %= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator >>= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator <<= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator &= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator |= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1,_AP_S1>& operator ^= (ap_range_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (op2.operator ap_private<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (op2.operator ap_private<_AP_W2, false>()); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<_AP_W2, false>(op2)); }
#1390 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator += ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator += ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator -= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator -= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator *= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator *= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator /= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator /= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator %= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator %= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator >>= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator >>= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator <<= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator <<= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator &= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator &= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator |= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator |= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1,_AP_S1>& operator ^= ( ap_private<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_private<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1,_AP_S1>& operator ^= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_private<_AP_W2,_AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (ap_private<1, false>(op2)); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::plus operator + ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator + (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::minus operator - ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator - (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mult operator * ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator * (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::div operator / ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator / (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::mod operator % ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator % (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator >> ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >> (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator << ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator << (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator & ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator & (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator | ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator | (ap_private<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_bit_ref<_AP_W1,_AP_S1>& op1, const ap_private<_AP_W2,_AP_S2>& op2) { return ap_private<1, false>(op1).operator ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1,_AP_S1>::template RType<1,false>::logic operator ^ ( const ap_private<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^ (ap_private<1, false>(op2)); }
#1453 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( bool op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,(-128) != 0>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( signed char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned char op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned short op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned int op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }




template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( unsigned long op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }

template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_slong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline bool operator > ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator > ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline bool operator < ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator < ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline bool operator >= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline bool operator <= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <= ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline bool operator == ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator == ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W + _AP_W1, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline bool operator != ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_private<_AP_W + _AP_W1, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator != ( ap_ulong op2, const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W + _AP_W1, false>(op)); }
#1495 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::plus operator + ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::minus operator - ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mult operator * ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::div operator / ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::mod operator % ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator >> ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::arg1 operator << ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator & ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator | ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<1,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<1, false>::template RType<_AP_W,false>::logic operator ^ ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<1,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::plus operator + ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::minus operator - ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::mult operator * ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::div operator / ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::mod operator % ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::arg1 operator >> ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::arg1 operator << ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator & ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator | ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,(-128) != 0>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,(-128) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, (-128) != 0>::template RType<_AP_W,false>::logic operator ^ ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,(-128) != 0>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::plus operator + ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::minus operator - ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mult operator * ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::div operator / ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::mod operator % ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator >> ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::arg1 operator << ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator & ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator | ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, true>::template RType<_AP_W,false>::logic operator ^ ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::plus operator + ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::minus operator - ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mult operator * ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::div operator / ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::mod operator % ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator & ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator | ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<8,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<8, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<8,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::plus operator + ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::minus operator - ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mult operator * ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::div operator / ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::mod operator % ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator >> ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::arg1 operator << ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator & ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator | ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, true>::template RType<_AP_W,false>::logic operator ^ ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::plus operator + ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::minus operator - ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mult operator * ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::div operator / ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::mod operator % ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator & ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator | ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<16,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<16, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<16,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::plus operator + ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::minus operator - ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mult operator * ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::div operator / ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mod operator % ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator >> ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator << ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator & ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator | ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator ^ ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::plus operator + ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::minus operator - ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mult operator * ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::div operator / ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mod operator % ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator & ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator | ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }




template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::plus operator + ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::minus operator - ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mult operator * ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::div operator / ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::mod operator % ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator >> ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::arg1 operator << ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator & ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator | ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, true>::template RType<_AP_W,false>::logic operator ^ ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::plus operator + ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::minus operator - ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mult operator * ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::div operator / ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::mod operator % ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::arg1 operator << ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator & ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator | ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<32, false>::template RType<_AP_W,false>::logic operator ^ ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<32,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }

template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::plus operator + ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::minus operator - ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mult operator * ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::div operator / ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::mod operator % ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator >> ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::arg1 operator << ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator & ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator | ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, true>::template RType<_AP_W,false>::logic operator ^ ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,true>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator + (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::plus operator + ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator + (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator - (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::minus operator - ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator - (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator * (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mult operator * ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator * (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator / (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::div operator / ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator / (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator % (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::mod operator % ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator % (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >> (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator >> ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator >> (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator << (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::arg1 operator << ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator << (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator & (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator & ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator & (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator | (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator | ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator | (ap_private<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator ^ (ap_private<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline typename ap_private<64, false>::template RType<_AP_W,false>::logic operator ^ ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_private<64,false>(op2).operator ^ (ap_private<_AP_W, false>(op)); }
#1520 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator + (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator + (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator - (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator - (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator * (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator * (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator / (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator / (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator % (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator % (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >> (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator >> (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator << (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator << (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator & (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator & (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator | (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator | (ap_private<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^ (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_private<_AP_W,false>(lhs).operator ^ (ap_private<_AP_W2, false>(rhs)); }
#1672 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_private<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 1, false > operator, (bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<1 + 1, false > operator, (bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op2); ap_private<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 1, false > operator, (bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<1 + _AP_W + _AP_W2, false> val(op1); ap_private<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + _AP_W, false> val(op2); ap_private<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 1, false > operator, (bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + _AP_W, false> val(op1); ap_private<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_private<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 1, false> operator, (bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_private<8 + _AP_W + _AP_W2, (-128) != 0> val(op2); ap_private<8 + _AP_W + _AP_W2, (-128) != 0> ret(op1); if ((-128) != 0) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, (-128) != 0> val(op1); ap_private<8 + _AP_W + _AP_W2, (-128) != 0> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if ((-128) != 0) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_private<8 + 1, (-128) != 0> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, (-128) != 0> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op2); ap_private<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, true> val(op1); ap_private<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_private<8 + 1, true> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<8 + 1, false > operator, (unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op2); ap_private<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 8, false > operator, (unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<8 + _AP_W + _AP_W2, false> val(op1); ap_private<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + _AP_W, false> val(op2); ap_private<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 8, false > operator, (unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + _AP_W, false> val(op1); ap_private<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_private<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 8, false> operator, (unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op2); ap_private<16 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, true> val(op1); ap_private<16 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_private<16 + 1, true> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<16 + 1, false > operator, (unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op2); ap_private<16 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 16, false > operator, (unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<16 + _AP_W + _AP_W2, false> val(op1); ap_private<16 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + _AP_W, false> val(op2); ap_private<16 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 16, false > operator, (unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + _AP_W, false> val(op1); ap_private<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_private<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 16, false> operator, (unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op2); ap_private<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op1); ap_private<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_private<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op2); ap_private<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op1); ap_private<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }




template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op2); ap_private<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, true> val(op1); ap_private<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_private<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_private<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<32 + 1, false > operator, (unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op2); ap_private<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 32, false > operator, (unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<32 + _AP_W + _AP_W2, false> val(op1); ap_private<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<32 + _AP_W, false> val(op2); ap_private<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 32, false > operator, (unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + _AP_W, false> val(op1); ap_private<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_private<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 32, false> operator, (unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }

template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op2); ap_private<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, true> val(op1); ap_private<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_private<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_private<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_private<_AP_W, _AP_S>& op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline ap_private<64 + 1, false > operator, (ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op2); ap_private<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_private<_AP_W + _AP_W2 + 64, false > operator, (ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_private<64 + _AP_W + _AP_W2, false> val(op1); ap_private<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + _AP_W, false> val(op2); ap_private<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< _AP_W + 64, false > operator, (ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + _AP_W, false> val(op1); ap_private<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_private<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline ap_private< 1 + 64, false> operator, (ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_private<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#1698 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
#1719 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h"
template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_private<_AP_W,_AP_S> &op)
{
  ap_private<_AP_W, _AP_S> v=op;
    const std::ios_base::fmtflags basefield = out.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    std::string str=v.toString(radix,_AP_S);
    out<<str;
    return out;

}

template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_private<_AP_W,_AP_S> &op)
{
    std::string str;
    in >> str;
    const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
    unsigned radix = (basefield == std::ios_base::hex) ? 16 :
                     ((basefield == std::ios_base::oct) ? 8 : 10);
    op = ap_private<_AP_W, _AP_S>(str.c_str(), radix);
    return in;

}

template<int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& out, const ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator<<(out, ap_private<_AP_W, _AP_S>(op));
}

template<int _AP_W, bool _AP_S>
inline std::istream& operator >> (std::istream& in, ap_range_ref<_AP_W,_AP_S> &op)
{
    return operator>>(in, ap_private<_AP_W, _AP_S>(op));
}

template<int _AP_W, bool _AP_S>
inline void print(const ap_private<_AP_W,_AP_S> &op, bool fill=true )
{
    ap_private<_AP_W, _AP_S> v=op;
    uint32_t ws=v.getNumWords();
    const uint64_t *ptr=v.getRawData();
    int i=ws-1;

    if(_AP_W%64 != 0) {
        uint32_t offset=_AP_W%64;
        uint32_t count=(offset+3)/4;
        int64_t data=*(ptr+i);
        if(_AP_S)
            data=(data<<(64-offset))>>(64-offset);
        else
            count=(offset+4)/4;
        while(count-->0)



            printf("%llx",(data>>(count*4))&0xf);

    } else {
        if(_AP_S==false)
            printf("0");




        printf("%016llx",*(ptr+i));

    }
    for(--i;i>=0;i--)



        printf("%016llx",*(ptr+i));

    printf("\n");

}
#75 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_int.h" 2
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h" 1
#75 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_int_sim.h" 1
#76 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h" 2
#93 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_bit_ref {



    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& d_bv;
    int d_index;
public:
    inline af_bit_ref(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), d_index(ref.d_index) {
        if (d_index < 0 )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", d_index);
        if (d_index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W);


    }

    inline af_bit_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>* bv, int index=0):
    d_bv(*bv),d_index(index) {}

    inline operator bool() const {
        return d_bv.V[d_index];
    }

    inline af_bit_ref& operator=(unsigned long long val) {
        if(val)
            d_bv.V.set(d_index);
        else
            d_bv.V.clear(d_index);
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
        return operator=(val!=0);
    }

    inline af_bit_ref& operator =(const af_bit_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        return operator=((unsigned long long)(bool)val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref operator=(const af_bit_ref<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_bit_ref<_AP_W2, _AP_S2> &val) {
        return operator =((unsigned long long) (bool) val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator =((const ap_private<_AP_W2, false>) val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_private<_AP_W2, false>)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline af_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_private<_AP_W2 + _AP_W3, false>)(val));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2> >(*this, const_cast<af_range_ref<_AP_W2, _AP_I2,
             _AP_S2, _AP_Q2, _AP_O2,_AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
              _AP_O2, _AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() == op.get();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() != op.get();
    }

    inline bool operator ~ () const {
        bool bit = (d_bv.V)[d_index];
        return bit ? false : true;
    }

    inline int length() const {
        return 1;
    }

    inline bool get() {
        return d_bv.V[d_index];
    }

    inline bool get() const {
        return d_bv.V[d_index];
    }

    inline std::string to_string() const {
        return d_bv.V[d_index] ? "1" : "0";
    }
};



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_range_ref {



    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &d_bv;
    int l_index;
    int h_index;

public:
    inline af_range_ref(const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& ref):
           d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline af_range_ref(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>* bv, int h, int l):
        d_bv(*bv),l_index(l),h_index(h) {
        if (h < 0 || l < 0)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) and lower bound (%d) cannot be negative.\n", h, l);
        if (h >= _AP_W || l >= _AP_W)
     fprintf((&_iob[2]), "Warning! Higher bound (%d) or lower bound (%d) out of range (%d).\n", h, l, _AP_W);





    }

    inline operator ap_private<_AP_W, false> () const {
        if(h_index >= l_index) {
          ap_private<_AP_W, false> val(d_bv.V);
          ap_private<_AP_W,false> mask(-1);
          mask>>=_AP_W-(h_index-l_index+1);
          val>>=l_index;
          return val&=mask;
        } else {
          ap_private<_AP_W, false> val = 0;
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        }
    }

    inline operator unsigned long long() const {
        return get().to_uint64();
    }

    template<int _AP_W2,bool _AP_S2>
    inline af_range_ref& operator =(const ap_private<_AP_W2,_AP_S2>& val) {
      ap_private<_AP_W, false> vval= ap_private<_AP_W, false>(val);
        if(l_index > h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,false> mask(-1);
            if(l_index>0) {
                mask<<=l_index;
                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
              ap_private<_AP_W,false> mask2(-1);
              mask2>>=_AP_W-h_index-1;
              mask&=mask2;
              vval&=mask2;
            }
            mask.flip();
            d_bv.V &= mask;
            d_bv.V |= vval;
        }
        return *this;
    }





inline af_range_ref& operator = (const char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const signed char val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned short val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned int val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }
inline af_range_ref& operator = (const unsigned long long val) { const ap_private<_AP_W, false> tmpVal(val); return operator = (tmpVal); }


    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline af_range_ref& operator =
        (const ap_concat_ref <_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template <int _AP_W3, bool _AP_S3>
    inline af_range_ref& operator =(const ap_range_ref<_AP_W3,_AP_S3>& val) {
        const ap_private<_AP_W, false> tmpVal(val);
        return operator =(tmpVal);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        const ap_private<_AP_W2, false> tmp= val.get();
        return operator = (tmp);
    }

    inline af_range_ref& operator= (const char* val) {
        const ap_private<_AP_W, false> tmp(val);
        return operator = (tmp);
    }

    inline af_range_ref& operator= (const af_range_ref<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& val) {
        const ap_private<_AP_W, false> tmp= val.get();
        return operator = (tmp);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline af_range_ref& operator= (const ap_fixed_base<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_private());
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs==rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs!=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs>=rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<rhs;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_private<_AP_W,false> lhs=get();
        ap_private<_AP_W2,false> rhs=op2.get();
        return lhs<=rhs;
    }

    template<int _AP_W2>
    inline void set(const ap_private<_AP_W2,false>& val) {
        ap_private<_AP_W,_AP_S> vval=val;
        if(l_index>h_index) {
            for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
                    vval[i]? d_bv.V.set(j):d_bv.V.clear(j);
        } else {
          ap_private<_AP_W,_AP_S> mask(-1);
            if(l_index>0) {
                ap_private<_AP_W,false> mask1(-1);
                mask1>>=_AP_W-l_index;
                mask1.flip();
                mask=mask1;

                vval<<=l_index;
            }
            if(h_index<_AP_W-1) {
                ap_private<_AP_W,false> mask2(-1);
                mask2<<=h_index+1;
                mask2.flip();
                mask&=mask2;
                vval&=mask2;
            }
            mask.flip();
            d_bv&=mask;
            d_bv|=vval;
        }

    }

    inline ap_private<_AP_W,false> get() const {
        if(h_index<l_index) {
          ap_private<_AP_W, false> val(0);
          for(int i=0, j=l_index;j>=0&&j>=h_index;j--,i++)
            if((d_bv.V)[j]) val.set(i);
          return val;
        } else {
          ap_private<_AP_W, false> val = ap_private<_AP_W,false>(d_bv.V);
          val>>= l_index;
          if(h_index<_AP_W-1)
            {
              ap_private<_AP_W,false> mask(-1);
              mask>>=_AP_W-(h_index-l_index+1);
              val&=mask;
            }
          return val;
        }
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_private<_AP_W2, _AP_S2> >
    operator, (ap_private<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_private<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3,
                  _AP_T3>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
             _AP_N2>& > (op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }

    inline int length() const {
        return h_index>=l_index?h_index-l_index+1:l_index-h_index+1;
    }

    inline int to_int() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int();
    }

    inline unsigned int to_uint() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint();
    }

    inline long to_long() const {
        ap_private<_AP_W,false> val=get();
        return val.to_long();
    }

    inline unsigned long to_ulong() const {
        ap_private<_AP_W,false> val=get();
        return val.to_ulong();
    }

    inline ap_slong to_int64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_int64();
    }

    inline ap_ulong to_uint64() const {
        ap_private<_AP_W,false> val=get();
        return val.to_uint64();
    }

    inline std::string to_string(uint8_t radix) const {
        return get().to_string(radix);
    }

};



template<int _AP_W, int _AP_I, bool _AP_S=true, ap_q_mode _AP_Q=AP_TRN,
         ap_o_mode _AP_O=AP_WRAP, int _AP_N=0>
struct ap_fixed_base {



private:

    inline ap_fixed_base(const std::string& val) {


        fromString(val);





    }

    void fromString(const std::string& val) {
        int radix = 10;

        std::string s = ap_private_ops::parseString(val, radix);

        fromString(s, radix);
    }

    void fromString(const std::string& val, unsigned char radix) {
        ((radix == 2 || radix == 8 || radix == 10 || radix == 16) ? (void)0 : _assert("radix == 2 || radix == 8 || radix == 10 || radix == 16", "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h", 653));
        V = 0;
        int startPos = 0;
        int endPos = val.length();
        int decPos = val.find(".");
        if (decPos == -1)
            decPos = endPos;
        bool isNegative = false;
        if (val[0] == '-') {
            isNegative = true;
            ++startPos;
        } else if (val[0] == '+')
            ++startPos;
#688 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
        ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4))+4, ((_AP_I) > (4) ? (_AP_I) : (4))+4, false> integer_bits = 0;


        uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);




        bool sticky_int = false;


        for (int i = startPos; i < decPos; i++) {

            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);

            sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 1] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 2] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 4];

            if (shift)
                integer_bits <<= shift;
            else
                integer_bits *= radix;


            integer_bits += digit;

        }
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] = integer_bits[((_AP_I) > (4) ? (_AP_I) : (4))+4 - 3] | sticky_int;

        ap_fixed_base<((_AP_W-_AP_I) > (0) ? (_AP_W-_AP_I) : (0))+4+4, 4, false> fractional_bits = 0;
        bool sticky = false;


        for (int i = endPos-1; i >= decPos+1; i--) {

            char cdigit = val[i];
            if (cdigit == '\0') continue;
            uint32_t digit = ap_private_ops::decode_digit(cdigit, radix);

            fractional_bits += digit;

            sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] | fractional_bits[3];

            if (shift)
                fractional_bits >>= shift;
            else
                fractional_bits /= radix;


        }



        fractional_bits[0] = fractional_bits[0] | sticky;

        if(isNegative)
            *this = -(integer_bits + fractional_bits);
        else
            *this = integer_bits + fractional_bits;


    }

    inline void report() {







        if (!_AP_S && _AP_O == AP_WRAP_SM) {
            fprintf((&_iob[2]), "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
            exit(1);
        }
        if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
            fprintf((&_iob[2]), "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
                   "default max value %d. Please use macro "
                   "AP_INT_MAX_W to set a larger max value.\n",
                            _AP_S?"":"u", _AP_W,
                            ((1024 + 1023) / 1024) * 1024);
            exit(1);
        }
    }


    inline unsigned long long doubleToRawBits(double pf)const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__D=pf;
        return LD.__L;
    }


    inline double rawBitsToDouble(unsigned long long pi) const {
        union {
            unsigned long long __L;
            double __D;
        }LD;
        LD.__L=pi;
        return LD.__D;
    }

    inline float rawBitsToFloat(uint32_t pi) const {
        union {
            uint32_t __L;
            float __D;
        }LD;
        LD.__L = pi;
        return LD.__D;
    }


public:
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
ap_fixed_base;
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> friend struct
af_bit_ref;

    inline void overflow_adjust(bool underflow, bool overflow,
                                bool lD, bool sign) {
        if (!overflow && !underflow) return;
        switch (_AP_O) {
            case AP_WRAP:
                if (_AP_N == 0)
                    return;
                if (_AP_S) {


                    if (_AP_N > 1) {
                        ap_private<_AP_W, _AP_S> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= ~mask;
                    }
                    sign ? V.set(_AP_W - 1) : V.clear(_AP_W - 1);
                } else {

                    ap_private<_AP_W, _AP_S> mask(-1);
                    if (_AP_N >= _AP_W) mask = 0;
                    else mask.lshr(_AP_N);
                    mask.flip();
                    V |= mask;
                }
                break;
            case AP_SAT_ZERO:
                V.clear();
                break;
            case AP_WRAP_SM:
                {
                bool Ro = ap_private_ops::get<_AP_W, _AP_S, _AP_W -1>(V);
                if (_AP_N == 0) {
                    if (lD != Ro) {
                        V.flip();
                        lD ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) :
                            ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                } else {
                    if (_AP_N == 1 && sign != Ro) {
                        V.flip();
                    } else if (_AP_N > 1) {
                        bool lNo = ap_private_ops::get<_AP_W, _AP_S, _AP_W - _AP_N> (V);
                        if (lNo == sign)
                            V.flip();
                        ap_private<_AP_W, false> mask(-1);
                        if (_AP_N >= _AP_W) mask = 0;
                        else mask.lshr(_AP_N);
                        if (sign)
                            V &= mask;
                        else
                            V |= mask.flip();
                        sign ? ap_private_ops::set<_AP_W, _AP_S, _AP_W - 1>(V) : ap_private_ops::clear<_AP_W, _AP_S, _AP_W - 1>(V);
                    }
                }
                }
                break;
            default:
                if (_AP_S) {
                    if (overflow) {
                        V.set(); ap_private_ops::clear<_AP_W, _AP_S, _AP_W-1>(V);
                    } else if (underflow) {
                        V.clear();
                        ap_private_ops::set<_AP_W, _AP_S, _AP_W-1>(V);
                        if(_AP_O == AP_SAT_SYM)
                            ap_private_ops::set<_AP_W, _AP_S, 0>(V);
                    }
                } else {
                    if (overflow)
                        V.set();
                    else if (underflow)
                        V.clear();
                }
        }
    }

    inline bool quantization_adjust(bool qb, bool r, bool s) {
        bool carry=ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V);
        switch (_AP_Q) {
            case AP_TRN:
                return false;
            case AP_RND_ZERO:
                qb &= s || r;
                break;
            case AP_RND_MIN_INF:
                qb &= r;
                break;
            case AP_RND_INF:
                qb &= !s || r;
                break;
            case AP_RND_CONV:
                qb &= ap_private_ops::get<_AP_W, _AP_S, 0>(V) || r;
                break;
            case AP_TRN_ZERO:
                qb = s && ( qb || r );
                break;
            default:;

        }
        if(qb) ++V;

        return carry && !(ap_private_ops::get<_AP_W, _AP_S, _AP_W-1>(V));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2>
    struct RType {
        enum {
            _AP_F=_AP_W-_AP_I,
            F2=_AP_W2-_AP_I2,
            mult_w = _AP_W+_AP_W2,
            mult_i = _AP_I+_AP_I2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            plus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            minus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,

            div_w = _AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)) + _AP_S2,



            div_i = _AP_I + (_AP_W2-_AP_I2) + _AP_S2,
            div_s = _AP_S||_AP_S2,
            logic_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            logic_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };

        typedef ap_fixed_base<mult_w, mult_i, mult_s> mult;
        typedef ap_fixed_base<plus_w, plus_i, plus_s> plus;
        typedef ap_fixed_base<minus_w, minus_i, minus_s> minus;
        typedef ap_fixed_base<logic_w, logic_i, logic_s> logic;
        typedef ap_fixed_base<div_w, div_i, div_s> div;
        typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1;
    };
#961 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base() {}



    inline ap_fixed_base(const ap_fixed_base& op):V(op.V) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op):V(0) {
        enum {N2=_AP_W2,_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2,QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN ||
                (_AP_Q==AP_TRN_ZERO && !_AP_S2))};
        if (!op) return;
        bool carry=false;

        enum { sh_amt =(F2>_AP_F)?F2-_AP_F:_AP_F-F2};
        const ap_private<_AP_W2, _AP_S2>& val = op.V;
        bool neg_src=val.isNegative();
        if (F2==_AP_F)
            V=val;

        else if (F2>_AP_F) {
            if (sh_amt >= _AP_W2)
                V = neg_src ? -1 : 0;
            else
                V = _AP_S2?val.ashr(sh_amt):val.lshr(sh_amt);
            if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                bool qb = false;
                if (F2-_AP_F>_AP_W2)
                    qb = neg_src;
                else
                    qb = ap_private_ops::get<_AP_W2, _AP_S2, F2-_AP_F-1>(val);

                bool r=false;
                enum { pos3 = F2-_AP_F-2};
                if(pos3>=_AP_W2-1)
                    r=val!=0;
                else if (pos3>=0)
                r = (val<<(_AP_W2-1-pos3))!=0;
                carry = quantization_adjust(qb,r,neg_src);
            }
        } else {
            if (sh_amt < _AP_W) {
                V=val;
                V <<= sh_amt;
            }
        }

        if ((_AP_O!=AP_WRAP || _AP_N != 0) &&
                ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                 _AP_I2 - _AP_S2 + (QUAN_INC|| (_AP_S2 &&
                     _AP_O==AP_SAT_SYM)))) {
            bool deleted_zeros = _AP_S2?true:!carry,
                 deleted_ones = true;
            bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                ap_private_ops::get<_AP_W2, _AP_S2, _AP_W2-_AP_I2+_AP_I>(val);
            enum { pos1=F2-_AP_F+_AP_W, pos2=F2-_AP_F+_AP_W+1};
            if (pos1 < _AP_W2) {
                bool Range1_all_ones= true;
                bool Range1_all_zeros= true;
                if (pos1 >= 0) {
                    enum { __W = (_AP_W2-pos1) > 0 ? (_AP_W2-pos1) : 1 };
                    const ap_private<__W, _AP_S2> Range1=ap_private<__W, _AP_S2>(val.lshr(pos1));
                    Range1_all_ones=Range1.isAllOnesValue();
                    Range1_all_zeros=Range1.isMinValue();
                } else {
                    Range1_all_ones=false;
                    Range1_all_zeros=val.isMinValue();
                }
                bool Range2_all_ones=true;
                if (pos2<_AP_W2 && pos2>=0) {
                    enum { __W = (_AP_W2-pos2)>0 ? (_AP_W2-pos2) : 1};
                    ap_private<__W, true> Range2=ap_private<__W, true>(val.lshr(pos2));
                    Range2_all_ones=Range2.isAllOnesValue();
                } else if(pos2<0)
                    Range2_all_ones=false;

                deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD)
                    :Range1_all_ones;
                neg_src= neg_src&&!(carry && Range1_all_ones);
            } else
                neg_src = neg_src && V[_AP_W-1];

            bool neg_trg= V.isNegative();
            bool overflow=(neg_trg||!deleted_zeros) && !val.isNegative();
            bool underflow=(!neg_trg||!deleted_ones)&&neg_src;



            if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
            overflow_adjust(underflow, overflow, lD, neg_src);
        }
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const volatile ap_fixed_base<_AP_W2,_AP_I2,
                _AP_S2,_AP_Q2,_AP_O2, _AP_N2> &op) : V(op.V) {
        *this = const_cast<ap_fixed_base<_AP_W2,_AP_I2,
        _AP_S2,_AP_Q2,_AP_O2, _AP_N2>&>(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_private<_AP_W2,_AP_S2>& op) {
        ap_fixed_base<_AP_W2,_AP_W2,_AP_S2> f_op;
        f_op.V=op;
        *this = f_op;
    }

    inline ap_fixed_base(bool b) {
        *this=(ap_private<1,false>)b;
        report();
    }

    inline ap_fixed_base(char b) {
        *this=(ap_private<8,false>)b;
        report();
    }

    inline ap_fixed_base(signed char b) {
        *this=(ap_private<8,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned char b) {
        *this=(ap_private<8,false>)b;
        report();
    }

    inline ap_fixed_base(signed short b) {
        *this=(ap_private<16,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned short b) {
        *this=(ap_private<16,false>)b;
        report();
    }

    inline ap_fixed_base(signed int b) {
        *this=(ap_private<32,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned int b) {
        *this=(ap_private<32,false>)b;
        report();
    }
#1119 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    inline ap_fixed_base(signed long b) {
        *this=(ap_private<32,true>)b;
        report();
    }

    inline ap_fixed_base(unsigned long b) {
        *this=(ap_private<32,false>)b;
        report();
    }


    inline ap_fixed_base(ap_slong b) {
        *this=(ap_private<64,true>)b;
        report();
    }

    inline ap_fixed_base(ap_ulong b) {
        *this=(ap_private<64,false>)b;
        report();
    }





    inline ap_fixed_base(const char* val):V(0) {


        fromString(val);




    }

    inline ap_fixed_base(const char* val, signed char radix): V(0) {




        ap_private<_AP_W, _AP_S> Tmp(val, radix);
        V = Tmp;

    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        *this = ((bool)op);
        report();
    }

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
        *this = ap_private<_AP_W2, _AP_S2>(op);
        report();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        *this = ((const ap_private<_AP_W2 + _AP_W3, false>&)(op));
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
         *this = (bool(op));
        report();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        *this = (ap_private<_AP_W2, false>(op));
        report();
    }

    inline ap_fixed_base(double d):V(0) {
        if(!d) return;
        const bool isneg=d<0;

        const uint64_t ireg=doubleToRawBits(isneg?-d:d);
        if((ireg&0x7fffffffffffffffULL)!=0) {
            const int32_t exp=(((ireg)>>52)&0x07ff)-((1ULL<<(11 -1))-1);
            ap_private<52 +2, true> man = ireg & 0x3fffffffffffffULL;

            if (exp == ((1ULL<<(11 -1))-1) + 1 &&
                man.range(52 - 1, 0) != 0) {

                fprintf((&_iob[2]), "[E] ap_%sfixed<%d, ...>: trying to "
                   "assign NaN to fixed point value.\n",
                            _AP_S?"":"u", _AP_W);
                exit(1);
            }
            man.clear(52 +1);
            man.set(52);
            if(isneg) {
                man.flip();
                man++;
            }

            enum {_AP_S2=true, _AP_W2=52 +2,_AP_F=_AP_W -_AP_I };
            const int _AP_I2=exp+2;
            const int F2=_AP_W2-_AP_I2;
            const bool QUAN_INC=F2>_AP_F && !(_AP_Q==AP_TRN || (_AP_Q==AP_TRN_ZERO &&
                    !_AP_S2));
            bool carry=false;

            const unsigned sh_amt=abs(F2-_AP_F);
            if (F2==_AP_F )
                V=man;
            else if (F2>_AP_F) {
                if(sh_amt >= 52 +2)
                    V=isneg?-1:0;
                else
                    V= ap_private<52 +2, true>((man>>sh_amt) |
                       ((man & 1ULL<<(52 +1))?
                        (0x3fffffffffffffULL>>(52 +2-sh_amt)
                        <<(52 +2-sh_amt)):0));

                if (_AP_Q!=AP_TRN && !(_AP_Q==AP_TRN_ZERO && !_AP_S2)) {
                    const bool qb=((F2-_AP_F > 52 +2) ? isneg : (man & (1ULL<<(F2-_AP_F-1))) != 0);
                    const int pos3=F2-_AP_F-2;
                    const bool r = (pos3>= 0) ? (man << ((0) > (_AP_W2-pos3-1) ? (0) : (_AP_W2-pos3-1))& 0x3fffffffffffffULL)!=0 : false;
                    carry = quantization_adjust(qb,r,isneg);
                }
            }
            else {

                if (sh_amt < _AP_W) {
                    V = man;
                    V <<= sh_amt;
                }
            }

            if((_AP_O != AP_WRAP || _AP_N != 0) &&
                    ((!_AP_S && _AP_S2) || _AP_I-_AP_S <
                     _AP_I2-_AP_S2+(QUAN_INC|| (_AP_S2 &&
                         _AP_O==AP_SAT_SYM)) )) {
                bool deleted_zeros = _AP_S2?true:!carry,
                     deleted_ones = true;
                bool neg_src;
                const bool lD=(_AP_I2>_AP_I) && (_AP_W2-_AP_I2+_AP_I>=0) &&
                    (man & (1ULL <<(52 +2-_AP_I2+_AP_I)));
                int pos1=F2+_AP_W-_AP_F;
                if (pos1 < _AP_W2) {
                    int pos2=pos1+1;
                    bool Range1_all_ones=true;
                    bool Range1_all_zeros=true;
                    if (pos1>=0) {
                        ap_private<52 +2,_AP_S> Range1=
                            ap_private<52 +2,_AP_S>((man >> pos1) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos1) <<(52 +2-pos1)):0));
                        Range1_all_ones = Range1.isAllOnesValue();
                        Range1_all_zeros = Range1.isMinValue();
                    } else {
                        Range1_all_ones=false;
                        Range1_all_zeros = man==0;
                    }
                    bool Range2_all_ones=true;
                    if (pos2<_AP_W2 && pos2>=0) {
                        ap_private<52 +2, _AP_S> Range2=
                            ap_private<52 +2, _AP_S>((man >> pos2) | ((1ULL<<(52 +1)&man) ? (0x3fffffffffffffULL >> (52 +2-pos2) <<(52 +2-pos2)):0));
                        Range2_all_ones=Range2.isAllOnesValue();
                    } else if (pos2<0)
                        Range2_all_ones=false;
                    deleted_zeros=deleted_zeros && (carry?Range1_all_ones:Range1_all_zeros);
                    deleted_ones=carry?Range2_all_ones&&(F2-_AP_F+_AP_W<0||!lD) : Range1_all_ones;
                    neg_src=isneg&&!(carry&Range1_all_ones);
                } else
                    neg_src = isneg && V[_AP_W -1];

                const bool neg_trg=V.isNegative();
                const bool overflow=(neg_trg||!deleted_zeros) && !isneg;
                bool underflow=(!neg_trg||!deleted_ones)&&neg_src;




                if(_AP_O==AP_SAT_SYM && _AP_S2 && _AP_S)
                    underflow |= neg_src && (_AP_W>1?V.isMinSignedValue():true);
                overflow_adjust(underflow,overflow,lD, neg_src);
            }
        }
        report();
    }





    inline void operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }

    inline ap_fixed_base& operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }

    inline void operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        V = op.V;
    }

    inline ap_fixed_base& operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                    _AP_Q, _AP_O, _AP_N>& op) {
        V = op.V;
        return *this;
    }




    inline ap_fixed_base& setBits(unsigned long long bv) {
        V=bv;
        return *this;
    }



    static inline ap_fixed_base bitsToFixed(unsigned long long bv) {
        ap_fixed_base Tmp=bv;
        return Tmp;
    }



    inline ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S>
    to_ap_private(bool Cnative = true) const {
        ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ret = ap_private<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ((_AP_I >= 1) ? (_AP_S==true ? V.ashr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I))) : V.lshr(((0) > (_AP_W - _AP_I) ? (0) : (_AP_W - _AP_I)))) : ap_private<_AP_W, _AP_S>(0));

        if (Cnative) {
            bool r = false;
            if (_AP_I < _AP_W) {
                if (_AP_I > 0) r = !(V.getLoBits(_AP_W - _AP_I).isMinValue());
                else r = !(V.isMinValue());
            }
            if (r && V.isNegative()) {
                ++ret;
            }
        } else {

        }
        return ret;
    }

    template<int _AP_W2, bool _AP_S2>
    inline operator ap_private<_AP_W2,_AP_S2> () const {
        return (ap_private<_AP_W2,_AP_S2>)to_ap_private();
    }

    template<int _AP_W2, bool _AP_S2, int _AP_N2>
    inline operator ap_private<_AP_W2,_AP_S2,_AP_N2> () const {
        return (ap_private<_AP_W2,_AP_S2,_AP_N2>)to_ap_private();
    }


    inline int to_int() const {
        return to_ap_private().to_int();
    }

    inline int to_uint() const {
        return to_ap_private().to_uint();
    }

    inline ap_slong to_int64() const {
        return to_ap_private().to_int64();
    }

    inline ap_ulong to_uint64() const {
        return to_ap_private().to_uint64();
    }

    inline double to_double() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x8000000000000000ULL : 0;
        ap_private<_AP_W, false> tmp(V);
        if (isneg) tmp = ap_private<_AP_W, false>(-V);
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(11 -1))-1)))<<52;
        if(i!=0) {
            tmp.clear(i);
            uint64_t man = ((i>52)?tmp.lshr(i-52):tmp).to_uint64() & 0x3fffffffffffffULL;
            res |= i<52 ? (man)<<(52 -i)& 0x3fffffffffffffULL : man;
        }
        double dp=rawBitsToDouble(res);
        return dp;
    }

    inline float to_float() const {
        if(!V)
            return 0;
        bool isneg = _AP_S && V[_AP_W-1];
        uint64_t res = isneg ? 0x80000000ULL : 0;
        ap_private<_AP_W, false> tmp = V;
        if (isneg) tmp = -tmp;
        int i = _AP_W -1 - tmp.countLeadingZeros();
        int exp = _AP_I-(_AP_W-i);
        res|=((uint64_t)(exp+((1ULL<<(8 -1))-1)))<<23;
        if(i!=0) {
            tmp.clear(i);
            uint32_t man = ((i>23) ? tmp.lshr(i-23) : tmp).to_uint() & 0x7fffff;
            res |= i<23 ? (man)<<(23 -i)& 0x7fffff : man;
        }
        float dp=rawBitsToFloat(res);
        return dp;
    }

    inline operator long double () const {
        return to_double();
    }

    inline operator double () const {
        return to_double();
    }

    inline operator float () const {
           return to_float();
    }

    inline operator char () const {
        return (char) to_int();
    }

    inline operator signed char () const {
        return (signed char) to_int();
    }

    inline operator unsigned char () const {
        return (unsigned char) to_uint();
    }

    inline operator short () const {
        return (short) to_int();
    }

    inline operator unsigned short () const {
        return (unsigned short) to_uint();
    }

    inline operator int () const {
        return to_int();
    }

    inline operator unsigned int () const {
        return to_uint();
    }
#1481 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    inline operator long () const {
        return to_int64();
    }

    inline operator unsigned long () const {
        return to_uint64();
    }



    inline operator unsigned long long () const {
        return to_uint64();
    }

    inline operator long long () const {
        return to_int64();
    }


    inline std::string to_string(uint8_t radix=2, bool sign=_AP_S) const;

    inline ap_slong bits_to_int64() const {
      ap_private<((_AP_W) < (64) ? (_AP_W) : (64)), _AP_S> res(V);
        return (ap_slong) res;
    }

    inline ap_ulong bits_to_uint64() const {
      ap_private<((64) < (_AP_W) ? (64) : (_AP_W)), _AP_S> res(V);
      return (ap_ulong) res;
    }

    inline int length() const {return _AP_W;}




    inline int countLeadingZeros() {
        return V.countLeadingZeros();
    }



    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::mult
    operator * (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::mult r;
        r.V = V * op2.V;
        return r;
    }

    template<int _AP_W1, int _AP_I1, bool _AP_S1, int _AP_W2, int _AP_I2, bool _AP_S2>
    static inline ap_fixed_base multiply(const ap_fixed_base<_AP_W1,_AP_I1,_AP_S1>& op1, const
         ap_fixed_base<_AP_W2,_AP_I2,_AP_S2>& op2) {
        ap_private<_AP_W+_AP_W2, _AP_S> OP1=op1.V;
        ap_private<_AP_W2,_AP_S2> OP2=op2.V;
        return OP1*OP2;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline typename RType<_AP_W2,_AP_I2,_AP_S2>::div
    operator / (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
        ap_private<_W1, _AP_S||_AP_S2> dividend = (ap_private<_W1, _AP_S>(V)) << ((F2) > (0) ? (F2) : (0));
        ap_private<_W1, _AP_S||_AP_S2> divisior = ap_private<_W1, _AP_S2>(op2.V);
        typename RType<_AP_W2, _AP_I2, _AP_S2>::div r;
        r.V = ((_AP_S||_AP_S2) ? dividend.sdiv(divisior): dividend.udiv(divisior));
        return r;
    }
#1568 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::plus operator + (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::plus r, lhs(*this), rhs(op2); r.V = lhs.V.Add(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::plus operator + (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::plus r; r.V = V + op2.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::minus operator - (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { enum {_AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2}; typename RType<_AP_W2,_AP_I2,_AP_S2>::minus r, lhs(*this), rhs(op2); r.V = lhs.V.Sub(rhs.V); return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::minus operator - (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::minus r; r.V = V - op2.V; return r; }
#1591 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator & (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V & rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator & (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V & op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator &(int op2) const { return V & (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator | (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V | rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator | (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V | op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator |(int op2) const { return V | (op2<<(_AP_W - _AP_I)); }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator ^ (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); r.V=lhs.V ^ rhs.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^ (const ap_fixed_base& op2) const { typename RType<_AP_W,_AP_I,_AP_S>::logic r; r.V = V ^ op2.V; return r; } inline typename RType<_AP_W,_AP_I,_AP_S>::logic operator ^(int op2) const { return V ^ (op2<<(_AP_W - _AP_I)); }
#1605 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator += (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator + (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator - (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator & (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator | (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator ^ (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator * (op2) ; return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator / (op2) ; return *this; }



    inline ap_fixed_base& operator ++() {
        operator+=(ap_fixed_base<1,1,false>(1));
        return *this;
    }

    inline ap_fixed_base& operator --() {
        operator-=(ap_fixed_base<1,1,false>(1));
        return *this;
    }



    inline const ap_fixed_base operator ++(int) {
        ap_fixed_base t(*this);
        operator++();
        return t;
    }

    inline const ap_fixed_base operator --(int) {
        ap_fixed_base t = *this;
        operator--();
        return t;
    }



    inline ap_fixed_base operator +() {return *this;}

    inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator -() const {
        ap_fixed_base<_AP_W + 1, _AP_I + 1, true> Tmp(*this);
        Tmp.V = - Tmp.V;
        return Tmp;
    }

    inline ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> getNeg() {
        ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O, _AP_N> Tmp(*this);
        Tmp.V=-Tmp.V;
        return Tmp;
    }



    inline bool operator !() const {
        return !V;
    }



    inline ap_fixed_base<_AP_W, _AP_I, _AP_S>
         operator ~() const {
        ap_fixed_base<_AP_W, _AP_I, _AP_S> res(*this);
        res.V.flip();
        return res;
    }



    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift () const {
        ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }

    template<int _AP_SHIFT>
    inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift () const {
        ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
        r.V = V;
        return r;
    }






    inline ap_fixed_base operator << (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        bool NegSrc = V.isNegative();
        if(isNeg) {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        } else {
            if(shiftoverflow)
                r.V.clear();
            else
                r.V=V<<sh;
        }
#1738 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator<<(const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator << (sh);
    }

    inline ap_fixed_base operator << (unsigned int sh ) const {
        ap_fixed_base r;
        bool shiftoverflow = sh >= _AP_W;
        r.V = shiftoverflow ? ap_private<_AP_W, _AP_S >(0) : V << sh;
        if (sh == 0) return r;
#1773 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator << (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator << (sh);
    }

    inline ap_fixed_base operator >> (int sh) const {
        ap_fixed_base r;
        bool isNeg=(sh&0x80000000) != 0;
        bool NegSrc = V.isNegative();
        sh=isNeg?-sh:sh;
        bool shiftoverflow = sh >= _AP_W;
        if(isNeg && !shiftoverflow) r.V=V<<sh;
        else {
            if(shiftoverflow)
                NegSrc?r.V.set():r.V.clear();
            else
                r.V=_AP_S?V.ashr(sh):V.lshr(sh);
        }
#1825 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator >> (sh);
    }

    inline ap_fixed_base operator >> (unsigned int sh) const {
        ap_fixed_base r;
        bool NegSrc = V.isNegative();
        bool shiftoverflow = sh >= _AP_W;
        if(shiftoverflow)
            NegSrc?r.V.set():r.V.clear();
        else
            r.V=_AP_S?V.ashr(sh):V.lshr(sh);
#1855 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
        return r;
    }

    template<int _AP_W2>
    inline ap_fixed_base operator >> (const ap_private<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator >> (sh);
    }
#1874 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator <<=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, bool _AP_S2> inline ap_fixed_base& operator >>=(const ap_private<_AP_W2,_AP_S2>& op2) { *this=operator >> (op2); return *this; }
#1891 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator << (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator << (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator <<= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator << (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base operator >> (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { return operator >> (op2.to_ap_private()); } template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator >>= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) { *this=operator >> (op2); return *this; }

    inline ap_fixed_base& operator >>= (unsigned int sh) {
        *this = operator >> (sh);
        return *this;
    }

    inline ap_fixed_base& operator <<= (unsigned int sh) {
        *this = operator << (sh);
        return *this;
    }

    inline ap_fixed_base& operator >>= (int sh) {
        *this = operator >> (sh);
        return *this;
    }

    inline ap_fixed_base& operator <<= (int sh) {
        *this = operator << (sh);
        return *this;
    }



    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator == (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        return OP1 == OP2;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator != (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this==op2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator > (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.sgt(OP2);
        else
            return OP1.ugt(OP2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator <= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this>op2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator < (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        enum {_AP_F=_AP_W-_AP_I,F2=_AP_W2-_AP_I2, shAmt1 = ((F2-_AP_F) > (0) ? (F2-_AP_F) : (0)), shAmt2 = ((_AP_F-F2) > (0) ? (_AP_F-F2) : (0)), _AP_W3 = (_AP_F==F2) ? ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)) : ((_AP_W+shAmt1) > (_AP_W2+shAmt2) ? (_AP_W+shAmt1) : (_AP_W2+shAmt2))};
        ap_private<_AP_W3, _AP_S > OP1= ap_private<_AP_W3, _AP_S >(V)<<shAmt1;
        ap_private<_AP_W3,_AP_S2 > OP2=ap_private<_AP_W3,_AP_S2 >(op2.V)<<shAmt2;
        if(_AP_S||_AP_S2)
            return OP1.slt(OP2);
        else
            return OP1.ult(OP2);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline bool operator >= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        return !(*this<op2);
    }






    inline bool operator == (double d) const { return to_double() == d; }
    inline bool operator != (double d) const { return to_double() != d; }
    inline bool operator > (double d) const { return to_double() > d; }
    inline bool operator >= (double d) const { return to_double() >= d; }
    inline bool operator < (double d) const { return to_double() < d; }
    inline bool operator <= (double d) const { return to_double() <= d; }


    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> operator [] (unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }

    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit(unsigned int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> bit (const ap_private<_AP_W2,_AP_S2>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int());
    }

    inline bool bit (unsigned int index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);

        return V[index];
    }

    inline bool operator [] (unsigned int index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);

        return V[index];
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool bit (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);

        return V[index.to_uint()];
    }

    template<int _AP_W2, bool _AP_S2>
    inline bool operator [] (const ap_private<_AP_W2, _AP_S2>& index) const {
        if (index >= _AP_W)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);

        return V[index.to_uint()];
    }

    inline af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit(int index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index + _AP_W - _AP_I);
    }

    template<int _AP_W2>
    inline af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N> get_bit (const ap_private<_AP_W2, true>& index) {
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(this, index.to_int() + _AP_W - _AP_I);
    }

    inline bool get_bit (int index) const {
        if (index < _AP_I - _AP_W )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", index);
        if (index >= _AP_I)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index, _AP_W);


        return V[index + _AP_W - _AP_I];
    }

    template<int _AP_W2>
    inline bool get_bit (const ap_private<_AP_W2, true>& index) const {
        if (index < _AP_I - _AP_W )
     fprintf((&_iob[2]), "Warning! Index of bit vector  (%d) cannot be negative.\n", index.to_int());
        if (index >= _AP_I)
     fprintf((&_iob[2]), "Warning! Index of bit vector (%d) out of range (%d).\n", index.to_int(), _AP_W);


        return V[index.to_int() + _AP_W - _AP_I];
    }

    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) const {
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<ap_fixed_base*>(this), Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_private<_AP_W2, _AP_S2> &HiIdx,
          const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_private<_AP_W2, _AP_S2> &HiIdx,
                 const ap_private<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() {
        return this->range(_AP_W - 1, 0);
    }

    inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() const {
        return this->range(_AP_W - 1, 0);
    }

    inline bool is_zero () const {
        return V.isMinValue();
    }

    inline bool is_neg () const {
        if (V.isNegative())
            return true;
        return false;
    }

    inline int wl () const {
        return _AP_W;
    }

    inline int iwl () const {
        return _AP_I;
    }

    inline ap_q_mode q_mode () const {
        return _AP_Q;
    }

    inline ap_o_mode o_mode () const {
        return _AP_O;
    }

    inline int n_bits () const {
        return 0;
    }


public:
    ap_private<_AP_W, _AP_S> V;
    static const int width = _AP_W;
    static const int iwidth = _AP_I;
    static const ap_q_mode qmode = _AP_Q;
    static const ap_o_mode omode = _AP_O;

};






template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
std::string ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>::to_string(
                                            uint8_t radix, bool sign) const {
    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && V.isNegative();


    ap_fixed_base<_AP_W+1, _AP_I+1> tmp(*this);
    if (isNeg) {
        tmp = -tmp;
        str += '-';
    }
    std::string prefix;
    switch (radix) {
        case 2 : prefix = "0b"; step = 1; break;
        case 8 : prefix = "0o"; step = 3; break;
        case 16 : prefix = "0x"; step = 4; break;
        default : break;
    }

    if (_AP_I > 0) {




        ap_fixed_base<((_AP_I+1) > (1) ? (_AP_I+1) : (1)), ((_AP_I+1) > (1) ? (_AP_I+1) : (1)), false> int_part = tmp;
        str += int_part.to_ap_private().to_string(radix, false);
    } else {
        str += prefix;
        str += '0';
    }
    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;

    if (radix == 10) {
        if (frac_part != 0) {
            str += ".";
            while (frac_part != 0) {
                char digit = (char)(frac_part * radix).to_ap_private();
                str += static_cast<char>(digit + '0');
                frac_part *= radix;
            }
        }
    } else {
        if (frac_part != 0) {
            str += ".";
            for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
                char digit = (char)(frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))));


                int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
                digit <<= -offset;
                str += digit < 10 ? static_cast<char>(digit + '0') :
                    static_cast<char>(digit - 10 + 'a');
            }
            if (radix == 16)
                str += "p0";
        }
    }
    return str;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_not(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = op.V;
    ret.V.flip();
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_and(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V & op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_or(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V | op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void b_xor(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V ^ op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    ap_fixed_base<_AP_W2+!_AP_S2, _AP_I2+!_AP_S2, true, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = - op.V;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = -op.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_W2 - _AP_I2 + ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V <<= i;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = op.V << i;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_I2 + ((_AP_W - _AP_I) > (_AP_W2 - _AP_I2) ? (_AP_W - _AP_I) : (_AP_W2 - _AP_I2)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp = op;
    Tmp.V = _AP_S2 ? Tmp.V.ashr(i): Tmp.V.lshr(i);
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N>
inline void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op,
            int i) {
    ret.V = _AP_S ? op.V.ashr(i): op.V.lshr(i);
}
#2317 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<> inline ap_fixed_base<1,1,true,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { } template<> inline ap_fixed_base<1,1,false,AP_TRN,AP_WRAP>::ap_fixed_base(bool i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed char i_op):V(i_op) { }
template<> inline ap_fixed_base<8,8,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { } template<> inline ap_fixed_base<8,8,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned char i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed short i_op):V(i_op) { }
template<> inline ap_fixed_base<16,16,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { } template<> inline ap_fixed_base<16,16,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned short i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(signed int i_op):V(i_op) { }
template<> inline ap_fixed_base<32,32,true,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { } template<> inline ap_fixed_base<32,32,false,AP_TRN,AP_WRAP>::ap_fixed_base(unsigned int i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_slong i_op):V(i_op) { }
template<> inline ap_fixed_base<64,64,true,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { } template<> inline ap_fixed_base<64,64,false,AP_TRN,AP_WRAP>::ap_fixed_base(ap_ulong i_op):V(i_op) { }



inline std::string scientificFormat(std::string& input) {
    if (input.length() == 0)
        return input;

    size_t decPosition = input.find('.');
    if (decPosition == std::string::npos)
        decPosition = input.length();

    size_t firstNonZeroPos = 0;
    for (; input[firstNonZeroPos] > '9' ||
           input[firstNonZeroPos] < '1';
         firstNonZeroPos++);

    int exp;
    if (firstNonZeroPos > decPosition)
        exp = decPosition - firstNonZeroPos;
    else
        exp = decPosition - firstNonZeroPos - 1;
    std::string expString = "";
    if (exp == 0);
    else if (exp < 0) {
        expString += "e-";
        exp = -exp;
    } else
        expString += "e+";

    if (exp < 10 && exp > 0) {
        expString += '0';
        expString += (char)('0' + exp);
    } else if (exp != 0) {
        std::string tmp;

        std::ostringstream oss;
        oss<<exp;

        tmp=oss.str();
        expString += tmp;
    }

    int lastNonZeroPos = (int) (input.length() - 1);
    for (; lastNonZeroPos >= 0; --lastNonZeroPos)
        if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0')
            break;

    std::string ans = "";
    ans += input[firstNonZeroPos];
    if (firstNonZeroPos != (size_t)lastNonZeroPos) {
        ans += '.';
        for (int i=firstNonZeroPos+1; i <= lastNonZeroPos; i++)
            if (input[i] != '.')
                ans += input[i];
    }

    ans += expString;
    return ans;
}

inline std::string reduceToPrecision(std::string& input, int precision) {

    bool isZero = true;
    size_t inputLen = input.length();
    for (size_t i=0; i<inputLen && isZero; i++)
        if (input[i] != '.' && input[i] != '0')
            isZero = false;
    if (isZero)
        return "0";


    int FirstNonZeroPos = 0;
    int LastNonZeroPos = (int) inputLen - 1;
    int truncBitPosition = 0;
    size_t decPosition = input.find('.');
    for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
         FirstNonZeroPos++);

    for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
         LastNonZeroPos--);

    if (decPosition == std::string::npos)
        decPosition = inputLen;

    if ((int) decPosition > LastNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision;
    } else if ((int) decPosition < FirstNonZeroPos) {
        if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
            if (FirstNonZeroPos - decPosition - 1 < 4) {
                return input;
            } else {
                if (input[0] == '-') {
                    std::string tmp = input.substr(1, inputLen-1);
                    return std::string("-") +
                           scientificFormat(tmp);
                } else
                    return scientificFormat(input);
            }
        }
        truncBitPosition = FirstNonZeroPos + precision;
    } else {
        if (LastNonZeroPos - FirstNonZeroPos <= precision)
            return input;
        truncBitPosition = FirstNonZeroPos + precision + 1;
    }



    std::string ans = "";
    std::string dupInput = "0";
    if (input[0] == '-') {
        ans += '-';
        dupInput += input.substr(1, inputLen-1);
    } else {
        dupInput += input.substr(0, inputLen);
        ++truncBitPosition;
    }


    bool carry = dupInput[truncBitPosition] > '4';
    for (int i = truncBitPosition-1; i >=0 && carry; i--) {
        if (dupInput[i] == '.')
            continue;
        if (dupInput[i] == '9')
            dupInput[i] = '0';
        else {
            ++dupInput[i];
            carry = false;
        }
    }


    if (dupInput[0] == '1')
        FirstNonZeroPos = 0;
    else {
        FirstNonZeroPos = 0;
        while (dupInput[FirstNonZeroPos] < '1' ||
               dupInput[FirstNonZeroPos] > '9')
            ++FirstNonZeroPos;
    }

    unsigned it = FirstNonZeroPos;
    int NValidNumber = 0;
    while (it < dupInput.length()) {
        if (dupInput[it] == '.') {
            ++it;
            continue;
        }
        ++NValidNumber;
        if (NValidNumber > precision)
            dupInput[it] = '0';
        ++it;
    }


    decPosition = dupInput.find('.');
    if (decPosition == std::string::npos)
        truncBitPosition = (int) dupInput.length();
    else
        for (truncBitPosition = (int) (dupInput.length()-1);
             truncBitPosition >=0;
             --truncBitPosition) {
            if (dupInput[truncBitPosition] == '.')
                break;
            if (dupInput[truncBitPosition] != '0') {
                truncBitPosition++;
                break;
            }
        }

    if (dupInput[0] == '1')
        dupInput = dupInput.substr(0,
                                   truncBitPosition);
    else
        dupInput = dupInput.substr(1, truncBitPosition-1);

    decPosition = dupInput.find('.');
    if (decPosition != std::string::npos) {
        size_t it = 0;
        for (it = decPosition+1; dupInput[it]=='0'; it++);
        if (it - decPosition - 1 < 4) {
            ans += dupInput;
            return ans;
        } else {
            ans += scientificFormat(dupInput);
            return ans;
        }
    } else if ((int)(dupInput.length()) <= precision) {
        ans += dupInput;
        return ans;
    }

    ans += scientificFormat(dupInput);
    return ans;
}



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::ostream&
operator <<(std::ostream& out, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    unsigned width = out.width();
    unsigned precision = out.precision();
    char fill = out.fill();
    std::string str=x.to_string(10,_AP_S);
    str = reduceToPrecision(str, precision);
    if (width > str.length()) {
        char *padding = (char*)malloc((width - str.length() + 1)*sizeof(char));
        for (unsigned i=0; i<width - str.length(); ++i)
            padding[i] = fill;
        padding[width - str.length()] = 0;
        str = std::string(padding) + str;
        free(padding);
    }
    out<<str;
    return out;
}



template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline std::istream&
operator >> (std::istream& os, ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
     double d;
     os >> d;
     x = ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>(d);
     return os;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline void print(const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    ap_private<_AP_W,_AP_S> data=x.V;
    if(_AP_I>0) {
        const ap_private<_AP_I,_AP_S> p1=data>>(_AP_W-_AP_I);
        print(p1);

    } else
        printf("0");
    printf(".");
    if(_AP_I<_AP_W) {
        const ap_private<_AP_W-_AP_I,false> p2=data;
        print(p2,false);
    }
}
#2704 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator + (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator - (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator * (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator / (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator & (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator | (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^ (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator == (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator != (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator > (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator < (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator += (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator -= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator *= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator /= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<= (ap_private<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator &= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator |= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^= (ap_fixed_base<1,1,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<= (ap_private<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator + (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator - (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator * (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator / (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator & (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator | (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^ (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator == (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator != (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator > (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator < (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator += (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<= (ap_private<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^= (ap_fixed_base<8,8,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator + (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator - (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator * (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator / (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator & (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator | (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^ (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator == (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator != (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator > (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator < (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator += (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator -= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator *= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator /= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator >>= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator <<= (ap_private<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator &= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator |= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, short i_op) { return op.operator ^= (ap_fixed_base<16,16,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator + (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator - (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator * (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator / (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator & (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator | (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^ (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator == (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator != (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator > (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator < (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator += (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<= (ap_private<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^= (ap_fixed_base<16,16,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<= (ap_private<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<= (ap_private<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<= (ap_private<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S,ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= (ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<= (ap_private<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }
#2754 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::plus operator + ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator + (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::minus operator - ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator - (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::mult operator * ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator * (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::div operator / ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator / (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator & ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator & (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator | ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator | (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator ^ ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^ (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator == ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator == (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator != ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator != (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator > ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator > (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator >= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator >= (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator < ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator < (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator <= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator <= (op); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator += (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator += ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator += (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator -= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator -= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator -= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator *= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator *= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator *= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator /= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator /= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator /= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator &= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator &= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator &= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator |= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator |= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator |= (op.to_ap_private()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, const ap_private<_AP_W2,_AP_S2>& i_op) { return op.operator ^= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W2,_AP_S2>& operator ^= ( ap_private<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator ^= (op.to_ap_private()); }
#2807 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<1,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<8,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<16,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<32,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,true>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator > (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator > ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator < (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator < ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator >= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator <= (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator == (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator == ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)).operator != (ap_private<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_private<64,false>(op2).operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator != ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
#2847 "C:/Xilinx/Vivado_HLS/2016.3/include/etc/ap_fixed_sim.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator > ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator < ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <= ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator == ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_private<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S> &op2) { return (ap_private<_AP_W, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != (const ap_private<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_private<_AP_W2, _AP_S2> &op2) { return (ap_private<1, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator != ( const ap_private<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_private<1,false>(op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator == ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator == (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator != ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator != (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator > ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator < (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator >= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator <= (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator < ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator > (op1);
}


template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator <= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator >= (op1);
}
#76 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_int.h" 2


template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_fixed;
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> class ap_ufixed;
template<int _AP_W> class ap_int;
template<int _AP_W> class ap_uint;


template<int _AP_W>
class ap_int: public ap_private<_AP_W, true> {



public:
    typedef ap_private<_AP_W, true> Base;

    inline ap_int(): Base() {}
    template<int _AP_W2>
    inline ap_int(const volatile ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const ap_int<_AP_W2> &op):Base((const ap_private<_AP_W2,true> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}

    template<int _AP_W2>
    inline ap_int(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2,false> &)(op)) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                 :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                  :Base(op.to_ap_private()) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_int(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_int(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}



    inline ap_int(bool v):Base(v) {}
    inline ap_int(signed char v):Base(v) {}
    inline ap_int(unsigned char v):Base(v) {}
    inline ap_int(short v):Base(v) {}
    inline ap_int(unsigned short v):Base(v) {}
    inline ap_int(int v):Base(v) {}
    inline ap_int(unsigned int v):Base(v) {}
    inline ap_int(long v):Base(v) {}
    inline ap_int(unsigned long v):Base(v) {}
    inline ap_int(unsigned long long v):Base(v) {}
    inline ap_int(long long v):Base(v) {}
    inline ap_int(float v):Base(v) {}
    inline ap_int(double v):Base(v) {}
    inline ap_int(const char* v):Base(v) {}


    inline ap_int(const char* str, signed char rd):Base(str, rd) {}


    inline void operator = (const ap_int<_AP_W>& op2) volatile {
      const_cast<ap_int*>(this)->operator = (op2);
    }

    inline void operator = (const volatile ap_int<_AP_W>& op2) volatile {
      const_cast<Base*>(this)->operator = (op2);
    }

    inline ap_int<_AP_W>& operator = (const volatile ap_int<_AP_W>& op2) {
      Base::operator = (const_cast<ap_int<_AP_W>& >(op2));
        return *this;
    }

    inline ap_int<_AP_W>& operator = (const ap_int<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, true>&)op2);
        return *this;
    }

};



template<int _AP_W>
class ap_uint: public ap_private<_AP_W, false> {



public:
    typedef ap_private<_AP_W, false> Base;

    inline ap_uint(): Base() {}
  inline ap_uint(const ap_uint<_AP_W>& op) :Base(dynamic_cast<const ap_private<_AP_W, false>&>(op)) {}
  inline ap_uint(const volatile ap_uint<_AP_W>& op):Base(dynamic_cast<const volatile ap_private<_AP_W, false>&>(op)){}
    template<int _AP_W2>
    inline ap_uint(const volatile ap_uint<_AP_W2> &op):Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2>
    inline ap_uint(const ap_uint<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)){}

    template<int _AP_W2>
    inline ap_uint(const ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, true>&)(op)) {}

    template<int _AP_W2>
    inline ap_uint(const volatile ap_int<_AP_W2> &op) : Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op.to_ap_private()) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
                   :Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_uint(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_uint(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.to_ap_private()) {}



    inline ap_uint(bool v):Base(v) {}
    inline ap_uint(signed char v):Base(v) {}
    inline ap_uint(unsigned char v):Base(v) {}
    inline ap_uint(short v):Base(v) {}
    inline ap_uint(unsigned short v):Base(v) {}
    inline ap_uint(int v):Base(v) {}
    inline ap_uint(unsigned int v):Base(v) {}
    inline ap_uint(long v):Base(v) {}
    inline ap_uint(unsigned long v):Base(v) {}
    inline ap_uint(unsigned long long v):Base(v) {}
    inline ap_uint(long long v):Base(v) {}
    inline ap_uint(float v):Base(v) {}
    inline ap_uint(double v):Base(v) {}
    inline ap_uint(const char* v):Base(v) {}


    inline ap_uint(const char* str, signed char rd):Base(str, rd) {}


    inline void operator = (const ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }

    inline void operator = (const volatile ap_uint<_AP_W>& op2) volatile {
      Base::operator = (op2);
    }

    inline ap_uint<_AP_W>& operator = (const volatile ap_uint<_AP_W>& op2) {
      Base::operator = (op2);
        return *this;
    }

    inline ap_uint<_AP_W>& operator = (const ap_uint<_AP_W>& op2) {
      Base::operator = ((const ap_private<_AP_W, false>&)(op2));
        return *this;
    }

};






template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_fixed: public ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {



public:
    typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;

    inline ap_fixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(op) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const ap_uint<_AP_W2>& op):Base(ap_private<_AP_W2, false>(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                    true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const volatile ap_int<_AP_W2>& op):
                   Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_fixed(const volatile ap_uint<_AP_W2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_fixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_fixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}



    inline ap_fixed(bool v):Base(v) {}
    inline ap_fixed(signed char v):Base(v) {}
    inline ap_fixed(unsigned char v):Base(v) {}
    inline ap_fixed(short v):Base(v) {}
    inline ap_fixed(unsigned short v):Base(v) {}
    inline ap_fixed(int v):Base(v) {}
    inline ap_fixed(unsigned int v):Base(v) {}
    inline ap_fixed(long v):Base(v) {}
    inline ap_fixed(unsigned long v):Base(v) {}
    inline ap_fixed(unsigned long long v):Base(v) {}
    inline ap_fixed(long long v):Base(v) {}
    inline ap_fixed(float v):Base(v) {}
    inline ap_fixed(double v):Base(v) {}
    inline ap_fixed(const char* v):Base(v) {}


    inline ap_fixed(const char* str, signed char rd):Base(str, rd) {}


    inline ap_fixed& operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }

    inline ap_fixed& operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::operator = (op);
        return *this;
    }

    inline void operator = (const ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }

    inline void operator = (const volatile ap_fixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::operator = (op);
    }

};


template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
         ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
class ap_ufixed: public ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {



public:
    typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;

    inline ap_ufixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const ap_int<_AP_W2>& op):
      Base((const ap_private<_AP_W2, true>&)(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const ap_uint<_AP_W2>& op):
      Base((const ap_private<_AP_W2, false>&)(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op) : Base(ap_fixed_base<_AP_W2,
                     _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2,
                     _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                      false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_int<_AP_W2>& op):
                     Base(ap_private<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline ap_ufixed(const volatile ap_uint<_AP_W2>& op):
                     Base(ap_private<_AP_W2, false>(op)) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                     _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline ap_ufixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline ap_ufixed(const ap_private<_AP_W2, _AP_S2>& op):Base(op) {}




    inline ap_ufixed(bool v):Base(v) {}
    inline ap_ufixed(signed char v):Base(v) {}
    inline ap_ufixed(unsigned char v):Base(v) {}
    inline ap_ufixed(short v):Base(v) {}
    inline ap_ufixed(unsigned short v):Base(v) {}
    inline ap_ufixed(int v):Base(v) {}
    inline ap_ufixed(unsigned int v):Base(v) {}
    inline ap_ufixed(long v):Base(v) {}
    inline ap_ufixed(unsigned long v):Base(v) {}
    inline ap_ufixed(unsigned long long v):Base(v) {}
    inline ap_ufixed(long long v):Base(v) {}
    inline ap_ufixed(float v):Base(v) {}
    inline ap_ufixed(double v):Base(v) {}
    inline ap_ufixed(const char* v):Base(v) {}


    inline ap_ufixed(const char* str, signed char rd):Base(str, rd) {}



    inline ap_ufixed& operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
      Base::operator = (op);
        return *this;
    }

    inline ap_ufixed& operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = const_cast<ap_ufixed&>(op);
        return *this;
    }

    inline void operator = (const ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
      Base::operator = (op);
    }

    inline void operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                    _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = const_cast<ap_ufixed&>(op);
    }

};
#68 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_fixed.h" 2
#25 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Xilinx/Vivado_HLS/2016.3/include/ap_int.h" 1
#26 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2

typedef ap_int<8> int8;

typedef ap_fixed<8, 3, AP_RND, AP_SAT> ldpc_dbl;



typedef unsigned short tab_int;






#1 "C:/Users/dougo/LDPC_Decoder3U/LDPCparms.h" 1




ldpc_dbl r[1408] = {
 -0.61408, 1.2682, -1.1558, -0.43168, -0.40887, -0.34668, 1.112, -0.89124, -2.0705, 0.41094,
 -1.3611, -1.8505, -0.6726, 2.5457, 0.40028, -1.4117, 1.7631, 1.3032, 0.52397, -0.4311, -1.723,
 -1.0503, 0.58494, 1.3864, -0.74677, -1.8243, 0.024578, 0.038084, -1.5064, 1.4555, -0.010043,
 0.86633, -1.1255, -1.1439, 1.2841, 0.29935, 0.56055, 0.26849, 0.70735, 0.42222, -0.12892, 2.2309,
 -1.1263, 0.23129, 1.032, 0.10066, 1.8296, -0.45892, -2.0763, -1.9206, -1.6604, 2.4299, 2.0045,
 0.98918, -0.62887, -1.283, 1.1879, 0.9794, 1.2221, 0.25119, -1.6194, -1.3021, -1.4594, -1.1189,
 -0.78178, -0.39877, 0.8549, 1.1283, 0.91305, -1.4557, 1.5715, -1.2576, 0.78197, 0.5391, -1.2131,
 1.2036, -0.94707, -1.4231, 0.48003, 0.75087, 1.2084, 1.0865, 0.65694, -1.1435, -0.83095, 0.34173,
 1.3597, -0.14293, 0.46785, 1.1362, 1.1792, 1.5298, 0.081297, -1.3287, 0.064095, -0.69708, -0.95876,
 -1.02, 0.10934, 1.7564, 0.001443, -1.1633, -1.7563, 1.1376, 1.1119, -1.3562, 1.2036, -0.39224,
 -0.37268, -1.5229, 1.2337, 0.085909, -0.83401, 1.7947, 0.14597, 1.5133, -0.96971, -0.79943, -0.66917,
 1.0816, -2.4612, 1.2346, -1.2274, 1.8078, -1.2666, -0.63665, 1.2675, 2.0004, -0.52412, -0.89036,
 -1.233, 0.8505, -1.4638, 1.0586, 1.7553, -1.7073, 0.30041, 1.3029, -1.6562, 1.2443, 0.4363, -1.0651,
 1.1739, -1.9643, 1.0825, 0.92543, -0.7234, 2.265, 0.75446, -2.344, 1.0008, -0.8817, -0.84634, 0.64922,
 1.1818, -0.84561, -0.56678, 0.0069944, 0.52956, 0.64904, 1.0863, -0.22843, -1.0042, 1.4875, 0.65168,
 -1.1695, -1.2441, -1.0233, 1.0687, -0.59659, -0.68063, -1.2252, -1.1249, -1.006, 0.92066, 1.1828,
 -0.71841, 0.92329, 0.92462, -1.1516, -1.1412, -0.72466, -1.5069, 1.1559, -1.3133, -1.2231, 1.3175,
 1.2458, -2.8748, -0.98481, -1.2889, 1.4118, 0.32255, 0.9808, -0.052563, 1.2263, -1.2073, 0.28911,
 1.2621, 1.6318, -1.0786, 1.9401, -0.43666, -1.3157, 0.29333, 1.1087, 0.29674, -0.67667, -1.8828,
 -0.45869, -0.020124, -1.0183, 1.4458, 0.9407, 0.46375, -1.4323, -0.44993, 0.53636, -1.5415, -1.416,
 0.26915, -0.016743, -1.5929, 0.75497, 1.6985, -0.65997, 0.09816, -0.50983, 0.70879, -1.7256, 1.8727,
 -0.016713, -1.5129, 1.3359, 0.30543, 2.024, 0.62968, 0.81096, -0.97389, -0.56715, 0.93237, 0.88627,
 1.1438, -1.3371, 1.227, 0.10269, 0.90853, -0.93168, -1.1854, -1.12, -1.0298, 2.0019, -0.97312, -0.077139,
 -0.89545, 0.79305, -0.63459, 1.5294, -0.28273, -2.2624, -1.9612, 0.92562, -0.13823, -0.72577, 0.2608,
 1.4705, 0.36132, 0.75461, -1.9212, -1.2209, 1.7252, 0.28957, 0.86248, 1.722, -0.76678, 1.1077, -0.88174,
 -1.3178, -1.6897, 1.2652, 0.33801, 0.10095, -0.98456, 0.3116, -1.364, 0.50859, -0.88509, -0.81628, 1.0997,
 1.4788, -1.242, 2.0841, -1.92, 0.021463, 0.072889, -1.785, 1.1539, 0.94805, 1.7711, 1.7112, -0.48045,
 -0.038397, -1.7317, 0.27248, 1.1514, 0.57109, 1.5493, -2.0255, 1.4252, -1.8226, -0.63357, -1.3153, -0.89829,
 0.60791, -0.85569, 1.3178, -1.3855, -1.4007, -0.97254, -1.1984, 0.60075, 0.23107, -0.29245, 1.38, 0.68636,
 0.80958, 0.92122, 1.258, 0.97689, 1.4689, 0.65908, 1.3884, -0.98813, -0.78127, 0.38543, 0.92451, -1.5447,
 -1.7398, -0.78067, -1.1893, -0.87883, 1.6897, 0.5729, 0.77758, -0.15689, -1.171, -0.6489, 1.3848, -1.983,
 -0.76518, -0.73506, 0.81812, -0.19543, -1.3966, -1.0811, 0.81619, -1.2223, 0.96959, 1.1706, -0.7364,
 -0.89235, 1.2952, 0.89381, -0.8231, 1.6786, -0.069318, 0.96665, 0.71858, 1.4563, 1.5565, -0.64643, -0.66734,
 0.97162, -0.46461, 1.9008, -2.0844, 1.2285, 0.47895, -0.65462, -1.9331, -0.63865, 0.73924, -0.029925, 0.7198,
 -0.44454, 1.0426, -1.1311, -0.80932, 0.93834, -1.6015, 1.7783, 0.80854, -1.3128, -1.4421, 0.030676, -1.2807,
 -1.106, 1.4729, -2.0438, -0.46583, 0.75824, -1.2366, 1.1222, 1.3602, -1.4522, -0.49413, -1.3294, 1.2579,
 1.9463, -2.1768, -0.68152, 1.5786, -0.57213, -2.0422, -0.0034228, -1.0251, -1.4806, -0.0029792, 1.5343,
 -1.3112, -1.2603, 0.80783, -0.47157, 1.3802, 0.99013, -1.2636, -1.1414, -0.76536, 1.2163, 1.6081, 1.3554,
 0.73723, -0.84983, -0.79978, 0.27587, -1.8861, -0.65691, 0.90406, -1.2699, -0.10443, 0.8023, -1.2289, 2.1651,
 0.87821, -0.81584, -1.8178, -0.49954, 1.4156, 1.1918, -1.2061, 1.4795, 0.70147, 1.6533, -2.0741, -1.156,
 -0.70305, -1.148, -1.1487, -0.79648, -1.4405, 0.41733, 1.7351, -0.34038, 1.5151, 1.7072, 0.67131, 0.12921,
 -1.5855, -1.1138, 1.1275, 1.1319, -0.51994, -0.67389, 1.9222, 0.40786, 2.1448, -1.4419, -1.0426, -0.41791,
 0.72943, 0.047145, -0.89716, 1.0244, -1.0467, -0.55234, -1.8382, -1.1846, -1.0625, 0.20774, 0.74544, 1.4291,
 1.0289, -1.5179, -1.178, -0.69351, -1.0121, -1.0047, 1.5489, 1.3265, 1.0112, 2.0945, -1.2898, 0.65785, -1.0008,
 1.0814, -1.1765, 1.1858, -0.85549, -0.77716, -1.0335, 0.79958, 0.38086, 0.20689, 1.5033, 0.63073, 1.7432,
 -1.4657, 1.1424, 0.55078, 1.47, 0.77969, 0.45493, 1.4556, -1.2029, -0.62012, 0.85697, -1.3953, -0.5479, 0.42076,
 0.41198, -0.31517, -1.5439, 1.0796, -1.4606, 1.7724, -1.381, -2.0446, -0.0025034, -1.75, 0.32993, -1.1557, -2.194,
 -0.59038, -1.4818, -1.0483, 1.0624, 0.85371, -1.6429, -0.45307, -2.2065, -0.6873, -0.94927, -1.2982, 2.3577,
 -1.8424, -0.90934, 0.11512, -0.55884, 1.6483, -1.1478, 1.6701, 1.1407, -0.073428, -0.89581, -0.71901, -0.5308,
 -1.1078, 0.56088, -1.8278, 1.2519, -1.9034, -1.8563, -1.047, -0.41011, -1.9902, 1.109, 0.044436, -1.0602, 0.32268,
 1.2789, -2.1906, 1.3206, -1.38, -0.45673, -1.4322, -1.0331, 0.6649, -0.0055921, -0.60926, -0.55932, 1.9477, -1.5054,
 1.0186, 1.3426, -0.79337, 1.7637, -1.4163, -0.59112, -1.4037, 1.4508, 1.8336, -0.88034, 0.41943, 0.74622, 1.0789,
 0.17257, 0.80613, -0.9783, -1.7236, 1.2206, -1.5139, 0.67914, -2.4439, -0.681, 0.81678, -0.018333, 1.1406, -0.90073,
 -0.81416, -1.4316, -0.039374, -1.093, -2.6428, -0.37943, -1.2744, -1.4313, 0.56677, 1.5293, 1.5533, 0.26159, 0.71338,
 1.2001, -0.49241, 0.95559, 0.57139, -0.99857, 1.4156, 0.25817, -1.3771, 0.12579, -1.5781, 1.0199, 1.6086, -1.8891,
 0.10557, -1.4141, 0.7592, -0.38134, -0.25669, 0.79808, 1.3459, 1.1725, 1.0281, -1.1876, -1.0785, 1.5243, -1.691,
 0.79923, 1.2732, -2.1858, 1.4536, -0.74548, 1.6889, 1.1547, 0.93758, 1.1939, 0.061073, 1.3522, -0.66683, 0.96753,
 1.6234, -0.35648, -0.97811, 0.74306, -1.4394, 0.63336, -1.9806, -0.64354, 0.32454, 2.1487, -0.52326, 0.89182, -1.527,
 1.4481, -0.1604, 1.9566, -1.2539, 0.81822, 0.12606, -1.8648, -0.82783, -0.051722, -1.2799, -0.3854, -0.69476, 0.17526,
 0.64254, -1.0152, -0.10182, 0.53111, 1.4785, 1.0584, 0.42947, 1.0472, -1.0999, -1.1915, 0.46281, -0.68913, 0.20283,
 1.34, 1.1147, -1.2096, -0.61061, 2.2138, 0.68684, -0.40394, 2.5599, 0.65468, 1.3306, 1.0087, 0.9781, 1.431, -0.83254,
 1.5706, -1.4607, -1.4591, -1.2667, -0.85928, -1.376, 0.83677, 0.69503, 1.2534, 0.93682, 0.45285, 1.1104, 2.2326,
 -0.55151, -1.3903, -0.4185, 0.054209, -0.8491, 0.63814, 1.2959, -0.24638, 0.80801, -1.4344, 1.814, -1.9154, 1.2243,
 0.55652, -0.16116, 0.96477, -0.45093, 1.3071, 1.4372, 1.1085, -0.50166, 1.0428, -0.81961, 2.3037, 1.0123, -1.2652,
 1.4124, 1.2584, 1.1603, 0.91316, 1.7394, -1.1009, -0.828, 0.58813, -0.59935, 1.431, -0.7932, -1.7073, -1.4138, 0.51949,
 0.99421, -0.78551, 1.2698, 0.4369, 0.30543, -2.0406, 1.401, 1.5685, 0.69837, -0.74314, 0.64257, -1.5892, 1.1713,
 -0.4476, -1.7308, -1.1477, -1.4138, 1.1739, -0.16143, -1.4168, 0.039791, 0.93836, 0.59316, 1.8494, 1.2908, 0.46825,
 -1.3052, -0.80345, 0.2854, 0.94984, 1.3375, 0.77446, 1.4393, 0.69799, -0.77443, -1.2096, -0.97214, 0.45129, -0.82185,
 -1.5871, -0.022129, 0.42447, 1.2876, -0.4306, 1.2415, 0.472, 0.90334, -1.0503, 0.42947, -2.4071, -0.39465, 0.38928,
 0.68647, -2.2996, -0.8351, 0.55013, 1.1731, 0.98281, -0.8035, 0.84396, 0.0027835, -0.47828, -0.23978, -1.7229, 1.6097,
 -0.38478, 1.3416, -1.4398, -0.94244, 0.55351, 1.6419, 1.0706, -1.5499, -0.78058, 2.0217, 1.2292, 0.84434, -0.1429,
 1.632, 0.85441, 0.78516, 1.1241, -0.2495, 1.0091, 1.6652, -0.28504, -1.6702, 0.86039, 0.9889, -0.44123, -0.70516,
 0.76466, -0.51353, 0.96272, 1.2258, 1.5908, 0.46317, -0.78978, 0.25847, 0.89822, -1.1284, -1.8127, 0.097643, -1.2736,
 1.1649, 0.26367, -0.31099, -2.0126, -0.41669, 0.078454, 1.2459, 0.30232, -0.91154, 1.4973, 0.86814, 0.62647, 1.2216,
 -0.48239, -1.0994, 0.81071, -1.3216, -1.1451, -1.404, -0.32482, 0.92249, -1.5352, -0.13785, -1.2633, -1.2769, 0.62574,
 1.3732, 1.6162, -1.1668, -1.0343, -0.8549, -1.6484, 1.7453, -1.5612, -1.0161, -1.4698, 1.631, 2.2033, -1.4418, -0.50259,
 -0.40012, -0.85665, -0.36119, -1.1521, -0.85222, -0.31103, -1.5562, -0.92009, -1.2662, -0.85916, -0.23171, 0.39846,
 1.5639, -1.1599, 0.99841, 0.01545, -1.0317, -1.3198, 1.2677, -1.4024, 1.3133, 1.0762, 1.5374, -2.1472, 2.0814, -1.1089,
 -0.014562, -0.46227, 1.6317, -1.0034, 1.4218, -0.0085208, -0.72445, 0.50761, 0.5347, 1.3223, 0.93687, 0.4418, 0.98999,
 0.88984, 0.52933, 0.90949, -0.46315, 1.6615, 0.95022, 1.1259, -1.0255, -0.84304, 1.79, -1.1023, 0.72478, 0.5888, 0.69018,
 -1.1564, 0.85077, 1.4011, 0.77185, -2.0413, 1.2673, 1.4281, -1.261, 1.2669, 1.0418, -0.75687, -0.801, -0.99544, 1.2543,
 -0.86099, -0.9636, 1.3832, -1.1194, 1.8883, -1.2817, -0.78768, 0.66892, -1.5335, 0.59158, 0.8675, -0.081862, -0.76323,
 -1.4297, -1.0279, -0.46477, 0.72334, 0.64725, 0.51211, 1.8424, -1.0153, -0.020576, -2.0002, 0.12776, -2.0194, 1.6498,
 -0.75344, -2.1007, 0.52961, -1.8687, 0.58342, 0.97654, -1.42, 1.9579, -0.41872, -0.55511, -2.0394, -0.26158, 0.10642,
 0.93725, 1.0338, -1.0478, -0.64439, 0.80446, 1.1641, 1.0503, 1.304, -1.6589, 0.95237, -1.2492, 0.75381, -0.85372, 1.209,
 1.3925, -1.1398, -1.7864, 0.59014, 0.75474, -1.2911, -0.29579, 0.79101, 1.5298, 1.3414, -1.4316, 1.2212, 1.6808, -0.60707,
 -0.37513, 0.66891, -0.24339, -1.5288, -1.5856, 2.3393, -0.72614, -1.7997, 0.98521, -0.78803, 1.0425, -1.1348, 0.44487,
 -2.438, 0.77395, 1.269, 1.0158, -0.58344, 0.16494, -0.66916, 0.38631, 1.8544, 0.015241, 0.18535, -0.9652, 1.7359, 0.31936,
 -0.69029, 0.49469, -0.35524, -1.2921, -1.6491, 0.079933, -2.3466, -0.074763, 0.71881, -1.0667, -1.1047, -1.4364, 1.6158,
 1.9502, 0.61908, 0.0073031, -1.5164, 1.5466, -0.91317, 0.30637, -0.69243, 1.1486, 0.85769, 1.4754, 1.1961, -0.71356,
 -1.5078, 1.231, 1.1259, 1.0453, 1.1646, -0.67563, -1.7021, -0.42787, -0.74862, 1.6954, -0.77776, 0.64371, -1.9575, 2.0241,
 -1.0292, -0.61006, -1.9728, 1.5875, 1.0886, -0.79819, -0.47617, -1.2636, -1.1378, 1.4282, -0.86536, 0.30567, -0.36531,
 0.88938, -0.56101, -1.0238, 1.053, -1.4543, -0.59167, 0.61213, 1.084, -1.4004, 1.4794, -1.7487, 1.4918, 1.0758, -1.1739,
 -1.9319, -0.9764, -0.83009, -0.95884, 1.0724, -0.3598, 1.46, 1.2395, -0.96836, -1.5603, 1.1595, -1.7038, -1.6929, 0.4202,
 1.4495, 0.2445, 0.88629, 0.75138, -1.1052, 1.3269, 1.0052, -0.026969, -2.0874, -0.56754, -0.90811, 1.2247, 0.11435, 1.801,
 -0.061553, 0.25141, -0.58194, -0.74971, -1.3795, 0.14132, -0.25682, 1.4559, 1.5494, 0.38431, 1.7796, 0.29669, -0.97852,
 0.43782, -0.94643, -0.48542, -0.13498, 0.94171, -1.025, -1.75, 1.145, 0.80697, -1.5225, 1.0318, 0.90021, -1.1882, 0.49137,
 0.7866, -1.3253, -0.027149, 0.4569, -1.9703, -0.87764, -1.3507, 0.43652, 1.1725, -0.77742, 0.87259, -1.1029, 0.89896, 0.68594,
 0.36143, 2.3385, -1.3304, -0.62033, 1.2049, 1.2286, -0.29466, 2.1836, -0.74605, 0.80481, 0.29207, -1.4907, 0.50446, 1.2931,
 0.6089, 1.9302, 1.5026, 0.50689, 1.4444, 0.21328, 0.67215, 0.83405, 0.56294, -1.1065, -2.296, -1.5486, 1.3334, 1.2245,
 0.42027, -1.7236, 0.85973, 1.4636, -0.74886, 1.5247, 1.5627, -0.16656, 1.3941, -0.83964, -0.1111, -0.70263, 0.8886,
 -1.0492, -1.2117, -0.78189, -1.7884, 1.3335, -0.76683, 1.4109, -1.2141, -0.96705, 1.1077, -1.4364, -1.6847, -0.62485,
 1.4201, 0.3341, 1.107, -0.50348, -1.6594, -0.32307, 1.491, 1.2858, -1.3367, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};



 char rawData[1408] = {
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x31
};

 ldpc_dbl r_1024_12[2560] = {
         -0.79196, 0.43217, 0.5252, -0.21526, 1.8259, 0.80066, 1.358, -1.4034, 0.19748, -1.1044, 1.2087, -1.5941, -0.28557, -0.8257, 1.122, -1.8016, -0.26555, -0.68259, 0.82791, -1.7652, -0.41072, 0.89146, 1.0508, 1.0174, -0.53566,
         1.8599, -1.553, 1.2655, 0.24153, -0.24794, 0.036091, -0.68169, 0.78527, 0.91602, -0.13355, -1.1882, -1.8239, 1.5022, 1.0666, -0.24662, -0.2867, 0.098174, -1.619, 0.14745, -1.9158, 1.1109, -0.11527, 1.4307, -2.0666, -0.94432,
         -0.041448, -2.0346, 1.6354, 1.6413, 1.5078, -0.38585, -1.0207, 0.92428, -0.97871, -1.5491, 0.36923, 1.4735, 0.17128, -0.33949, 0.65935, -0.537, -1.3333, 0.24838, 0.33903, -1.6075, 0.39944, 0.10928, 1.4868, -0.96123, 1.1021,
         -0.63544, 2.1265, 1.1435, 1.788, 0.13211, -1.9172, -0.073406, -0.88296, 1.1714, 0.57449, 0.36793, 1.2146, 1.4134, -0.65234, 1.2101, -0.077207, 1.7077, 0.52309, 0.71397, -0.031306, 0.91785, -0.88679, -1.1114, 1.0551, 1.16,
         -1.1709, 1.1648, -0.46385, 1.1108, -1.0064, -0.91428, -1.1278, -1.1746, -1.2037, 1.2673, 0.12433, 2.0663, -1.0206, -1.906, 0.97067, 1.3095, -2.416, 1.5221, -0.42982, -1.0958, 0.64605, 2.4577, -2.1156, 1.8003, 0.77665,
         0.87859, 0.37708, -2.4288, -1.2517, 0.53818, 1.6357, -1.0497, 0.1683, 1.3276, 0.386, -0.75919, 1.3072, -1.5196, 1.8988, -1.2094, -0.62033, -1.7976, -2.2155, 0.28604, -1.1144, -1.4211, -1.3452, -0.86819, -2.6507, -1.1292,
         -0.24007, -1.7508, -1.1379, -0.081616, 1.5167, -1.3242, 0.76989, -1.5983, -1.5441, 1.208, 1.0523, -0.9054, -0.98028, -0.85401, -1.0948, 0.58385, -0.8281, 0.2991, -1.3445, -0.48551, -0.54086, 2.7671, 0.66323, 2.3871, 0.48127,
         0.055895, -0.15378, -0.79805, -0.97615, 2.2848, 0.86288, 0.65925, -0.87139, 0.62103, -1.1857, 0.6973, 1.1258, -0.52681, -1.1137, -0.20762, 1.365, -1.2718, 1.083, -0.44675, 0.87317, 0.84921, 1.0283, -0.52069, -1.0284, -1.2539,
         -0.24979, 0.35474, 0.53357, 1.0383, 1.5495, -1.7129, -1.636, 0.93121, -1.5565, 1.8379, -1.2487, -1.475, -1.4912, -0.49346, 1.992, 2.0259, 0.90226, -1.6177, 2.4867, 1.2035, 0.79377, -2.2221, -0.43323, -0.048767, -1.7707,
         0.60407, 1.2647, 0.73713, -1.1238, -1.3514, 0.30674, -1.9142, 1.16, -1.0344, 0.83811, 1.3239, -1.93, 0.76263, 1.1506, -0.5838, -1.3849, -0.92799, -0.75122, -1.0701, 0.64194, -0.36188, 0.87546, -0.54383, -0.83191, -2.0703,
         1.7386, -2.1015, 0.66244, 1.3282, -1.1667, 1.2026, -1.0982, -2.1334, -0.44775, -0.1019, 0.29828, -1.1024, 0.05389, 1.5095, 2.4138, -0.68394, -1.18, -2.45, 1.6508, -2.9074, 0.87329, 1.1491, 0.86298, 1.1634, -0.60556,
         -1.8749, 0.084919, 1.2305, 0.22146, 0.98993, -2.2673, 1.1799, 1.0576, 1.1493, 1.7787, -0.13103, 1.379, -1.4878, -2.3401, -1.2847, -1.8192, -0.97429, -0.24955, 1.2778, -0.89814, 0.78389, -2.0912, 0.22869, 1.3351, -1.4065,
         -0.93054, 0.32538, 1.5732, -0.69519, 0.65836, 0.37885, 0.59051, 1.7775, 1.9767, -1.2401, -1.7142, 1.0682, 1.8716, -0.39513, -1.491, 0.28233, 1.7185, 1.1033, -0.37949, -1.4974, -1.6511, 1.1065, -1.4915, 1.203, 0.93533,
         2.1944, 0.18618, -2.3521, 0.72137, -1.1831, -1.063, 0.31592, -1.4455, -0.16068, 1.3118, 0.064598, 2.9936, 1.3595, -1.0774, 1.2752, -1.0315, 1.2432, -1.2349, -1.04, 0.31715, -0.095808, -1.3757, 2.0066, -0.55483, 0.55333,
         -1.1306, -0.8213, -0.40196, 0.57732, -0.64661, -1.3751, 0.035202, -1.45, 0.23883, -1.2584, -1.4933, -0.68538, 2.2132, -0.24814, 0.066829, -0.20573, 0.83641, -1.1055, -0.56243, 1.3294, 0.35907, -0.6965, 0.32473, -1.3527, -0.60251,
         0.37963, 1.2348, -1.1644, -1.2522, -0.76921, -0.59073, -1.4338, 1.7872, 1.46, -1.5566, 0.95109, 0.79455, 0.26158, 0.081059, 1.3805, 0.23483, 1.3573, 2.9742, 1.3995, -2.5241, 0.75423, -1.0673, -0.83401, -1.0083, 0.8265,
         -0.52765, 0.37456, -0.37403, -0.29151, -1.1325, 0.74253, -2.1718, 0.20393, -0.99952, -1.4615, 1.1424, -1.6919, -1.6767, 0.43358, -1.0007, 0.52936, 0.16459, -1.0133, -0.76778, 0.665, -2.3174, -1.3318, -0.92261, 0.20803, -1.141,
         -0.68909, 1.2866, -0.031012, -0.25106, 1.6463, -0.3129, 1.1983, -1.4173, -0.69396, 1.3246, 1.3854, -1.6635, 0.36282, -0.17444, 1.8946, -0.77328, 1.237, -0.90449, 0.80466, -0.52603, 1.8766, 0.4816, -1.8338, 0.61303, -0.72113,
         -0.8887, -0.89461, -0.44729, -0.23124, -1.942, 0.7644, -0.51734, 0.94224, -0.48515, 0.21714, 1.3494, 0.068623, 0.68208, -0.70845, -0.13214, 0.33184, -1.9432, 0.36813, 1.17, -1.1847, -0.91567, -0.12965, 0.4821, 1.0973, -0.57859,
         1.1224, -0.73692, -0.98497, 1.5208, -1.3458, 0.67752, -0.59702, -0.25256, 1.0788, -1.2675, -0.41125, -1.1731, 0.91242, 0.46167, -1.3934, 1.4906, 0.93118, -0.51315, -0.53416, 0.77885, 2.2145, 0.50677, -1.1964, 2.2991, 2.6448,
         -2.4714, -0.70765, -0.78414, -2.5699, -0.13192, -0.72688, -0.64315, -0.86412, -1.5057, -1.2034, -1.5349, 0.5411, 0.83331, 2.4152, -1.1229, -0.81322, 1.5672, 0.34248, -1.3993, -0.45142, -1.852, -1.3115, -0.35835, -2.3819, 0.019029,
         -0.76693, -0.97934, -2.5521, -0.14965, 1.7935, -0.015739, 0.58694, 1.4283, 1.889, 0.91859, 2.5964, -0.88352, 0.71426, 1.5413, 0.82648, -1.1319, -1.3011, -0.036356, -2.0694, -0.28782, 0.75757, 2.4935, 0.69448, -0.70434, 1.2845,
         0.032629, 0.19679, -0.99885, 0.37354, 1.0445, -1.1981, 0.41388, 1.4084, -0.4605, 2.2689, -0.95724, 1.9192, -0.74195, -1.3628, -1.3154, 0.72464, -1.4325, -0.23345, -0.58337, 1.1202, 1.2837, -1.7972, -0.73065, -0.15483, -1.7318,
         -0.44319, -0.59796, -0.60586, 1.5478, -0.51745, 0.68781, -2.3415, -2.0587, 1.5123, -0.24711, 1.8919, 1.2858, -0.84215, -1.3052, -0.76687, -0.91751, -1.3102, 2.1145, -0.65721, -0.18874, -0.16491, 0.77812, -0.7252, 0.15574, 1.807,
         -1.4403, 1.9407, 1.9224, -0.4482, 0.26408, -1.0124, 0.75045, 0.70594, 0.6067, -0.52115, -1.1876, -0.72378, 0.035007, -2.0076, 1.0306, 1.2745, -1.7013, -1.3334, 1.8499, 1.1565, 0.73859, 1.5306, -1.3923, -1.3076, -1.2276,
         1.7682, 1.7061, -0.41168, -0.9241, -1.6066, 0.97161, -0.3414, -0.15132, 1.5821, 1.1182, -0.12527, 1.0423, 0.01301, 2.099, 1.331, -0.8515, 0.58478, 0.50831, -0.75118, -0.84559, -1.0708, 1.8675, -2.0284, 1.0429, -1.387,
         -1.3521, 1.2092, -0.43533, 1.2284, -0.1094, 0.034755, -0.20097, 1.2004, 1.7608, -1.2411, -0.5289, 1.732, -0.57939, -0.40181, 1.4422, -1.6786, -0.8718, 1.8503, -0.96464, 0.14273, -0.93143, 0.22608, -0.87816, 2.3044, -0.05084,
         0.39523, 1.5449, -0.28867, 0.66685, -1.0855, 1.1492, 0.20777, 1.7983, -1.0882, 1.7021, -1.53, 1.1455, -0.40258, 0.96879, 1.1901, 1.7933, -0.8172, -1.1638, -0.24839, -0.22015, -0.38182, 0.45443, 1.6181, -2.1377, 0.52368,
         0.48318, 0.20791, 0.2764, 0.79657, -1.9865, -1.4734, 0.54265, -0.90427, 1.195, 0.18756, 1.1469, 0.62691, 0.88994, -1.6503, -0.57059, 0.68801, -0.92887, 1.4472, -1.2753, -0.24554, 0.34536, -1.5181, 1.3374, -1.9969, 1.8265,
         -1.739, 1.1293, 0.82773, 0.041327, -1.2915, 0.62303, 0.90544, -2.0725, -0.68948, 0.74422, -2.2291, 1.2851, -2.3463, -1.7233, 0.34059, -0.9025, 1.4366, 2.0743, 1.1223, 1.2806, 2.0824, -0.43128, -0.15485, 0.94029, -0.61514,
         0.80859, 0.94824, -1.9129, 0.49543, -0.83546, -1.3034, -0.60596, -1.1445, 2.54, 1.1285, -0.75028, 0.74111, -1.7864, -1.0632, 0.5705, 0.75964, -1.5346, -0.1248, 0.50176, -1.3496, -2.4076, 1.4007, 0.39023, -1.875, -1.3171,
         1.9825, -0.089699, -1.039, -1.9447, -0.47722, -1.4855, -0.53511, 1.3649, 0.66319, -1.4236, 0.6387, 0.47357, 0.35568, -1.6495, 1.4648, -1.7986, -1.8875, -1.6351, 1.2206, -1.0729, 1.7449, -1.6068, 1.6114, 0.84668, 0.1927,
         1.3433, 0.60785, 1.1331, -0.58761, -1.0575, -0.65455, 1.2777, 1.8111, -1.585, 1.4646, -1.6029, -0.85027, -0.63215, 0.9235, 1.3242, -0.94889, -0.70261, -1.3109, 0.96393, -1.3141, -1.9512, 1.2622, 0.43091, 0.79683, 2.4037,
         -1.9172, -1.4392, -0.99203, 0.81834, -1.2161, -0.90701, -0.48819, 1.461, -0.61465, 0.91666, 1.369, -0.70645, 1.293, -1.3245, 1.5029, 0.60713, -1.4176, 1.6985, 0.90189, 0.63411, 1.7841, -0.11408, 0.22095, -1.3491, -0.64097,
         -1.5332, 1.3294, 1.0674, -0.98173, -0.018119, -1.3133, 1.3, -1.1357, 0.65357, 1.1564, -0.21471, -2.1839, -1.5006, 0.75356, 1.1962, -2.0188, 1.6619, -1.3163, -0.56825, -0.87682, 1.2426, 1.6011, -0.28074, 1.7783, 0.60223,
         -0.68994, -1.7294, -1.1701, -0.80453, 0.85098, 0.88182, 1.8626, 0.80459, -1.3973, 0.65147, -1.4265, 0.68241, -0.87292, 1.0215, 0.48396, -1.5603, -1.9903, -1.9002, 2.054, -2.0069, -0.76289, -0.46395, -1.2088, -1.0825, -0.89923,
         0.015935, -0.24561, -0.11904, 1.0002, -0.56524, 0.72857, -0.050203, -0.78159, 0.67758, 0.85678, -0.36069, -1.6506, -0.19283, -0.77121, 1.8114, -2.4561, 0.40328, -2.315, 1.3559, -1.6252, 1.9872, 1.3342, -1.1989, 0.94303, 1.6286,
         -0.82841, 0.93875, 1.3799, -1.9386, -1.0913, 1.3993, 0.65513, -1.1644, 0.48785, -0.8596, 0.28457, -1.4724, -0.78888, -1.2005, -1.0087, 0.54992, -1.4858, 0.69399, -1.2815, -1.2035, 0.39087, 0.23531, -0.46408, -0.43673, 0.68784,
         1.0337, 0.48516, -0.71535, 1.8851, 0.91234, 0.21032, -2.5786, -1.2663, -0.34525, 1.3128, 0.6151, 0.50569, 1.0766, -0.48096, 0.59124, -2.6938, -0.25619, 1.2187, 1.2479, -0.45608, 0.19488, -0.45969, 0.87125, 0.32741, -1.0209,
         -2.2807, 0.82458, 0.43128, -1.1846, -0.25571, 0.83251, -1.1343, 1.7955, -1.1357, 0.67526, 1.3166, 0.80074, 2.0476, 0.90915, -1.6205, 1.5681, 0.98609, -1.8042, -1.9883, -0.27049, 1.911, 0.0017601, 1.5122, -0.5478, -1.1212,
         -1.3126, 0.46438, -0.041026, 0.88658, 1.8608, 1.2657, -0.40682, 0.7644, -1.1616, -0.22081, 0.59551, -1.1178, -1.788, 1.1619, 1.138, -0.53734, 2.0521, 0.81539, 0.79014, -2.4243, 0.16034, -1.183, -1.5153, 0.42093, -1.743,
         1.3665, 0.73174, 1.792, 2.4886, 0.69963, -0.45495, -1.2069, 1.9656, 1.0007, 1.1304, -0.41831, 1.133, 1.1526, 1.471, 2.0742, 1.4906, -1.7043, -1.8297, -2.3104, 0.69197, -0.38981, 1.4086, -0.50646, 0.23135, 0.66799,
         -0.86877, -1.6742, 1.6911, -1.3874, 1.334, 0.94151, -0.31544, -0.87931, 1.696, 0.98082, 1.1031, 0.22343, 2.1185, -1.3966, -0.95085, -1.4684, -1.0685, 0.37501, -0.34303, 0.33615, -1.9677, 1.6604, -2.8994, 2.3937, -1.1408,
         -0.33321, -0.065748, 1.0451, -1.2158, -0.7207, 1.7269, 1.5092, -1.3198, 0.034611, -0.81908, -1.2954, 1.0654, 1.6426, 0.83857, -1.5277, -0.24472, -2.0334, 0.47094, -1.4539, 0.49429, -0.46596, -1.5616, 0.98319, 1.6883, 1.7823,
         -0.32531, -0.25133, 1.3219, 0.0040781, 0.53557, 1.5694, 1.2041, -1.3573, 1.0963, -1.4042, 0.90469, 0.38933, -2.376, 0.30172, -1.2155, -0.44668, 0.13401, -0.66183, 2.9934, 0.063599, 0.14453, 0.66704, 1.5143, -1.3186, 0.37637,
         1.9314, -0.83478, -0.78047, -0.92571, -1.3034, 1.0788, -0.24369, -0.30361, 1.2994, 0.91141, -2.065, 1.3102, 1.9912, -0.56142, -0.48907, -0.75983, 0.63068, 1.6255, -1.1155, 1.3574, -1.5501, -1.1542, 0.97377, -0.18812, -0.46443,
         1.0788, -0.70467, -1.7992, 1.0491, -0.92985, 0.60233, 0.071472, 1.311, 1.1472, -0.25067, -2.159, -0.76237, -0.35528, -1.2041, 1.8048, 0.14899, -0.74075, -1.8651, 0.66409, -1.9116, 0.29017, -0.95914, -1.1503, -1.1863, -0.71947,
         -0.88647, -2.5236, -3.1391, -0.10987, -1.5158, -0.53976, -1.1178, 0.064587, 1.0261, 0.42049, -0.80893, 2.1648, 1.5308, 0.21526, -1.3329, 1.2544, -0.0044439, 0.40652, -1.1096, 0.0019624, 0.4276, 0.44399, -0.78752, 2.0543, 1.4378,
         -1.6366, 1.7445, -0.74773, 0.7202, -1.0864, 0.33812, 0.1401, 1.2207, -1.2766, -1.2992, 0.84279, 1.2699, -1.0376, -0.34249, 1.2296, -0.29268, 1.3748, -0.57277, -0.061318, -3.0993, 1.5794, -0.27701, -1.0681, 2.2468, 1.7285,
         -1.148, 1.1357, 0.71227, 0.75685, 0.89418, -0.87444, -1.0585, -1.6221, 1.9056, -1.063, -1.4354, -0.42924, 1.3616, 0.49948, -0.49417, 0.69844, 0.12404, 0.36793, 0.718, 1.0303, -0.11678, 0.77362, -0.75223, 0.13247, -0.59196,
         0.48106, 0.20021, -1.1742, -0.61923, 0.94816, 0.53016, -1.2423, 1.0251, -1.4495, -0.9768, 0.44556, -0.2764, 2.0853, -0.70259, 1.6729, 0.2636, -0.83929, 1.3816, 1.7802, 2.1469, -1.0382, -1.4658, -1.6405, -0.46309, 0.43847,
         1.5975, -0.3885, 1.2515, -0.64759, 0.050534, 0.65082, 1.4856, 1.7903, 3.4788, -0.29188, -1.1668, 1.3938, -0.83722, 1.0374, 1.113, -0.33395, 0.61351, -1.3928, 1.6028, 0.13458, 1.607, 0.26029, 0.015732, -1.1744, -0.32556,
         0.035566, -0.69018, 0.80875, 2.3475, 0.90792, -1.4826, -0.92017, -1.1277, -1.2892, -0.54485, 1.0426, -0.95918, -1.7991, 1.0587, 0.75932, -0.6014, 2.1863, 1.1343, -0.25421, 0.81637, 0.2116, -0.6721, -1.2381, -0.7628, -1.4893,
         1.3514, 1.3117, 1.6437, -0.40885, 1.3383, 1.9912, -0.16583, -0.91639, 0.66585, -0.83338, 0.64274, 0.96837, -2.0549, 1.5405, -1.4622, -0.09051, -0.3071, -0.96021, -1.3121, -0.52272, 1.1191, 0.949, 0.82913, -1.584, 2.292,
         0.17078, -0.82027, 0.41865, -0.44662, -0.66306, 0.038818, 0.12478, -0.28611, 1.4757, -1.1448, -0.41797, 0.26953, 0.94633, -0.45794, 1.3732, -0.21072, -2.9876, 0.3067, -1.9307, 1.0659, 1.4121, 0.057546, 0.09172, 0.55842, -1.5802,
         0.20023, -1.4089, -1.1429, 1.005, 0.31216, -0.54911, -1.5081, 1.7388, -0.98657, 0.86465, 0.87773, -2.1158, 0.086248, -0.5818, 0.075622, 1.1688, 1.0532, -1.4084, 1.2039, 0.86285, -1.1086, -0.37248, 1.4812, 0.75859, -1.5162,
         2.0778, 1.8227, 1.8637, -0.60287, 0.94138, 0.74895, -1.6683, -1.1123, -1.3839, -0.41697, 1.1529, -0.94878, -1.5565, -0.70753, 0.55825, -1.0277, 2.1259, -1.5847, 0.44432, 2.1541, 1.0776, 0.88951, -3.0584, -0.79456, -1.0407,
         0.41268, 1.0956, 1.0017, -1.6684, 0.90103, 1.3392, -1.5555, -0.7981, 0.88201, 3.0842, -0.12134, -0.25837, 2.1572, -0.18789, 0.40542, 0.61072, 1.8039, -1.7231, -0.9507, 0.85239, 0.24679, 1.4939, -2.7163, -0.60505, -1.1197,
         -0.3717, -0.61998, -0.70256, -0.06944, 0.97041, 1.7111, 1.0127, -1.638, -0.55472, -0.79392, 1.7138, 0.83595, -0.02371, -0.64551, 0.43091, 0.86407, 1.9072, 0.60859, -1.0652, -1.7692, 1.6121, 0.81521, -1.5844, -0.33197, -0.83153,
         0.98068, -0.91559, 1.3058, 2.1824, -1.0897, -1.2475, -0.94656, -0.75326, 0.44985, 0.90403, -1.0152, -1.1388, -1.0554, 1.4094, -0.13384, -0.46324, 2.2572, 1.132, -0.59192, 1.3963, -1.0102, -1.2085, 0.2243, -0.53775, 1.9741,
         -1.2812, 0.97187, 1.1701, 0.52528, 0.44316, 1.521, -0.53896, -0.80425, -2.0942, 2.214, 0.20247, -0.26817, 1.3785, -0.43762, 1.9898, -1.8873, -1.3062, -1.0232, -0.33846, 1.6385, -0.42282, 0.53591, 1.8523, 0.41142, -1.18,
         -0.25199, 0.51145, -0.69926, 2.0972, 1.0446, -0.43954, -0.7291, 1.4857, -1.447, 1.1709, 1.0384, -0.45463, 1.3622, -0.27709, -1.7531, -2.2264, -0.80153, -1.668, 0.71204, 1.493, -0.026798, -2.9719, 1.2435, -1.0206, 2.1795,
         0.91204, -0.61772, 2.0557, -0.80029, -0.42011, -0.1815, -0.87172, 2.6013, -1.1853, 1.5877, -0.69178, -1.9866, -1.977, -0.68139, 0.18052, -1.6428, -0.88489, 0.087536, -0.75681, -0.5601, -1.683, 0.81772, 1.5777, -0.26712, -0.94276,
         -1.6855, 0.72961, -2.2685, -0.63105, -0.82874, 1.394, -1.2503, 2.6237, -0.93221, -1.1799, 0.17877, -2.4353, -0.5356, -1.3577, 1.2664, -2.1193, -0.96274, -1.6157, -0.62083, -1.0168, 1.0769, 0.62979, 0.26195, 0.31385, -0.9873,
         -1.107, 1.5773, -1.8522, -0.80502, 0.0031343, -1.2238, 1.0047, 2.3057, 0.36198, -1.8413, -0.087123, -2.3933, 0.36698, -0.36872, -1.3146, 1.7336, -1.0274, 1.2629, 0.86537, 1.1205, -2.0451, 0.64326, 1.0355, -1.4209, 0.51706,
         -0.20083, -3.2153, -0.40988, -0.75494, -2.5364, 1.9772, -1.8794, -0.98397, 0.71316, -1.8232, 1.2494, 1.4923, 1.3689, 1.0944, 0.79522, -0.022898, -0.86803, -0.64402, 2.3749, -1.3602, -1.8076, -0.52133, 0.91368, 0.10276, -0.41945,
         -1.1225, -0.60312, 1.2943, -1.2219, -1.8382, 0.47427, -0.84952, -2.1107, -0.34447, 1.9162, 1.8029, -1.1631, 0.76066, 0.87885, 0.37677, -0.89693, -0.49093, 0.99514, -0.97487, -1.6749, 0.067413, 2.2456, -0.53506, -0.16468, -1.3496,
         -1.1317, -0.19991, -0.63242, -2.0948, -0.19102, 0.76614, 1.5116, 0.90533, 0.62258, -1.9151, 0.48483, -0.35793, 0.99278, -0.52734, 1.7452, 0.88462, 0.23801, 0.87862, -0.18577, 0.74956, -1.2688, 0.86175, -0.14524, 1.1268, -0.30723,
         2.1255, -0.94455, 1.0474, -1.9007, -0.61238, -0.50906, -1.7634, -1.9633, 2.3225, -1.6609, -0.35328, -1.7069, 0.4677, -0.11144, -0.2912, 2.7643, 0.24422, -1.0496, 0.88509, -0.64983, 1.9666, -0.55404, -1.1267, -0.95609, -1.5021,
         -0.59903, 1.3028, -2.5191, -1.1883, 2.4582, 1.1075, 0.046375, 2.4434, 0.84833, 1.1179, 0.54961, -0.76779, -0.72868, -0.6473, -1.0964, -1.1772, -0.96118, -1.8347, 0.23701, -1.7476, -0.024753, 1.6439, -0.59759, 1.5988, 0.76945,
         -0.46273, -0.55609, -1.0978, 0.069773, -1.0671, -0.11593, 0.8734, -0.97005, 1.1074, -0.052496, 1.4841, -0.028513, 0.48498, -0.62757, -1.3092, 1.1863, 1.438, 1.2929, 0.12905, -1.6878, -1.2396, 1.2229, -0.40376, -1.336, -1.5835,
         2.1412, 3.0452, -1.7624, 1.967, 0.2439, -0.22084, -1.5187, -1.9538, -1.0552, -1.0646, -0.26395, -1.6938, -1.6763, 1.4663, 0.78534, -1.1372, -1.9844, 0.31452, 1.3698, -1.5298, 0.55999, -0.29632, -0.60225, 0.6453, 0.67081,
         -0.1395, 1.1611, -0.71359, -0.90115, -0.65688, 0.31831, -1.1585, -2.1238, -1.6192, -0.8194, -0.61238, -0.076846, 2.5149, -1.006, -0.44345, 0.65015, -0.79193, -0.68669, 0.80485, -1.7505, 0.95372, -1.0853, -1.8771, 1.5705, -0.80972,
         -0.78947, 1.4784, 1.0169, -0.64387, -1.8041, -0.55988, -0.2412, -1.0065, -1.9682, 0.33928, 1.3776, -0.39829, 0.71084, 1.7794, -0.088566, 1.2768, 0.8251, 0.70099, -0.75072, -1.2502, -1.3076, 1.0148, -0.60978, 2.3681, -0.011132,
         1.0477, -1.3971, 1.208, -0.25391, -1.304, -1.2674, 1.0567, 0.97206, -0.54556, -0.058856, 1.9899, -0.36319, 0.51836, 0.54586, -1.5897, -0.96612, 0.22032, -0.55525, -1.1443, -1.7451, -1.3051, 1.1038, -1.2251, -1.3126, -1.0132,
         0.58056, 0.60984, -0.46798, 0.91103, -1.289, -0.81944, 1.0779, 0.91849, -2.1295, -2.1827, -0.96955, -0.8817, 0.030583, 0.59061, 2.2537, 1.6947, -2.1467, -1.9371, 1.2577, 1.8386, -0.32548, 0.87443, -0.40292, -0.73775, -3.039,
         -1.2353, -1.5877, -0.32102, -0.21791, -0.73864, 0.78195, -1.5256, 0.9171, 1.0267, 1.5929, 1.248, -0.48088, 1.1451, 2.068, 1.0137, 1.3141, -1.9337, 1.1832, 0.14649, 0.40456, 1.3936, -1.5416, -1.5582, 0.67664, 0.50201,
         0.46201, 2.1292, 2.7309, 1.09, 1.1096, -0.89082, -0.59522, -1.1382, 1.7899, 0.34296, 0.2964, -0.93824, 0.32687, -0.78084, -1.4958, -2.696, 0.1214, -0.77296, -1.356, -0.27393, -0.58929, -1.9314, -0.7619, 0.15545, 1.7018,
         -1.1348, 0.57267, -1.7733, -0.5693, 0.33791, -1.3385, -1.6026, -0.93886, -0.028635, 0.53192, -1.7868, 1.5035, 1.3058, -0.17245, -1.8487, -0.79235, 0.96785, -1.7902, 0.9591, -1.3157, -1.0872, -0.41657, 1.4383, 0.19167, -0.82032,
         0.17708, -0.4742, -0.5938, 0.53987, 2.6237, 0.3511, 2.5358, -0.87416, -2.3005, -1.4328, -1.2937, 0.17762, 0.98144, -0.48159, 1.8285, 0.47247, 0.11176, 0.21646, -1.6319, -1.8004, 1.3081, -0.6988, -0.019755, -0.6338, 0.31769,
         0.98304, 0.61297, -0.35551, 0.35984, -1.8054, -0.081862, 0.40051, 0.35552, 0.61534, -0.068709, 1.2752, 0.99015, 0.0007881, -1.3267, 0.56528, -1.7735, 0.25985, -0.94359, 1.0728, 3.0852, 1.2738, 0.062698, 0.50994, 1.2722, 0.27816,
         -1.2751, 0.19063, 0.40501, 0.96474, 1.3062, 2.1108, -1.221, -1.6466, -0.15381, -1.8648, 1.3721, -0.58228, 1.1729, 0.83754, 1.3476, -1.7122, -0.70435, -1.3967, -0.080135, -0.80478, 1.3271, 1.7864, -0.35976, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };

char raw_1024_12[1024] = {
        0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
        1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
        1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1,
        0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1,
        0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1,
        1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1,
        1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0,
        0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0,
        1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
        1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0,
        0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0,
        0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1,
        1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1,
        0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0,
        0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0,
        0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0,
        1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1,
        1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0,
        0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1,
        0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0,
        0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1,
        0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1,
        0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1,
        0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0,
        1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1,
        0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0,
        0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1,
        0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1,
        0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1,
        1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
        0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0,
        0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1
};

ldpc_dbl r_1024_23[1792] = {
        -1.2302, 1.2303, -0.73713, 1.6895, 0.74086, 0.72018, -1.5705, 1.6433, -0.99331, 0.21686, -1.2037, 0.51564, 0.13912, -0.89098, -0.56477, -1.4055, -1.3376, 0.76543, 1.0148, -2.0463, 1.793, -0.42326, -1.352, -1.9331, 0.039075,
        0.57061, -1.2565, -1.26, 0.30931, -1.661, -2.3174, 0.65102, -1.591, -1.4933, -0.58635, -0.61393, 1.3864, 0.87697, 1.6659, -1.5412, -1.6589, -2.2395, 0.22092, -1.5971, 1.1572, -0.87097, -0.22305, -0.99281, -0.36085, -0.74219,
        -0.94445, -1.1121, -0.20304, 0.5858, 1.3112, -1.5427, -0.071962, -2.0362, 0.67529, 1.8735, -0.34111, -1.8425, -0.52202, 0.81728, -1.4197, -1.8525, 0.8545, -0.60533, -1.2268, -1.339, -0.9375, -0.33082, -1.4252, 0.99815, 0.89797,
        -0.59086, 0.32453, -0.58272, -0.66304, 0.89957, -1.8999, -1.1776, -1.1311, 1.0392, -0.99037, 0.99759, 1.5625, 1.5866, 2.4422, 0.83384, 0.86703, 1.3321, -0.9395, 1.8407, -0.88031, 1.4123, 1.7741, 0.18829, 0.48713, 0.27739,
        -1.6497, 0.59755, -1.0765, 1.0389, -1.365, -2.5076, -0.86543, -1.6985, 1.0346, -1.6394, -2.0995, 0.89479, 0.042333, 0.39379, -1.5993, -1.3876, 1.8612, 1.3295, 1.6911, -0.7698, -0.93063, -1.7053, -1.2629, 1.2765, 0.13771,
        1.6636, 1.0366, 0.70484, -1.0926, -1.4155, 0.20347, -1.4399, 0.84762, 1.5407, -1.0542, -1.4983, -2.1401, 0.25899, 0.72874, 0.93974, -0.87982, -0.59849, 0.73163, -0.49851, -0.95905, -1.0603, 1.3134, -0.48443, -1.0461, -1.7126,
        1.0584, -1.8988, 1.8046, 1.1166, 1.615, -1.0985, 1.1079, 0.39276, 0.8317, -0.86837, -1.6684, -0.3858, -0.487, 0.62884, 1.4348, 0.8467, 1.194, 0.10575, 1.7873, -1.3012, -0.9293, -1.8909, -1.0121, -0.47004, -1.3467,
        -1.0372, 1.862, -0.76938, 1.5802, -0.49958, -1.1709, -0.48867, -0.65602, -0.85208, -0.90452, 1.6488, -1.3916, -1.0751, 0.6561, -1.981, 0.67604, -0.7676, -1.7593, 1.0015, -0.64561, 0.6329, -0.05761, 0.97757, -1.2577, 1.4403,
        -0.6883, -1.2202, -0.68381, -1.1043, -1.1435, -0.76984, 0.13107, 1.1025, 1.3532, 0.19603, 0.40617, 0.16631, -1.2568, 0.89003, -1.4552, -0.096944, 1.1787, -1.0727, -0.25924, -0.54379, -1.1014, -1.8507, 1.7944, -1.0158, 1.7608,
        0.18327, -1.0305, 1.053, 1.673, -1.6113, -1.042, 0.9929, -1.3692, 0.15701, -0.36002, -0.47314, -1.8576, -0.5353, 0.96142, 0.73778, -1.2544, 1.2344, -0.42996, -1.1422, 0.4612, -1.4833, -1.6815, -0.60897, 0.67512, -1.0406,
        -0.71343, 0.86696, -0.57972, 1.7833, 1.3039, -0.38402, 1.642, -1.2298, -1.2458, -0.59708, 1.2691, 0.9132, 1.7542, 1.191, -1.0957, 0.62338, 0.12539, -0.65164, 2.163, 2.3085, 1.5333, 1.3568, -1.0479, 0.87131, 1.0537,
        0.33887, -1.1966, 0.76385, -1.1585, -0.95099, 0.2757, 0.13629, 0.34758, -0.33341, 2.274, 0.66897, -1.12, -1.0962, 0.2795, 0.6253, -1.4647, 0.75343, -1.2654, -0.78838, -0.75457, 0.94347, -0.087717, 1.6804, -0.54339, -1.0365,
        -0.42443, -1.2352, -0.26683, 1.0927, -1.7986, -1.3329, -1.0888, 0.6101, 0.71532, -0.39424, -1.3106, -1.6743, 2.5993, -0.60457, 0.1375, -0.29547, 0.62499, 0.50806, -0.42846, 1.5624, 1.4687, -0.27548, 1.321, -1.3202, 0.22653,
        1.7289, 0.56304, 1.05, 0.33309, 0.63571, 1.0329, -1.156, -1.4168, 1.5445, 0.14144, -1.3529, -1.7222, -1.0047, -2.2608, -1.905, -0.61935, 0.64822, 0.46678, -1.3861, -0.55751, 1.2996, 1.133, 1.5599, -0.72869, 1.3793,
        0.96213, 0.44828, 1.5927, 1.4885, -1.1569, 1.8418, -0.27306, 0.96024, 1.1255, -0.050417, -1.0788, -0.025002, -0.76807, -2.5846, 0.38565, 0.82535, 0.89758, -0.12394, -0.3422, 0.91071, -1.1488, -0.2629, 1.0974, 1.7676, -0.81554,
        -0.65487, -1.7358, 0.18461, -1.7223, -1.1334, -0.2475, -1.6979, -0.8058, 1.691, 2.0559, -1.3642, 0.35925, 2.053, 0.66555, -1.2965, -1.4504, 1.4728, 0.88654, 0.94353, 1.416, -0.86257, -0.01286, 0.91502, -0.64336, 0.68323,
        -1.2763, 1.6344, -0.51499, 0.2496, -1.5288, -0.89595, -0.47407, -0.72872, 0.49045, 0.9889, -0.5959, -2.0499, -1.046, -0.17169, 0.98017, -1.8647, 1.2226, -2.8756, 1.4233, 0.25801, -2.2159, 0.89911, 2.026, 2.0389, -0.81537,
        -1.1992, 1.4368, -1.2574, -0.39906, 0.28089, 0.23351, -1.1022, 0.67286, -1.5627, -1.4689, -0.45303, 1.5619, -0.97177, 1.0341, -1.3274, 0.93972, -1.3784, 0.91428, -1.0144, 1.0923, 0.70081, -1.5389, -0.13168, -1.9929, -0.84383,
        0.84707, 1.5135, 0.65271, 0.49975, 1.3628, 2.1452, 1.3463, 1.4775, 1.7381, -0.75176, 0.86827, 1.1086, 1.6318, -1.3451, 1.1019, 0.047098, 1.4284, -1.3326, 0.2962, -1.0201, -0.71414, -0.36017, -0.5014, 0.94153, 0.89321,
        -0.86534, -0.33588, -0.84867, 0.24413, 0.64393, 1.1959, 1.2445, 1.9297, 0.47142, -0.92003, -0.79473, -1.7515, -1.1032, -1.1289, 0.77506, 0.05804, -1.4679, 1.682, -0.95701, -1.4528, -0.93189, -0.91794, 0.42634, 1.2018, -1.2735,
        -1.348, 1.539, -0.87886, -1.471, 1.3022, 1.5056, -0.24612, -0.61749, -1.6887, -1.5278, -1.083, 1.2604, -0.80356, 0.040226, -1.5235, 0.70721, -0.75806, -1.1945, -1.0439, -0.72845, -0.58859, 1.7208, -0.71401, 1.822, -1.2547,
        1.4608, -1.1848, 0.106, -0.70611, 1.3789, -0.49942, 0.32062, -1.1243, -1.0928, -1.6521, -0.87082, -0.65487, -2.0347, -1.2005, 0.54417, -0.14271, 0.49661, -1.2085, -1.4004, -2.1622, -0.39151, 0.54027, -1.2784, -0.68409, 1.1863,
        0.74805, -1.2363, -2.2167, 0.86396, -0.21902, -1.0263, 0.85348, -0.091678, -1.3471, 1.1089, 0.72745, 0.2827, 1.8403, 0.29473, 1.8131, -1.3411, 0.80311, -0.036482, 1.5351, 0.68512, 0.82259, 0.74958, 1.761, -0.76197, -1.1529,
        -0.1013, 1.2414, -2.1025, 0.99844, -1.1505, -0.21951, -1.0118, 0.17211, -1.3671, 0.7392, -1.4385, -0.49392, 1.4283, 1.4112, 2.4531, 0.38824, 1.5873, 1.5326, 2.0875, -1.5532, -0.99388, 2.0369, -1.0747, 1.8016, 0.67813,
        1.1462, 0.77227, -1.3467, 1.006, -1.6603, -0.66258, 0.94843, -0.82286, -1.2667, 1.6507, 0.15711, -0.054021, 0.95491, -0.9935, 0.14382, 1.1987, -0.34547, -1.3409, -0.62017, -0.84072, -2.36, 1.4812, 0.78183, 0.17782, -1.4882,
        0.64747, 0.2391, -2.3753, 2.1831, 0.89801, -0.71504, 0.77239, -1.835, 0.71557, -1.4623, 1.3726, 1.0515, 0.24452, 1.0822, 0.68117, -0.69186, 1.7926, -0.60798, 0.47168, -0.61946, -1.4277, -0.0069245, -1.4694, -0.49032, -0.941,
        1.1445, -1.5401, 0.135, 0.085024, -2.3421, 0.6968, -1.564, -0.66449, -0.77991, 0.65755, -1.8741, 1.7651, -1.1422, -1.007, -0.2931, -0.75385, 1.1568, -0.34209, -0.74904, 1.6675, 0.5592, 1.0127, 0.035172, 0.93642, -1.2138,
        -0.90398, 0.77158, 0.64033, 1.5194, 0.21967, -0.85659, -2.2566, -2.1681, -0.71684, -0.36896, -0.80044, -1.0995, 1.7242, -2.0867, -1.2432, -1.6632, -1.3101, 1.7279, 0.88076, 1.1477, 1.1916, 2.0076, 1.2273, 0.95681, 1.7374,
        -0.79188, 2.4579, 0.78217, -0.28951, -1.3424, 1.1663, -0.46199, 0.69009, -0.58019, 1.1494, 1.0281, 1.1566, 0.84734, -1.0834, 2.6287, -1.0083, -1.1413, 1.7325, -0.97628, 1.7927, 0.84519, -2.6566, 0.35934, -0.6328, -0.90163,
        1.0568, -1.3299, 0.57834, -1.9369, -0.53322, 0.96598, -1.2056, 1.6646, 0.19414, -0.47995, 1.7301, -1.1807, 1.5329, -1.254, 0.54825, 1.0319, 0.26088, -0.43585, 1.824, 1.076, 1.2415, 1.5051, -1.0182, -0.95338, 0.9515,
        -0.78453, 1.3754, -1.3434, 1.9965, 0.59766, 1.0981, 1.6996, 0.15559, 1.3234, -1.2742, 0.13309, -1.4062, -1.3059, -1.1444, 1.3661, -1.3702, 2.3474, 0.78843, 0.82707, 0.65175, 0.4798, 0.56307, -0.19165, 1.0446, -1.3794,
        0.62455, 0.43694, -0.30524, 2.2835, -1.4062, 0.22971, -0.65347, 1.201, 1.4228, -0.69028, -0.39487, 1.7345, -1.8121, -1.4772, 1.1379, 1.9477, 0.77834, -1.503, -1.4288, -1.8952, 0.44398, -0.77038, -1.6013, -1.1132, -0.79172,
        0.86979, 1.1189, 1.2139, 0.081379, -1.0548, -2.4222, 1.9072, -1.2014, -1.8791, 0.83342, -1.555, -1.0672, -0.6348, -1.3255, 1.7472, -1.173, -1.4208, 0.63485, -0.11061, 1.5122, -1.4103, -1.6693, 0.90615, 0.38378, 1.9656,
        -1.2982, -1.1772, 1.2571, -0.36009, -1.1047, -0.066442, 0.17124, 1.1947, 0.64639, -0.62504, -0.5884, -1.7775, 1.4778, -1.592, -2.1327, 0.69828, 0.6408, -0.4687, 0.85225, 3.0341, 0.26521, 0.24681, -0.40357, -0.89939, -2.0325,
        0.53543, -0.18304, -1.3846, -0.96474, 1.1694, 1.0328, 1.9448, -0.98575, 0.13983, 0.58306, 1.7781, 0.18564, -1.5813, 2.0697, 1.4898, 1.561, 1.6125, -0.75963, -1.4654, 1.3504, 0.36599, 0.98119, 0.19257, -1.5536, -1.3206,
        0.90055, -0.38135, 0.17799, -1.2605, 0.46967, 0.99381, 1.133, -1.1775, -2.5519, -0.89121, 0.12561, 0.60456, -1.5696, 0.8398, 0.68612, 1.4831, 0.89818, -1.3623, -1.1756, -1.2065, -2.506, 0.74513, 0.79875, 0.69289, 1.3361,
        -0.71097, 1.0108, 0.18875, -2.4358, 0.50482, 0.90871, 1.1331, -1.4363, 1.211, -0.21549, -0.77014, -2.1825, 1.0526, 1.3438, 1.1616, -0.12673, -1.2626, 0.7232, 0.65679, -1.9825, 1.2099, -0.89, -1.0452, -0.44886, -1.1754,
        -1.2309, -1.9128, 0.52183, 0.72493, -0.35618, -2.2311, 0.20513, -1.2987, -0.010782, 0.037648, -1.118, 0.80594, 1.7214, -0.35676, -1.1099, 1.62, -0.50495, -0.03675, -1.3178, -1.8292, 0.5648, 0.1276, 0.49024, 2.3654, -0.30139,
        0.83193, 0.065704, -0.73658, -0.81748, -0.42858, 1.3493, -1.7803, 0.0014969, -0.86365, -1.4864, 0.54756, 0.83585, 1.0629, -0.76886, 1.0947, 1.1358, -2.2687, -0.92616, 0.14685, 1.6823, 0.16435, -0.27847, 1.1358, -0.046669, 1.3649,
        1.1782, -0.83251, -1.8564, -1.2993, 0.74696, 0.915, -0.27436, -0.8363, 1.7217, -0.77313, 0.98179, 2.1077, 0.31706, 2.6174, 1.7498, -1.6489, 1.1357, 0.96412, 1.4949, -1.6746, 0.070403, 2.618, -1.54, -0.27311, 0.58846,
        0.98336, 1.0128, 1.3539, 0.54421, 1.0422, 0.6738, -0.52794, -0.99913, -1.0156, 2.2088, 1.2008, -1.1041, 1.0712, -0.8338, 1.2955, -0.68484, -0.94231, -0.17862, 0.48354, -2.6932, 0.66033, 0.35945, 1.9851, 0.75953, 0.12671,
        1.7986, 0.18136, 1.2816, 1.935, -0.81504, 1.7342, 0.5895, -0.95382, 0.16566, -0.70138, 1.1096, -0.96052, 0.90531, 0.36447, -0.95867, -1.0686, -1.0049, 0.95937, -0.74427, -1.4349, -0.35983, 0.1738, 0.85761, -0.5398, 0.073119,
        1.3063, -0.44705, -0.48149, 1.0312, 0.32425, 0.023033, 1.5641, 0.9485, -2.5457, 0.7794, -1.5654, 0.86778, 1.1707, 1.6687, -0.10077, -0.4567, -1.0589, -1.306, -1.8817, 0.13362, 0.69775, 1.5183, -1.6351, 1.105, -1.2928,
        1.1829, -1.2509, 1.0891, -1.0583, 1.6062, -0.16045, 1.1101, -0.82532, 0.81326, 0.28573, 0.77786, 0.39088, 1.1451, 0.2325, -0.84754, -0.48663, 0.86528, 0.63166, -0.35483, 1.0064, 1.1276, 1.0836, -1.0669, -0.95859, -0.91582,
        -0.5135, -0.6196, 1.4159, 1.1841, -0.47492, -0.31467, 0.52189, -1.2672, -0.62837, -0.55266, -0.0014049, -0.93221, 0.36134, 0.5745, 1.358, 0.86881, -0.060959, -0.69523, -0.21252, 0.65166, -1.7653, -0.17151, -0.76727, 0.69071, 0.5167,
        -1.4573, -0.0038942, 0.84638, -0.36903, 0.69203, 0.82337, 0.49052, -0.20793, 0.52884, 0.11039, -0.75013, -0.95196, -1.3203, 1.1304, 0.86449, 0.35576, 0.65766, -1.474, -0.2322, 1.4635, -1.1304, -0.72701, 1.8149, 0.2721, -1.4819,
        2.175, 1.4258, 0.93079, 1.0759, -0.51297, 0.31035, -0.070331, 1.7079, -0.25343, 0.17138, -0.87942, -1.1329, 0.67385, -1.0877, 1.092, -0.85951, 0.84645, -0.52927, 1.3576, 0.84402, 0.71117, 1.3875, 0.13349, 1.5779, -1.4485,
        -1.8216, 0.5048, -0.14636, 1.3129, 0.15517, 0.66391, -1.3072, 1.0926, 0.81107, 0.42074, -0.89493, -0.79456, 1.0036, -0.74402, 1.5445, 0.14031, 0.88064, -1.3135, 1.2396, -0.37881, 1.5203, 0.26249, 1.1034, 2.0965, 1.1464,
        -1.4602, -2.1875, 1.4673, -1.1011, 0.06169, -1.1432, 1.9746, -0.95556, -0.6423, -0.13942, 1.0704, -1.6799, -0.39118, -1.3959, 1.6677, -0.7235, 0.040618, 0.71813, -0.67891, 1.2464, -0.72621, -1.0991, 1.5684, 1.2084, -1.1904,
        1.2403, -0.80181, -0.73457, 1.3363, -0.81624, 0.35625, -1.7677, -0.30545, 0.8029, 1.7937, -0.75877, -1.6823, 0.74204, -0.93055, -0.96278, 0.10452, -0.85235, 0.97168, -0.60414, 0.94242, 1.3327, 0.79206, 2.021, -1.0084, -0.4028,
        -1.3261, 0.72407, 0.30973, -1.6874, 0.40657, -1.6144, 1.1717, 0.31535, -0.76266, -0.27144, -0.40753, 1.1014, 1.3227, 2.0162, 1.9834, 0.61904, -1.651, -1.062, -1.005, 0.39686, -0.68231, 1.1011, 1.6683, -1.0798, -1.2242,
        0.31078, -2.3835, -0.57642, -0.36976, -1.3482, -0.57704, -0.94179, 0.26902, -0.67962, 0.58185, 1.4507, -2.0313, 2.0282, -0.1083, -2.0533, -1.4959, 1.0017, 0.53539, 1.2618, 0.48398, -1.3557, 0.8996, -0.93906, 1.189, 1.2502,
        1.5722, -0.32196, -0.13703, -1.2913, 0.73226, -0.33908, 0.29254, -0.65458, -0.21483, 0.3992, 0.29194, -0.13414, 2.2467, 1.4006, -0.91014, 1.6898, 1.015, -0.75863, -0.41079, -1.0622, 0.58201, 0.048488, 0.72252, -2.1979, -0.6971,
        1.3297, -1.4575, 0.67511, 1.2743, 2.1861, 0.69409, -1.2422, 0.3371, 1.8915, 0.73947, 0.95366, -1.0582, 0.21909, -1.1033, 0.36288, -1.7026, 0.75933, -0.52157, 0.80686, -1.0717, 1.3556, 1.1387, 1.0362, -0.74518, 1.4343,
        1.0507, -1.7926, 1.0279, -0.67098, -0.974, -1.7014, 0.047197, -1.3644, -0.46728, -0.47463, 0.16495, 0.89964, 1.7531, 1.0315, -0.76474, 0.78425, 0.30806, 0.73716, 0.90165, 0.45113, 1.3711, 0.93176, 1.6422, -1.9943, -1.0647,
        2.5426, -0.72242, 1.3114, -1.0824, -0.47936, 0.98411, 1.8404, 0.092354, 0.66066, 0.29249, 1.9731, -1.9461, 1.9389, -1.0534, 1.5663, -0.35828, 0.75935, 1.897, 1.2012, 0.62182, 0.63494, 1.9939, 0.86765, -0.30557, 1.6957,
        -1.4531, -1.3235, -1.5369, 0.8246, -0.9851, 1.0075, -1.6013, 0.44427, 1.5639, 1.5638, 0.87476, 1.3904, 0.03981, -2.5854, 0.59235, -0.10933, 1.3993, 1.4545, -1.8585, -0.20776, -1.6542, -1.5059, 0.44861, -0.88198, -1.7772,
        -0.94413, -0.39532, 0.87938, 0.12129, -0.79133, 0.92096, -0.57133, 1.4721, -0.90329, 0.60971, 0.57988, -0.66801, 1.5609, -0.30069, -1.5126, 0.87857, -1.3729, -0.67877, 0.26243, -1.9511, -2.0362, 0.83259, -0.078403, 0.44211, 1.2139,
        -0.37272, 1.006, 1.3007, 0.34538, 1.1113, -2.5564, 0.43565, 1.0407, -1.1649, -0.17765, -0.81407, -0.94728, -1.1733, 0.54298, -1.61, 3.2176, -1.1747, 2.304, 1.1152, -0.69625, 1.2955, 1.9934, -0.83669, -1.33, 2.1282,
        -0.16138, 0.48958, -0.47616, -0.34748, -0.1764, 1.0171, 0.5566, -0.61804, -0.41831, 1.1427, 0.089885, 1.5753, 0.75479, -1.2968, -0.58516, 0.74779, -1.3511, -1.0486, -0.76808, 0.21197, -1.8921, 0.74456, -0.61882, 0.23289, 1.6431,
        1.8614, 1.3974, -1.5044, 0.19858, -0.39268, -0.96809, -1.0249, -1.6419, -2.2243, 0.18271, 0.85351, -0.88017, 0.75562, -0.96121, 1.5047, 0.59919, 1.6632, -1.1713, -0.71706, -0.56211, -1.1572, 1.5299, 0.31217, -0.60415, 2.0858,
        1.0161, -0.13736, -1.0855, -0.40657, 1.5694, -1.2479, 0.59748, -0.72919, -1.2901, 0.18509, -0.77545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

char raw_1024_23[1024] = {
        0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
        0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1,
        0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
        1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1,
        1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0,
        0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1,
        1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1,
        1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1,
        1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1,
        0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
        0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0,
        0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0,
        1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0,
        0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1,
        1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0,
        1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0,
        0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0,
        1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1,
        0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0,
        1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
        0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
        0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0,
        1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
        0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0,
        1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1,
        1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1
};

ldpc_dbl r_4096_45[5632] = {
        -0.52819, -0.45341, 0.36673, -0.69317, -0.55042, -1.8846, -0.033055, -0.72408, -0.90287, -1.1826, -0.64471, 1.1545, 1.3406, -0.93636, -1.145, -1.9174, 0.62762, -0.20168, -1.0127, 0.84226, 0.72122, -1.3876, -1.2357, -0.10423, -0.16755,
        -0.65922, -0.21383, 1.0952, 1.2702, -0.078592, -0.26143, -1.3566, 0.23971, -2.4706, -0.46235, 1.054, 1.5246, 1.5467, -0.26741, 1.5945, -0.82571, 1.6348, 1.5198, 0.72966, 1.0181, 0.54809, -0.57005, 0.26456, 0.56776, -0.2826,
        -0.89608, 0.76577, -1.2681, -0.27173, -0.43459, -2.0484, 2.3363, 1.8085, -0.9859, -0.072948, -0.39037, -0.99354, -0.87791, 0.091297, -1.6914, 1.7211, -1.9235, -0.80325, 0.60924, 0.88494, 0.65521, -0.3854, -0.80288, 1.1477, -0.76573,
        -1.0452, -1.0954, -1.2892, -0.05979, -1.361, 0.8226, 1.305, -1.7184, 0.57622, 1.2718, -1.0776, -0.95585, 1.5888, 0.63798, -2.3792, 1.3129, 1.7061, -0.33267, -0.47997, 0.11862, 1.6213, 0.68684, 1.0943, 1.5051, 0.2578,
        -0.50561, 1.6136, -1.478, -0.17104, 1.1118, -0.75071, -0.66739, -1.479, -1.07, 0.2089, 0.78925, 2.2979, 1.4287, 1.0873, -0.23438, -1.5118, 1.2661, 1.5587, 0.13292, -0.36466, -0.71013, 0.9647, 0.79528, -0.13742, -1.9963,
        -0.64954, -0.95536, -0.93809, 0.68746, -1.4103, -0.69626, -1.5572, 1.6531, 1.0985, 0.85064, 1.6848, -0.026874, 1.2855, -0.54177, -1.3469, 2.1112, 0.11951, 0.20384, 1.1555, 0.98467, 1.9529, 0.72825, 0.94221, 0.54554, 1.7285,
        -1.4487, -1.0788, -1.2018, 0.34344, 0.051627, -0.49224, 0.5318, -1.4352, -1.5872, -1.335, -1.4326, 1.5117, 0.39317, 0.52291, 1.217, -0.039749, -1.567, 1.3746, 1.0232, 1.0609, -1.1678, -0.95451, -0.36408, -0.85457, 1.1317,
        0.43047, 1.3564, -0.91312, -0.17813, -0.84182, -1.5715, 0.87089, -1.4311, -1.3739, -0.38953, -0.89621, -0.21546, 1.4846, 0.70312, 0.75298, 0.86854, 1.9516, 0.65223, -0.69288, 1.9734, 1.5959, -0.71515, 1.2081, -1.0331, -0.10701,
        1.6816, -1.313, 1.5107, 1.1838, 0.44888, -0.17184, -0.96341, -0.80814, 1.3191, 0.55311, 0.4656, -2.0453, -0.911, 1.6513, -1.8115, 1.1628, 1.4013, 1.4648, 1.2507, -0.57632, -1.0752, 1.3228, -1.693, 0.31856, 1.4724,
        1.5131, -0.41001, 0.32866, -0.345, 0.7612, -0.88244, 0.55027, 0.25967, -1.5175, -0.42589, -0.80169, -1.6071, 2.1914, -1.667, -0.80972, -0.88466, -0.66449, 1.1925, 1.1288, -0.39138, 1.3233, 0.56425, -0.8668, 1.819, -1.8408,
        -0.64691, -1.2511, 1.0461, -1.0645, 0.57766, 0.62259, -1.1863, -1.8114, -1.0771, -0.75283, -1.2732, 0.60948, -1.9136, 0.73624, -0.90291, 1.3747, -0.45553, -1.2523, -0.64306, -0.46363, -0.66373, -0.88416, 0.96172, 2.3591, -0.72905,
        -0.90153, -0.65874, -1.6402, -0.97333, 1.7815, -1.2498, 0.91806, 1.0711, 0.77262, -0.19927, 0.91284, -1.9006, -0.81517, 0.50077, 0.80999, -1.1448, -2.1405, -1.3844, -0.2122, -1.3985, 0.82651, 1.7724, -1.0773, -1.2383, 1.043,
        -0.38337, -0.89429, 1.2488, -0.46828, 1.728, -0.48718, -0.022214, 1.0088, -1.1824, 0.19415, -1.3652, -1.0489, -0.57854, -1.709, 0.29904, -0.81408, -0.9449, -1.4143, -1.5671, -0.87451, 1.3454, -0.59986, 1.5701, -0.17334, -1.1738,
        -0.85382, 0.5833, 0.79476, 1.2841, -0.60048, -0.93111, -1.295, -1.5708, 1.8122, -0.46647, -0.90851, -2.6841, 0.61212, 1.0599, -1.1706, 0.91854, 0.54381, 1.7128, -0.76807, -0.98581, -1.9663, 1.5178, 0.23252, 0.96095, 1.6764,
        -1.5273, -1.0397, -1.4214, 0.35234, 0.37551, -0.046095, 1.0572, -1.9017, -0.65262, -0.38716, -1.4684, 1.0086, -0.36177, 0.41039, 0.86784, 0.0068441, 0.43947, -1.7697, -0.48669, -1.1438, -0.62898, 0.77213, 0.50612, 0.93642, 0.87256,
        -1.0094, 0.56715, 0.56263, 0.84299, 1.129, -0.95585, -0.53354, 0.6665, 0.91845, -1.5887, -0.72872, 1.1282, 1.2181, -1.155, 1.3537, 0.38909, 0.56528, -0.91553, 1.4096, 0.27171, 0.90417, 0.572, -1.05, 0.64478, -1.3415,
        -0.97275, -0.90034, 0.75502, -0.031799, 1.4934, 0.34062, 1.2153, -1.5882, -0.033238, 0.034876, 1.1056, -1.8043, 0.53752, -1.6019, 1.6093, 0.080843, -0.3995, -1.0794, -1.3571, -0.45484, 0.40515, -0.62252, -1.1616, -1.1634, 1.0695,
        1.5184, -1.6087, 0.97376, 0.55056, 0.85675, -0.51247, 1.6606, 1.7757, -0.51685, 0.96704, 2.0403, -0.68808, 0.5436, -1.9786, 1.4547, -1.7322, 0.97227, -1.1374, 0.85439, 0.68468, -1.253, -0.97216, 1.4609, 1.7309, 1.6161,
        -0.95116, -1.2553, 0.92021, -0.99803, 1.0391, 0.95131, 0.64909, 1.522, 0.87489, 1.3208, 1.0621, -1.5329, -0.45215, 0.88517, 1.0059, -0.29035, 0.9326, -0.65201, -1.7698, 1.3938, -1.0609, -0.72798, 0.68741, 0.87931, 0.78861,
        -0.94651, -0.39615, 0.64481, -0.19101, 0.14748, 0.84071, -0.96152, -0.26978, -1.0504, -0.11495, -1.4407, 0.16897, -0.89767, -0.7127, -0.53284, 2.1302, 0.89861, 1.0852, 0.29197, 0.33644, -1.6856, 1.3082, -1.3571, 0.32167, 0.87349,
        -0.80583, 0.96799, 1.3709, -1.2936, 0.34856, 1.0701, -1.8157, 0.76384, 1.1152, 0.48945, -0.94612, 1.3166, -0.93882, -0.9269, -0.27238, -1.3507, 0.59559, 1.2356, 0.64293, -1.2472, -1.582, -0.78182, -1.3006, -1.4835, -1.2443,
        1.995, 0.8236, -0.80904, 0.88698, -0.92655, 1.4716, -1.6068, -1.1041, 1.3156, -0.87945, -0.57781, -1.2487, -1.0055, 1.7945, 1.2831, 0.69696, 1.127, -0.47094, 1.0968, -0.96944, 1.7239, -0.88032, -1.3696, -0.34099, -0.8922,
        1.6695, 1.6666, 1.1318, -1.2977, -1.3527, -0.90065, -0.55901, 0.83699, -0.52961, 0.21426, -0.54205, 1.1668, -0.56708, 1.9737, 2.3463, 0.34543, -1.0457, 0.37812, -1.4083, -1.3908, -0.87725, 0.73487, 1.3339, -1.359, -1.4043,
        0.46719, -1.3679, 1.2529, -0.30487, 1.104, 0.82021, 1.7512, 0.97977, -0.026397, -1.6806, -0.5604, -0.94344, 0.0019938, 0.32148, -1.5585, 1.1404, -0.3798, -0.1573, 1.3719, -1.6012, 1.9769, -1.779, -0.84138, -0.20495, -0.56598,
        -0.89084, -0.17455, -0.60519, 1.9093, -0.72349, -0.031118, 0.029324, 0.65984, -0.53719, -0.034988, 0.50294, -1.0011, 1.3927, -0.68481, -1.5034, -0.6438, 0.30064, -0.76252, -1.577, 0.98031, 0.71594, -0.96544, -0.58326, 1.1414, 1.0744,
        -1.1945, 0.88884, 1.6181, -0.74349, 0.12439, -2.1659, -0.35338, 0.7126, 1.172, -0.85922, -1.1251, 2.25, -1.4172, 0.34225, 0.78768, 0.64793, 0.82114, -0.73282, -1.3274, -0.72226, 0.24644, 0.93119, 1.4216, -0.25334, 1.3359,
        1.1665, 0.26705, 0.59843, -0.40829, -1.1089, -0.93146, -0.80549, -0.92967, -1.6634, 0.95652, 1.5855, 1.1264, 0.87486, -0.39524, 1.164, -0.99343, 1.5563, 0.18456, -1.8953, -0.31263, -1.3212, -1.4523, 0.68383, -0.47407, -1.5686,
        1.1537, 0.55368, -2.318, -1.6702, -0.02827, -0.49571, 0.90331, 1.5201, -0.034153, -1.4399, -1.0192, -0.6249, -1.5211, -1.3363, 1.48, 1.6587, -1.4226, 0.74192, -1.3922, 0.49089, 0.91403, -1.4582, -1.6053, 1.3832, 0.97082,
        0.92871, 1.6654, 0.65269, 2.1471, -0.54297, 0.88635, 0.98616, 1.0095, -1.8448, -1.7004, 1.7019, -1.1743, -1.0883, 0.2247, 0.93519, -0.071317, 0.058744, 0.56978, -1.3121, 0.24615, -1.0886, -0.69039, 1.2379, -0.57321, -0.81881,
        0.49654, 1.3651, 0.93141, 1.8296, 0.45232, 1.3985, -1.0731, 0.98272, 0.98273, -1.4148, 0.78697, 1.3997, 1.4549, -1.6191, 1.0625, 0.82339, -1.9445, 0.76584, 1.8363, 0.74979, -1.292, -0.30192, 0.74195, -1.6662, -1.1011,
        -1.6472, -0.018351, -0.3249, -0.77553, 0.82523, 1.5612, -1.2867, -1.1439, 1.3963, 0.55706, -0.2677, -0.26393, -1.8425, 0.82787, -1.2626, -0.15002, 0.095065, -1.4577, 0.93582, 0.5521, 1.5491, -1.2467, 1.2826, -0.43531, 0.22676,
        0.030921, -0.85918, 1.3424, 0.38835, -1.2333, -2.0043, 1.3321, -1.2676, 0.074369, 1.6835, -0.13207, 1.548, -2.1561, -0.63907, 0.61099, 0.90238, -1.1627, -1.4681, 0.64805, 2.8315, -0.79648, -1.3165, -1.4066, 0.88155, 1.3324,
        -1.5438, -0.53479, 1.3093, -1.0477, -1.4589, 1.1845, 1.8967, -1.5261, -1.6441, -0.84249, -0.15665, 1.4923, 1.4133, -0.90492, -1.1577, -0.73473, 0.39132, 0.52725, -0.72688, 1.014, 1.2153, -1.3377, -1.8801, 0.80539, 0.11374,
        1.505, 0.98561, 0.69774, -0.93775, -0.52678, -1.0516, -1.1367, 0.53932, 0.66879, -0.63807, 0.80573, 1.5099, 0.18951, 0.060237, 1.0641, -1.0419, -1.1572, -1.2831, 1.0318, -0.6416, -0.22985, -0.56146, 0.99495, -1.5426, -1.9898,
        0.93558, -2.2444, -2.0886, 0.63838, 0.92805, -0.60435, 0.2673, 1.6003, 0.78674, 0.3787, 0.95129, -1.2868, -1.2041, 0.52807, -1.9532, 1.382, 0.20571, -1.1903, 0.9648, 0.037239, 0.22796, 0.42667, -2.2447, 1.8041, 0.037526,
        0.13315, 1.0751, -1.4773, -1.3987, -0.79667, 0.52899, 0.74077, -1.0241, -1.0844, 0.99029, -1.5547, 1.1818, 0.9356, 1.2565, 1.419, 1.5276, -2.0868, 1.4007, -0.49032, -1.3344, 1.4933, -0.75266, -1.2772, 1.2344, 1.3832,
        1.0452, -1.2776, -1.5251, -1.1105, 0.61844, 0.72628, -0.44435, 1.3939, -1.348, 1.2234, 0.85933, -0.65433, 1.7909, 1.3234, -0.58667, -1.4712, -0.54801, -1.2015, -0.6792, 0.81135, -0.65559, 1.5954, -1.2575, 2.2515, -1.4099,
        -0.15613, 1.3623, 2.284, 2.0599, 0.4293, 1.3063, 0.79955, -2.0959, 1.7272, 0.57137, 0.52942, 0.48979, 1.0092, 1.7003, 1.0218, -1.8654, -2.0335, -1.165, 0.97514, 0.051773, 0.24598, -1.4574, -0.29863, 1.3319, 1.6111,
        0.45633, -0.66501, 0.63588, 1.884, 0.88974, -1.1136, -0.94165, 0.57809, -1.5059, 1.1452, 0.7775, 1.6747, -0.15171, 0.038718, 0.99439, -1.5008, 0.56917, 1.156, 0.38304, 1.0902, 0.49619, 0.99605, -0.83548, 0.41986, 0.064043,
        -0.38389, -1.085, -1.2426, -0.79685, -1.4002, -0.4368, 0.72354, 0.17946, -0.23513, -0.36793, 0.81422, -1.3102, -0.92262, -1.0317, -1.4861, -1.4297, -1.0055, -0.94912, 0.32236, -1.3274, -1.6668, -0.019208, 1.1272, -1.2158, 1.0639,
        -1.212, -0.94477, -1.5022, -1.7354, 1.5175, -0.522, -1.5971, -1.9726, -0.93953, -0.81798, -0.78227, 1.3549, 0.71329, -1.0626, -1.8842, 0.76346, 0.66862, 0.85969, 0.34125, 0.44754, -2.2201, 2.0128, 2.0969, 1.2919, -0.32719,
        0.60959, -0.4855, -0.73421, 0.60863, 0.51984, 1.0602, -0.86336, -1.0207, 1.4419, -0.017341, 1.207, 0.88968, 0.21431, -1.1649, -0.20395, -1.0714, -0.94753, -0.21936, -1.8209, -0.81525, 0.76955, 0.91996, -0.36012, -0.96078, 1.7749,
        0.066105, -0.94794, 0.29442, -0.75584, 0.66514, 0.89743, 1.4212, 0.9347, 0.67484, -1.0502, 0.080024, 1.2792, 0.52635, -0.7331, -1.869, 1.3995, -0.77107, 0.66901, -0.75811, 0.74231, -0.81781, -0.90131, 1.11, 1.0999, 1.2888,
        -0.97324, -0.68537, -0.58144, 1.1711, 0.12082, 1.1595, 0.382, -0.93774, -0.91394, 0.23389, -0.35241, -0.92278, 0.29297, 0.5629, -1.0851, 1.8397, 1.6436, 0.50015, 0.038526, 1.4528, -1.4706, 1.1796, 0.63802, -1.1718, -1.3286,
        1.7223, 0.67688, -0.38361, -0.5259, -1.0108, 0.61956, 1.194, -1.4934, 0.106, 0.75703, 1.121, -0.52128, 1.1569, 1.3377, -0.63107, 1.4502, -0.41673, -0.095296, 0.016095, 0.56765, -1.5169, 0.39183, 1.3807, -0.050026, 0.87098,
        0.15621, -1.1111, 0.25797, -1.2051, -1.2897, 1.2955, -0.96587, -0.60422, -2.0576, -0.68553, 0.62632, -2.2033, 0.2706, 1.0427, -0.38608, -0.82463, 0.73632, 0.67642, -1.8578, 1.0645, -0.42809, -1.8701, 1.9926, -1.0455, -0.68382,
        -1.2078, -0.94534, 1.2111, 1.7344, -1.0684, -0.75103, 1.2681, 0.77143, -1.0779, -0.82428, -0.80989, -0.90859, -0.2363, 0.59819, 1.4203, -1.4612, -0.51266, 1.7867, 0.44269, 0.33607, 0.7154, 1.4235, -0.1849, 0.88409, 0.65031,
        -1.5872, 0.85404, 2.1635, 0.70792, 1.1086, -0.32135, 0.68578, -1.0332, 1.4899, -1.356, -0.98229, -2.0202, -0.91539, -1.6659, -1.2771, 1.2182, 1.6134, -1.267, 0.87916, 0.48488, 0.19634, 1.6447, -0.7194, 0.33204, 0.5287,
        1.2433, 0.58534, -0.64299, -1.5053, -0.86203, -0.48223, 1.6129, 0.030919, 0.059575, 1.2379, 1.7726, 1.6728, -2.0488, -0.38107, -1.6551, 0.69343, 1.4155, 0.69537, 1.359, 0.90612, -1.4174, -1.4089, 1.7378, -0.84988, -1.0293,
        1.1353, -0.70759, -2.2726, -0.77834, -1.0545, -1.6013, 0.80483, -0.77764, 0.55599, -0.33765, 0.051147, 0.36268, -0.0043966, 0.64564, -1.8745, 0.7419, -0.56231, -0.14735, -1.3936, -1.5247, 0.0099206, -1.0699, -0.34502, 1.2688, 1.1345,
        -0.91152, -0.80126, 0.016313, 1.0029, 1.4227, 0.81923, 1.2272, 0.77035, 1.5286, 0.64794, -0.38922, 1.2509, -1.2151, 0.44688, 2.0234, -1.1967, 0.12091, -1.4308, 1.5901, 1.3834, -0.82295, -0.77486, -0.98341, -0.9184, -0.23505,
        2.0034, 1.0484, 1.0843, 0.60573, 0.44724, -1.6112, 2.0191, 1.2005, 0.23717, -1.3805, 1.0281, -0.50265, 0.11454, -0.51212, 1.0602, 1.112, -1.271, -1.4655, -1.6343, -0.28077, 0.13459, 1.2363, -0.65574, 0.8991, -1.46,
        1.734, 1.135, -0.87336, 0.52435, -0.45711, -1.0294, -0.50601, -0.25092, -0.84574, 1.3825, -1.3424, 0.92693, 0.85781, 0.023774, 1.3516, -0.63024, 0.94612, 1.1141, -0.11011, -1.0327, -0.029473, 1.5428, 1.3672, 0.9871, -0.25545,
        -0.085711, -0.96163, 1.749, -1.2372, -0.95682, 0.98558, -1.2776, 1.2157, -0.66924, -0.92835, 0.51906, -1.8568, 0.40233, 1.0826, -0.65409, 1.43, 2.1935, -1.6952, -1.7453, -2.0539, -0.69816, 0.28968, 0.90388, 0.19571, -0.68515,
        0.78324, 0.18142, 1.1382, 0.12713, -0.61044, -2.168, 0.49336, -0.31685, 0.2325, 0.80394, 0.64999, 0.77912, 1.8212, -0.28026, -0.42626, 1.4366, -0.67022, 0.6437, 0.66084, -1.161, 0.9554, 1.5099, 1.3461, 0.92214, -1.0405,
        -0.36531, 0.74338, -1.3247, 0.50568, 0.476, -0.70233, 1.7834, -0.35724, 0.89324, -1.9846, 0.057367, -1.5484, 1.169, -0.71399, 0.20062, -1.681, -0.94035, -1.082, -0.29626, -0.94704, -1.2725, -0.90948, -1.387, 0.35862, -1.0965,
        -1.5471, -0.97833, 0.13508, -1.22, 1.0689, 0.64809, -1.0528, 0.99355, -2.1152, -0.70096, -1.5011, 0.94202, 1.962, -0.72578, -1.3798, 1.1983, -0.23421, 0.1772, -1.4515, -0.51846, 0.25246, 1.1392, -0.39355, 0.85937, -0.92276,
        1.0374, -1.3279, -0.12151, 1.1499, -0.19414, -0.55132, 1.3273, -1.626, -1.2922, -1.1587, 0.91013, -0.56914, -0.75743, -1.1561, 0.73875, 0.87084, -1.0958, -0.42378, -0.86842, 1.7245, -0.047231, 1.0865, 0.56678, -0.58681, -1.85,
        1.7927, 0.46482, 0.10821, -0.9202, -0.7632, -0.3031, -0.12321, 1.2582, -0.94395, 0.83009, -0.77143, 1.7102, -1.4685, 1.4202, -0.58838, 2.0471, -0.52971, 0.70195, -0.82167, -1.7691, -1.1239, -0.66059, -0.75449, 1.3395, -0.49826,
        -1.0657, -1.8283, 1.2777, 0.23245, 0.7046, -0.48295, 0.72285, -0.70783, 0.37003, 1.0372, -0.34957, 1.3159, -0.73719, 1.4706, 1.6938, 0.90523, -0.89603, -0.80749, 1.7644, 0.90034, 1.0857, 0.95003, 1.4055, 1.026, -0.81062,
        0.96995, -0.8361, 1.3302, -1.3369, 1.3295, -0.36027, 0.68837, 1.4303, 1.3015, 1.1199, 0.32155, 0.98554, 1.3171, 0.62564, -0.70092, 1.5473, 0.88717, -0.89402, 0.65451, -1.5024, -0.42253, 1.0791, 1.0556, -0.26246, 0.33984,
        1.5441, -0.75587, 1.0966, 2.0487, -0.51513, -0.68985, 0.44331, 0.14938, 1.1415, 0.15156, -1.3757, -0.66336, -1.0665, 1.2722, -0.78913, -0.64271, -0.37019, 0.29933, -1.7179, -0.89383, -1.4864, 0.95162, -1.3989, -0.55093, -1.1796,
        1.1025, 1.5562, -0.59174, 1.3487, 2.3148, -0.14732, 1.3412, -1.4256, 1.0941, -0.08346, -0.81529, -1.1079, 0.98125, -2.0167, -1.2713, -0.84774, -0.63021, -1.7424, 0.34549, 0.68528, 1.1975, -0.84309, 0.69201, 0.88858, -1.1583,
        -0.63089, 0.89429, -1.7514, 1.0809, 1.4261, 0.88231, 1.7085, -0.74264, -1.8669, 0.70848, -0.74956, -2.2625, 0.57027, -0.93926, 0.3052, -0.57545, 1.7167, -1.2521, 0.36092, 0.53849, 1.2374, -0.3905, 1.107, -1.4064, 1.3007,
        -1.2536, -1.052, -0.4611, 0.14465, 1.2695, -0.10574, -2.3654, -1.6098, -2.3448, -0.33505, 1.147, -0.41233, -1.4979, -1.6433, -0.75153, 1.7034, 1.8136, 1.3669, -0.13502, 1.2499, 0.37867, 1.2098, 0.73002, 0.63495, -1.0293,
        0.36507, -0.62459, 0.8916, 0.074862, 1.5613, -0.70543, -0.76093, -1.2765, -1.2788, 1.3361, 1.6482, 0.21982, 0.64488, -0.30096, -1.2636, -1.1495, -0.717, 1.7851, -0.86821, 0.79214, -1.8637, 0.61831, -0.6142, -0.26875, -1.3923,
        -0.74768, 0.076356, 0.79563, -1.5296, -0.72598, -0.13889, -1.3526, 0.68508, 0.51337, 1.0851, 0.81267, -1.3473, 1.6168, 0.896, 0.81731, 0.4081, -0.92995, -0.82649, 0.27546, 0.99551, 0.74474, 1.1811, 1.0493, 0.80201, -0.82516,
        -0.0041132, 0.27553, -2.0591, -0.87273, -1.6383, 1.3907, -0.53628, -1.4965, 0.9295, -0.54966, -1.1571, 1.1388, 0.51626, -0.71562, -0.6511, -0.8221, 1.0207, 0.49206, -0.91101, -1.421, -0.99941, -1.0155, 1.5713, 0.15712, 0.30386,
        1.1945, -0.93744, 0.48494, 1.6126, -1.1963, -0.54747, 0.84333, -2.505, -0.90382, -1.8914, -1.4464, 1.7703, 1.4127, 0.92991, -0.67432, -0.85958, 1.4919, 1.8428, -0.31088, 0.64187, 0.8214, -1.1313, 0.50275, -1.9986, -0.96157,
        0.99123, -1.8239, 1.1544, -1.1695, -0.91488, -0.96993, -1.7343, 1.0564, 1.6744, 0.80234, -0.73443, 1.4529, 1.8195, -1.1317, 1.075, 1.0613, 0.55516, -1.514, 0.59443, 1.1658, -0.52085, 1.8539, 1.0095, -0.78246, 1.5584,
        -1.0755, 1.4079, 1.3173, -0.77882, 0.49236, -1.2812, 0.98775, 0.74023, 2.1753, -0.58129, 1.8022, -2.397, 1.1925, -0.88728, -1.3703, 1.3204, 0.55104, 2.3457, 0.30355, 0.72193, -1.1636, -0.5739, -1.1003, -1.1767, 0.49608,
        0.98391, -0.068832, 1.0846, 1.8694, 0.89967, -0.17655, -1.1509, 0.88606, 1.0348, -1.7218, 1.6352, 1.0216, -0.99747, -1.0424, -0.32588, -0.87036, 1.1163, 1.0513, 0.59654, 0.7381, 0.62335, -0.81013, -0.82005, 0.003242, -1.2221,
        -1.2673, 0.73606, 0.90868, 0.32898, 1.9228, -1.2861, 1.2274, -1.0301, 1.2066, 2.3938, 1.1004, -1.4594, 1.6523, 1.1375, -0.56591, 1.3536, -0.89581, 1.7088, -1.9383, 1.5456, -1.1229, 0.52454, 1.1644, 0.87418, -1.897,
        2.1799, 1.6746, -0.65261, 1.3912, -0.36388, -0.85545, 0.57183, 1.0748, 0.30973, 2.2621, 1.2504, -1.4865, -0.091684, 1.6026, 0.72748, 0.29853, -0.38688, 0.85769, 0.71709, -0.61673, 0.90439, 1.6026, 1.7495, 1.1942, -0.91337,
        -1.1372, 1.5231, -0.91972, -1.1101, -0.40749, 0.5331, 0.99349, -1.2045, 0.68862, 1.368, 1.217, 1.0156, -0.90338, -1.0956, -0.47604, -1.5707, 0.68628, -0.72478, 1.7689, 0.88682, -0.19907, -1.0724, 1.7522, 1.0057, 1.667,
        -0.44326, -1.0943, 0.78611, -1.1473, 1.2245, 0.64167, -1.4431, -1.3634, 0.82904, 1.8944, -0.57566, -1.1428, 1.9381, -1.0013, -1.0763, -0.75965, -2.3227, 0.44834, 0.93964, -1.1098, -0.22456, -1.9609, 0.40708, 0.64363, 1.917,
        0.40093, 1.5573, 1.6582, -1.1642, 1.1806, 0.8704, 1.6051, 0.68847, 1.3747, 0.81158, -1.733, -0.65621, -0.71538, 0.49819, 0.7323, 1.2129, 0.037705, 0.61792, -0.94868, -0.88384, -2.0464, -0.98118, 1.0231, -1.2934, 1.719,
        1.7873, 0.81996, 0.054645, 1.3016, 1.5474, 1.2784, -0.60678, 1.121, 0.46704, 1.0371, -1.3207, 0.62151, 1.9528, -0.99607, 0.39739, -0.83201, -1.2091, -0.097552, 1.4143, -0.29691, 1.5524, 0.61401, -1.1098, 0.64622, -1.3395,
        1.2148, -1.2275, -1.04, 0.383, -0.44446, -1.0217, -1.2212, 0.8518, -1.662, 1.4991, 1.2837, 0.99099, 1.0108, 0.54257, -1.861, -1.1201, -1.2257, -0.22684, 1.4313, 0.54999, -0.99318, 1.4143, 0.9727, 1.4169, -0.17694,
        0.58256, 1.7359, -0.76518, 0.18302, -0.94622, 0.013568, 0.89736, -1.1536, -0.84088, -0.11996, -1.5377, 1.4358, -0.38565, -1.022, 1.7566, -0.9945, -1.0003, 1.1857, -1.676, 1.2658, 0.92172, 0.91586, -0.96733, -0.56571, -1.0489,
        -0.79527, -0.15576, -0.7618, -1.1103, 1.0844, -1.3288, -0.46764, -1.2657, -1.2858, 1.1231, 1.0216, 1.1542, 1.1771, 1.4917, -0.46017, 1.2585, 0.62675, 1.3324, -0.93077, 0.0065231, 0.86308, 0.24833, -0.76135, 1.4611, 0.54077,
        0.7144, 1.2127, -0.56102, -0.86269, -0.9433, 2.0539, 0.92438, -0.56032, -0.74911, 1.6214, 0.57167, 1.8702, -0.67472, -2.1613, -0.42608, 1.1795, -1.275, 0.95825, 0.28597, -1.1929, 0.67693, -0.8884, 0.84968, 1.1248, 2.2205,
        -1.8549, 1.7877, 0.40974, 0.4284, -1.3453, -0.32095, -1.0572, -2.1915, -0.17643, -0.43259, 0.74466, -0.13573, -1.1012, 1.1148, 1.7315, 1.1343, 2.0785, 1.3314, 0.34968, -1.1645, 1.5853, 0.66384, 1.6638, 0.98788, -1.7614,
        0.68487, 0.30241, 0.10164, -0.13231, 1.4905, 1.2119, 0.87205, 0.59292, 0.47849, -0.35852, -1.2914, 2.0176, -0.2978, 0.94497, -0.72777, 1.7398, -1.1839, -1.2209, 0.98382, 0.77012, -1.057, -0.65331, -1.2551, 0.57278, 0.89929,
        -1.6272, -0.038629, -0.59338, -1.5877, -0.91406, -0.27569, -0.014549, -1.2868, 2.1146, 1.041, -1.1766, -0.44715, 1.0755, -2.2462, 1.6461, -0.083859, -1.1288, -1.1778, 1.2093, 0.63047, 1.1242, 1.3311, 1.1053, 1.0623, 0.67523,
        -0.36633, 0.83397, -0.56412, -1.3861, -0.95883, 0.89722, 1.6499, 0.6735, -1.3238, 1.4128, -0.75473, 1.4109, -1.0209, 1.0722, -0.93744, 0.72169, -1.4101, -0.27269, 0.052773, 1.8116, -0.28893, 1.996, -0.76462, 1.5531, 1.7482,
        0.38266, -1.4168, -0.18242, 0.49884, 0.81753, -1.3527, -1.2042, -2.1345, -1.0594, 0.84691, 2.0019, 0.48044, 0.97695, -0.85326, 0.66736, 1.0989, -0.4844, -0.0056164, 1.2064, -0.041029, 1.3516, -0.70982, 2.2738, -0.72488, -0.76904,
        -0.56272, -0.40707, -1.0663, 0.67663, -0.15829, -1.3516, -1.6184, -1.2904, 1.1392, -0.92156, -1.0605, 1.6662, 0.94697, -1.7667, 1.5111, -1.2778, -0.089216, 1.1816, 0.54856, 0.29263, 1.7217, -0.4411, -0.30547, 1.0052, -0.71718,
        -1.1468, -0.5776, 0.8883, -0.45507, -1.817, -1.2643, -0.68993, 0.53203, 0.36744, -0.91333, -0.68683, -0.50914, -1.562, 0.78106, -1.0702, 2.1305, 0.67721, 0.34631, 0.37984, 1.5227, 1.6088, -1.3345, -1.8783, 1.452, 1.4218,
        1.1514, -1.2195, 1.2728, 0.70768, 1.449, -0.89083, 0.043346, 0.86776, -0.87496, 1.1732, 1.6221, 1.6235, 1.3899, -0.54177, 1.7464, -0.29853, -0.99634, -0.028456, 0.98299, -1.0903, 1.4006, 0.57543, -0.048962, -1.6061, 0.058937,
        -0.76615, 1.4958, -1.0578, -0.38887, -0.9978, 0.99576, 0.88851, -0.81001, -0.74406, 0.31276, 0.6744, 0.77065, 0.92971, 0.16134, 1.7357, 0.27685, -1.3466, 0.38653, -1.0596, -1.8113, -0.054504, 0.57336, -0.89561, -0.94334, 1.5548,
        0.25671, -0.75496, 0.64839, 0.25659, -0.51284, -0.80329, -1.0725, 0.10409, 0.83508, -2.1794, -1.1702, 0.44608, 0.57641, -0.27458, 1.3662, 1.1178, 1.2833, -1.845, 0.93258, -1.0174, -1.4634, 0.23984, -0.93328, -0.42701, 1.4129,
        0.038843, -1.8638, 1.3681, 0.75976, 2.1201, -0.82837, 1.0593, -0.74073, -1.1014, 1.1425, 0.31964, -0.80082, 1.2684, -2.6091, -0.60143, 1.4557, 0.23944, 0.90406, 1.216, 0.56367, -0.86987, 1.4138, -1.8238, 1.2995, 0.96534,
        1.3992, -0.39539, 0.81416, 0.54066, 0.39893, -0.95964, -0.57315, 0.098692, 1.2903, 0.62337, 1.0741, 1.0535, -0.9454, -0.20976, 0.4581, 0.75028, 1.1505, 0.08771, -1.213, -0.97705, -0.9116, 1.4649, 1.2575, -0.2685, 1.1304,
        -0.78319, 1.0395, -1.365, -0.698, -0.98866, -2.3421, 0.85207, 0.23249, 1.2675, 0.98733, -1.208, 0.45012, -0.84389, -1.4249, 0.67543, -1.0034, 2.1074, 0.73121, 0.50942, -1.9908, -0.40027, -1.415, -0.61526, 0.96464, 0.51759,
        -0.18603, -1.0227, 0.2032, 0.15238, 1.226, 1.2954, 1.5337, -0.76747, -0.0081063, -0.66692, -0.58358, -1.6247, 0.65935, -0.067787, 1.5663, 1.3333, 0.49956, -2.0662, -0.96494, -1.2307, -0.37735, -0.97435, 0.79908, 2.4877, -0.14081,
        -0.49547, 0.020784, 1.1796, 0.91831, -0.38607, 1.6548, 0.36869, -0.72874, -0.45731, 0.93668, 1.0469, 0.26624, -0.7889, 1.1752, -0.72474, -1.1765, 1.374, -1.6532, 1.2259, -0.87374, 0.85812, -1.0887, 0.76988, 1.3502, -1.5738,
        -0.85355, 1.555, -0.70395, 0.67477, -1.1159, -1.2755, 0.84102, 0.31154, 0.91092, -1.2255, 0.69584, 1.8253, -0.55685, 0.93075, -0.88971, 1.0941, -0.43788, 1.4513, -1.1918, -0.57909, 1.2316, -1.6949, 1.0373, -0.44406, 1.3889,
        0.47139, 0.098668, 1.1647, 1.9036, 0.70546, -1.3086, 1.3008, -0.38345, -1.3179, -1.8093, 1.093, 0.83326, -1.6164, -0.089541, -0.84218, -0.52921, 1.2008, -0.15033, -0.64539, -0.4119, -0.63213, -1.274, 2.2558, 0.054246, -1.1649,
        0.53372, 1.4861, 1.0347, 0.77732, -0.92796, -0.95104, 0.20394, 0.69655, 0.83872, -0.89956, 1.5111, 0.12984, -0.32758, 1.067, -0.19863, 0.47804, -1.6571, -0.69078, -2.0937, -1.4714, 0.78231, -1.21, -1.3762, -1.9082, -0.46702,
        1.4551, -0.8101, 0.51123, -1.3312, -0.99921, -1.7773, -0.04963, 0.56263, -2.1672, 0.79929, 0.067646, -0.49233, -1.3537, -1.6361, -1.4581, 1.1542, 1.3755, 0.99093, 0.69523, -1.2734, -1.0759, -0.42849, 1.2673, 0.9744, -1.0484,
        0.77831, 0.77669, 1.82, 0.8915, -0.96854, 0.9686, -1.0887, 0.91986, -1.335, -0.60472, -0.69665, 1.7066, -0.78662, 0.92002, -1.0857, -0.1515, 0.90927, 0.99247, -1.1278, -1.5867, -1.4328, 2.0863, -1.7196, -0.48521, -0.24413,
        1.3562, -1.0258, 0.12118, 1.8683, -1.6857, 0.77839, 1.1485, 1.8602, 0.18055, -1.236, -0.2829, -0.2574, -1.0651, -1.1718, -0.69062, 0.5255, -1.1918, -0.90021, -0.37112, 0.4848, -0.85508, -1.2884, -1.4793, 1.4804, -1.8427,
        1.4085, -0.65658, -0.36287, -1.7165, 1.6137, -1.1717, -0.86051, 0.17721, -0.29422, 0.32769, 0.12074, -0.23452, 0.85424, 0.76138, 1.6252, -0.10176, -1.7316, -0.6129, -0.29521, -1.0362, -1.1883, 1.2603, 0.63294, 0.95351, -1.3274,
        -1.2316, -0.53107, 0.50121, -0.78811, -0.78547, -1.3117, 0.41002, -0.67369, 1.3752, -1.3697, 1.1793, 1.025, -0.98152, -0.72167, -1.0589, -1.4819, -1.1185, -0.76979, 0.74939, 1.5979, -1.9327, 0.52233, 1.6289, 1.0077, -0.994,
        -1.0423, 1.9039, -0.94837, -1.3541, 1.9171, 0.30784, 0.97661, -1.8121, 0.51007, 0.52063, -1.6934, -0.71691, 0.66175, 0.36578, -1.1329, 1.8218, 0.62594, 0.082661, -0.90594, 0.8696, -0.59267, 1.3781, 0.88245, 1.4927, -0.96132,
        -1.1291, 1.551, -1.8912, -1.1602, -0.86637, -1.6005, -0.6725, -0.87511, 1.3243, -0.74362, 2.307, 1.6758, 1.2751, -0.70887, 1.515, -1.3886, -1.5213, 1.0218, -0.84179, 0.58966, -1.9539, -0.29243, -0.88997, -1.5304, -0.012447,
        0.61479, 0.22409, -1.134, 0.46106, -1.1044, -1.0859, -0.32255, 0.33543, 1.6148, 1.75, -0.72083, 0.66107, -0.79317, -1.4432, -1.0596, -1.0698, -1.3139, 0.85358, -0.9509, -1.4503, -0.53772, -0.018069, -1.4981, -1.0009, -1.4461,
        -0.58611, -1.1742, -1.2362, -1.1185, -0.68334, 1.435, -0.42843, -1.3776, -1.1363, -1.8164, 0.88072, 1.841, 0.88033, -0.47528, 0.22661, -0.44442, 1.816, -0.8018, 1.2973, 0.0825, -0.72568, 1.4644, 0.26495, 0.18401, 1.2891,
        -1.2849, -0.86958, -1.6083, 0.46657, 0.62975, -1.2405, -0.62425, 1.071, 1.0384, -1.2362, -0.98405, 0.37248, 0.27587, -0.65963, -0.89257, -1.1502, -0.67722, -1.3158, -1.0876, 1.176, 0.31784, 1.2312, -1.9681, 1.0886, -0.51662,
        1.953, 0.59827, 1.2201, -1.1421, 0.51831, -0.59068, 1.2613, -0.39417, -0.90797, -0.69939, -0.21828, 1.2682, -1.787, -0.32352, -1.745, 0.53428, 0.88208, -0.26789, -0.2091, -1.3865, -1.5615, 0.89204, -1.5231, 0.010646, 0.83379,
        -0.55216, -1.7062, -0.93979, 0.28757, -1.6436, -0.63047, -1.2181, 0.98467, -0.86947, 1.4649, 1.6963, 1.7249, -1.3476, -0.94981, -0.78528, 1.0024, 0.67276, 1.5487, 1.0936, 1.1472, 0.42194, 0.55636, 1.2103, 1.2355, -1.0218,
        0.39456, -1.2494, 0.34828, 0.51893, -1.1601, 1.6472, -1.6958, -1.3181, -0.27971, 1.5013, 0.82953, 1.4555, 0.079239, 1.6929, -0.098358, 1.243, -0.87335, 0.7426, -1.4748, 1.7666, 0.9021, -1.2995, -1.0374, -0.66574, -1.1204,
        0.28904, 0.78255, 1.9079, -1.5659, -0.58284, 1.0822, -0.95229, 1.6889, -0.056516, 0.92536, 0.87334, 0.57894, 1.2326, -0.37195, -0.05625, -0.64858, -1.6489, 0.49215, -1.354, -1.4095, -0.92821, -0.78962, -1.3225, 1.3927, 0.90509,
        -0.88167, 1.2354, 0.74565, 1.132, -1.4221, -0.28541, 1.1208, 0.6592, 0.65603, -0.066836, 1.0867, 1.6481, -1.2882, 0.73082, 0.46812, 1.3839, -0.95463, 1.9085, -0.33158, -0.70611, 1.433, -0.99228, -1.3244, 1.2601, -0.90205,
        -1.7167, -1.6609, -1.7743, 0.90721, 1.401, 1.2509, 0.98143, -0.76975, -1.3068, -0.45673, 0.80323, -1.7724, 0.040017, 1.124, -1.6676, 1.4141, 2.0185, 0.29851, -0.099424, 1.5524, -0.64203, -0.60671, -0.91907, -0.89123, -1.878,
        0.21226, 0.66632, 0.21393, 0.83882, 1.9604, -0.29198, -0.73982, -1.3446, -1.0573, 1.0922, 1.2341, -2.0067, 0.97626, 1.0483, 1.1228, -1.1444, 1.0099, -0.76781, -0.40738, -0.35235, -0.49774, -1.0403, -1.2673, 2.0736, 1.0676,
        1.166, -0.76225, -0.25514, 0.39686, 1.0932, 0.70548, -1.0932, -1.9727, -1.6659, -1.9214, 0.89757, 0.89479, -1.2999, -0.69793, -0.56433, -1.0827, -0.93392, -0.40157, 0.78799, 0.03384, 0.90734, -0.46817, -0.66299, -0.086748, 1.2962,
        -0.8562, 0.61732, 0.98241, 1.7103, -0.74818, 0.89104, -1.685, -0.31388, 1.0726, -0.026653, -0.97384, -1.1703, 1.1851, -1.5722, 0.77227, -0.8654, 1.567, -0.51787, 0.47855, 0.29914, 0.34386, -1.2861, -1.5498, -0.34596, -0.27152,
        -0.094751, -2.3115, 0.51352, -1.2598, 1.1313, 1.5554, 1.2341, 0.58033, 0.38696, -0.21266, 0.39588, -1.1643, -0.63062, 0.55871, -0.83379, 1.3617, 0.66043, -0.18059, 0.95066, -0.78701, 1.5717, -0.15653, -1.0636, -1.5164, -0.61132,
        -1.2349, 0.5973, 0.074291, 0.67913, -0.71392, 2.1163, 0.18889, -1.4122, -0.88433, 0.94564, -1.3758, 0.8855, 1.7225, 1.5588, 1.4792, -1.8209, -1.1516, -1.4259, 0.11527, -0.78684, -0.23306, -1.3925, -0.61276, 0.59122, 0.17344,
        -0.11351, -1.2008, 1.0721, -1.3592, 0.49451, 1.4875, 0.78944, -1.5105, 1.4258, 1.5926, -0.78128, 0.25692, -1.1727, 0.52112, -1.5319, 0.1851, 1.3059, -0.5754, -0.56691, -1.2456, -0.60114, 0.64264, -1.1769, -0.020687, -0.62116,
        1.3711, 0.2574, 0.88914, 1.3016, -0.57923, -0.7887, -0.25275, 1.7496, -0.34041, 0.83787, 1.6386, -1.8287, -1.5037, 1.152, -1.0661, -1.6475, -1.2186, -0.1652, 1.0617, -0.53843, 1.2077, -0.75946, -1.17, -1.2261, -0.66612,
        -0.30385, -1.0837, -0.26912, 0.674, 0.37844, 1.0593, 0.86946, 2.3071, 0.91426, 1.3124, 0.76912, 0.70202, 1.3494, -0.544, 1.2469, 1.418, -0.99408, 0.27792, -1.113, -2.9055, 0.35709, 0.54343, 1.8628, -0.79688, -1.777,
        0.092775, -2.6079, 0.81773, 0.96623, -2.0164, 1.0646, -0.77546, -1.1207, -1.2897, 0.76396, 0.73795, -0.98279, -1.3186, 0.86362, -0.45905, 1.1421, 0.15695, 0.62971, -1.8606, 0.49419, 1.041, 1.0856, -0.68524, -1.3999, 1.0229,
        -0.11615, -0.034312, -1.479, -1.0399, -1.677, -1.7653, -0.92606, 1.2815, -0.38272, 0.96921, -0.7111, 1.3469, 1.2322, 1.1926, -0.5368, -1.5491, -0.70019, 1.3554, 1.2146, -0.14629, -0.1063, -1.5137, -1.1263, 0.62843, 0.88411,
        0.42694, 1.3054, 1.6413, -0.9338, -1.7561, 0.56523, 1.1527, 0.55679, 0.54116, -0.84165, -0.5195, 0.29167, -1.1396, 2.1045, -0.98542, -1.5064, -1.0035, 1.7892, -1.1953, -1.327, 1.5663, -1.6452, 0.26396, -0.97813, -1.004,
        -1.6514, 1.5336, 2.138, 1.7601, 1.378, -0.68686, 0.35633, 1.4443, 0.65677, -1.4448, 1.8154, 0.64284, 1.3548, 1.1971, -0.81305, 1.2597, 2.0157, 0.85557, 1.6052, -1.2812, -0.063943, -0.67428, 1.2278, -1.0874, -0.051999,
        -0.82367, -1.0658, -1.5315, -1.3408, 1.3416, -1.5122, 1.1591, -1.0804, 1.1861, 0.48141, 0.24911, 1.0617, 0.58303, 0.95419, 0.83843, -0.60889, -0.61824, 0.83784, 0.46023, 1.4325, 0.9312, 1.2391, -1.2135, -1.1508, -0.30314,
        -1.2367, -0.55865, 0.37089, -0.78358, -1.8351, 1.1433, -0.67622, 1.029, -0.57395, -0.7106, 0.42287, -1.8141, -1.257, -0.10581, 0.045402, 1.3887, 1.34, 0.91583, 0.76209, 1.1487, -0.89125, -1.4888, -0.7345, 1.3103, -0.35573,
        -1.9187, 1.1377, -1.8181, -0.1072, -0.67774, 0.72708, 1.0671, -1.3872, -1.033, 0.79852, -0.77016, 0.4824, -0.86702, 0.5301, -0.98596, 1.0629, -1.7937, -1.0238, -0.65306, 1.3162, 1.4204, 0.3535, -0.88992, 1.2137, 1.3496,
        0.6974, -1.6933, -0.2881, 0.24954, 0.94674, 0.31213, 0.61749, 1.8125, 0.67232, 1.4446, -0.94179, -0.89259, -1.0801, -0.67348, 1.0439, 0.0050048, 1.1032, -1.3546, -1.6949, 0.72807, 0.26281, -0.94529, 1.3747, 0.080208, -1.0078,
        0.48842, 1.21, -0.64034, -0.92206, 1.0586, 0.33195, 0.87059, 1.9943, -1.1284, -1.2901, 1.4076, -0.7061, -1.1736, -0.87879, 1.1053, -1.9869, -0.97212, 1.556, -0.66258, 0.74738, -0.61505, -1.3269, -0.8897, -1.1239, 1.388,
        -1.2233, -1.3824, -1.4186, -0.50369, 0.59258, 0.80823, -1.2725, -0.18885, -1.184, -1.2894, 0.42005, 0.65855, -1.1027, -1.4257, 1.8152, -0.80309, -0.54298, 0.66589, -1.773, -0.6998, -0.26845, -0.24801, 1.4917, -1.1962, -1.5616,
        0.54366, -0.43349, -1.5391, -1.4722, 1.6862, 1.2343, -0.22493, -1.6876, -0.97255, 0.8993, 1.1139, 1.5953, -1.6211, -0.71282, 1.41, -1.2433, 0.14823, -0.63558, 0.43842, -1.1261, 1.2392, -0.99894, 0.18838, 2.482, -0.85642,
        -1.0346, 0.93275, -0.80939, 1.5469, -1.0493, 1.2656, -1.0441, 1.1934, -2.4312, -1.6134, 0.39699, 0.1902, -1.1683, 0.63311, -1.1241, -0.07962, -0.80535, 1.0575, -0.17642, 1.3537, -0.54006, 0.57952, 1.0766, -1.3861, 0.25834,
        -1.9531, 0.65252, -0.65792, 0.72347, 1.1547, 0.71319, -1.1787, 1.0393, 1.2052, 0.7278, -1.2211, -0.26224, 1.3583, 1.02, 1.0653, 0.81777, 0.41591, -0.58108, 0.26961, 0.84044, -1.1549, -1.0017, 0.37551, 1.2931, 0.95983,
        -0.10519, -1.9936, 1.1981, -0.49567, 1.2089, -0.91475, -0.14277, 1.6991, -0.63576, -0.24808, -0.62086, 1.2931, -1.8123, -1.5199, -2.6268, -1.7157, 1.0497, -1.6091, 0.11782, 1.2956, -1.4196, -0.49238, 1.0141, 1.4858, -0.36542,
        -0.60777, 0.29268, -1.2702, 1.8514, -0.62858, 0.98493, 1.0255, -1.0686, 1.292, -0.79425, 1.4426, -1.9337, 0.83909, 0.36398, -1.2918, 1.9494, 0.26701, -0.92264, 1.0199, -0.67516, -0.33988, 1.1893, -1.5642, -1.1767, 0.088714,
        0.64831, 1.4691, 0.59427, -1.0039, -0.81122, 1.206, -1.4569, -0.73192, 0.14444, -0.47175, -1.0909, 1.3075, -1.4963, 0.79356, 0.87044, 0.99588, -1.2719, -0.74268, -1.4214, -0.6646, -0.86068, 0.97557, -1.9559, -0.69621, 0.86089,
        0.94259, -1.034, 1.3531, 0.06054, 1.9138, 1.8235, 0.5609, -1.7332, 0.58759, 1.1265, -0.54312, 0.70543, 0.17016, 0.61609, 1.3106, 0.92611, -1.3013, -0.83154, 0.448, -0.35791, -0.63642, 1.4139, 1.724, -1.1573, -1.4757,
        -0.45967, 1.3291, -1.1949, 1.1964, -0.88812, -1.3668, -1.6045, -0.16604, -1.4027, -0.058422, 0.0010989, -0.52504, -1.3438, 0.67552, 1.3763, -0.96912, 1.3295, 0.2602, -0.31843, -0.73473, -1.3685, -0.50674, -0.37701, -1.253, -1.2341,
        0.81492, 1.3856, -1.3119, -0.011284, 0.53249, -0.42735, 1.2952, 0.80197, -0.60817, 0.91734, -1.1561, 1.3935, -2.0088, -0.76851, -1.8898, 2.3419, -1.3677, 1.439, 1.0767, 1.0974, -1.3005, 0.68325, -0.86961, -0.77056, 1.1543,
        0.59706, 1.6193, -1.1535, 1.2992, -0.35628, 1.3946, -1.387, 0.78649, -0.30938, -0.90041, 1.1249, -0.76016, 0.23386, -1.4741, 1.2117, -1.656, 0.53664, 0.70564, -1.1407, 1.1467, -1.0362, -0.59907, 1.7021, 1.4383, 0.58703,
        -1.0447, -1.4054, -1.6815, 0.65229, 1.5727, 1.1316, -1.2256, -0.64486, -0.5122, 1.4773, 1.795, -1.142, -2.0939, 1.083, 1.8366, 0.67276, -0.84794, -0.46467, -0.83631, -1.2211, 1.7312, 0.73537, 1.7659, -1.7048, -0.89983,
        -0.46938, 0.61889, 0.85984, 1.6012, -1.3044, -0.88695, -1.0687, -0.017383, 0.98095, -1.1683, -0.70813, -1.413, -0.029903, 0.95316, -1.1824, -1.7299, 0.86859, -0.60428, -1.1596, -0.57276, 0.85114, 0.70937, -0.85834, 1.0072, -1.0965,
        -0.85989, 0.01519, -0.99057, 1.9392, 1.1859, -1.5716, 1.456, -1.7825, -0.28776, 0.73519, 0.54544, 1.2276, -0.31025, 1.7178, 0.49296, -0.47179, 0.72135, -1.024, -1.2194, 0.084844, -0.35228, 1.535, -1.4406, 0.80902, 1.0735,
        -1.1999, 1.3026, -0.27755, -0.88722, 0.16935, 1.8184, -0.7449, 1.4652, 1.027, 0.70532, -0.96637, -2.5437, -0.8109, 1.5096, -0.38298, 0.69409, -1.799, 1.4571, 0.050973, -1.116, 0.63934, 1.5716, -1.3393, 1.7807, -0.29978,
        0.20394, -1.5461, 0.31167, 1.1661, 1.7099, -1.4728, -1.1908, 1.4703, 1.5757, 1.937, -0.12496, 0.84856, 1.3364, -0.72786, -1.1982, 1.5189, 1.538, -0.72937, 0.71337, 0.17962, -1.2861, 1.4568, -1.7658, 0.40988, -2.6571,
        1.399, -0.99895, 1.7818, -0.2465, -1.7588, -1.6671, -0.50775, -1.2376, 0.44208, -1.0376, -1.1272, -0.65555, 0.15546, -1.8963, -0.21581, 0.77933, -1.2613, 1.1708, 1.165, 1.1432, 0.69569, -0.76942, -1.8027, 0.74907, 2.0431,
        -0.96032, -0.56658, 0.023741, -0.18144, 0.68799, 0.97591, -0.89769, -0.31834, 0.1053, 0.81255, -0.39941, -0.85714, -0.55123, -0.68196, -1.7667, 1.4634, -1.4548, 1.143, -0.79833, 1.3997, -2.0822, -0.46033, -1.8376, -0.89422, 1.5328,
        -0.44861, -1.7, -1.5277, -1.5059, 0.07606, -0.825, -0.55819, -0.80466, 0.50788, -0.71784, 1.3183, -0.45631, -0.1066, -0.88466, -2.0232, 0.048611, -0.5598, 0.94539, 0.68406, 1.5838, -1.0663, -0.83187, 1.1512, 1.3206, 0.74006,
        1.1286, 0.40865, 0.4119, 0.22663, -0.98456, -1.164, 1.5632, -0.13002, -0.067259, -1.4094, -0.8157, 2.1825, 1.3575, -1.2291, -0.50589, 0.77377, -1.0665, -0.12131, -0.47633, 0.020202, 1.1149, 2.4027, 1.2619, 1.0379, -0.3372,
        -0.77087, -0.91655, -0.37554, 0.81447, 0.11471, 0.1091, -0.9013, -1.1339, 1.2682, 0.85791, 0.99016, -0.03539, -0.56388, -1.8507, -1.8744, 1.0958, -1.2935, 1.1002, 0.69126, 2.2825, -1.545, -0.93217, -0.97938, 0.42292, -1.8759,
        1.335, 0.71473, -0.78038, 0.38574, -0.98809, -1.1848, -0.40869, 0.95717, -1.4772, 0.58695, 1.5327, 0.35671, -1.1579, 2.0556, 0.25995, -1.0099, -1.1182, -0.67694, -1.0954, -0.41244, -0.91617, -0.90029, -1.4503, -0.78073, -1.4286,
        -1.62, -1.6664, 0.81772, -1.116, -0.79768, -0.75849, 1.2204, -2.6942, 0.4112, 0.75423, -0.68074, -1.0923, -0.70885, 0.58478, 0.71738, -1.1991, -1.1254, 0.89933, 1.5148, 0.21236, 1.2619, -0.97377, -0.085083, 1.1705, 0.69361,
        -1.2064, -0.77584, -1.3907, -1.5039, -0.5036, 1.0738, -1.6829, 1.1146, -0.68424, -0.32334, 1.1954, -1.5875, -0.82023, -1.6212, 0.51438, -0.42061, 0.74594, -0.35118, 0.76172, 0.98727, -0.91784, 1.3898, 0.035646, -0.94218, 0.82786,
        -1.2085, 1.1447, -1.1405, -0.1162, -0.47089, 0.76531, 1.0055, 0.76328, -1.6365, -0.82495, 1.7301, -1.4746, -1.7113, 1.5815, 0.68371, 0.54816, -1.3446, -0.012168, 1.5217, -1.2182, -1.404, 1.3446, -1.4897, 1.7992, -0.94971,
        0.38796, -1.4443, -1.6344, -0.03245, 0.99964, 1.5734, -0.99451, -2.1146, -0.44003, -0.76042, -1.2862, 1.3114, 0.1318, 0.48671, -0.23935, 1.6151, 1.6154, 0.85707, -1.0609, 0.20311, -1.1972, -1.2745, -0.7233, -2.1966, 2.0482,
        0.29401, 1.7622, -1.7752, 0.32492, -0.27463, -0.74111, -0.68216, -0.63692, 0.93147, 2.0235, -0.79937, -0.57711, -1.6746, 1.1125, -0.79499, 1.2461, -0.78232, 1.0987, -0.88642, -1.5394, -0.059326, -1.1101, -0.41095, -1.1863, 0.72073,
        -1.4317, 0.61957, -0.92414, 2.0867, 1.3198, -0.28368, 1.3755, -0.72741, 0.13573, 0.70602, -0.70568, -1.523, -1.0921, -0.73438, -0.76007, -0.30553, -1.358, -1.0365, 1.0715, -1.5215, -1.6235, -0.73678, -1.165, -0.84064, -1.1005,
        -1.0121, -1.2795, 0.030951, 0.54484, 1.8599, 0.58451, 2.5267, -1.9082, -0.44372, 2.0406, 0.79847, -1.0334, 1.4849, -1.109, 0.92963, 0.75307, 0.97793, 0.86615, -1.1133, -0.43908, 1.0991, -0.48149, -0.77786, -1.5563, 1.2873,
        0.32211, -1.2903, -0.2369, 1.871, 1.4654, -0.39924, -1.3318, -0.57899, 2.5019, 1.7447, -0.6574, -0.035442, 1.3302, 0.80252, 1.3464, 1.6047, -1.0536, 0.96682, -2.1978, -1.1379, -0.31805, -0.7491, 0.50399, -0.68173, -1.0119,
        0.23601, 1.0262, 0.79707, 0.53837, -1.3643, 0.033466, 0.80095, 1.1872, -0.24285, -0.059879, 0.27157, 1.0388, 0.71467, 1.219, -0.65339, 0.95956, 0.9891, -0.89068, -0.43893, 2.2279, 0.9122, -1.4183, 1.1959, 0.41662, 1.3261,
        -0.44118, 0.31708, 1.409, -0.58482, -0.052542, 1.1199, -1.1106, -1.4263, 0.75601, -0.52561, 1.602, -0.15211, -1.4881, -1.2366, 0.92657, 1.224, -1.8974, 1.4704, 0.18232, 0.21722, -1.4417, -1.1233, 1.2759, 0.051055, -0.72092,
        -1.6308, 0.27524, -0.97914, -1.3941, 1.1339, 0.20085, 0.71811, 0.11143, -1.443, -1.7647, -1.2945, -1.8982, -0.93199, 0.50053, -0.78336, 0.31816, -1.6391, -0.18412, 1.3437, -2.0151, 0.26717, 1.5442, -1.0942, -0.034681, 1.6892,
        1.0078, 0.26609, 0.4157, 0.33905, 1.2775, 2.0767, 2.2833, 1.0803, 1.1591, -0.81216, 1.621, 1.5071, 1.3469, -0.9083, -1.2399, 0.30487, 0.033275, 1.8457, 0.72038, -0.97824, -1.2758, 0.94042, 0.86378, -0.94766, -1.2778,
        0.6013, -1.6302, -1.4093, 0.1999, -0.74068, -0.69347, -0.98832, -0.47792, -1.346, 0.0044775, -0.70999, -1.5119, -0.64825, 0.84131, 1.5227, 0.66852, 1.5837, 0.7576, 0.86653, -1.2662, -0.46183, -0.083906, 0.27456, -0.72061, 0.96342,
        -1.2306, -0.19654, 0.78387, 0.60976, 0.19683, -0.91394, -1.581, -0.38196, -0.19028, -0.13134, -1.4151, -1.7864, -2.1471, -1.0589, 0.65231, -0.61825, -0.9121, 0.6118, -0.95903, 1.2144, 0.89974, -1.4257, 0.63333, -0.37296, -0.24042,
        0.76304, 0.96406, -0.26054, 1.4935, -0.15071, -0.50579, 0.95687, 1.0445, -0.95243, 1.7888, -1.0886, -1.0548, 0.39238, -0.98238, 0.50824, -0.3798, 1.7706, 1.0803, 1.2572, -1.0335, -1.3516, -0.36893, 1.0608, 1.4117, 2.3152,
        -0.22668, -1.3522, -0.35825, 0.27707, -0.065338, -1.323, -1.4629, 0.091451, -1.5328, -0.37667, -0.84497, 0.76068, -1.1971, 0.81624, -1.1505, 0.70962, -0.44179, -0.75393, -0.82908, 0.85897, 1.7918, 0.82183, -0.78147, -0.54565, -0.85368,
        1.2529, -0.43397, 1.0308, -0.37686, 1.8381, -1.759, 0.87746, 2.4192, 0.16191, 1.2449, -0.26483, -0.48082, 0.86313, 1.6194, -1.3704, -1.6933, -1.1966, 0.65375, -1.6854, -0.37031, 2.2169, -0.56094, -0.040426, 1.2336, 1.1433,
        -0.91653, -1.8448, -1.6999, 0.10737, -1.549, -0.89831, -1.2469, 1.6341, 1.2613, 0.23712, 1.9601, -0.10565, -0.42945, -0.77629, 1.3662, 0.5513, -1.1018, -0.74806, 0.98313, -2.1519, 0.2591, 0.63744, 0.48192, 0.041075, 0.78176,
        -1.3651, 1.1494, -1.2885, 1.0398, 0.94993, -0.85483, 0.53088, -0.8827, 1.1239, 1.1742, -0.17802, -1.1757, 0.62001, 0.19386, 0.9848, -1.2895, -0.42507, 0.99897, 0.73715, -1.2247, 0.94668, 0.73364, 1.6599, 0.30239, 0.47714,
        0.87882, 0.6848, 1.4919, -0.32195, 0.58729, -0.75187, -0.56564, -1.6935, -0.57012, -1.22, 1.7398, -0.33811, -1.541, 0.7388, 1.0392, -1.5346, 1.0926, 1.1358, -1.6096, 0.65027, 1.3085, 0.51159, 1.6038, -0.28572, 0.35892,
        -1.5288, -1.5192, -1.7265, 1.3094, -1.1272, -1.3743, 0.90237, -1.2071, 0.49845, 0.23771, 1.176, 1.8853, 1.1421, 2.1431, -1.7347, 0.83718, 1.4649, -1.2335, -0.11151, -0.96884, -1.4599, -0.61884, 1.6412, 1.23, -1.7343,
        -0.67397, 0.4892, -1.2192, 0.82943, 0.43442, 1.7971, -2.3138, 0.75537, 1.1367, -0.92823, -1.3081, -1.3801, 0.028882, 1.0405, 1.7452, -1.4201, -1.0672, -0.90059, -0.87449, 0.45548, 0.15551, -1.8283, -1.1159, 0.81371, -0.71153,
        -1.5015, -0.31492, -0.68991, -0.51281, -0.94165, -1.1348, -0.015731, 1.5112, -0.21851, 0.88685, 1.2904, -1.5481, 0.38933, -0.60258, -1.2553, 0.91338, 0.47176, 1.6531, 0.34181, 0.069934, -0.49592, -2.0997, -1.0797, -0.80598, 0.36264,
        0.44963, 0.1432, 1.5529, -1.3227, 0.54577, 1.5486, -1.1358, -0.67934, -1.7446, -1.4088, -1.1808, 0.86036, -0.77886, 0.65509, 1.0126, 0.86715, 0.52596, 0.30713, 0.73699, -0.21714, 1.3904, 1.0526, -0.57464, -1.2333, -0.76844,
        1.4686, -1.6227, -0.67238, -0.85634, 1.1927, 0.74293, -0.82127, 0.62877, 1.9604, -0.49674, 0.76779, 1.2474, 0.27401, -0.95721, 0.36012, 0.54782, 1.284, -1.0765, -1.2232, 1.8495, 1.1556, 0.60232, -1.3016, 0.33026, 0.89281,
        -0.69428, -0.75138, -1.0387, -1.106, 1.5694, 1.1168, -0.10063, -1.1941, -0.67186, 1.0415, -1.3112, -0.34396, 0.92237, -1.3008, -1.2314, -1.2699, 0.39459, 0.83427, -1.7409, 0.96335, 1.3428, 1.2926, -1.4455, -1.4767, 0.29318,
        -1.6623, 0.16267, 1.3489, -1.0944, -2.0257, 0.35148, -1.0188, 1.4963, -0.17924, 0.53152, 0.9043, 0.65483, -0.96102, -0.8153, 1.2265, -1.4254, -1.1623, 0.8179, -0.28069, 0.61288, 0.73208, 1.2853, -0.45279, 0.85323, -0.58041,
        -0.85133, 1.1146, 1.0598, 1.0998, -0.70781, -1.3641, -0.95236, 0.71078, 0.62571, -0.45172, 2.3395, 0.63375, -1.0243, -0.18335, -1.6802, -0.53731, -0.94949, 0.93504, -0.11624, -1.1474, 0.14106, 2.3873, 1.1327, -0.82328, 1.1521,
        0.46273, -0.79636, -0.84338, 1.098, -0.71393, 0.74365, -0.73644, -0.47713, 0.38267, 1.5696, -0.057764, -0.79204, 0.51124, 1.5098, 1.2982, -0.90469, -1.1828, -1.024, 0.087755, -0.56378, 0.52681, 0.84323, 0.10728, -1.0441, 1.0152,
        1.7149, 1.4771, -0.97505, -0.49607, 0.87101, -1.6199, -1.3114, -0.43429, 2.2143, -0.91435, -1.3431, -1.1111, 1.5578, -1.199, 1.0726, 0.014596, -0.93276, -1.4438, -1.9289, 1.069, -1.3924, -0.37923, 1.1612, -1.162, 0.18203,
        -1.1309, 0.62041, 0.74543, 0.078344, -0.22613, -0.66618, -0.88573, -0.52906, -1.1962, -1.3102, 1.9419, 0.70499, -0.55738, 1.7383, 1.5802, 1.7796, -0.97509, 0.90657, 0.79003, -1.3207, -0.21551, 0.96176, 0.61797, -1.2434, 0.0070087,
        -0.65355, -1.3043, -0.48611, -0.46736, -0.39437, -0.4828, 0.39106, 0.43486, -0.78903, 1.1254, -0.90352, -1.6484, -0.68007, -1.1818, 1.3794, -0.88971, 1.2697, 0.70088, 1.8394, 1.2627, 1.0889, -0.011163, 0.92565, 0.55975, 0.49324,
        -1.6428, -0.86185, -2.1363, 1.0289, 1.1546, -0.91629, 0.57533, -0.80258, 2.1798, 0.80612, -0.66589, 0.79009, 0.48415, -0.20507, 1.3498, 0.86491, -0.4869, 1.6711, 1.638, -0.45102, -2.0949, -1.3858, -1.5133, -1.3292, 0.43935,
        1.5033, -1.3787, -0.96934, -1.6125, -0.45843, 0.68799, 1.0404, 2.1686, 1.8997, -0.18647, -0.41927, 0.72843, 1.9426, -0.027973, 0.80062, -2.3264, -0.2222, 1.342, -1.4026, -0.95734, 1.3322, -1.1286, 1.2988, -1.846, -0.13769,
        -0.77776, -0.07853, -1.7294, 2.2143, -0.99697, 0.34383, -0.99285, 0.043053, -1.0092, 1.9416, 0.67735, 1.3042, 0.95757, 0.96448, 1.0107, -2.042, 0.56491, 1.3756, 1.6226, 0.95148, 0.98394, -0.55124, -1.8809, -1.0468, -1.3696,
        -0.84895, 0.81072, 1.7618, 1.4441, 1.417, -0.1396, -1.6513, 0.64669, -0.51919, 1.214, 0.70868, 0.29474, 1.1583, -0.43909, -1.7737, -1.5276, 2.3958, 0.84907, 0.77701, 1.5252, 0.17849, 0.43802, 0.96593, 0.70377, -0.39389,
        -1.1337, -0.49932, 1.0049, -0.23913, -1.7891, 0.84695, 0.87704, 0.84538, 0.4742, 0.21234, -0.49335, -1.3519, -1.5411, 0.1075, -1.3606, -0.4681, -1.7772, -1.1419, 1.7583, -2.5586, 1.22, -0.10376, 0.50732, 1.3483, 0.9686,
        0.82936, 0.88538, 0.99731, -0.59094, 1.1592, -1.1196, -1.6504, 0.77579, 0.39482, 0.95732, 1.5259, -1.2103, 1.6169, -0.41787, -1.1104, 1.8733, -0.52344, -2.0482, 0.82938, 1.0003, 0.24815, -0.69128, -0.090747, -0.5217, -0.89918,
        -0.59159, 2.0496, -1.6107, -1.2882, -1.1231, -1.2264, -0.70491, -0.22871, -0.74317, 0.42621, 1.2381, -0.35796, -1.6363, 0.56079, -1.2403, -0.67119, 0.86301, 0.021771, -2.0179, -0.87548, -0.80286, -0.47492, 0.41285, -0.98098, 1.2836,
        1.4953, -1.4467, 1.2475, -1.1078, -1.1849, -1.5941, -1.4795, 0.91543, -1.0586, -1.2622, -0.97298, -0.4273, -0.47999, 0.74954, -0.12495, 1.2487, 1.3647, 1.8827, 0.14994, 1.1623, 2.303, -1.0271, 1.5416, 1.152, 1.3024,
        -0.26785, 1.4535, -1.1834, 0.98663, 0.76673, 1.4448, -0.5808, 0.46356, -0.54735, 0.14204, 1.3046, 1.9971, -1.2025, 2.0815, -0.22231, 0.57076, -1.3764, -0.60314, -1.5028, -1.0942, 1.6431, 0.91337, -1.2313, 0.54269, -2.3168,
        -0.56211, 1.5245, 1.3487, -0.54273, 1.3998, 2.3192, -0.58568, 1.2709, -0.50817, 0.48563, 1.3078, 1.3448, 2.2455, 0.87246, 1.5486, -1.1103, 0.23485, -1.5666, -0.049144, -1.2649, -0.33992, 0.33601, -1.5767, -0.33571, 0.36852,
        0.98589, 0.90802, 0.80619, 1.238, -1.6124, -0.28356, -1.2426, 1.4109, 0.22101, 1.114, 1.5618, 1.0023, -1.3599, 1.4062, 0.10819, -1.8801, 1.3995, 1.5354, -1.4365, -0.2161, -0.67692, -0.92923, 0.090564, -0.46121, -1.3363,
        1.5033, 1.0792, 1.3464, -0.88023, -1.6544, -1.3653, -0.83911, 0.65248, 0.51746, -1.0544, -0.99573, 1.051, 0.30813, -1.3305, -0.15597, 0.70145, 0.75117, -0.21846, -0.28222, -1.4212, -1.4076, 0.11903, 0.56836, 1.2019, -1.9919,
        -0.25701, 1.3718, -1.3605, -0.55681, -0.097196, -0.54334, -0.94234, 1.5305, -1.1547, -0.65849, 1.4348, 0.1778, 1.2321, 0.99391, 1.1822, 1.0356, -0.67639, -0.21395, -0.61954, -0.61529, -0.44523, 0.66535, 0.27818, 1.7848, 0.53744,
        -0.4301, 0.73396, -1.4271, 1.0385, 0.49609, -1.8292, -1.6105, 0.64043, -0.59092, 0.67675, -0.47067, 1.8716, 1.0351, -1.3428, 0.16625, 1.5441, 0.86934, -1.0561, -1.5769, -0.79996, 0.92445, -1.3438, -1.5262, -0.011501, 1.1885,
        0.92786, 0.72557, 0.97087, 1.4112, 0.17512, -1.0151, 1.1697, -2.3582, 1.0454, 0.41167, 0.12323, -1.0605, -1.2993, 0.22268, 0.64795, 0.89483, 0.89537, -0.45082, 1.1, 0.59307, -0.63015, 0.5665, 0.12141, -0.52416, 1.6526,
        -0.8804, 1.4663, 0.46645, -1.3475, -0.66126, -1.5416, 1.6201, -2.1908, -0.16864, -1.4509, -1.7063, 0.27486, 0.33614, 0.5167, -0.46768, -0.1793, -1.5371, -0.95065, -0.25515, -0.78012, -0.93168, 0.1253, 0.57724, 1.6504, 1.966,
        -0.46635, -1.1815, 1.3096, -0.18373, -0.7152, -0.19816, 1.2551, -0.50486, -1.2855, -1.1168, 1.4174, 0.31164, -0.89359, -1.1418, 0.46476, -0.91439, 0.17428, 0.50935, 1.2011, 1.5262, 1.2127, -1.1969, 0.13156, 1.0554, -2.1025,
        -1.8924, -1.3835, 0.1468, -1.2989, 0.40349, -0.42817, -0.25445, -2.347, -1.0735, 1.6615, -1.3449, 0.84614, -1.9793, -0.42009, 1.6794, 0.4774, 0.33994, 0.0088352, 1.5008, -1.028, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0
};

char raw_4096_45[4096] = {
        0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0,
         0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0,
         0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0,
         0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0,
         0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
         0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
         0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1,
         1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0,
         1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1,
         1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0,
         1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0,
         0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1,
         0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,
         0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1,
         0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
         0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
         0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1,
         1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,
         0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1,
         0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
         0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
         1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0,
         1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,
         1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0,
         0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1,
         0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1,
         1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0,
         1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1,
         1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0,
         1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0,
         0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
         0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1,
         0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
         1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
         1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1,
         0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1,
         1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0,
         1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1,
         1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1,
         0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
         0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,
         1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1,
         1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1,
         0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0,
         1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1,
         1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0,
         0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1,
         0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
         1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0,
         1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1,
         0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
         1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0,
         1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0,
         1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0,
         1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
         0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0,
         1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0,
         1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
         0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0,
         1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1,
         1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
         1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0,
         0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
         0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,
         1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
         0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0,
         0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1,
         1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0,
         1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
         0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
         1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0,
         0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0,
         1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
         0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,
         0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1,
         1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1,
         1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0,
         1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
         1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0,
         0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1,
         1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1,
         0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,
         1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1,
         0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
         0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1,
         1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0,
         0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0,
         0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
         1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1,
         0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1,
         1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1,
         1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
         1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1,
         0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,
         1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0,
         0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0,
         0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1,
         1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0,
         1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
         1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0,
         1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0,
         1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
         1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0,
         0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0,
         0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0,
         0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0,
         1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
         0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1,
         0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0,
         1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1,
         0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
         1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0,
         1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
         0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
         0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0,
         1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
         1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1,
         0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0,
         1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1,
         0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1,
         1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0,
         1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0,
         0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,
         0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1,
         0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1,
         1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
         0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,
         0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
         0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
         0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1,
         1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
         1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1,
         0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
         1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0,
         0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1,
         0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1,
         0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0,
         0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0,
         1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
         1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,
         0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
         1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1,
         1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1,
         0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,
         0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0,
         0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1,
         0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0,
         1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0,
         1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1,
         0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1,
         0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
         1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,
         0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
         1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1,
         0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
         0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0,
         1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1,
         0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1,
         0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
         0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
         1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
         1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1
};

ldpc_dbl r_4096_23[7168] = {
        -0.4308, 0.29068, -1.4321, -0.2628, -1.4502, -1.501, -0.29644, -0.90615, 0.74169, -0.82472, -1.3706, -0.97637, -0.40957, 0.92845, -1.4369, -1.6046, 1.9417, 0.83653, -0.82976, -1.4745, -1.7207, -1.9991, 0.50361, 0.74834, -1.1926,
        0.71973, -0.79627, 0.87521, -1.232, 1.8036, -1.4257, -0.99686, 2.5082, 1.1055, -1.0113, 1.3849, 0.2406, -1.5601, 0.90453, 1.6264, -1.6055, -0.89847, -0.23041, -1.4159, -0.44899, 0.26001, 0.68556, 0.41769, 1.4662, 1.5894,
        -2.1688, 1.4371, 0.75253, -1.5639, -0.84373, -0.69638, -1.2284, -0.45946, 0.34059, 0.77952, 0.80343, -0.49622, -1.1382, 1.1312, -0.94624, -0.78144, -1.2344, 0.32335, 1.146, -1.0921, -0.16463, 0.80758, -0.57722, 1.0636, 1.7863,
        0.76409, 0.53215, -0.75478, 0.12544, -1.3549, 0.45015, -1.5826, -1.2023, -1.5731, 1.9982, 1.2729, -0.20272, 1.7709, 0.01893, 1.2161, -1.4449, 0.88128, 1.3814, 1.3911, 1.1561, -1.0109, 0.70824, -1.1553, 0.098474, -1.6475,
        0.81815, 0.4923, -1.2343, 0.2758, 0.25072, 1.7211, 1.708, 0.58495, -1.2067, -1.6933, -0.5972, -1.3215, 1.2075, 1.1745, -0.6683, -0.90575, 1.155, 0.91262, 1.4582, 0.78707, 1.4026, -1.4361, 0.32619, 1.2928, -0.25986,
        -0.69103, 0.2905, 1.0956, 1.5984, -0.96282, 0.28095, -0.70719, 0.66132, 0.74566, 0.0068099, -0.90855, -0.36306, -0.24003, 0.23389, 1.2968, -1.5455, 1.5664, -0.98843, -1.0471, -1.3772, 2.221, -1.3806, 1.1583, -1.6019, -0.80618,
        0.57261, -0.4629, 1.3101, -0.7747, 0.27755, -1.1156, 0.33206, -1.5117, -1.7171, -0.84369, -0.77357, 1.3924, 0.47194, 0.50665, -0.52628, 1.2122, -0.30622, -1.7135, -1.386, -1.0241, -0.76803, 1.9074, -0.29127, -0.96487, 1.1238,
        0.42523, 2.0401, 0.25887, 1.4286, -1.5126, 0.5886, -1.1632, 1.5311, 0.74083, -0.092563, -0.66017, 1.065, 2.4657, -0.51877, -2.2334, 0.35511, -0.91369, 0.44659, -0.96397, 1.2859, 1.1293, -0.92314, 1.4594, -0.1208, -0.59047,
        0.84026, 2.1268, 1.0295, -1.2391, -1.8753, -0.30202, -0.72274, 1.0352, 0.88961, -0.30329, 1.8388, 1.3409, 2.0542, 1.576, -1.5912, -0.80739, -1.9916, 0.37206, -0.14073, -0.30456, 1.7857, 1.011, -1.71, 1.2004, 0.49835,
        1.1043, -1.5925, -1.2891, 1.1874, 1.723, 0.93838, 0.61382, -1.7422, -1.5652, 0.37618, -0.99885, -0.24178, 1.1668, -1.364, -0.85404, 1.4637, 0.84811, 0.83529, 1.4462, -2.836, -0.73679, 0.45725, -1.4554, -0.81161, -1.6607,
        -0.77429, -0.23676, 1.4534, -0.64209, -0.86733, -1.1734, 1.5838, -0.96698, -0.51035, -1.1333, 0.39349, 1.6216, 0.17821, 2.3934, 0.095688, 1.2355, -1.7486, -0.64425, -0.89261, 1.7094, 0.47186, 0.62792, 1.5348, -1.1973, 0.98461,
        0.77781, -0.65242, 1.4828, 0.61037, -1.0777, 0.25764, -1.053, 0.97703, -0.89534, -0.62109, 1.6786, 1.2768, 0.63664, 0.26279, -1.6764, -0.64352, -1.4779, 0.87491, -0.95439, -1.1457, -1.1994, 0.95412, -0.78892, 0.84495, 1.2473,
        1.5851, -0.89833, -1.1656, 1.1985, -0.68387, -0.11435, -1.6561, -0.64243, 0.26358, 0.68387, -1.3774, -1.8377, 1.5333, 2.165, 0.76223, 1.7288, -0.66689, -0.81068, 1.2698, -1.148, -1.8661, -1.0036, -1.3068, 1.3508, 1.7789,
        -0.7384, 2.718, -0.73992, 0.58254, 0.5083, -0.81103, 0.40329, 0.156, -0.33031, 2.091, -1.9663, 1.3653, 1.0002, 0.65417, 1.0869, -0.6336, 0.072229, -2.0259, 0.010218, -1.2287, -1.0662, 0.91903, 1.8984, 1.6388, -0.68446,
        1.8879, -1.2815, 2.0404, -0.86963, 0.76467, -0.77642, 0.67206, -0.7355, 1.4643, 1.5407, 1.9754, -0.90155, 0.48286, -1.5502, -0.66834, 0.70676, -0.04914, -1.7498, -0.079167, -1.0774, 0.57856, -0.38791, -1.5721, 0.70846, 1.0226,
        1.1962, 1.8857, 1.4092, 0.93831, -1.4649, -0.77246, 1.613, 0.91651, 1.9039, -1.4862, -1.0556, -1.0982, 1.2298, -1.3595, -0.55684, 0.12343, -1.215, 1.4867, 0.80676, -0.047892, -0.48619, 0.85696, -0.75671, 0.58923, 2.6159,
        1.225, -0.28761, 1.4935, 0.36787, 0.94457, -0.64542, -0.93318, -0.6586, -0.88231, 0.74086, 1.2452, -0.47685, 1.7326, -0.83765, 1.5004, -1.2808, 0.28611, 1.1264, -0.19049, -0.72715, 1.0676, -0.69711, 1.1367, 0.32788, -0.81081,
        -0.95623, -0.59792, 1.7407, 0.97124, 0.021091, 1.1003, -1.283, -0.11344, -1.9591, -1.6236, -1.4967, 1.9359, -1.579, 0.66573, -2.1545, 1.0019, -0.65666, 0.20985, -0.47914, 0.97792, -0.083138, -0.97621, 2.6958, 1.1486, 1.7091,
        -1.9056, 0.9877, -2.4171, -0.39537, -0.17769, 0.82482, -2.864, -0.68045, 0.75068, -0.31767, -0.23733, -1.0757, 0.47068, -0.94042, 0.10278, -0.70739, 0.59332, -1.2417, -2.0777, 1.0252, -1.963, 0.3779, -0.46618, -2.2173, -1.4766,
        2.1605, 1.4571, 1.5048, -1.1274, -0.13737, -1.1119, 1.323, -2.202, -0.52031, 0.57337, 1.7112, 0.80813, -2.0396, -0.69236, -0.47246, 1.0007, 0.026638, 1.1954, 0.91698, 1.4093, -0.3491, 1.552, 1.5659, -0.39101, 0.55181,
        -1.0073, 0.075523, -1.0941, 1.5393, 0.15547, 0.59961, 1.5359, 0.89647, -1.1618, -0.58227, 1.0299, 0.95164, -1.715, 1.2726, 2.3172, -0.59121, 0.18412, -0.034554, -0.95419, 1.0684, -0.93745, -1.1095, 2.0297, -1.4975, 0.31305,
        0.75647, 1.3164, -0.82669, -2.1376, -2.6796, -0.73383, -0.16631, 1.2802, 1.223, 1.0344, -2.0147, 1.0296, -0.35593, 0.54264, 2.1905, 0.6414, 0.56692, -0.86999, 0.7355, -0.5684, 0.8682, 1.3957, 1.1959, -1.4922, 0.25461,
        1.4946, -0.66876, -1.4658, 0.6515, -0.30073, 0.45261, 0.95982, 0.07538, -1.2278, 0.35335, -0.80188, 1.6795, 1.3311, 0.75925, -0.70832, -0.42825, 0.37819, -0.61044, -0.80697, -0.63462, -1.7534, 1.4042, 1.3751, 1.0922, -0.99665,
        -0.80789, 0.16397, -0.24766, 0.85938, -2.1253, -0.87121, -1.8055, -1.4164, 1.0664, 1.086, 1.447, -0.75155, -0.83303, 1.6264, -0.44967, -0.18347, 1.1686, 0.43532, -0.39452, -0.71494, 2.1485, 0.029401, 1.2014, 0.41812, -1.3055,
        -1.0132, 0.49502, 0.87558, 1.4719, 0.99952, 0.29193, -1.7403, 0.67662, -0.60727, -1.2422, 1.4765, 0.51018, -1.8142, -1.5477, 1.1501, 0.88144, 0.49015, -0.48564, 1.0397, 0.74762, 0.58825, -1.3625, 0.96709, -0.97276, 1.2931,
        1.2204, -0.21491, 2.034, 0.35245, -0.78018, 0.47279, -1.3827, -1.1913, -1.1462, -1.4398, -0.47001, 0.18654, -1.574, -0.23178, -1.0718, 1.9152, 0.97032, 0.23943, -0.58234, -0.43456, 1.2019, -0.92007, -0.6479, 1.5521, 2.5982,
        -0.43062, -0.057432, 0.75134, -0.09575, -1.7914, 0.32635, -0.029077, 0.81983, -0.91636, 2.2473, 1.5149, -1.1237, 1.4092, 0.28777, -0.68539, 0.53102, 0.55821, 1.0354, 1.6047, 0.96815, -0.19183, 1.0326, -2.052, 1.0534, 1.6102,
        -1.3535, 1.3342, -0.060349, 1.4115, 0.089225, -1.5048, 0.81722, 1.7226, -0.0071149, -0.0095934, 1.9576, 0.69136, -0.95035, 1.2819, -0.32805, 0.39726, -0.67381, -0.13849, -0.90046, -0.6842, -1.3935, -1.5623, 1.0958, 1.311, -0.13647,
        1.2612, -0.35928, 1.0327, -2.2406, -0.20464, 1.4908, -1.1269, 0.49196, -1.4819, -1.1761, 1.4435, 1.0912, 1.6784, 1.7352, 0.96037, 0.64221, -0.43429, 0.69187, 1.8454, 0.93966, -0.14989, -0.75179, -0.6321, 0.293, -0.22838,
        0.31348, 1.0566, -1.7911, 1.3141, -0.93135, -0.12234, -1.7259, -1.1498, 1.5164, 1.0346, 0.14697, -0.92677, -1.3606, 0.64591, -0.19382, 0.40566, 1.4954, 0.70922, -0.77147, -0.88414, -1.5353, -1.3141, 0.64725, -0.66007, 1.3897,
        1.3263, -0.98767, -1.7146, -0.19245, -0.82719, 0.64547, -0.60218, -0.46009, 0.99283, -0.25773, -1.2357, 0.99605, 0.1839, 0.30339, 1.3301, -0.95551, 1.2426, -0.033964, 0.81841, -1.1294, -1.1928, 1.4757, -0.7981, 0.9165, -0.28921,
        1.6887, -1.7152, 0.34847, 1.1753, 1.564, 2.0308, 1.5903, 0.13762, -1.6326, -1.2803, -0.69465, -1.0755, 1.7405, -2.2011, 0.45017, 0.99627, 1.3994, 0.68716, -1.5703, 0.95323, -0.13142, -1.6454, 0.50217, -1.8282, 1.2272,
        -0.81283, -0.60582, 2.0484, -0.71374, -0.52511, 0.21793, -0.87145, 0.96617, -0.76878, -0.62314, 0.0066172, -0.62093, -1.6867, -0.93217, 0.11154, 0.64711, 0.95689, 1.3918, 0.88817, 1.4485, -0.86387, -1.0781, -0.070848, 1.6399, -0.85593,
        1.9863, -1.0121, -1.7601, -0.58511, -1.4797, 0.74195, 0.48562, -1.7033, 1.3442, -2.3615, -0.64513, -1.1133, 0.59481, -0.71949, -0.74459, -0.7348, -0.62427, 1.464, -1.394, -1.4627, 1.2556, -0.27763, -0.88033, 0.2547, -1.2759,
        -0.0027823, 1.1325, 0.17132, 1.2547, 0.19131, 1.5466, -1.6453, -0.8533, -1.6942, 0.39884, 0.78776, -1.9204, 1.2287, 1.2407, -1.2423, 1.0634, -1.3665, 0.31571, -1.8814, -1.4321, -0.68849, -0.71511, 0.21121, -1.8325, 0.63014,
        1.8585, 0.52737, 0.017424, 1.1633, 1.1224, -0.78621, 1.4234, -0.19248, -1.7294, 1.2768, 1.0222, -0.6966, 1.7018, 1.8226, 0.20966, -1.1285, 0.46725, 1.3009, 0.98106, 2.4111, -0.011897, 0.22237, -1.3232, -1.9916, 0.6205,
        -0.021075, -0.8626, 1.0462, 1.2115, 0.61634, 0.93369, 0.7019, -1.0457, 1.8537, 0.46747, -0.38479, -0.7177, 0.9978, -0.94076, 1.4054, -0.50845, 1.3452, -1.5609, -0.52777, 0.0030062, 0.64168, -1.1656, -0.11904, 0.76109, -1.6839,
        0.11347, -0.97227, 1.3845, 1.169, -0.69933, 0.95247, -1.3638, -1.4532, 1.9212, -0.97247, -1.4197, -0.49756, 0.81996, 0.73077, 0.6594, -0.88809, -1.1692, -0.16982, -0.25655, -1.7252, -1.2041, -0.41186, -0.28954, -1.2287, -0.82866,
        -1.1574, -0.40744, -1.068, -0.092404, 0.097223, -1.026, 0.21791, 1.2176, -0.935, -0.87159, 0.53947, -0.62997, -0.86575, -0.92611, 0.4025, 0.16386, -1.3009, -0.012455, 1.1037, -1.1549, 0.14936, -1.332, -1.5298, -1.4493, 1.1756,
        1.1609, -0.74438, -0.06741, 0.44794, 0.19249, -1.5991, -0.46052, -2.1304, -1.6003, 0.88999, 0.37077, 0.86306, -2.2043, -1.494, 2.3346, 0.70229, -0.98724, -0.80737, 0.25367, -0.74499, 1.1675, 0.13153, -0.23771, 0.36734, -0.76222,
        -0.76214, -1.3032, 1.2574, 0.71095, -0.52086, 1.0208, 0.59158, -1.1541, -1.4846, 0.5437, -1.2318, -2.0351, -2.4817, -0.97069, -1.6053, 1.2408, -1.8254, -0.17554, -0.065086, 0.64853, -1.6243, -2.0737, 1.4351, 0.8264, -1.5371,
        0.22248, -0.46781, 0.86145, -0.81326, -0.49382, 0.46438, 0.94884, 1.518, 1.7952, 1.8928, -1.7499, -2.0386, 1.482, 2.0409, -0.5405, 1.2139, -0.79549, -0.84109, 0.32908, 0.87858, 0.5174, 1.9944, 1.4608, -0.78764, 0.58396,
        -1.7219, -1.1644, 1.2103, -1.0902, 1.2318, 0.76663, -0.80884, -1.2468, 0.81187, 0.44583, 0.95264, -0.71451, 1.3261, 0.20524, 1.0383, -1.0283, -0.85084, -0.7672, -2.3762, 0.99785, -1.1985, -1.5868, 0.79106, -0.17146, 0.78636,
        0.75932, 1.5747, -1.302, 0.33566, 0.43808, -1.5783, -0.26071, -1.3285, 0.80342, 0.41481, 1.4424, 0.44321, 1.6929, 1.4936, 0.64531, 0.59801, 0.70067, 0.99709, -0.75924, -1.6078, -1.0787, 0.71012, 0.039246, 1.6146, 1.0521,
        -1.3869, 1.2905, -1.6004, 0.30343, -1.63, -0.83106, 1.2438, -0.9245, -1.5366, -0.44834, 0.16139, -2.0307, -0.73624, 1.1242, -0.51185, -0.073307, 0.3327, -1.4465, -0.76354, 1.1305, -0.8705, 0.89608, 1.2324, -0.26848, 1.8275,
        1.9397, -1.7865, 0.20485, -1.025, -0.58935, -0.82502, 0.94305, 1.3965, -2.4462, -0.93761, -1.6771, 0.029258, 1.1038, -0.7172, -1.6243, 0.55853, 2.4595, -2.3667, 0.63912, -0.7391, -0.69033, 1.4065, -0.58028, 1.4483, 0.8185,
        1.0908, 1.4741, 1.4948, -1.33, 0.2644, 0.9484, -0.15014, 1.3255, -0.41027, -1.2271, -1.3848, -1.4773, -1.8012, 0.41998, -1.103, 0.74939, -2.484, -1.3081, 1.7993, -0.94773, -0.91912, 1.4142, -1.1622, -0.52676, -0.46508,
        -1.502, -0.61827, -1.1771, 1.13, -0.97134, -1.7187, 0.68592, 0.25611, -1.8634, 1.2933, 0.62724, -0.66531, 1.0895, -1.0104, -1.3577, 0.92445, -1.3402, -0.039118, 0.11653, 1.2103, 1.3166, -0.83438, -2.3573, 1.2656, 0.91834,
        -0.84734, 0.47948, -0.41876, 1.1697, -1.8097, 1.008, -0.80667, -1.3777, 1.2164, 0.97947, -1.3744, -1.0358, 2.3553, 0.69494, -0.6969, 2.0477, 1.9581, 0.18653, 1.7272, 1.4091, -2.2172, -0.62453, -0.2502, 1.4352, -0.48098,
        0.66129, -1.2036, -1.9056, -1.7709, -0.8345, -1.308, 1.5205, -1.3212, -1.4721, 0.015642, -0.94944, 1.0924, 2.2754, -1.829, -0.49144, 0.10953, -1.4988, 0.81204, 0.39372, 2.2672, -1.8052, -1.8411, -1.316, 0.91976, 0.84083,
        -0.16984, 1.6915, 0.97175, 0.7619, 1.2892, -0.74084, 0.5175, 1.9082, 0.11658, 0.971, 1.6639, 0.048393, -1.6506, -0.76238, -0.87116, -1.3729, -0.3246, 0.43126, 0.48255, -1.9296, 0.062501, 2.0088, -0.092774, -0.86757, -1.099,
        2.4495, -1.0051, -0.69446, -1.6649, 0.84743, 1.0501, 1.0885, 1.5712, 0.52638, 0.61509, 2.6452, 1.1735, -1.2861, -0.71403, 0.88752, -0.20083, 1.2618, -1.1868, 1.5151, -0.9548, -1.2527, -0.54529, -0.7431, 1.3437, 0.36039,
        -0.75534, 0.23942, -0.84738, 0.8839, -0.23252, -0.9529, -0.35087, 1.2722, 0.82301, 1.2087, 1.1758, -1.1497, -0.045056, -0.93572, -0.61718, -0.90359, 1.3227, 0.73608, -1.191, -2.0716, 1.2003, 1.7591, -1.7692, 1.1768, -0.67833,
        -1.3159, 1.2108, -2.1466, -1.3618, -1.0468, 0.14982, 0.63488, -0.87003, 1.0208, 2.2161, -1.199, -0.91455, -1.66, -0.83437, 0.29756, 1.6843, -1.3195, -0.57103, -0.50105, 1.7373, 0.21481, 1.093, -0.80583, 0.6644, 1.8408,
        -0.81915, -1.2812, 1.404, 1.1457, -1.828, -1.3112, 0.96795, 0.60239, -0.4939, 0.79944, 1.1393, -0.14673, 0.19337, 1.0929, -1.4431, -1.2334, 0.53534, -1.0815, 0.44689, 1.5562, 0.32523, -1.5771, 0.43883, -1.3755, 1.2966,
        -0.6382, 0.047378, 1.2366, -0.43701, -1.4073, -1.4712, -0.6613, -2.0328, 0.20624, -0.0047516, -0.83223, 0.18797, 1.6432, -0.75679, 1.275, -0.99524, -0.61981, 1.49, 0.95494, 0.45741, 1.1401, 1.0869, 0.2881, 0.5858, -1.0238,
        -0.46268, -1.1634, 0.40617, 0.62233, 0.71311, 1.2217, -0.33072, 1.7298, -1.5861, 0.99715, 0.64298, -1.7922, -0.17926, 1.7357, -1.0849, -1.9927, -2.6331, -1.0294, -0.57031, -0.11926, -0.29332, -1.5826, -0.072061, -0.63526, -1.1905,
        -1.2613, 1.2774, -1.499, 0.5588, -0.83121, -0.25653, -0.2525, 0.0037746, 1.3929, -1.9379, -0.72957, -0.97401, -1.8618, 1.0042, -1.4473, -1.3866, -0.81883, -0.97286, -1.7321, -0.45661, -1.0412, 0.50098, 0.57239, -0.17571, -0.63326,
        -1.7464, -0.25349, -0.85599, -0.32429, 0.90366, -0.80376, 1.6678, 0.70315, 0.67174, -0.57292, -0.95808, -0.64083, -0.83379, -0.63033, -1.6998, -0.36346, -1.0061, 0.33082, 1.4639, 1.0438, 1.8506, 0.35931, 0.40966, -2.3384, -1.5281,
        -0.14838, -0.3523, -1.0475, -0.6524, -0.69091, 1.0121, 0.75396, 0.31082, -0.45133, 1.5298, -0.50225, -1.0119, 0.97625, -0.85643, 1.0458, 0.70021, 1.2824, -1.196, 0.36743, -1.7256, 0.91259, 0.65754, 0.73134, -0.93142, -0.38786,
        -0.60351, -0.23035, 0.64858, 0.73968, -0.88335, -1.864, 0.62131, -0.72791, 0.80066, -0.13524, 1.3127, 0.57716, 0.85643, -1.1546, -0.31192, -0.35335, -1.3449, -0.45844, 1.4057, -2.1825, 0.28515, -0.40834, 0.5745, 0.49509, 0.5598,
        0.95822, 1.625, -0.10078, 1.2678, 1.6608, -0.32387, -1.0614, 1.5411, -2.0361, -1.4736, 0.81007, 1.1533, -0.95111, -0.89536, 0.14265, 0.5844, -1.6437, 0.24338, -0.94224, -0.57827, -0.85314, 2.408, 1.7845, -0.27848, 0.1666,
        -0.80278, -0.0094685, 0.28043, 0.083486, 0.3555, -0.46863, 1.1933, 0.50483, -2.0193, 1.0837, -2.4759, -1.569, 0.088936, 1.2151, 0.77243, 0.28927, -0.17731, -0.93609, 0.26859, 1.483, -1.0673, -1.2244, -2.0212, -0.67186, 1.1979,
        -0.29201, -0.47644, -0.7235, 0.8807, 0.0071426, -1.5717, -0.65895, -1.4636, -1.6884, -0.57138, -1.5803, 1.0837, 1.2258, -1.3837, 1.1543, 0.74813, 2.745, 0.93746, -0.77563, 1.4352, 0.49727, -0.17286, 0.98257, 2.3785, 0.23923,
        0.72704, -1.2384, 1.5163, -1.2752, 1.3135, 1.8988, 1.5257, 1.1796, 1.9881, -1.0344, -1.6734, -0.19317, 1.6345, -1.5151, 1.3129, -0.88493, -1.9251, 0.025106, -1.8697, 0.69591, 0.39992, -0.51121, -1.2239, -0.38988, 0.23268,
        -0.90639, -1.3561, 1.3333, 1.1498, -0.17857, 1.4005, -1.1772, -1.2661, 1.5062, -1.4416, -1.03, 0.76032, -0.94582, -0.095873, 0.81851, 1.2289, 1.4227, 0.4427, -1.1265, -0.66253, 0.56966, -0.57266, -1.3769, -0.68912, 1.1046,
        0.49246, -1.3272, -1.6076, -0.18549, -1.8667, -0.56966, -1.366, 1.9646, -1.2792, -0.70988, 1.2034, 2.0231, -0.27453, -0.9713, -0.97183, 1.3618, -0.3885, -1.2342, -0.85298, 0.5166, -0.76405, -0.28225, -0.33063, -0.83558, -1.0114,
        1.2272, -0.5575, 0.97565, 0.56991, 2.0503, -0.62609, 0.69387, -0.66611, 0.9934, 1.9468, 2.0073, 0.56665, 2.0844, 0.78666, -2.6994, -0.57702, -0.59984, 2.2762, -0.67456, -1.0936, -0.44626, 0.98546, 1.2031, -0.87229, 0.34404,
        0.12072, -0.60149, -0.38694, -0.10391, 0.38914, -1.535, -1.8623, -1.9762, 0.32632, -0.75695, 2.4066, 0.19419, 1.2802, 1.4787, -0.75711, -0.18813, -1.8367, -1.1413, -0.11966, -0.68973, 0.62083, 0.047894, -0.28807, -1.0351, -0.59399,
        -0.86638, 0.33967, -0.096249, 1.0923, 0.55677, 1.5654, 1.0081, 0.8223, 1.2801, -0.41147, -1.1788, -1.4401, 1.3566, 1.1471, -0.41404, -1.1649, -0.97862, 1.3219, 1.4619, 1.0857, 0.7067, 0.90226, -1.1897, 1.1112, -1.0345,
        0.40846, -0.73029, 1.276, 1.7734, -1.242, -0.18006, 0.35089, 1.6611, -0.96157, -0.58979, -1.2414, -0.71335, 1.15, -0.10126, -0.69505, 0.68167, -0.77927, 0.08712, -1.0395, -0.74715, 1.646, 0.33362, -0.6603, -1.6145, -0.39792,
        -1.7138, 1.6822, -1.4185, -0.43339, 0.90308, 1.3696, 1.9399, 1.5757, 1.9314, -1.1824, -1.8186, -1.0888, -1.4155, 0.38748, 1.588, 1.1578, 1.2644, 1.0388, 0.85674, -1.3572, -1.5187, -2.3718, 0.033427, -0.64815, -1.5319,
        -0.79329, 0.24902, -1.0879, -0.44892, -1.4332, -0.5895, 1.9964, 0.7788, -1.0479, 1.3511, 2.1503, 0.64577, -1.1839, -1.6854, -0.68998, -1.115, -0.52364, 0.82615, -1.6312, -0.27978, 1.1735, 0.4871, -2.0667, -1.587, -0.46418,
        0.2928, 0.14263, -0.90085, -1.0523, -1.1708, -1.5449, -2.4589, 0.92827, 0.37207, 0.3337, 2.0034, 1.3787, -0.27798, -0.77867, 0.90668, -0.53805, -1.5688, 0.72256, 1.3184, 0.84372, 0.83854, -0.50027, 1.5498, -1.0987, 0.099637,
        -1.2592, 0.8598, -0.60949, -1.4958, 0.84408, -1.9151, 1.5659, 1.1208, 1.1937, -1.4227, -0.77868, 1.5357, 1.8758, 1.2855, 1.4641, 0.67701, -0.16691, -1.4405, 1.6039, -2.17, -0.74192, -2.0108, -0.16024, 1.839, 1.1259,
        0.93734, -0.68866, -0.66755, -0.14163, 0.46229, -1.7028, -0.773, 1.4168, 1.7662, -0.99447, 1.2695, 0.79039, 0.80807, -1.5826, 0.099804, -1.2301, -0.9587, 0.45977, 1.7262, 1.1412, -0.82171, -0.44802, -1.6303, -1.7168, 0.10807,
        1.7798, -1.0896, -0.9375, -0.77926, -1.0308, 0.92136, 1.0173, 1.3116, 0.7675, 0.18299, 1.0913, 1.9413, 0.6027, 1.0988, 0.65382, 1.0664, -0.9411, -1.4451, -0.88295, 0.24588, -1.4858, 1.624, 0.68204, -0.61793, 0.15429,
        -1.7323, 0.58099, -0.11601, -0.36385, 0.082932, -1.8371, 0.5363, -1.5479, -0.3515, 0.81277, 0.20519, 2.0438, 0.62388, -0.80999, -1.1478, 2.0889, -0.73113, -0.5961, -0.82434, -1.4006, 0.45345, -2.1529, 0.3438, -1.3007, 2.1978,
        2.243, 1.4859, -0.79981, -1.5153, -1.9756, -0.63366, 1.1815, -0.63689, -1.1551, -1.3366, -1.3191, 1.1286, -1.3648, 1.4437, 1.2857, 0.82628, -0.66033, -0.82057, 0.6725, 1.8083, -1.8817, 0.12627, -1.1456, 1.3068, 1.5012,
        0.56322, -0.3939, -0.062666, 0.032575, 1.3829, -1.1676, -0.18377, 0.58334, -1.4596, -1.6677, -0.73454, -0.80067, 0.92305, -0.27878, 0.48542, -1.8612, -1.3326, 0.29297, -0.70923, 0.69113, 0.65843, -0.41936, -2.1811, -0.1439, -1.0531,
        -0.51724, -0.76136, -0.2161, -0.064373, 1.1502, -0.0714, 1.0941, -1.0402, 1.4749, -0.75456, -1.8406, -0.099251, 0.83521, 1.0292, -1.2168, 1.2691, -0.95251, 0.068015, 0.83049, 2.0152, 0.11858, 1.36, -1.1335, 1.0439, -0.26376,
        -0.090486, 0.25281, 1.4673, -1.0543, -1.5135, 1.8209, 0.97314, -0.49961, -1.1115, 1.197, 0.14431, 1.0358, -1.9926, 1.624, -0.22135, -1.2089, 1.6744, 1.3625, 1.1685, -0.69542, 0.95621, -0.82328, -0.22982, 0.48271, -1.9361,
        -1.768, -0.018665, 1.1621, 1.669, 0.77284, 0.63456, -1.978, -1.244, -1.3053, -1.206, 0.53485, -1.4162, -0.15232, 1.6291, -0.30294, -1.8404, -0.70373, 1.188, 1.2018, 0.82327, -0.66479, 1.2601, -0.096821, -1.0856, 1.1308,
        2.0007, -1.179, -0.21357, -0.65339, 0.92433, 1.6764, -0.20883, -0.24868, 0.6447, 0.96231, -0.5324, 0.45119, -0.089275, 0.51442, 0.93155, -0.96443, -1.1392, -0.83193, 1.3199, 0.67589, 0.76602, -1.716, 0.48487, -1.4777, -1.001,
        -0.78135, -0.11427, 0.91285, -1.6875, 0.43191, -0.11931, -1.6964, -0.67356, -1.8069, -0.36758, 0.84793, 0.86027, -1.4521, 1.8837, -0.56855, -1.9386, 0.96414, 1.072, 0.3553, 1.6796, 0.4912, 0.63303, -1.5052, 1.3103, -1.0457,
        0.64838, -0.94121, 0.67534, -2.2922, -0.53299, 1.4815, -0.59637, -1.9277, -0.57052, -0.78758, -1.4311, 0.78128, 1.4054, -0.52088, 0.86423, -1.3738, 0.55508, -1.217, -0.4757, 1.8694, -1.3712, 1.3035, -1.0978, -1.8862, 1.143,
        1.23, 1.5516, 1.9264, 1.2653, -0.34548, 0.96274, -1.5268, 0.61015, 0.95291, 1.1485, 0.086157, -1.4443, 1.3286, 1.6367, 0.19689, -1.542, -1.357, -1.7759, -1.0322, 1.2268, -0.92831, 0.033041, 1.8669, 1.4841, -1.3852,
        0.67593, 0.61313, -1.3728, 1.3702, 1.1871, 0.82253, -0.56413, 0.63235, -0.9385, 0.23299, -0.17597, -0.44966, 1.9585, 0.68688, 0.54683, -0.11318, -0.87677, 0.23189, 2.1225, -1.6866, 1.7956, -0.79965, 0.9702, 1.481, -0.50724,
        1.38, 0.48119, 0.032071, -1.5831, -1.4548, -2.4442, -1.4974, 1.308, 1.3185, -1.3255, 2.3489, -0.89891, -0.53557, 1.4786, 1.0892, 0.86736, -1.007, -0.99208, 0.93918, -2.1205, -0.91968, -1.5459, 0.42597, 1.2356, 0.65261,
        0.41436, 1.511, -0.64801, 2.3955, 1.7565, 1.5809, 1.4151, -1.1676, 0.75361, -0.030676, 1.6996, -0.84375, -2.2021, 0.21799, 0.42625, 2.0954, 0.19953, 1.3701, 1.4853, 1.4669, 1.6081, -1.0328, 2.0152, -0.98175, -1.2243,
        0.20456, -0.97106, 1.4188, 0.47105, 0.27538, -0.95977, -0.92368, -1.8805, -1.6268, 1.1968, -1.478, -1.3322, 1.5796, 0.72378, -0.58924, -1.451, -0.0048253, -0.38529, 2.3668, 0.97152, 0.40578, 1.1232, -0.85763, 0.14444, -2.0531,
        1.5919, -1.0481, 1.1975, 1.2843, -1.7767, 0.7799, -0.85228, 1.645, -1.0138, -1.5976, 0.5778, -1.5048, 0.20462, 0.3475, 1.5423, 1.164, 1.2304, -0.79631, -0.99506, -1.1743, 0.88575, -2.0215, -0.83355, 0.074741, 1.507,
        1.1645, -1.2676, -0.18146, 1.2765, -0.11944, 0.050887, -0.77211, -0.17205, -1.3414, -1.6481, -0.78008, 0.67509, 0.37314, -1.4419, 1.016, -0.95869, -1.3317, -1.8546, -1.5895, 1.499, 1.9004, 1.1359, 0.71667, -0.056742, 0.86603,
        -1.4977, -0.63951, -1.9686, 1.5696, -1.0376, -0.9663, -1.4721, -1.7593, 0.027833, -1.0378, -1.4471, -0.031218, -1.8581, -1.5012, -0.5145, 0.39636, -2.901, -0.92025, -0.78224, 0.32888, 0.82152, -1.009, -0.59651, 1.6083, 0.42564,
        1.0474, 0.62561, -1.1601, -0.84466, 0.82819, 0.4649, -0.07437, -2.1953, -1.4739, -0.55036, 1.3742, -0.84104, 0.76575, -1.0214, -1.7465, 1.2952, -1.1558, 0.6657, 1.0882, -0.9121, -1.7125, -1.1614, -0.28852, 1.659, -0.29652,
        1.2212, 0.93615, 1.0158, 0.87914, 1.5324, 0.33946, 1.4798, 0.72053, 1.5732, 0.91007, -1.2459, -1.2911, 1.5992, 2.1472, 1.834, -0.89668, 0.52512, -0.49705, 0.99718, 0.44806, -0.52253, -1.338, -1.6571, 0.07984, 2.4508,
        1.1407, 1.3892, 0.95482, -0.58649, -0.52822, 1.2925, 0.77671, -1.252, 0.61018, 1.0578, -1.1392, -2.3515, 1.019, -1.9573, 0.31157, 1.3545, -0.70241, 1.0474, -1.5007, -0.65893, 0.10433, 0.90996, -0.65748, 1.8278, 0.35498,
        0.84052, -0.92252, 1.1889, 0.81494, 1.7886, -0.91356, 0.2285, -1.3488, -1.5229, -1.2471, -1.5185, 1.6598, 1.0116, -1.2965, -0.9753, -1.1396, -0.95226, 0.22965, -1.911, 0.40206, 1.4045, -0.38513, 1.5063, 0.29374, -0.97403,
        -0.74354, 0.67594, 1.6963, 0.24568, 2.4131, 0.77488, 2.1477, 0.91532, 2.1215, 0.81766, 0.34304, 0.29468, -0.58289, 1.4377, 1.0387, 0.53009, 1.7007, -0.69389, 0.66398, 0.01384, -0.27179, -1.2843, -1.6188, 2.8448, -0.59974,
        0.90135, 1.2135, -1.4278, -0.945, 1.0987, 0.13981, -0.87781, -1.2981, 0.32248, -1.7155, -0.25038, 1.858, 1.3447, 1.6787, -0.28935, 0.6852, 1.7945, 1.6272, -0.18729, -1.3611, -0.13028, -1.1923, 1.8562, -0.37056, 0.52747,
        -0.95767, 0.99175, 0.57498, -0.86364, -0.3947, -0.66447, -0.85659, 0.87258, 1.4205, -0.39482, 1.729, 1.0248, -0.90617, -1.238, 0.097212, -0.050935, -1.5138, -1.4989, -2.0117, 0.78328, -0.31382, -0.023962, 0.19425, -1.368, -0.15166,
        2.5309, -1.1607, -0.39703, 0.90756, 1.4178, -1.4534, -1.4601, -0.39258, 0.27314, 1.2485, 0.41636, 1.3722, 0.42235, 1.3571, -0.59508, 0.40451, 0.25101, 0.011188, 1.1449, 1.7451, -0.8773, -0.80343, -1.1985, 1.8895, 0.73628,
        -1.0586, 0.67805, -0.58774, -1.1622, -0.95896, -0.97136, -0.68586, -0.9197, 2.2215, 1.0487, 1.0627, 0.44517, 1.4586, 0.84977, 0.024032, -3.4191, -1.5182, -1.5704, 1.0459, 1.987, 1.3045, 2.17, -0.50468, -0.40144, -0.69294,
        -1.0079, -1.2322, 1.2944, -0.83532, -1.2581, 0.59815, -1.7159, 1.391, -1.1001, -1.0234, 1.3804, 0.2347, 0.015374, 0.5953, -0.25755, -0.094513, -0.054169, 0.99511, -1.2983, -1.1157, -1.2976, -1.3437, 0.51603, 0.76324, 1.4375,
        -1.0465, 1.2687, 0.43309, 1.2784, 1.0742, 0.58871, 1.8375, 1.3915, -0.4865, -0.77797, -0.88734, 0.90258, 1.0637, -1.391, -0.43206, -0.70033, 1.2616, -0.28863, -0.41241, 1.7912, 0.91869, 0.70517, 1.0954, -1.0126, 0.38231,
        0.71132, 1.8005, 1.6242, 1.2334, -0.51777, -0.5559, -1.4805, -1.9107, -0.092512, -1.6923, -1.6053, 1.4101, -1.8322, 0.97767, -0.63319, 0.9062, -1.4047, -1.3895, -0.42176, -1.9279, 1.094, -1.4706, -1.7027, 0.524, 1.6747,
        0.71661, -0.32584, -1.5714, -0.35227, -1.5632, 0.039887, 0.79914, 0.097706, -1.0436, 0.64182, 0.42746, 0.0014732, -1.4445, -1.0474, 0.58061, 1.9339, -2.3624, 1.4528, 0.81515, 0.62426, 0.44258, 1.6336, 1.2515, -0.0037408, -1.6087,
        1.7112, -1.4555, -1.6176, -0.45227, 1.3743, 0.29163, 1.4281, -0.55708, 1.1506, 0.55198, -1.4773, -0.62466, 0.58147, 0.95693, -0.46905, 0.42226, 1.0503, -1.7256, -1.0047, -1.1409, -0.59582, 0.75686, -0.78423, 1.974, 0.92224,
        0.86802, 1.6396, -0.99217, -0.32694, 0.9361, 0.91917, 1.8391, -1.0582, -1.5507, -0.59001, 0.94018, -1.206, 0.66517, -1.6575, 1.9195, 1.7416, -0.82794, 0.52379, 2.1683, -1.9212, -1.0653, 1.4553, 1.2094, -1.3753, -1.0084,
        1.9492, 0.58708, -0.58088, 0.74851, 1.9485, -2.2822, -0.85999, -0.62937, -1.5492, -1.2591, -1.1038, -1.7018, 1.8497, 0.91239, 1.3822, -0.91001, -0.54667, -0.87941, -0.93374, -1.0417, -1.2987, -1.5984, -0.4522, 1.744, -0.80446,
        -0.85862, -1.4478, 1.1764, -1.988, 0.069531, 0.92988, 1.0047, -1.3366, 0.74741, 0.10584, 0.11669, 2.0289, -2.5609, 1.7404, -0.18157, 0.238, 0.44884, -0.95651, 1.0345, 0.77571, 1.5312, -0.77091, -0.72274, 1.3488, -0.84133,
        -1.4211, -1.401, 1.213, -1.3971, 0.91411, -0.4991, -0.34868, 0.62956, 0.0522, -0.52453, -2.3732, -0.30457, 0.89592, -1.5954, -0.2749, 1.2954, -0.82596, 0.068112, 1.9857, 0.82476, 1.3223, -1.3764, 0.67124, 0.98321, -0.99375,
        -0.90378, -1.5247, -1.4691, 0.12465, 1.2367, -0.51835, -1.208, 1.1932, 0.80267, 0.22846, -1.173, -1.2461, 2.2563, -0.46501, 1.9121, -2.0985, -0.75091, 0.548, -1.6131, -0.93468, -0.16707, 1.0483, -0.70372, -1.5631, -1.5659,
        -2.3538, -0.67353, 0.62925, 1.2489, 1.6045, -0.16197, 2.14, -0.59131, -1.54, 0.11005, -1.972, 0.4235, 0.22049, 2.3086, 1.4664, 1.1895, 1.2379, -1.3641, -1.1312, -0.17993, -1.5057, -0.61954, 0.14688, 0.28024, 1.258,
        1.9344, -1.1029, -1.4395, 0.80956, -0.97094, 1.2502, -1.5069, 0.93356, 1.7942, -1.444, 0.48008, -0.93509, -0.43742, 0.10106, -0.68412, 1.01, -0.3127, -1.2944, -0.47602, -0.020639, -1.2625, 2.2048, 0.47273, 1.606, 2.2115,
        0.72815, 1.0748, -1.1497, 0.71565, 0.75645, -1.009, -0.84116, -0.018541, 2.1235, 0.31526, -0.57062, 0.84374, -1.4243, 1.3269, 0.78969, -0.25119, 0.26181, -1.4705, 0.59308, 1.1303, -1.5161, -0.24169, -0.90688, -0.88464, 0.86545,
        -1.8653, 1.5371, 1.6098, -1.5837, -0.80778, 0.60849, 1.7313, 2.4056, 0.60768, 2.5562, 0.86854, 0.88678, -1.0963, -1.5594, -0.92371, 1.1694, -1.2399, -0.80607, 1.129, 1.3174, -1.1296, -0.91107, -1.3714, 1.3117, 1.5816,
        1.3975, 0.54348, -1.0384, -1.503, 1.8724, -1.0035, -1.0934, -0.76267, -0.24729, -0.027712, 1.4486, -0.98884, -0.75015, 1.4196, -0.43772, 0.050163, 1.529, 1.3065, -1.534, 1.074, -1.4815, 0.29394, -1.5948, -1.7071, 0.86845,
        0.40244, -1.4492, -0.15907, 0.1884, -1.313, 2.3091, -0.36067, -1.427, 1.2863, -1.301, -0.97816, -2.6244, -1.4958, -0.52364, -0.73848, -1.0406, -1.3551, 0.68997, -0.82587, 0.73189, 0.90588, -0.53663, 0.8755, -1.4977, 1.8523,
        -1.1284, -1.0492, -0.12794, 0.66229, 0.38804, -1.0365, -0.8162, 1.961, 0.70004, -0.53151, -0.17167, 1.4597, -1.8366, 1.2111, -1.4852, 1.1123, -0.67555, -0.36249, -0.86476, -1.6786, 0.97201, 0.48208, -1.4279, -0.012363, -0.1886,
        1.1977, -0.19176, -0.56428, 2.1209, 0.57392, 0.90379, -0.20465, -1.2966, -2.5194, 0.75329, 1.2746, -0.94093, 2.0691, 1.3421, -0.47932, 0.96552, 0.79216, -1.4038, 0.11125, -1.4902, 1.4624, -1.5513, -2.0048, 1.1609, -1.0248,
        2.2761, 0.1572, -1.2844, -0.19722, 1.1242, 0.99008, -0.58207, -0.59596, -1.4342, 1.2296, 0.361, 0.69057, -2.0959, 0.043631, 1.5166, 1.8685, -2.113, 0.33955, 0.64423, -1.356, 1.4832, 1.408, -0.09935, 0.41827, -0.67151,
        -0.47635, -0.38253, 2.0625, -1.7057, -0.74234, 0.097089, -0.88254, -0.98402, -0.49655, -0.81733, 1.0888, -0.58085, 0.81748, 1.0001, 1.0191, -0.53948, 1.8108, 0.51609, 0.41268, -0.31449, -1.7621, -1.1969, -0.88588, 0.95129, 1.1139,
        -1.1049, -0.18266, -0.79148, -0.92623, 0.75598, 2.3251, 1.0078, 1.4827, 0.99537, 1.8869, 2.1026, -1.0477, -2.0497, 0.534, -1.0897, 1.7899, 0.74343, 0.60388, -0.80239, -1.0066, 0.32141, 1.9411, -1.3738, -0.93463, -1.6401,
        -0.87929, 1.8033, -0.63789, 0.27071, -0.74512, 0.53773, 0.34566, 1.2102, 1.1693, -0.22248, 1.4065, -0.76512, -1.0409, -0.80359, 0.12404, -1.1519, -0.96611, -1.1423, 1.4174, 0.070958, 0.23793, -0.90568, 0.41749, 0.69411, -1.0269,
        -1.5724, -0.07976, -0.45213, 1.1731, 1.6433, -1.3373, 1.1876, -0.58782, -0.83505, -1.0597, 1.766, 0.78642, 2.127, -2.8939, 2.0615, -1.7918, 0.52484, 0.74365, -1.3315, -0.36784, 1.0889, -1.069, -1.8828, 1.0143, -0.06399,
        1.2681, -1.6009, 0.039007, -0.0067088, 0.7633, 1.6163, -0.39726, -0.77776, 1.011, -0.42268, -0.99805, -0.81662, 0.56922, 0.58645, 1.3536, 0.028748, 0.91819, -0.92643, -0.94287, 0.75103, -1.2684, 0.39058, 1.0425, 1.2962, 0.76195,
        1.2948, -1.1133, -1.2196, 0.52276, -0.41103, -0.72718, -1.2427, 1.1641, 0.16011, -1.542, -0.6011, 0.76041, -1.1978, 1.4863, -0.50283, 0.76781, -0.011928, 1.1636, -0.88447, -0.76424, -1.3597, 1.7751, 0.59365, -0.6942, -1.3341,
        -0.45603, 1.0311, -1.5494, -0.27215, 0.89376, 1.0751, 1.7801, -0.37967, 1.609, -0.42539, -1.5452, 0.89734, -1.2007, 0.31301, 1.4867, -0.91943, -0.9045, 1.778, -0.71596, -0.38537, 1.4983, -1.3663, -1.0743, -1.1665, -1.1766,
        0.45458, 0.6574, -0.27211, 0.35097, -0.54851, 0.086959, 0.50086, -1.2286, -1.0275, -0.8668, -1.5187, -0.56924, 0.05226, 0.62372, -2.3651, 0.79023, 0.12649, 1.0717, -1.51, -0.44006, 1.9153, 0.82634, 1.4368, -2.0447, -0.67098,
        -1.6872, 1.9318, -0.43835, 0.4597, -2.3793, 0.8884, -1.946, 0.11275, -1.2628, 1.7215, 1.1387, -1.2497, 1.038, -1.3866, 1.0618, -0.80308, -1.7408, -0.015607, 1.2758, -0.4911, 0.91467, -0.36574, -1.2787, -1.4115, -2.2575,
        -1.9626, -0.5751, 0.5579, 1.0188, -0.818, 0.60593, 1.0503, 0.65086, 0.84938, -1.0457, 0.18526, 1.0727, -1.1575, -0.5987, -0.59991, -1.1902, -0.38043, 1.5496, 1.4961, 1.4123, -0.0088632, -0.44469, -1.2828, -1.6135, -1.6632,
        -0.040713, 0.78147, 0.9852, 0.66012, 0.38759, 0.78055, 1.8688, -1.4028, -1.0698, 0.10286, 0.98307, 1.5391, 0.63933, -1.0847, -1.0434, -1.5935, 0.96632, 1.3976, -0.40119, 1.5929, 1.4502, 0.65549, -0.25803, 0.072837, 0.86867,
        1.0928, -1.5301, 0.18261, 1.5708, -2.1968, 1.2793, 0.89738, 0.032984, -0.53644, -1.2106, -1.9845, -0.97956, -1.088, -2.0613, -1.6765, 0.64678, 0.89146, -0.70484, -1.4915, 1.8018, 0.975, 1.2625, -0.67887, 0.72604, 1.7294,
        1.4138, 1.4921, 0.69343, 1.5169, -1.4085, 1.3222, 0.89087, -0.50681, 0.96576, -1.9307, 1.1228, -1.2535, 0.031151, -1.0892, 0.5627, 0.46743, -1.2561, -1.3049, 0.81701, 0.50556, 0.98674, -1.8301, -1.5658, 0.83047, 0.61934,
        -0.11773, 1.0548, -0.70613, 1.3611, -0.97277, -0.36823, 0.93853, -0.97741, 0.93429, 0.53211, 0.99997, -1.503, -0.80625, 0.27256, 1.2983, 0.96668, 0.83148, 1.2208, -0.72248, 1.109, 1.1118, -0.4349, -1.1832, 0.94066, -1.2933,
        -2.0224, 1.6927, -0.94568, 0.38416, 0.72547, -0.19504, 1.8772, 0.46804, 1.6873, -0.81952, -1.1036, -0.20947, 0.26466, -2.1385, -2.4022, -1.3064, 0.35036, 1.1758, 0.94312, 0.86136, -1.4856, -0.25775, -1.3801, -0.68128, -0.94864,
        -0.55432, 0.47683, -1.0253, 0.46568, -0.62699, -1.2625, 0.90652, 1.0832, -0.59987, 0.47167, 0.16198, -0.78693, -0.84024, -0.1977, 1.958, -1.9615, -1.1088, 0.3374, 0.95431, 1.009, 1.1907, -0.34455, 2.232, -2.0524, 0.93064,
        -1.9425, -1.7081, 1.3544, 0.95901, 1.0713, -1.6625, -0.81571, -2.0533, -0.34011, 1.1213, 1.3885, 0.90287, 1.375, 1.0126, 1.1243, 0.35206, -0.86896, 1.1143, -0.7175, 1.556, -2.1749, -1.0544, -0.6061, -0.0040998, -1.1609,
        1.3474, -1.1996, 1.448, 1.2024, 0.78306, 0.58395, 1.2097, -0.71307, 0.54093, 2.1601, -0.75113, -1.1925, -1.0184, -1.6923, -1.9559, 0.99722, 0.26535, 1.5266, 1.3924, -1.2359, 0.98335, 1.6193, -1.5505, -2.2617, -1.6033,
        2.1501, 0.038789, -1.3735, 1.0564, -0.094272, 0.24164, 0.54433, -0.53513, -0.068806, -1.6411, 1.1326, -0.9058, -1.4072, 1.6764, 2.0303, 1.0805, -0.52931, 1.8568, 0.19827, 1.2073, -1.6268, 0.98255, 2.442, -1.8852, -1.3713,
        1.589, 1.7178, -2.0533, 0.83286, 1.8913, 0.84605, 1.35, 1.0607, -1.5837, 1.4267, -1.0314, -0.031152, 0.97551, -1.503, 0.9812, 1.5979, 0.10717, -0.47166, 1.343, 0.72173, -0.81299, -0.49309, 1.5793, 0.29737, -1.7799,
        -0.99094, 0.37461, -0.82032, -1.1193, -1.4848, -1.2244, 0.59071, -0.47226, 1.2419, -0.95623, 0.11813, -0.9592, 0.19413, 0.78754, -0.8482, 2.1035, -0.93961, -0.60352, 0.77662, -1.5156, 0.78729, 0.54356, 0.047127, -0.40335, 0.40707,
        -0.57986, -0.41616, 0.12981, 3.1623, 0.28162, 0.57163, -1.123, 1.0598, 1.0479, -1.1362, -2.072, 0.66274, 0.54072, -0.11297, 1.1646, -0.9461, -1.3199, -0.92098, 1.6935, 1.5603, -1.0374, 0.46921, -0.87182, 1.3856, 0.98628,
        -0.19715, 1.4056, -0.066811, 1.2008, 1.159, 1.7689, 0.15452, 0.10636, 1.7011, -0.46695, 1.6247, 1.4499, -1.2395, -1.4283, -1.4832, 1.7983, -1.1855, 1.258, 0.46677, 2.2672, 0.70412, 0.4535, 1.0907, -1.4162, -1.2818,
        1.4361, -1.6396, -0.7754, -0.86928, 1.0599, 1.2989, -1.0273, 1.1922, 1.2701, 0.90139, -0.66159, 1.7169, 0.70608, -1.6875, 1.2776, 1.7789, 0.72506, 1.6043, -0.12274, -0.87267, -1.1652, 1.2042, 1.1978, 1.1733, 0.45018,
        -0.64388, -0.13501, -1.9127, -0.62098, 0.13057, 1.8769, 1.1474, 1.5828, -0.88981, 1.5751, 0.10981, 0.3611, 0.42418, 0.99609, 0.18421, 1.2807, -0.84738, 0.91612, -1.6658, 2.4661, -0.79326, -0.62332, 0.94138, 0.7088, -1.9303,
        1.2824, 0.91711, -0.15497, 0.60659, -1.2127, 1.2975, 1.1366, 1.0463, -0.25447, 1.0829, -0.59121, 1.7168, 0.6943, 0.4879, -0.72383, -0.57443, 0.91935, -0.16449, 0.092097, 0.99166, 1.3807, -1.0439, -0.57106, 1.7538, -1.4096,
        0.2068, -0.66383, -1.265, 1.3397, 1.1197, -1.7708, -0.7065, 1.3942, -1.2012, -0.86788, 0.94847, -1.8718, -0.81889, -0.62566, 0.73798, -0.068789, -0.64118, -2.1759, 0.64092, 0.57827, -1.6779, 0.52719, -0.91005, -0.83253, -1.3116,
        0.70668, 0.18233, -0.60334, -0.56661, 1.6381, 0.65443, 1.1831, -1.6775, -1.149, 0.25312, 1.2233, 1.1722, 2.1942, 1.5443, -0.79605, -1.8211, -1.684, 0.81638, 1.5833, 0.43434, -2.5013, -1.5668, 1.5943, -1.0256, -0.37863,
        -0.88445, 0.48139, -0.2217, -1.5676, -1.0647, -0.60217, -1.7098, -0.99615, -0.53687, 1.0558, -1.5895, 1.0796, 0.78487, 1.4229, 0.83664, -0.0036028, -0.46951, -1.1954, -1.21, 0.86941, 0.51664, 0.61422, 1.3957, -0.21387, 1.0403,
        -0.249, -0.53088, -0.22295, 0.88962, 0.85354, 1.3608, -0.822, -0.60115, 1.3858, -0.3423, -1.5954, -0.68155, -1.1033, 1.7992, 0.90185, 1.4468, -1.0143, 1.5231, 0.61992, 0.28769, 1.6248, 1.6612, 1.9306, -0.15773, -1.2353,
        -1.6262, -1.8101, -1.4827, 0.14349, -0.24141, -0.27079, -0.46724, 1.0969, 1.528, -1.6309, 1.5784, 0.68453, -1.4499, -1.7734, -1.4081, -0.15487, 1.6263, -1.1142, -1.4764, 1.3806, 1.4782, -0.21018, -0.99846, -1.9641, 1.2803,
        1.1826, 0.21544, 1.2552, -1.0209, 1.4981, -0.94367, 0.70963, 0.30524, 0.2058, -0.58712, 1.4348, -1.4552, -0.74423, -0.7809, 0.071568, -2.5653, 1.5007, -1.3254, 0.58021, -1.1645, 1.0548, -1.9926, 0.12285, -1.503, -0.050454,
        -0.28044, 1.3083, -0.5697, 0.2932, 0.72391, 1.61, 1.0714, -1.6245, 1.7231, -0.1241, -0.16803, 0.035732, -0.40196, 0.24528, 0.044646, -0.78634, -1.2628, -2.1524, -1.0468, 1.6147, 1.4852, 1.2998, -0.15538, 0.6901, 1.6241,
        -1.346, 0.47274, 1.4272, -1.1761, 0.52361, -0.46982, -0.61973, -1.3056, -2.253, -1.0561, 0.069103, 0.41111, -1.9193, -1.9462, -1.4966, -0.27428, 0.8055, -0.23636, -0.22031, 1.0375, -0.18645, -1.7562, 1.0303, 1.1132, -1.415,
        1.718, 0.57841, -0.97678, 1.3446, -0.37413, -0.66923, -1.0024, 1.2501, -0.97504, 0.55238, 0.82561, -0.7923, -0.42731, 1.2266, -1.0904, -1.3403, -0.4836, 1.5996, -0.77318, 0.54984, -1.5145, 1.1616, 0.8212, 1.6364, -0.49205,
        -0.13871, 1.4693, -0.2681, -0.4091, -1.1616, 0.11912, -1.4789, 0.39446, 1.1792, -1.0944, -0.65633, 1.9752, 0.087157, 0.18966, -0.99711, 0.53876, -1.5854, 0.74825, -0.17448, -1.9534, -1.9913, -1.1964, 1.5752, 1.3691, 1.0723,
        -0.82381, -1.6705, 0.25906, -1.5652, 0.53585, -0.88459, 1.8172, 0.17723, -0.55599, -1.3665, -1.3871, 1.8962, 2.0628, 2.1869, -0.18612, 2.3395, 0.61225, -0.18376, 1.3261, 1.0377, -1.0515, 1.1368, 1.3982, -1.2655, 0.99809,
        1.6496, 0.31956, -1.5395, 0.61391, -0.86682, 1.2939, 1.1921, 0.13934, 0.90192, -0.60096, -1.4134, 1.7025, 1.1133, -0.82399, 0.11394, 1.5462, 1.8231, -0.84283, -1.1578, 0.82708, -0.17383, 2.1395, -0.80048, 0.19414, 1.8672,
        -0.3799, 0.94904, -1.4226, 1.2133, 1.3858, 1.1926, 1.3918, -0.76205, 1.054, -1.3207, 1.233, 0.26942, -0.46167, -0.19117, 1.7099, 1.2314, -2.3391, 0.75719, 2.378, -0.67636, 2.2433, 0.67457, 1.3946, 0.0033231, -0.48584,
        -0.93326, -1.3172, 1.6926, -1.2854, -0.74308, 1.8377, 0.2013, -1.9155, -0.24218, -0.25954, 0.48233, 0.15262, 2.0086, -0.78189, -1.1492, 1.2865, 0.31439, -1.3094, 0.058811, 1.0591, -1.0942, 0.33904, 0.64322, 2.1438, 0.92911,
        1.0463, -0.61488, -0.57977, 1.1363, 0.58266, 1.7941, -1.2703, 0.14234, -1.1153, -1.4199, 1.7204, -1.9373, -1.9557, 0.49737, 1.8143, -0.74942, -1.8862, 0.5996, 0.66288, 0.25447, 1.1688, 0.10431, 1.2261, -0.16514, -1.06,
        2.1705, -0.85651, 2.293, 1.2483, -0.63672, -0.43763, 1.8731, 1.0715, 1.7148, -0.80805, -1.774, 1.4516, -1.1202, 0.67641, 0.94466, 1.4294, 0.79815, 0.91069, -1.4764, -0.5305, 0.20254, 0.42886, 1.0715, -1.1263, 0.34795,
        -0.23704, -0.85512, -1.5101, 0.88933, -0.57352, 2.4084, -0.98988, 1.4591, 0.76147, -1.7987, -0.24002, -1.0835, -1.5981, -0.13276, 1.0201, 1.1621, 1.6167, 1.3082, -1.1602, -1.1907, 0.76887, 1.0409, 0.53132, 0.69362, 1.9139,
        -1.3005, 1.3429, -1.1524, 1.2928, -0.60485, 0.60481, 1.6512, -1.9202, 1.39, -0.29677, -0.282, -1.8004, 1.2582, 1.2061, 1.1781, 0.58415, 1.2986, 0.33834, -0.95448, -2.1137, -0.69432, -0.67536, 0.30638, -1.0353, 1.3362,
        1.0157, -0.64799, 1.7708, 0.96034, 0.70488, 1.5784, -0.82816, 0.9224, -0.72694, -0.21763, 0.47449, 1.4294, -1.3463, 0.89519, 1.5456, -2.4589, 0.6498, 1.9454, -1.3118, -1.5829, 1.4194, -0.6526, -1.0039, 0.78542, 0.91865,
        -2.5181, 1.5268, -1.4765, 0.79343, 1.06, -0.43711, -0.773, 0.59527, 0.91429, -1.868, 1.5823, -0.90298, -0.65141, 0.69008, 1.0582, 1.4906, -0.95762, 2.2328, -0.4487, 0.64885, 2.3738, -1.114, -2.2794, -1.2166, 0.81839,
        1.7595, 0.75084, -1.1981, 0.778, 0.96607, 0.19925, -1.6804, 1.5211, -0.36744, -1.498, 0.43818, -1.4215, 1.465, 1.3881, 0.63576, 0.53159, 1.3492, -1.45, 1.4121, 1.5256, 0.53748, 1.9315, -0.3989, -0.76799, -1.8926,
        -1.2427, -1.4713, 2.1578, 1.1644, 1.2418, -1.0269, -0.026711, -0.59364, 0.42395, -0.56519, -1.7305, 0.53908, 0.91269, 1.1206, 1.366, -1.2957, -0.37221, 1.0558, -1.5145, -1.0426, 0.70104, -0.15721, 1.775, 0.68948, 0.63037,
        1.1869, -0.96591, 0.14066, 1.7383, 0.040624, -1.3476, -2.2956, -1.2458, 1.614, 1.6893, 1.3159, -1.1931, -0.60465, 0.25244, -1.2946, 1.207, -1.0007, -0.99418, -0.85441, -0.3971, 0.42421, -2.0778, -1.0197, 0.89994, 1.3002,
        1.1864, 0.5264, 1.6586, 1.1976, 0.71647, -0.77978, 1.5059, -1.1058, -0.77719, -0.47735, -0.35666, -0.78008, 1.5496, 0.79008, 1.2362, -0.40243, 1.117, 0.65861, -0.37296, -0.4101, 1.2931, 1.4051, 0.20477, -2.1873, 1.2681,
        0.72935, 1.093, -0.86212, -1.3974, -1.1856, -0.57832, -1.7673, -0.61173, 0.87265, -1.7977, -0.84096, 1.1654, -1.2338, 0.88362, -1.1141, -1.7346, -1.0328, 1.0875, 0.52289, 1.8869, -0.60178, 0.47192, -0.35683, -1.2091, 0.34006,
        0.6965, 1.2168, 1.8859, -0.73061, -0.42772, 1.6303, -1.4202, -0.61664, 1.48, 1.9466, 1.4649, -0.92541, -0.46036, -0.47263, 0.39018, -1.8772, 1.4304, -0.80289, -0.22576, 0.96203, 1.6687, 2.2025, 0.62069, 1.2902, 1.5984,
        1.0592, -2.3038, 0.058845, 0.39004, 1.7412, -0.58448, -0.82143, -1.1117, 1.112, -1.2031, 1.6525, 0.84746, 0.74326, 1.6672, -0.065079, 0.33736, -0.51928, 1.1921, -1.7813, 0.72568, -1.0871, 1.598, 0.838, -0.8569, 0.59645,
        0.33823, -1.3677, -1.3027, 1.9021, 0.35208, -2.4154, -1.2115, 2.0973, 1.1144, 0.5548, -0.81745, -0.80636, 0.60882, 1.4671, 0.49114, -0.0029176, -0.26058, 1.2075, -0.33592, -0.73355, 0.34586, -1.1931, -1.2949, 1.2144, -1.5195,
        0.22148, -0.1019, -1.521, -0.25119, 1.0693, 0.37721, -1.3259, 0.66036, -1.7662, -1.8452, -1.5577, -0.40687, 1.8906, -0.28018, 0.65145, -0.037701, 0.74558, -0.70509, -1.6007, 1.2882, -0.32473, -0.029818, -0.55741, 2.1992, 0.37616,
        0.36612, 1.6605, -0.119, 1.8496, 0.44007, -1.333, 1.3035, 1.3458, 0.65424, 0.58547, -1.3145, 0.94156, -1.0698, -0.83307, -0.81946, 0.99856, 0.23456, -0.90838, 0.78518, 0.27457, -1.0903, 2.4422, -0.99938, -0.95595, 1.0516,
        -1.4069, 1.5358, 1.8122, 0.80528, -0.74671, -1.573, 1.5195, 0.81791, 0.86761, 0.086562, -0.90507, 0.48946, 0.87009, -0.53093, 1.3016, 0.69128, -0.015867, -0.99672, 0.11637, -0.62218, 0.88269, -1.1833, -2.0994, -1.3407, -0.94668,
        -0.19697, -2.1558, 1.0258, 1.3639, -2.4945, -0.57273, 1.091, -0.38394, 2.2028, 0.1454, -1.7866, -0.94117, -1.4997, 0.93382, 1.6786, 1.0567, 1.3026, 0.9012, 0.97946, 1.3205, -1.5036, 1.1207, 0.96734, 0.93487, -0.11326,
        -1.0704, 1.0967, 1.3103, -1.2503, 1.114, 2.0666, -1.2547, -1.4565, -0.27121, -0.046122, 1.7024, 1.179, 1.5351, -0.77205, -1.0811, -1.4254, -1.1128, 0.033497, 0.50273, -0.13487, 0.95116, 0.56623, -1.1687, -0.78968, 0.82939,
        -0.75449, 0.28005, 0.37319, -0.88692, 1.0701, 0.78109, 1.2219, -0.61451, 1.2686, 0.97649, -0.74032, -1.9099, -1.2694, -1.9191, -1.6631, 1.1574, 0.42902, -1.1132, -2.1098, -1.4501, 1.7275, 0.50548, 0.80601, 0.81639, -1.1733,
        1.1971, 0.84716, 0.74144, -1.228, -1.0762, 1.5989, -1.3138, 1.1547, 2.0533, -0.30027, 1.1368, -1.1956, -0.010658, -2.1915, 0.44569, 0.90557, -1.0573, 1.5578, 0.93896, -0.67013, 1.0871, 0.31271, 0.0053355, -1.4883, 1.2845,
        0.87532, 2.2626, 1.5265, 1.488, 1.4113, -0.56788, 0.94035, -0.18616, -0.49888, -0.61583, -0.58977, -0.59996, -0.86387, 0.46936, -0.88507, -1.2308, -0.39648, 1.478, 0.34311, -1.5286, -1.3081, 0.81483, -1.6891, 0.84172, -2.4532,
        -1.1249, 1.1949, 0.44909, 1.2554, 0.36335, -1.671, 1.8513, 2.4111, 1.5132, 0.014918, 1.8196, -1.1605, 0.19275, 0.90001, -1.5286, -0.85014, 1.2251, -1.864, -0.91204, -1.5105, -0.28405, 0.87261, -1.2097, 0.56256, 0.96937,
        -0.63822, -0.6993, -0.59559, 0.60016, -1.3072, 0.5644, 0.71712, 0.97681, -0.56425, 0.16379, 0.80432, 1.4384, -0.39346, 1.7018, -0.58885, 1.592, 2.1215, -1.6219, -0.8593, -0.2178, 0.82127, 2.2852, 0.45903, -0.13801, -0.66978,
        1.4131, 1.3564, 1.4576, 0.94913, -1.1541, -0.47094, -1.1114, -1.3395, 0.98943, 0.32588, -1.0557, -1.1939, -1.8877, 1.1921, -0.009231, 1.3391, 0.084585, -0.33155, 0.44845, 1.0584, -0.82216, -0.95939, -0.75661, 1.9202, -1.0015,
        0.54145, -0.80169, 1.0097, 0.65478, -1.2494, -0.29743, 1.5832, -0.051966, -0.81287, 1.5641, -1.249, 1.3461, -1.3669, 0.72276, -1.7745, 0.12438, 0.84285, -0.98762, -1.9666, 2.549, 0.78311, -0.67213, 1.3673, -1.0359, -0.65459,
        0.89932, -1.6568, 0.72691, 0.36999, -0.98932, 1.6389, -1.3171, -0.27762, -0.98974, -0.34755, -0.93996, -0.92848, 0.99083, -1.7982, 1.213, 1.1821, 0.23771, 1.7961, -0.029229, -0.96262, -1.1982, -0.74177, 0.81655, 1.273, -0.19291,
        0.94044, -1.5172, -0.79366, 1.1262, 1.0791, 0.93693, -0.60454, -0.2049, -1.1879, 1.1274, -0.92369, -0.75632, -0.80897, -1.0805, -1.0052, 1.553, 1.5963, 1.1005, -0.86867, -1.1221, -1.9144, 0.41034, 1.1209, 1.284, -1.2799,
        -1.9507, 0.7819, -2.2398, -0.45488, 1.0607, -0.72322, -1.6947, 0.42997, 2.0533, -1.0542, 0.25241, -0.43423, 0.19113, -0.34082, 1.0913, -1.1423, -1.324, -0.79843, 0.84898, -0.65706, 0.81775, 0.76742, 1.0094, 0.66832, -1.3887,
        1.1935, 0.72498, -1.1543, 0.92449, 0.66481, 0.090011, -0.95207, 2.316, 1.5045, -1.814, 0.051172, 1.6297, 0.98173, 1.3356, 0.62799, 1.2766, 0.18818, 0.92271, -1.3198, -1.1881, 2.1657, 0.29463, -0.52348, -0.61546, 1.2937,
        1.2381, 0.9514, 1.3421, 1.4878, -1.2262, 0.42055, 0.18068, -1.7295, 0.88511, -0.48947, 0.75703, -1.1795, -1.2164, -1.6233, 1.1044, -1.7257, 0.8182, -0.93682, 1.6893, -0.90595, 0.91875, 0.78736, -0.57907, -0.01377, 0.266,
        -1.7898, 2.0559, 0.65873, 2.6374, -1.8181, 1.6538, 1.3519, 0.72122, 0.48682, 1.1515, -1.4518, 0.48024, -1.7818, -1.337, -0.58994, 0.91787, 1.1696, -0.30839, 1.3938, -0.74603, -0.29706, 0.60592, -1.2337, -0.15819, -1.422,
        0.6505, 1.553, -0.56331, -1.7717, 0.2556, -1.4909, -0.44273, 0.63623, -1.0321, 1.144, 0.72969, -0.98823, -1.6609, 0.24257, -0.36459, -1.0584, 2.0999, 1.0325, -1.2455, 1.9801, -0.29418, -1.6747, 0.88198, -0.92224, 1.143,
        0.28369, 0.62983, -1.7612, 1.8397, 0.63835, 0.53981, 0.27927, 0.45691, -0.69762, 1.2018, 1.9126, -0.99811, 0.18473, 1.4745, -0.22277, 0.20089, -0.55099, -0.66316, 1.3804, -0.092552, 2.1772, 1.1777, 1.2775, 0.9097, 0.86263,
        1.3588, 1.7954, 1.7528, -0.26783, -0.49057, -1.2991, 1.1158, -1.2219, -1.6825, 0.60354, 0.43923, 0.61549, -0.33166, -1.2756, 0.94037, 1.8491, -1.3455, 0.37005, -0.095476, -0.99486, 1.1381, -1.8006, 0.38143, -0.33544, -0.73483,
        -0.61446, -2.2111, -0.84567, 0.78371, -1.0058, 0.45557, 0.21767, -0.0068338, 1.8009, -1.9183, -0.46388, -0.87544, 1.8476, 1.2449, 0.35124, 1.6186, -0.6476, -0.31693, 1.4052, -1.5726, 0.09027, 0.47865, 1.7426, -1.1181, 1.0808,
        1.566, -1.4387, -0.88425, -0.08288, 1.866, -0.8316, 2.1042, -0.075772, -0.25468, -0.12663, -1.1641, 0.48805, 1.2864, 1.0105, 0.92638, -0.47147, -0.9598, 0.82938, 0.89443, 1.3385, -1.0469, -1.1321, -2.1462, -1.1694, 0.85605,
        0.88739, -1.647, 0.17463, -2.2466, -1.3673, 1.0067, 1.9177, -0.88331, -1.3218, -0.30279, 1.5747, -0.87027, 1.7867, -0.94823, -2.1269, 1.1772, -1.0977, -0.50598, 1.1859, -1.4845, 0.34423, -0.7321, 1.4808, -0.59876, -2.3563,
        1.385, 1.4303, -0.56739, 1.8261, -0.97577, 0.038986, -1.1502, -1.0412, 0.92146, 0.55284, 1.0655, -1.1288, 0.58549, 0.96524, -0.49376, 2.5258, -0.24421, -0.89104, -1.1547, 0.15295, -0.48899, 1.1932, 0.56455, -0.91591, -0.85717,
        0.87046, 0.32296, 1.6243, -1.4685, 1.7249, -0.62157, -1.3339, -1.1767, -0.61544, 1.8372, -0.66532, 1.0982, -0.11155, -1.1336, 0.41353, 1.0472, -0.45225, 0.75422, -0.6949, -0.21511, 0.52036, 1.1364, 0.13504, -0.79197, -1.0256,
        -1.2621, 1.7123, 0.066924, -0.37412, 0.67847, 1.7927, -0.31152, 0.83711, -1.1895, -1.1921, -1.636, 1.7467, 1.2641, -0.5089, -1.2281, -1.0875, -1.27, -1.038, -2.0292, 0.39997, -1.392, 1.6651, 1.9606, -0.50112, -0.96726,
        -1.6891, -1.6002, -1.0982, -0.94003, -1.3572, 1.0685, -0.5915, 1.33, 0.71442, 1.2369, 0.044847, 0.90325, -1.2741, 1.3287, -0.9597, 1.4594, 2.018, 0.94256, -1.4556, 1.2172, -0.35192, -0.53867, 1.6599, -1.1553, -1.6795,
        -0.35926, -1.5893, -0.7482, 0.16572, -0.61425, -1.4969, -1.069, -1.0987, 0.75571, -1.4854, 0.51844, 0.98923, 0.042288, 1.7711, -2.1606, -1.9669, -2.1707, 0.72063, -1.6729, -0.80055, -1.8596, -0.65687, -0.54807, 1.8841, 1.658,
        0.87858, 0.59962, -0.97093, -1.0383, -1.2581, -0.68944, 1.4802, -0.71636, -1.164, -0.080092, 1.3443, -1.168, -1.8205, -1.5302, 1.3229, 0.52977, 0.42618, 1.3155, -1.2178, 0.57894, 1.626, -1.1527, 1.806, 1.6693, 0.94243,
        -1.0073, -0.88678, 1.1569, -1.469, -1.1105, -0.68211, -0.41327, -0.30305, -1.715, 1.4737, 0.81464, -0.16343, 0.93772, -1.3556, -1.8122, 1.6525, -0.67613, 0.55806, 1.1169, -1.5248, -2.2736, -0.47593, 1.2788, 0.64831, 0.92,
        0.95272, -1.218, -0.30359, 1.9744, -0.93454, 1.9145, -0.71226, 0.4851, -0.97736, 2.1286, 1.0053, -1.4788, 0.35901, 0.93916, -0.37784, -1.8072, 0.96462, 0.822, 0.15089, 0.86338, -0.51028, -1.172, -0.36654, -0.81597, -1.2903,
        -0.68156, -0.32728, 1.5211, -0.51813, 1.2358, -0.1339, 0.69894, -0.93139, 0.51422, -2.0767, 0.73472, -0.99796, -1.1057, -2.1397, -1.8924, 0.27074, -1.1578, 0.9365, -1.1111, 1.1746, 0.31487, -1.0508, -0.51217, 1.0516, -1.3747,
        0.80357, -0.048922, 0.23694, 1.9504, 1.5892, 0.44832, -2.0897, -0.49704, 1.0916, -2.3558, 0.19464, 1.17, -0.59732, 0.45783, 0.53535, 1.0268, 1.5417, 1.5245, 1.4668, -1.645, -0.64083, 0.32338, -0.9681, -1.6139, 1.0612,
        0.88926, 1.3069, -0.22958, -0.020016, -1.3941, 0.97948, 1.246, 0.94082, 0.25448, 1.1901, 1.4415, -1.6503, 0.96039, -1.8276, 0.87675, 1.0258, -0.48214, -0.78912, 0.14275, 0.22949, -1.0304, 1.6707, 0.75598, 0.63086, -0.41338,
        -2.5734, 1.0285, -0.92236, 0.4805, -0.36268, 1.7522, 0.84718, 1.4568, -1.554, 0.57005, 0.59908, 0.80807, -0.71654, -0.43269, 2.23, 1.3586, 1.799, -0.87275, 1.1415, 0.17335, 0.86276, 0.84153, -0.73542, -1.269, 1.4285,
        0.095888, 0.75451, 2.1886, 1.3211, 0.69518, -0.74678, 1.8198, -0.029382, -1.7606, 0.44978, 0.70263, 0.44129, 1.3976, -0.38426, 1.1546, 1.2614, 0.81667, -0.319, -1.3171, -0.93235, -1.6323, 1.9296, -0.90826, -0.70448, 0.92504,
        0.28694, 0.84107, -0.14401, 0.8496, 0.66683, 1.9889, 1.4689, -1.1937, -2.1138, -1.2021, -0.61138, -1.0104, 0.02886, -1.5473, -0.50825, -1.6442, -1.315, -1.974, -0.60932, 1.7962, 0.29179, -1.4434, -2.031, -0.64634, 0.011454,
        -2.1478, 1.9072, 0.55958, 1.9057, -1.0182, 0.76945, 0.21131, 0.10591, 1.6222, -0.0061162, 1.0187, 0.89782, -1.0662, -1.1833, -0.89281, -0.47766, 1.1501, 1.9524, -0.55057, 0.80273, 1.0971, -0.86928, -0.018059, 1.8649, 0.96515,
        -0.55334, 1.5933, 0.53883, -1.7722, -1.2793, -1.2633, 1.6666, -1.3364, -1.6502, 0.32283, -1.4866, -0.66916, 1.088, 0.80562, -1.7779, 0.9042, 1.3584, -1.9641, -0.93818, 1.051, -2.4538, 1.8265, 0.67608, 0.30778, -0.58984,
        -0.21038, -0.72168, -1.3831, 1.2229, -1.9531, 0.74588, 0.12418, 1.0481, -0.10598, -0.33306, 0.14971, 1.8602, 1.4988, 2.1533, 1.6279, 1.2746, 0.99528, 0.58038, -0.63254, 1.9436, -0.83845, -0.49472, -0.94826, -0.4067, 0.91729,
        -0.73995, -0.97559, 0.89813, -1.8438, -1.6143, -0.88959, -0.56506, 0.76241, -0.33332, 0.29429, -0.54813, 1.1057, 1.4843, 0.96778, -0.53659, -0.6918, 1.4144, -0.17115, 0.65847, 1.5178, -0.49857, 1.3582, -0.30634, -0.44203, 0.80083,
        -1.6171, 0.72951, 2.6115, -0.36574, -1.3038, -0.65593, 1.3963, -1.2403, 0.99666, 1.6289, -1.3602, 0.42323, -0.91496, 1.139, 0.16997, -1.0252, 0.8482, 0.13916, -1.5315, 1.5316, -1.2693, -1.5442, -1.5714, -0.67629, 1.2809,
        0.94153, -0.014811, 0.88054, -1.3111, -0.82551, 0.82425, 0.87623, 1.4438, 1.83, -0.93864, 1.5831, -1.7083, -0.6038, 2.3592, 1.2008, 0.89272, 1.6217, 1.3992, 2.1985, 0.70644, 0.51557, -0.94532, -1.7179, 1.281, -0.056977,
        -0.27174, 0.44278, -1.3103, -0.11011, 0.86092, 0.79292, 1.0513, 1.3899, -0.36776, 1.9429, -0.59712, 1.8983, -1.5766, -0.73726, 0.77095, 1.5852, -1.1412, -1.5813, -0.54313, -1.7139, -0.18628, -1.7561, 1.5625, 0.31195, 2.2889,
        1.5812, 0.88497, 1.2307, 0.037595, -0.97401, -1.1597, -2.0563, 1.6245, 1.649, -1.142, -0.50679, -1.7468, -1.8491, 2.115, 1.3044, 0.11243, -1.3388, -0.8435, -0.15821, 0.088501, -0.46165, -0.87117, 1.1148, 1.4707, -1.5743,
        -0.99053, -0.75128, 1.0059, -1.7137, -0.67302, 1.798, 2.2342, -2.5108, -0.80389, 0.13512, -1.746, 0.24052, -1.9701, 0.10869, 2.3982, -1.0096, 1.123, -1.9961, -0.08023, -0.23994, -1.0438, -1.7742, -0.59838, 0.60256, 0.74611,
        -0.1972, 0.56278, 1.2308, -1.4044, 1.3534, 1.4518, -0.55186, -1.5091, -1.5418, -0.046623, -1.5839, 1.105, -1.0408, -0.7336, 1.0877, 1.2689, -0.22544, -0.60807, 1.3894, 1.6243, 1.5206, 0.14137, 0.41349, 0.306, 1.6083,
        -1.1604, -1.622, 0.73994, 1.2778, -0.53578, -1.9958, -0.39256, 0.04257, 2.2856, 1.4581, 0.70079, -1.4687, 1.2885, -1.3281, -1.7881, -1.7765, 1.7337, 1.2143, 0.76949, -1.4106, 0.68434, -0.4422, -1.8111, -2.361, -2.0135,
        1.9865, 1.5911, -1.7349, -0.11798, -0.35707, 1.2003, -0.82835, -1.2894, 1.3805, -1.6893, 0.40434, -1.7231, 0.35827, 0.67805, 1.3123, -0.68985, -0.77882, -1.121, -2.0504, 1.1292, 0.14623, -0.84026, -0.71937, -0.77393, -1.226,
        -1.8008, 0.19368, -1.864, -1.6848, 0.18149, 1.7912, -0.45269, 0.83597, -1.1582, 1.1294, 0.83931, -1.1915, -1.4074, 1.45, 1.0727, -1.3512, 0.99466, -1.045, -1.4864, -1.4031, 1.2158, 1.7781, 0.66479, -1.3962, 0.94129,
        -1.0396, 0.73138, 0.50595, -2.0997, 1.9278, -2.2444, 1.58, -1.3872, -0.67663, 0.57622, 1.6378, -0.030361, 0.82238, -1.013, 1.6817, -0.91335, 1.0028, -1.2043, 1.2204, 0.098207, -1.0562, -1.7704, 0.29271, -1.4076, 0.14934,
        1.0991, -1.1286, 1.0201, 0.18088, -0.40178, -1.2058, 1.2426, 1.2226, 0.86088, -1.6118, -0.81521, 1.1413, 2.0852, -1.1305, -1.0351, 1.8061, 2.2537, 0.0040908, -1.8875, 0.25816, -0.7086, -0.45913, -0.72145, 2.1069, -2.0426,
        1.6408, 1.9723, 0.44063, -0.2648, 0.52461, 0.66166, 1.9007, 1.5102, 0.67541, 0.99977, 0.90217, 0.61104, 0.75167, -0.16892, -1.1831, -0.84918, -1.1256, 0.69764, -0.72596, -0.98612, 0.74945, 0.20295, 1.6878, -1.3675, -2.7735,
        1.1479, -0.8607, -1.0045, 0.20692, 0.73975, -2.3647, 1.5477, 1.8585, -0.57588, 0.85559, -0.96854, 1.2708, -1.2559, 1.3138, 1.5881, -0.032938, -1.1061, -2.0857, -0.26405, 1.1148, -1.2966, -0.68932, -0.72226, 0.93469, 1.1019,
        -1.2237, -0.80892, -1.6266, -1.1503, -1.1485, -0.47606, 1.4041, 1.2179, -0.99391, -0.43573, -1.849, 1.1074, 1.2561, 1.039, -1.6106, -0.78378, 0.5093, -1.1224, -1.094, -1.9255, -1.4544, 0.64774, 1.0727, 0.45751, 0.78182,
        1.6082, 1.891, -0.31806, -0.37983, -1.284, -1.8555, -1.6215, 0.63524, 1.6519, -0.99803, 1.3671, 0.40681, 1.4368, 0.16311, 0.5752, -0.95626, -1.7647, 0.96471, -0.30866, -0.91758, 1.269, 0.99287, 2.3337, 0.36706, -1.6396,
        -0.11685, -0.8638, 1.9719, -1.7053, -1.0048, 1.0132, -1.8953, 0.85968, 1.6971, -1.3387, -1.2362, 0.87507, -1.4451, 0.41931, -2.3399, -0.78906, -0.00029319, -0.15152, -0.46892, -1.415, -1.6706, 1.346, 1.6316, -0.9606, 0.68496,
        -1.3529, -1.2146, 0.33285, 1.3931, -1.0883, -0.93129, -1.0192, -0.7293, 1.8523, 0.58833, 0.59557, 0.3958, 1.157, 1.9027, -1.3825, -1.0101, 1.2931, -0.87474, 0.92916, 0.14002, -0.56249, -0.55097, -1.0741, -0.94305, -1.5523,
        0.8945, -0.95778, -1.3452, -1.3663, -1.3983, 1.9704, 0.68979, -2.1889, -0.046368, -0.28157, 0.049358, 0.62655, -2.1681, 0.80395, -0.091166, 1.483, -0.91445, -1.1401, 1.7639, 1.2451, -0.86459, 1.5326, -0.43729, -0.95912, 1.1638,
        -1.3794, -1.6609, -0.81081, 0.98097, -1.5399, 1.4234, 0.679, -1.7405, -0.52406, -1.6995, -1.2295, -0.70817, -0.18687, -2.2299, 1.4964, 1.9984, -1.5813, -0.024698, -0.90872, 1.7573, 0.8267, -0.52773, 0.43109, -1.6121, 0.88518,
        -1.5289, -1.336, -0.47922, 1.8606, -0.76832, -1.522, 1.2431, 1.6237, -1.2489, -1.3664, 0.70551, 0.27258, -2.1316, 1.3853, 0.73705, -0.65537, -0.76963, 1.3105, -0.16674, 0.018879, 0.98708, -1.1389, -2.1748, -0.3649, 1.3821,
        -1.614, 0.48296, 0.58656, 0.41238, 1.8553, -0.043736, 1.1654, -0.77364, -1.0832, 0.54162, 1.4442, 0.27069, -0.087584, -0.46058, -0.79411, 1.4382, -0.33348, 0.46461, 1.7921, 0.69058, 2.1717, -1.0526, -1.0417, -1.4928, 0.80593,
        0.094443, -1.1328, 0.29702, 1.2591, 1.347, -1.6243, -1.3402, -0.41525, 0.43892, 0.94642, -0.15096, -1.1841, -1.7544, -1.211, -1.3947, 1.8478, 1.5542, -1.402, -1.628, -1.4658, 0.40386, -1.2895, -1.4673, -0.70059, -0.18537,
        -1.0443, 0.77111, 1.6168, 0.67074, 0.23347, 1.4706, 1.3071, -1.0434, 0.84386, 1.0382, 2.248, 0.71795, 0.46252, -0.50985, 0.7583, 1.9215, 0.28307, 1.0154, 0.32399, -0.0099279, 1.3345, -0.78874, 1.4213, -0.50463, -0.67807,
        1.6476, -0.64274, -0.40304, 1.6893, -1.0337, -2.3011, -0.13767, -1.3333, 1.7496, 0.68087, 0.34353, -0.12089, -1.6477, 0.16052, 1.8439, -1.3218, -1.929, -0.72394, 1.463, -0.69439, -1.586, -1.4919, 0.89975, 0.8791, 0.44534,
        -0.013951, -1.1714, -1.7577, -0.34137, 0.9273, -2.0086, 1.1346, -0.078094, -0.49546, 0.60857, -0.84333, 1.0197, 1.4624, -0.13135, 0.99934, -1.7336, 0.72985, -1.1114, -0.41463, 1.5511, 0.98359, 1.484, 0.92993, 0.95839, -1.5503,
        -1.6418, -0.80565, -2.0173, -0.30695, 0.91748, 0.26645, -0.73627, 0.0023572, 1.9749, -1.5334, 1.1869, 0.68483, -1.0379, 0.63313, -0.29304, 0.35853, 1.9066, 0.93839, -0.5902, 1.2576, 1.9691, -1.5297, 0.21193, 1.5777, 1.3141,
        -0.40716, 1.1002, 1.444, -1.2123, 1.2712, 0.22507, 1.1765, -1.2382, 1.3192, -1.0403, 0.077501, -0.49708, -1.0172, 0.94589, -0.12358, 1.473, -0.018618, 0.39189, -1.1886, 0.45274, 1.8636, 0.92796, -0.38472, 0.87863, 1.2566,
        -0.27055, -0.65295, -1.7851, 0.64548, 0.63782, 1.7553, 0.60542, 2.4142, -0.48413, 1.1047, 1.4085, -0.95931, 0.22959, -0.11803, 0.3903, -0.95931, -0.91137, -1.9811, -1.2177, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

char raw_4096_23[4096] = {
        0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0,
        1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1,
        1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0,
        1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0,
        0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,
        1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0,
        1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1,
        1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1,
        1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1,
        1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1,
        1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0,
        0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1,
        0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0,
        1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0,
        0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1,
        1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0,
        0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
        0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1,
        0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1,
        0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0,
        1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
        1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
        1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
        1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
        0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
        1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
        0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1,
        0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0,
        0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0,
        0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0,
        1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1,
        0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1,
        1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1,
        1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,
        1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0,
        0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
        0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0,
        1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1,
        0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0,
        1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0,
        0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1,
        0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
        0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0,
        0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
        0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0,
        0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0,
        0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1,
        1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,
        0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0,
        1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0,
        0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1,
        0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0,
        0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1,
        1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1,
        1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0,
        0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0,
        0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0,
        0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
        1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0,
        0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0,
        1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
        1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
        1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
        1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0,
        1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,
        1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1,
        1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,
        0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
        1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0,
        1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0,
        1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
        0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
        1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1,
        0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,
        0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1,
        0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1,
        1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1,
        1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0,
        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
        0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0,
        0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0,
        0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
        0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1,
        1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1,
        1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
        1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,
        0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0,
        1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0,
        1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1,
        0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0,
        0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0,
        0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1,
        1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1,
        1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,
        0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
        1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0,
        0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
        0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1,
        1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1,
        1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1,
        0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0,
        0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,
        0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0,
        1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0,
        1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0,
        0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1,
        0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0,
        1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0,
        1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0,
        1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1,
        0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0,
        1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0,
        1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0,
        0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1,
        0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
        1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1,
        0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0,
        0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1,
        1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0,
        1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1
};

ldpc_dbl r_4096_12[10240] = {
        1.4717, 0.3468, -0.86242, -1.3675, -0.60315, 0.54069, -1.1234, -1.0195, -0.38535, 0.72831, 1.4395, 0.42286, -0.72388, 0.31653, 1.0919, -1.2857, -1.2158, -0.24768, -1.1133, 0.63167, 1.1044, -0.87925, -1.8866, 0.73936, -0.40241,
        -0.95323, 0.16997, 0.4075, -1.4287, 0.70993, 0.20855, 0.93277, 0.26027, 1.227, -0.5468, 0.63811, 0.78154, 0.4038, -1.5107, 1.1758, 0.49675, 0.68858, -2.4827, 0.97095, 2.0017, 1.1292, -0.96469, -0.13885, 0.59775, -0.044254,
        -1.0145, -1.4178, -1.8467, 0.039169, -1.9361, -1.697, 2.0435, -0.40576, 0.08414, -2.0409, 0.40288, -0.5659, -0.028421, -1.4745, -1.0135, 0.19956, 1.1669, 0.8065, 0.43519, -1.8505, -1.478, -1.0435, -0.53594, 2.6849, -0.46272,
        0.70598, -0.33855, 0.096683, 1.5831, 1.0059, 0.051248, 1.147, 0.50835, 0.46563, 1.5045, -0.77452, -0.63152, -0.25703, -1.088, -0.44602, 0.69909, -1.0664, 0.35698, 1.0964, 1.5618, -1.064, 2.3136, -1.3855, 0.22939, 1.0856,
        -1.4818, -0.16458, 1.3552, -0.68593, -1.3863, 2.3027, -0.62302, 1.0884, -0.57242, 2.2064, -1.2595, -0.19691, 0.33003, 1.2966, 1.6118, -1.0124, -1.4342, -0.67015, -0.30051, 0.9497, 0.97767, 0.56214, -0.27544, -0.77784, -1.8334,
        0.58358, 0.96877, 1.462, 0.26432, -1.4397, 1.5449, -0.29609, 2.3817, -0.19718, 0.86627, 0.15945, 0.17185, 2.5732, 1.0811, -0.45805, 1.2972, 0.72765, 2.0312, -0.19011, -0.088688, 1.325, 0.15951, -0.14428, -1.5179, 1.5945,
        0.31259, -0.2629, -1.7943, -0.18976, 0.75406, 1.0544, -0.2003, -0.043297, 1.6473, -1.0604, 1.9166, 2.2422, 1.4232, 2.1777, -0.33417, 1.0723, -1.6837, -0.090337, -0.62369, -0.81196, 1.0861, 0.49474, -1.0893, 0.45442, 1.6153,
        1.1586, 1.4032, 0.40829, 1.0447, -0.91677, -0.074422, 0.26054, 1.4194, 0.79167, 1.4116, 1.9139, -0.9795, -1.8575, 1.8493, -1.7283, 0.91989, 1.5008, 1.3993, 0.6286, 0.66225, -1.1406, 1.2137, -0.60442, 0.95246, -2.7195,
        0.23436, -0.029324, 1.8677, 1.3724, 0.2621, -0.67364, 1.7652, 0.42422, 1.7089, -0.83256, 0.29008, -1.2091, 0.96061, -0.45351, 2.5737, 0.0056871, -0.45085, 0.050946, 0.32665, -1.7978, 1.1582, -0.11774, -1.3354, 1.5413, 0.17335,
        1.246, 1.6697, 2.7411, -1.1237, 0.145, 0.19522, 0.8976, 0.59392, -0.55317, -0.04919, 1.4453, 0.75751, -0.92922, 1.9976, -1.4352, -0.81463, 0.61015, 0.42361, 0.33422, 1.6481, -0.73238, 0.92624, 2.2943, -1.2475, 1.5369,
        -1.4871, -0.80654, -0.69295, -2.4743, 1.7532, -0.6357, -0.65039, -1.5529, 0.46633, -0.61152, -0.2226, -1.4599, -0.49981, -0.33914, -1.1052, -1.1972, -1.404, -1.7637, -1.8197, -1.2501, -1.8992, -0.99872, 0.88632, -0.63879, -0.8512,
        0.57898, -1.2044, -0.67176, 0.43975, 1.9178, -0.90409, 0.36236, 1.4084, 0.30099, -0.014313, -1.0176, -0.67539, 1.8675, -0.45776, 0.011085, -0.66819, 0.86195, 0.25422, -1.02, 1.1963, 2.82, -1.0597, -1.9674, 1.7184, 1.0111,
        -0.44418, -2.2467, -1.3649, -1.1767, 1.4604, 1.4093, 0.53676, 2.6168, 1.0022, -1.3154, -0.78365, -1.2559, 2.0444, -0.76651, 1.4564, -1.5209, -0.77649, 1.571, -2.1157, 0.95458, -0.97315, 0.73427, -0.61076, -0.50185, -0.72902,
        -0.66371, 2.0451, -0.65566, -0.59052, 0.093171, -0.2614, -2.1218, -0.67077, 1.8804, 1.7417, -1.0835, 0.79914, 0.060536, -0.57172, 1.0467, -0.33903, 1.1049, 0.93343, 0.48144, 0.44136, 0.29309, -0.0027456, -1.0031, -1.3474, 2.1535,
        0.3291, -1.6406, 0.61766, 1.4059, 1.1354, 0.5075, -1.9184, 2.08, 1.071, -0.066664, -1.527, 0.93172, 0.86271, -0.6013, 2.4587, 0.26824, -1.7784, -0.92765, 1.5576, 1.1982, 0.4835, -1.2782, 1.4189, 0.27983, 0.56301,
        -1.0922, -0.30968, 2.064, 1.5917, 0.84097, 2.4225, -1.5618, -1.6898, 1.351, -2.6212, -1.7253, -0.7273, -0.51035, -1.4239, -0.46231, -1.0123, 1.7186, 0.73522, -0.95447, 1.5978, 0.90056, -1.0173, -1.1827, -0.70494, -0.71246,
        -1.7417, -1.3529, 1.5839, 0.52773, 0.52112, -0.14553, -0.34543, 1.5167, -1.8229, 0.93814, -1.8767, -1.4542, -0.73015, -0.64454, 0.92328, -0.24261, -1.5937, -1.6637, -2.2664, -0.55762, -1.1519, -1.3149, 1.2133, 1.4268, 0.7583,
        -0.42475, -0.6388, -0.96907, -2.1437, 0.59142, 0.093548, 0.60286, 0.71523, 2.4395, 1.0602, 1.3809, 0.54536, 1.839, 1.0503, 1.6537, -2.4128, 1.0593, -2.9219, -2.6439, -0.72196, -2.2508, -1.9634, -0.31281, 0.90266, 0.60913,
        0.40287, -1.5943, -2.5868, 1.0903, -1.9158, -1.0369, 1.495, -0.10956, -0.44976, -1.4963, -1.726, -1.2953, 0.162, -0.82535, -0.083324, -0.91683, -1.669, -1.0631, 1.5846, 0.90952, 0.58201, 0.24548, 0.078079, -1.0961, -2.2997,
        -1.5709, 1.4128, -0.82858, -1.3712, -1.4976, -1.0931, -0.94595, -0.94876, -0.63387, 0.23066, 0.54963, -0.85185, 1.6676, -1.3219, -1.2112, -1.5953, 1.1988, -1.3919, -0.14382, -2.1958, -0.92526, -1.2201, -1.8523, 0.30798, -1.2877,
        -1.2276, -1.4502, 0.60613, -0.90812, 1.4975, 0.99763, -0.77911, 2.2346, -0.65569, 1.4836, -0.97487, -0.91266, -0.53794, 1.712, -1.8885, 1.0588, 0.744, 1.5363, -1.879, 0.60794, -1.6685, -0.38658, -1.0211, 0.89504, 1.0497,
        0.2899, 0.0075936, 1.1017, -0.22799, 0.29614, -1.4428, 1.844, -0.55328, -0.52883, -0.94122, 1.0887, -0.77434, 0.84247, 0.65103, 1.3569, 1.1523, 1.6156, -0.60167, -1.6894, -1.46, 1.2338, 1.4995, -0.59303, 1.431, 0.65847,
        -0.77457, 1.5261, 0.84412, 1.38, 0.95345, 0.37531, 0.4445, -0.50639, 0.52353, -0.68091, 0.37562, -0.70627, 1.2916, -2.1629, -1.5217, 0.49944, 1.5734, 1.0719, -1.4576, -1.1221, 0.80915, -0.14092, 1.185, -0.81177, -0.39896,
        1.5596, 0.54352, 1.1097, -0.61409, 1.014, 1.4089, -0.56548, 0.15318, -1.8112, -0.66987, -0.01371, 0.30587, -0.89978, -1.2416, -0.1213, 0.6747, -1.4856, 0.36115, 1.3887, 1.3899, -1.6281, -0.28548, -0.6118, 2.2125, -0.80087,
        0.47678, 0.37386, -2.1456, 1.1638, -1.3839, -0.65339, -0.74703, 0.75776, 0.99753, 0.54888, -0.54118, 2.2065, 0.51241, -0.51234, 1.2787, -0.39152, -0.82605, 2.1126, 1.7343, -0.33024, -0.41987, 0.39121, 0.67338, -1.1295, -0.98874,
        1.5106, 0.9075, 0.30642, -0.57648, 0.77955, -1.9778, -0.12204, -0.13064, 0.21462, 0.88204, 1.2527, 1.8427, 0.96115, 1.906, 0.50857, -0.95877, 1.4007, -0.11222, -1.9574, -0.63812, 0.6883, 1.2329, -1.6893, 0.91674, 0.65804,
        -1.1597, -1.2727, -0.16391, -0.84214, 1.1837, -1.1548, 1.2638, 0.69319, -1.7047, 0.72798, -1.5829, -1.896, -0.018212, 1.5969, 0.9301, -2.3587, 0.28653, 1.0466, -0.59896, 1.031, 0.32059, 1.1782, -1.7614, -0.40087, 0.11937,
        0.71162, -1.4207, -0.094664, -1.1361, -1.0631, -2.5079, -0.37421, 1.2201, 1.0111, -0.66484, -2.3055, 1.7874, 1.381, 0.95793, -0.068094, 1.5595, -1.5789, 0.47455, -0.66733, 1.1727, 1.6435, 0.78485, -1.2712, 0.10495, -0.69703,
        1.8194, -1.1119, 0.49635, -1.3439, 1.3363, 0.54557, -1.0779, -1.4062, 1.2698, 0.62638, 1.8071, -0.22039, 1.6861, 0.97228, -1.1746, 0.063266, 0.044954, -1.2817, 1.4385, 0.15552, 0.81844, -0.2014, -2.26, -1.3552, -1.3695,
        -0.60637, 0.64227, 1.6052, -1.5541, -0.5463, -0.25296, 0.13018, 1.0802, -0.49466, 1.8804, -1.2319, -1.2421, 0.86834, 1.1037, 0.12522, 1.0556, -2.5171, 1.9879, -0.35227, 0.019182, -1.1597, 0.91203, 0.86725, -1.4664, 1.0802,
        0.10178, 1.5145, -0.72741, 1.1472, -1.6085, -1.5365, -0.7001, -0.7981, 1.0506, -0.093524, -1.1305, 0.24457, -1.5436, 0.31122, 1.3775, -0.82195, -1.3461, 0.058512, 0.7174, -0.52317, 1.7769, 0.81755, 0.51402, 0.28287, -1.7018,
        -0.80084, -1.3091, 0.056694, -1.25, 0.40845, -1.4601, -1.1259, 0.97812, -0.090422, 0.84865, 1.1289, 2.3623, 0.71154, 0.03672, 1.0876, 0.50574, -1.8988, -0.96519, -0.40783, -0.12723, 0.80144, 1.5924, 1.2651, -1.7215, -1.2506,
        0.3344, -0.49222, -0.48072, -1.6004, 1.4469, 1.7256, -1.9455, 1.5619, -1.2758, -1.312, -1.5164, -1.9369, 2.2577, -1.3182, -2.5819, 0.60143, 1.8543, -1.1988, -0.7526, -1.9201, -1.8668, 0.74062, 0.98121, 1.1145, 0.99605,
        -0.19808, -1.0725, -1.0155, -2.0068, -0.87775, -0.3436, 0.24835, 2.305, 0.53697, -0.3521, -0.29355, -0.75507, 0.091728, 0.53384, -1.1901, 0.51957, 1.4077, -1.1372, 0.97504, 2.1525, 1.2682, 1.389, -0.058186, 1.775, -0.82207,
        -0.90471, 2.0844, 0.36093, 0.52686, -1.2778, -0.54497, -0.56827, 1.3004, -1.2227, -0.62674, 0.14624, 0.89511, 1.099, 0.095626, 0.65488, 0.35286, -0.61396, -0.77687, -0.15846, -1.0133, -1.0223, 1.0465, -0.69282, -0.62997, -0.64833,
        0.94987, 2.0298, 1.2683, -0.66839, 1.0042, 1.3787, 0.82151, 0.71637, -0.33316, 1.6095, -1.8764, 0.54635, 0.55593, 0.90739, 1.6918, -1.2847, 0.12879, 0.10324, 0.86622, 0.57692, 1.0718, -0.35655, 0.086734, -1.3166, 0.032551,
        0.31033, 1.2763, 0.36723, 1.8238, -1.2249, -1.8907, -0.0029564, 0.14682, -1.4777, 1.48, -1.9906, 1.1363, 0.91813, 1.9871, -0.32745, 0.40739, 0.26421, -1.6387, -2.3153, -0.98828, -0.73505, -0.84582, 0.79992, 1.4183, 1.4696,
        -0.80772, 1.1381, -1.1805, 1.1899, -1.0386, -0.57891, 0.025556, -0.24305, -1.8518, 0.027104, -0.31181, 1.0639, -0.28141, 0.74025, 1.0755, -1.2739, -1.1459, 1.0654, -0.22198, -1.4706, -1.1784, 1.345, 1.2196, -0.17375, -0.62811,
        -1.4727, -0.54418, -0.428, -0.74696, -0.86609, -0.8307, -1.3991, 1.1669, 0.32307, -0.27615, 0.68964, 0.84938, 0.76269, -0.83942, -0.41834, -0.29602, 2.2272, -2.1868, 1.6725, -1.0492, -1.0622, -0.084464, 1.058, 1.325, -1.5959,
        0.46979, -0.5546, 1.8874, -0.11531, 1.062, -1.0428, 0.93041, -1.0499, 1.4254, 0.50239, -1.7874, 1.3595, 1.5585, 1.0665, 0.55498, -1.3594, 1.9641, 0.60007, -0.41915, 1.044, 0.046995, 1.7487, -0.018857, -1.5785, -1.803,
        2.0751, -1.0393, -0.2721, 2.0533, -2.3966, 1.2073, 1.1905, -2.3883, 0.80896, 0.3769, -0.99845, -1.772, 1.4156, 1.142, -1.1341, -0.43764, -0.49964, 1.1334, -0.71589, -1.7609, -1.4349, 0.67273, 0.59926, -0.53596, 2.1703,
        0.41034, -0.48973, 2.0236, 1.9915, -2.3567, 1.9714, -1.2879, -1.4242, 1.5407, -1.3987, 0.98164, -1.0372, -1.7883, 0.3777, -1.3328, -1.5113, 1.3971, 1.9896, 1.0388, 2.255, -1.0905, 1.1126, -1.883, -0.063753, 1.148,
        -0.69641, 0.4949, -0.83965, 0.61571, -0.77122, 1.6085, -1.5799, 0.99899, 0.77265, 0.43894, 0.85895, -1.1553, 1.8986, 1.0388, 1.746, 0.52197, -0.42468, -0.50999, -0.77365, -1.1091, 0.32786, -0.60925, -1.4307, -0.10345, -1.0451,
        0.97524, 0.032953, 1.8035, 1.7907, 0.15107, -1.3337, -0.45353, 0.96705, -1.7484, -2.1689, 0.82487, -0.84729, 1.2791, 1.2664, -0.45799, 0.65031, 0.38601, -0.89035, -0.24458, -0.036041, 1.9729, -0.92076, 1.4524, -0.80372, 2.2405,
        1.4846, -2.0511, 0.25919, 0.92716, -0.12544, -1.3186, -1.9971, -2.0928, 2.3357, 2.231, -0.04203, -1.1203, -0.24832, 2.524, -2.0317, 1.0341, -1.0306, -0.63702, 1.7774, 0.46702, 0.3826, 1.0152, -0.7212, 0.013645, -0.84799,
        0.92073, 0.6423, 0.70602, 2.2654, -1.8655, -0.77692, -1.5352, -0.92222, -1.2533, 3.1631, 0.36646, 0.5216, 1.0934, 1.0629, 1.1833, 1.3888, -0.053309, -0.72516, -1.7726, 0.18785, 2.0976, -1.1232, -1.453, 0.14457, -0.2161,
        0.74267, -1.0964, 1.0479, 1.3876, -0.33948, -1.5666, 1.6138, 0.43441, 1.594, -0.39128, -0.4358, -1.5419, -0.57749, 0.94793, -1.4041, -1.0946, 1.2072, 0.028492, -1.9849, -0.42514, 0.6974, -1.2937, 1.3883, -1.3823, 1.0841,
        -1.7801, -0.17448, 0.81218, -2.7193, 1.6801, -0.11777, -3.6271, -0.93184, -0.72201, 0.92095, -2.3914, 1.3257, -0.032763, 1.8235, -0.91499, -1.6433, 1.1104, -0.51874, 0.55788, 0.52703, -0.70306, -0.43979, -1.1943, -1.0905, -0.83251,
        -0.95848, 0.73718, -0.45453, 0.94024, 0.10888, -1.2356, 1.2179, -0.80398, -2.173, 0.15738, -0.41974, -1.7405, 0.9779, 0.37419, 0.6454, -1.3018, -1.1947, 1.3123, -0.46559, 0.35486, 1.1992, -1.0625, 0.85486, 1.0264, -0.72756,
        -2.2462, 2.2637, 1.5542, 0.36871, -0.90788, 0.66336, -1.5195, 1.1811, -0.37326, 0.63607, 0.66391, -1.1055, -1.9763, -0.68576, -1.4027, 0.090915, 0.76064, 1.7858, -1.6008, 1.7348, 1.1698, 1.1144, 2.1609, -2.0594, 0.88248,
        0.65771, 1.1146, -0.71094, -0.15928, 1.5644, -0.34378, -2.2412, -1.697, -1.1324, -0.82795, 0.36544, -1.045, 1.3498, 0.7815, -0.10879, -1.1609, -0.13308, 1.313, 1.8671, 0.38424, 0.22807, -1.278, 1.3003, -2.3234, -2.4212,
        -0.15326, -1.3731, 1.4356, 0.49504, 0.5155, -1.664, 2.3071, 0.058605, -2.0164, 0.98003, 0.053839, -0.90562, 0.81094, -2.3509, 0.47444, -0.69157, -1.1158, 1.1992, -2.723, -1.3393, -0.70804, -0.81516, -1.1705, 1.5923, 0.22456,
        1.5457, 0.85119, -0.1325, 0.97541, 1.0037, -0.85419, 1.766, -0.83181, 0.39787, 2.4777, 0.68296, 2.5658, 1.3453, 0.70451, -0.42288, -0.20134, 0.61156, -1.9255, 0.099624, -0.61164, 1.6136, 1.3854, -1.316, -0.6014, 1.222,
        -0.90669, -1.4846, 2.2399, -1.802, -1.3805, 0.48769, 1.5263, -2.2001, -1.0097, -1.0237, 1.9518, 0.57758, -1.406, 1.1652, -0.42349, -1.6296, -0.58113, -0.64447, 1.3841, -1.0737, 0.79064, 1.3504, 0.97851, -1.5069, -0.46014,
        -1.9504, -1.4479, -0.0084851, -0.055196, -1.3959, 1.0203, -1.7188, 2.6607, -0.83451, -0.028915, -1.2253, 0.48098, -0.12905, 1.6741, 1.1046, 1.6638, 0.075058, -1.5696, -0.8624, -0.92387, -0.441, -0.11368, -0.81447, 0.89091, 1.3532,
        1.9568, 0.13365, 1.4876, 0.28114, 0.81079, 0.52065, -0.096998, -0.41679, -0.5576, 0.15702, 1.5222, -1.3556, 0.89375, -2.479, -0.78698, -1.6746, -0.59813, 0.92981, 1.7974, 0.59759, 1.1127, -1.3076, 1.0618, 1.9651, -0.35314,
        -1.575, -0.25975, 1.9223, -1.1557, -0.96385, 1.1551, 0.13905, -0.87877, -0.72787, 0.72573, 0.34964, 1.9053, 0.39574, 0.28587, -1.886, 0.31429, -1.0656, -0.76123, 2.0993, 1.736, 0.64706, 0.54306, 1.2131, 2.0873, -0.23605,
        -0.82139, 0.60507, 1.4235, 0.46559, -0.92133, 1.5216, 1.1543, -1.5669, 1.988, 1.1345, -1.301, -0.9856, 0.91147, -0.42383, -0.71961, -1.8809, -1.2313, 0.40235, 0.081122, 1.2573, 1.1354, 0.74679, -1.7637, -1.198, 1.101,
        1.0323, -1.3903, 0.69551, -0.52231, -2.1164, 1.5991, -1.8574, 0.65543, -1.9875, 0.38789, 0.8459, -1.0697, 2.5107, -1.3418, -0.8317, 2.0992, -1.1529, -0.33743, -1.3221, -1.4467, 0.51521, 1.6241, 1.5941, -0.84314, -2.0462,
        0.85968, 0.84605, -2.2791, 0.19448, 1.3439, -2.649, -1.4818, -0.15775, -1.5516, -1.9535, 1.9418, 1.8774, -1.3134, 0.4991, -0.38648, 0.45219, -1.1922, -0.055536, -1.4754, 0.62513, 0.019012, 0.38519, 1.3414, -1.1248, 1.1106,
        0.84256, -1.6325, 0.38531, -1.0459, -1.4218, -0.96382, -0.068129, 2.3664, 0.23413, 0.67019, -0.66381, -1.1482, 0.14951, 1.0951, 1.6266, -0.33403, 1.1524, 0.0049503, 1.9719, 1.8276, 1.3365, -0.38671, -1.4974, -1.3473, 1.1434,
        -0.66657, -0.73458, -1.4759, -1.9571, -1.3278, -1.1584, 0.81043, -0.23913, -0.49864, -0.46144, 0.2991, -1.0692, -0.89919, 2.5108, 0.05395, 0.7879, 0.63807, 0.73107, 0.9691, -1.1814, -1.3461, -1.4702, 1.7156, 1.4471, -1.1277,
        -0.26167, 1.1814, 1.2357, 0.22733, -1.8834, 1.047, -0.79924, 1.2525, 1.87, -0.2124, 1.5466, 1.4939, -1.7543, 1.7305, -1.8424, 1.1567, 1.2541, 1.9373, 2.4119, 0.36813, 0.89114, 2.1605, 0.77769, -1.2829, -0.46462,
        1.1764, -1.7981, -0.67552, -0.72281, -1.8256, -1.7611, 1.9516, 0.67509, -0.962, -2.0483, 0.87679, -1.4418, 0.48448, -0.32375, -1.7713, 0.1868, 1.4251, -1.3764, 1.7947, 0.17325, 1.3296, -1.0073, 1.6897, 0.20017, 1.2155,
        -0.39226, -0.34999, 1.3447, 1.5548, -0.49396, 1.1653, 1.4884, 1.7633, 1.1566, -1.6884, -2.0276, 1.0499, -1.2381, 0.55517, -0.50528, -1.6549, -1.1527, -0.82481, 1.7419, -1.4143, -0.48387, -1.2911, -1.114, -0.84548, 0.37421,
        -0.87683, 0.16945, -0.65135, -0.48358, -0.76868, -0.91985, -1.513, -0.73737, 0.56668, -1.0829, -1.9743, 0.58031, -1.4732, 1.3886, 0.53467, 0.25832, -0.79374, 1.4116, 1.2571, 1.3491, -0.8927, 0.47053, 0.95228, -1.2237, 0.9676,
        1.1384, 0.38929, -1.3321, 1.3406, 0.55363, 0.52165, 1.037, -0.68438, 0.47811, -0.56662, 1.1235, 1.6818, -0.90478, 1.1337, -0.096952, 1.0439, -0.51364, -0.35292, 0.77605, -1.6683, 0.68472, -1.8868, -1.521, 0.9396, 0.4305,
        -1.2926, -0.98087, -1.5903, -0.6248, -1.1996, 1.2077, -1.5987, 2.2896, 2.2573, -0.57511, -0.59302, -0.013083, 1.4809, 2.0593, -0.95449, 0.88024, 1.599, -0.11716, -0.35457, -0.31718, -1.7222, -0.29039, 1.5976, -0.70247, -0.16278,
        1.501, 0.51385, -0.36017, 1.5522, -0.13912, 1.3091, -0.43688, -2.5369, -0.41348, 0.65811, 1.1873, 0.83267, -0.27935, 1.2295, -0.87817, 1.4798, -1.0659, -1.5117, -2.5222, 1.7972, 1.9546, -0.17334, 1.605, 0.6102, -0.82008,
        -0.26736, 0.24027, 0.62724, -1.6989, -1.5442, 1.1756, -1.7999, 1.0076, 0.66472, -1.4973, -0.61287, 0.98487, 0.22784, -1.5394, -0.023843, -1.1353, 1.9316, -0.805, -0.49608, 1.3054, -1.6593, 1.8111, -1.2948, -1.5251, -1.306,
        -1.6712, -0.16061, 1.1669, -0.71689, -2.1185, -3.2858, 0.43668, 0.038134, 0.55844, 1.5345, 1.7546, 1.4641, -1.5863, -0.83659, 1.4076, 0.043301, -1.299, 1.1707, 0.24635, -0.21744, -1.0158, -0.61879, -0.75897, -0.74649, 0.62703,
        0.3501, -0.55811, 2.1987, 0.16254, -0.011168, -1.4918, -1.4065, -0.58602, 0.94519, 0.5836, -0.43366, -1.7136, -1.5177, 1.1773, 0.11841, -1.4839, -0.50431, -0.79838, -1.6368, 0.35241, 1.1536, -0.97224, 0.5789, 1.254, -1.5797,
        1.557, 1.1671, 0.78018, 1.8097, -0.94454, 1.2452, 0.45669, -2.5637, 1.0589, 2.388, -2.3661, 1.3272, 0.54599, 0.60554, -0.36011, -0.19592, -1.326, -0.18245, -0.85105, -0.56694, 1.6771, -1.1031, -0.4121, 0.29627, 1.9113,
        0.78338, -1.0648, 0.91877, 0.41865, 1.3747, -1.4933, 1.0516, -0.027815, -1.3499, -1.3847, 0.87731, 2.0647, 0.08816, -0.52096, 0.84296, 1.0175, -1.7092, -0.30436, -0.75648, -0.61298, -0.54065, 0.63777, 1.9567, 1.5926, 0.18005,
        -1.0089, -1.1182, -0.25836, -0.60396, -1.9974, 0.37836, -2.1172, -1.2078, -0.6641, 1.6491, -1.8083, -1.061, 0.55479, -1.1691, -0.12256, -2.0058, 0.60782, 0.10462, -1.377, -1.2959, 0.49339, 1.3373, -1.4649, -1.1687, 1.8171,
        1.6256, 1.3144, -0.81087, 2.3851, 0.59638, -1.2624, 2.4877, 1.7273, -2.4505, -1.0189, -1.1501, -0.32708, -0.75357, -2.1679, 1.132, -1.1624, -0.62509, 0.050808, 1.612, 0.15271, -2.0848, -0.51344, 1.2914, 1.4498, 0.41602,
        0.83112, 1.0155, 1.2517, 1.0861, -0.49993, -1.706, -2.2673, 1.1277, -1.2245, -0.94313, -1.0427, 2.0986, -1.1814, 1.4033, -1.7709, -1.3673, 0.73569, -0.71695, -0.4535, -2.8925, 0.044531, -1.5494, -0.92785, 1.0225, 1.2879,
        -0.90029, -0.35829, 0.78152, 1.2178, 1.0845, -1.12, -1.2379, -1.2212, -0.16021, -0.95277, -1.2335, 1.1256, 3.2289, -1.1971, -0.54998, 0.72107, -1.018, 1.1835, 1.4241, -1.1012, 0.88703, -1.8596, 0.41517, -2.3252, -1.4475,
        0.068754, 1.8202, 2.0228, -1.2024, -0.42872, 1.3551, 2.7501, 0.83748, 0.065694, 2.2917, -0.065817, 0.37999, -1.3101, 0.53279, -0.29918, 1.0599, -1.9672, 2.4476, -0.94239, 1.4491, -0.94602, -0.72467, -1.3274, 1.1321, 0.059371,
        0.46252, -1.1532, -1.5077, -0.19747, -0.15383, 2.37, -1.5777, 1.0435, 0.040296, 0.71622, 0.72428, 0.6191, -0.36022, -1.2248, -0.4202, 1.8258, 0.68608, -1.2709, -0.8071, 0.96366, 1.726, -1.1199, 0.081539, 0.54759, -0.96363,
        0.80342, 1.043, -1.8846, 3.0539, 1.1602, -1.6976, 2.638, 0.84577, 0.6928, 0.46389, 1.0947, -0.43452, 0.085122, 1.2886, -1.1678, -0.74855, -0.030501, 1.2938, -0.026636, 0.89318, 2.5511, -0.32108, 0.92016, 1.0407, -0.2441,
        -0.30789, 0.41908, -0.18674, 1.654, -0.21712, -0.90546, -0.44877, -0.51032, -0.030303, -1.9038, 1.4935, -0.049859, 1.7287, -2.6125, 1.0394, -0.548, -1.4497, -1.4875, 0.48153, 1.568, 0.75542, -0.81309, -0.76456, -0.79844, 0.42391,
        0.17748, 1.6266, 0.93378, -2.0599, -0.27073, 0.20202, 1.7252, -1.2782, -1.2739, -0.31567, 0.71411, 1.4954, 1.7043, -1.2523, -0.54775, -1.7325, 1.4721, -0.092583, -0.70661, -1.6421, 1.3503, -0.68455, -0.57816, -1.5007, 1.5489,
        -0.096062, -0.64241, 1.809, 0.23584, 0.67746, -1.1075, -1.428, -2.133, -1.0141, 0.72907, -0.14071, -0.99282, 0.4009, 1.9015, 0.20829, -0.4948, 1.2063, 0.83074, 1.5285, -1.7998, -1.6255, 0.60116, -0.84757, 0.69046, 1.2747,
        -1.3782, -1.0092, -0.99975, -0.61979, -1.1379, 1.0483, -0.42415, -1.4465, 0.59425, -1.3751, -0.77463, 0.48685, -1.21, -0.82476, -1.644, -0.20563, -1.494, -0.92773, 1.4233, -1.6586, 0.47034, -1.085, -1.4535, -1.591, 0.55107,
        2.1185, -0.30217, -1.1872, 0.051952, 0.12441, -0.46709, 0.67539, 0.1648, 1.168, 0.019064, -0.10498, 0.42463, -1.3242, -0.59038, -0.32766, -1.2806, 0.14146, 0.57379, -1.1339, -0.25679, 0.2963, 1.168, -0.57598, -0.3162, -0.63084,
        -1.8927, -0.19915, 0.32087, 0.044256, -1.962, -0.94942, -1.6205, 1.4233, -0.79425, -1.0227, 0.20587, -1.0904, -0.86672, 2.3219, -0.54099, 1.521, -1.2005, -0.4747, 0.9484, -0.8951, 1.334, -1.1679, 2.27, 0.70604, -0.72368,
        -1.7188, 0.69776, 1.3657, 1.1936, 0.91338, -0.92844, 1.193, -1.7505, 0.65577, -1.5743, -1.5283, -1.1788, -0.28404, 2.0106, -1.2845, -0.53511, -1.3326, -1.2686, -0.41607, -1.9095, -1.2161, -2.2643, -1.2237, 0.57085, 1.5656,
        1.0103, -1.1799, 1.0063, -0.34282, -0.19768, 1.396, 1.1657, -1.822, -1.0539, 0.98936, 2.1586, 1.8509, 1.1931, -0.92193, -1.1597, 2.0106, 0.61063, -0.64807, 0.92314, 0.64091, 1.4889, -1.6514, 1.5, 0.41049, -0.43552,
        -1.0653, -0.96771, 0.894, 0.76111, 0.6557, -0.29791, -1.1741, -1.4938, 2.5725, 1.7284, -1.487, 0.038531, -1.2275, 0.3152, -0.76061, -1.5192, 2.4146, 1.0975, -1.5449, 2.1638, -1.3018, 0.57932, -1.0145, -1.1581, 1.2722,
        -0.43881, 0.75271, 0.25716, -1.1667, -0.1698, 1.4943, -1.4197, -0.032727, 2.4307, 1.4948, -2.1669, -1.7485, 0.84119, 0.027832, -1.2235, 0.46443, 0.20177, -0.93336, 0.57724, -0.7519, -1.1955, -0.48132, -1.3426, -0.68652, 0.87282,
        -1.4876, 0.95113, 0.1337, 0.5512, 0.86019, -0.4475, 0.6638, 1.3488, 0.26945, -1.0875, 1.819, 1.8921, 1.4269, -0.37164, 1.401, -0.57266, -0.66792, 0.72728, -1.5911, -1.1747, -0.66708, 0.84276, 0.91765, 1.6353, -0.86895,
        1.5767, 0.33286, -0.55861, 1.0557, 0.67891, 1.2984, 2.0503, 0.49194, -1.4103, -1.4075, 0.94709, -1.8557, 0.94332, -2.2705, -1.9049, -1.2616, 1.3823, -0.11962, -1.814, -0.79203, 0.78338, 0.6397, 2.3943, 0.19457, -1.6534,
        1.0429, 1.3219, 0.04876, 0.90018, -1.6287, 2.1328, 2.4696, -2.3146, -2.06, 1.2059, 1.7313, -1.1506, 1.6693, 0.21777, 1.6781, -0.92201, -1.1426, -0.68695, -0.93689, -0.83295, -1.615, 2.1563, 0.52934, -1.6355, -2.0889,
        1.3023, -1.2487, 0.58113, -1.3817, 0.98893, -0.019221, 1.0667, -0.55985, -1.7922, 0.063956, -0.25619, -1.0968, 1.846, -1.0232, 1.1847, -1.6221, -0.36366, -0.69447, 0.60656, -0.55134, 0.14978, 0.014615, 0.40405, -0.33163, -1.6189,
        -1.6891, 1.3718, 1.1166, 0.71075, 0.56682, 1.1376, -0.86978, -0.03891, -0.95411, -1.4981, -0.30344, 1.0765, -1.7126, -2.0418, 1.523, 1.6227, 1.5334, -0.56792, -1.605, -1.4717, -0.68616, -1.488, 0.11975, -0.42304, 1.4537,
        -0.50509, 2.121, -1.294, 0.18873, -0.24986, -1.7321, 0.72048, 1.4196, -0.034527, 1.9407, 0.55359, -0.8754, 0.85921, -1.0546, -0.80668, 0.71419, 0.44471, 0.25994, 1.1563, -0.029838, 1.9158, -0.086643, -2.2663, -0.18783, -0.20285,
        -2.0113, -0.07512, 0.49879, 1.1346, -1.1917, 0.454, -1.041, -1.2342, 0.91885, 1.407, -1.6463, -2.4624, -0.70797, -0.84282, 1.4729, -0.69611, -0.6695, -1.1245, 0.19913, 0.43067, -1.91, 0.25642, 0.25115, 1.1388, 1.5171,
        -0.60483, -1.4672, -0.013269, 1.4895, -0.1141, 0.91909, -1.2261, -1.2737, -0.78367, -0.074451, 1.7428, -2.5709, -0.89559, 1.1606, 0.69436, 1.0563, -1.4421, 1.1196, 0.073757, -1.7752, 2.0564, 0.30652, -0.7752, 0.97905, 1.2895,
        -1.5011, -1.4509, -3.1281, -0.58665, -1.2028, -1.2624, 0.65719, 1.5127, 1.805, -1.5815, 1.2874, 0.55286, -1.3822, -0.84291, -0.37786, -0.99383, 1.4336, 1.5602, -0.50506, 0.090131, 0.83827, -0.65194, 1.0557, 0.98838, -0.73406,
        -0.9825, 1.5666, -2.0886, 1.9128, -1.1629, -1.9213, 0.078472, 0.28809, -1.6333, -0.66918, 1.0908, 1.8923, 0.9961, 0.74, 0.94757, -0.76839, 2.3961, 1.9879, -1.042, 1.1112, -0.10555, 1.0383, 1.0389, 1.8381, 1.7882,
        0.072999, -2.039, -2.1469, -0.42752, 0.74199, 2.032, 0.66485, 1.0733, -1.2533, -1.1988, -2.2778, 0.16497, -0.69391, -0.10101, -0.33368, 2.3562, -0.84146, -1.9357, 1.539, -1.2858, -0.66383, 1.0933, -1.5205, 1.8523, -0.37776,
        1.533, -0.076429, 0.58512, 0.31047, 0.95341, -1.4067, -2.4312, 2.1684, 0.99151, -1.2164, -1.4805, 1.4566, -1.3404, -0.30941, 1.0597, -1.6085, -1.1182, 0.25813, -2.1051, -0.27037, -1.0511, -0.3622, -1.5403, -1.4106, 1.262,
        0.18959, -1.6452, -0.36456, -0.044132, 0.47327, -1.3962, 1.3839, -1.3235, -1.0221, 0.8349, 0.44658, -1.0338, -0.11929, -1.5072, -0.25756, 0.78381, -0.4038, -0.096899, -1.2305, 2.5676, -0.60046, 0.1639, -1.5011, 0.98227, 0.76204,
        0.17452, 1.332, -0.18724, -2.2526, -1.6109, -0.52587, 1.8335, -0.56619, 0.38921, -0.94264, 1.7889, -0.89491, -0.84074, -0.84405, -0.12984, 0.078007, -0.94344, -1.2313, -0.54066, 1.967, 0.10642, 0.36905, 1.8093, -0.29778, 0.12506,
        -0.67672, -0.40019, -0.90768, 0.54798, 1.0096, -2.234, -0.38314, -0.22532, 0.55079, 2.2597, 2.1195, -0.54728, 1.1558, -1.5904, 0.93355, 0.0073059, 0.26576, -1.0855, -1.7094, -0.87512, -1.885, -1.1877, -0.55648, 1.0261, 1.9385,
        0.60101, 0.52554, -1.1482, -1.8281, -0.6278, -0.28229, -0.11791, -1.3699, 1.2394, 0.50782, 1.7497, -0.88706, 2.4055, -0.80476, 0.34008, 1.9325, -0.94389, -0.67635, 0.94983, 1.0194, 0.50897, 1.7475, 0.20318, 1.9084, -0.71921,
        1.3976, 0.47698, -1.4416, -1.2859, -0.84787, 2.1977, 1.1552, -0.9943, -0.42747, -0.69664, 0.99171, -1.2418, -0.75924, 1.1048, -0.62923, -1.1975, 0.96899, 1.0792, -2.2386, 1.7604, -1.543, -1.0996, -2.3204, 0.044609, 1.3883,
        -0.08703, 0.7277, 0.12518, -1.0235, -1.4723, -1.2362, -0.39252, -0.55148, 0.56848, 1.2718, 2.0268, 0.4083, 1.6916, 1.0005, 0.10262, -0.49451, -1.5044, 1.1954, -0.55983, 2.0061, -0.26742, 0.51666, 1.5925, -1.1907, 1.1978,
        0.31416, 0.50723, 0.87919, -0.68023, -1.4348, 0.35898, 0.46003, 1.2953, -0.66216, -0.88564, 1.3486, 0.7894, 0.09989, -0.12247, 1.0155, 0.99895, 0.47622, -2.2476, -1.0349, -0.40704, 0.1545, 0.45651, 1.1458, 0.98665, -1.9202,
        0.88034, -1.5575, 1.8456, 0.84692, 0.53139, -0.19968, 0.94941, -2.2107, -1.558, 0.2343, 0.67722, 0.52634, 0.51195, 0.67037, -1.8289, 0.69524, 1.0481, 0.13314, -0.52855, 1.5122, -1.0104, 0.69722, 1.1999, 0.50499, -0.96427,
        0.82172, 0.76067, -1.117, 0.054454, 1.5491, 0.55137, -1.2104, -0.9038, 1.5961, 0.72065, 1.1239, 1.1089, -0.60124, -1.6007, -2.6399, -0.86813, 1.6573, 0.21897, -1.8552, -0.67221, 0.32507, 1.3701, -0.48571, -0.8954, -2.0862,
        -0.56627, -1.7481, -0.42076, 0.61297, -0.63213, -0.92717, -0.74464, -1.1631, -0.43772, -1.3201, -1.1627, 1.0083, -1.4681, -0.54196, -1.4381, -1.7073, -1.4229, -2.239, 0.38038, 1.2998, -0.54562, -0.85515, -1.3095, 0.49245, -0.54356,
        -0.73895, 1.0367, -1.0571, -1.0518, 0.30423, -0.0819, -0.57573, -1.5616, -0.88968, 1.9491, -1.3088, -1.3453, -0.1673, 0.44183, 1.0131, -0.036868, 1.0531, 2.0299, 0.26453, 0.19654, 0.67024, -0.44877, 0.2763, 1.2564, 0.47032,
        -0.76235, 0.60312, 0.071616, -0.047976, -1.3235, -1.0319, 0.43926, 0.039761, 0.73959, 0.77658, -0.26113, 0.50133, 0.72751, 1.382, -0.63364, -0.0020222, -1.3837, -0.94692, 1.5207, -1.1217, -1.1408, -0.95999, 0.47755, 0.75127, 0.16754,
        0.014296, -1.3734, 0.069438, 1.2265, 1.204, 0.78448, 0.57683, -0.302, -1.7073, 1.5807, -2.3057, 1.863, -1.6158, 0.37738, 1.6586, -0.5306, 2.1814, -1.4399, -0.59266, -0.91539, -1.4953, 1.6388, 1.4543, 2.27, 1.7027,
        1.9567, 0.71132, -2.1887, -1.9994, -1.4104, 0.75137, -0.82484, 0.55254, -0.02146, -1.299, -2.5688, 0.71423, 0.57999, -0.08156, 0.82013, 1.171, -0.32178, 0.97694, -0.5307, -0.015252, -0.41811, -0.91057, -1.6799, -0.61339, -1.2593,
        -1.657, -0.81756, 1.6692, 0.7107, -1.5744, 0.85403, -1.169, -1.0731, 0.47255, -0.90497, 0.0091209, 0.45218, 0.016792, 0.29072, 1.8009, 0.53106, -0.56797, -0.13355, 1.2963, 1.4562, 2.4272, -1.8962, 0.30671, 0.42426, 0.81701,
        0.46437, 0.028843, -1.0971, -1.0658, -0.80885, -0.42751, 0.22708, 1.9744, 0.75459, 2.0513, 0.30328, -0.22003, -1.0443, 1.5167, -0.75613, 0.62867, 1.1945, 0.64143, -1.404, 0.40496, -1.8486, 1.0295, 1.8046, -1.3662, -1.912,
        0.86644, 1.7146, 1.8789, -0.69775, -0.5287, -0.84414, -0.79759, -0.60804, 0.091639, 1.2096, -1.1109, 0.57929, 0.13359, -0.34014, -0.51901, 0.99756, 0.62467, 0.99859, 1.8896, 0.40996, 2.3277, -1.4176, -0.9925, 0.74153, 0.094597,
        -0.16837, -1.073, 1.7225, -0.68604, 1.8177, -0.58001, -1.367, 0.73411, 1.3908, -0.76486, 0.90905, 2.2181, -0.37886, -0.12863, 1.861, 0.081174, 0.53229, 1.9493, -0.21729, -1.0375, -1.5592, 1.7568, -2.4309, 1.0868, 1.2129,
        1.2271, -1.1879, -0.13769, -1.2568, -0.28061, -0.36427, -0.83596, 1.5471, -2.0354, 0.94622, 0.85935, 0.99707, 1.0623, -1.3438, -1.2459, -1.7927, 0.11761, 1.4696, 2.5242, 1.7521, 0.5879, -0.40867, 1.1888, -0.12552, 2.108,
        1.1332, -2.3602, 0.76402, -1.5384, 0.38604, -1.6258, 1.4832, -2.032, 0.052511, 1.4301, 0.64544, -1.0867, -1.6701, -0.076262, 1.4473, 1.8739, -0.95483, 0.16585, -1.3309, 2.0151, 1.0297, 1.6259, -1.4208, 0.76187, 0.53394,
        -1.5268, 1.6913, 0.67606, 1.789, -0.3474, -1.4041, -0.47849, 1.1629, -0.44279, 0.89748, 0.4792, 1.656, -0.49288, -1.0181, 0.36084, -0.50903, 0.5857, -0.76825, 0.47372, -0.78904, -0.51393, 1.4053, 0.76288, -2.1247, -3.1532,
        -1.3085, -0.074951, -1.0564, 2.0035, -0.60652, -1.1888, 1.5851, -0.077329, 2.1612, -1.7434, -1.3295, -0.094608, 0.084975, -0.41616, -1.7671, -2.2029, -1.6785, 1.8859, -0.54792, -0.85882, -1.8824, 0.16003, 2.2831, 1.1845, -0.031689,
        -1.806, 0.46981, 0.47103, -0.10094, -0.3054, -1.1089, -1.6245, 1.3108, 0.34685, 0.37513, 0.23607, -0.62827, -1.3744, -1.4398, -0.11159, 1.6055, 0.18207, 0.55068, 1.21, -1.3537, 1.0871, -1.6186, 1.3001, 0.36335, -0.80488,
        0.29199, -0.76911, -1.9074, -1.051, -1.9886, 2.2497, -1.4281, -1.3184, -1.1059, 0.79598, -1.584, -0.97596, -1.0844, 0.57823, 1.2669, -1.3451, 1.7392, -1.6769, 0.67643, -0.97141, -1.6029, -0.091482, 1.2511, 1.4622, -0.9622,
        0.70517, -1.2062, -0.82811, 0.73651, 1.4349, -0.8524, -1.0048, 1.6956, -1.1436, -0.87324, 2.2447, 1.6627, -0.87949, -0.44136, -0.65135, 0.66359, 0.057727, -1.1961, -0.9444, 1.2152, 0.71491, -0.44442, -1.5852, -1.6667, -1.8104,
        -1.3635, 0.93485, 1.3573, 2.016, -0.83914, -0.18829, 1.202, -1.2668, -1.6184, 1.5085, 1.3794, 0.82595, -1.2523, -1.2753, 1.3575, -0.5079, -0.4993, 0.44333, 0.91584, 1.0253, -0.01967, 0.75245, -0.93855, 0.83464, -2.069,
        -1.5064, 0.43689, -0.26634, 0.96674, 0.72307, -0.22856, 0.21993, -1.3352, -0.95505, -2.199, 0.20892, -0.974, -0.57258, 0.60988, 1.1536, -1.4755, -0.55626, -0.2304, -1.2419, -0.33538, 1.069, -0.35414, 0.24111, 0.081989, 0.26381,
        2.0659, 0.64618, -0.5999, -1.1809, -2.3222, -1.7282, -2.4634, 0.30134, -2.307, -0.6803, -1.5707, -0.97552, -0.3158, -1.2522, -0.94708, -0.13951, -0.84792, 0.78349, -0.97606, -0.74825, -0.66606, 1.9436, -0.89527, -1.0711, 1.4923,
        2.1599, 0.91839, 1.5244, 1.2028, -0.086973, 1.117, -1.5734, 1.4603, 1.5695, -0.014583, 1.6394, -1.1596, 2.1169, -1.6039, 0.45269, -1.2558, -0.48293, 0.7284, 0.88122, -0.94571, -0.23768, 1.8075, -0.6552, -1.3006, 0.49756,
        -0.058691, -0.51023, 1.1752, 2.3786, 0.22211, 0.85491, 1.9159, 0.04573, -0.46695, 0.15695, 0.56962, 0.85912, -1.2239, -0.74023, -1.5135, -1.5819, -0.81318, -0.046067, -0.3871, 1.6985, -1.2625, -0.88023, -0.75391, -0.55425, 0.45381,
        1.1902, 0.030206, -0.51481, -0.088363, 0.95436, 0.64821, 3.2878, 0.28732, 2.1867, 1.1599, -0.6474, -0.10327, -0.73319, -0.84628, -0.59967, 1.186, 0.5753, -0.99019, -1.9035, 1.8058, -1.5974, -1.018, -1.491, -1.6519, -1.4251,
        -1.0747, -1.0185, -1.3116, -1.5278, 0.16538, -1.7105, -0.055125, 1.3445, 0.44037, 0.78932, -0.8189, -0.52145, 1.1128, 1.2275, 1.1594, -0.85804, 1.4345, -1.6723, -0.88694, -0.036772, -0.0031402, 2.2004, 0.61809, -0.9334, 1.3168,
        -0.24449, 0.85031, 1.0328, -1.3568, -2.4237, -1.0328, -0.41638, -2.1489, 2.1124, -1.8637, -1.3602, 0.72676, 1.7822, -0.12818, 1.4677, -0.00061097, 0.63702, -1.3865, 1.7873, 1.3053, -1.2218, 0.59805, 0.30054, 0.86185, 1.2084,
        -1.238, 1.0038, -0.11451, 0.16535, -1.7613, -0.87243, -0.7688, -0.47428, 0.23522, 0.63909, -1.9554, 0.89101, 0.55122, -0.82352, 0.85611, 1.5908, 0.33637, -0.83844, 0.53066, -1.4741, -0.62513, -1.4922, 0.85808, 0.3914, 0.75198,
        -1.7639, -1.4389, 0.61791, 1.1469, -0.1652, 1.3619, 1.0844, 0.47978, 0.4164, 0.51538, -2.43, 0.12749, -2.4477, 1.1907, 0.5314, 2.5521, -0.62356, 1.3527, -0.52738, -0.87188, 1.0183, 0.58593, -1.0607, 1.4297, -0.53335,
        -0.16834, -1.5117, 0.045667, 0.39455, -0.96817, 1.0035, -1.6051, -1.3436, -1.6279, -0.23017, -0.095695, 1.7474, -0.53385, -1.1955, -1.4437, -0.81736, -1.374, -1.481, -2.2197, -2.3555, -0.31701, -1.8322, -1.046, 1.2155, -0.77258,
        -0.96177, 0.78404, 0.052692, -2.6675, -0.50815, -0.66103, -1.0902, -0.31381, 1.3763, 1.4174, 0.71481, -0.27696, -2.4248, -0.51534, -0.44232, -1.495, 0.95109, 1.2519, -1.4296, 1.6094, 0.5819, 0.71058, -1.4986, 1.6106, 0.78048,
        -1.0074, 0.91411, 1.5799, -1.3186, -2.0695, 0.9199, 1.065, 0.89175, -1.1149, -1.8202, 0.76362, 1.8248, 0.92115, 1.3805, 1.1896, 0.59355, -1.2958, 2.2022, 0.7536, 1.2523, -2.6142, -1.309, -0.61115, -0.93958, -1.1727,
        0.68418, -1.8604, -1.7584, 0.93942, 1.0778, 1.4091, -1.0371, -2.7156, -0.70557, 0.66014, -0.94668, -0.26238, 2.4343, -2.741, 0.57828, -0.84555, 0.78464, -3.1283, -0.99802, -0.39124, -0.12107, 1.2346, -0.50419, 1.1107, 1.1688,
        1.2146, 1.888, -0.23723, 1.1453, 1.5528, -1.2047, -0.25591, -1.5622, -1.3182, 1.1555, -0.67984, -1.7896, 1.1579, -0.76049, -1.9494, 0.69268, 0.28093, -2.1662, 0.25114, -0.90399, -1.3364, -1.2802, -0.24494, -0.99959, -2.2899,
        -1.32, 2.3696, 1.9332, 0.60054, 1.0826, 0.10123, -0.59715, 0.5049, 1.2019, 1.2351, 0.12338, 2.275, 0.99445, -0.029751, -1.4154, 0.80389, -1.3138, -2.0537, -0.54929, -0.22825, 0.59687, -0.9664, 0.80661, -0.021599, 0.64104,
        -1.6281, 1.8343, -0.76435, 1.7139, -2.2049, 0.8289, 1.3139, 2.2552, -1.874, -0.045327, -1.4243, -1.7415, -0.24024, -0.41063, -1.1297, -0.27112, 0.45235, -1.4161, -0.69148, 1.8203, 1.1594, 1.5898, -0.11106, -0.98009, -1.7253,
        -1.3122, -0.90724, -1.7123, -0.55922, 1.2995, -1.5486, -1.3714, -1.3413, -1.6426, -1.2063, -1.0035, -0.02085, 0.96533, 0.85984, 2.2266, 0.74377, -1.7843, 0.60993, -0.35914, 0.62031, 0.34245, 0.42748, -1.0496, -1.124, -1.3289,
        0.98071, 1.4122, 0.69647, -0.84633, -1.7295, -0.80491, -0.5449, -1.3024, -0.55626, -1.1629, -0.62734, -1.3763, -0.17148, 1.7026, 1.8964, -0.1831, -0.95225, 1.7815, 0.87646, -0.91776, -1.2416, -1.6937, -0.53603, -0.74271, -0.40698,
        1.2956, -0.32939, -0.54542, 1.1624, -0.58308, 2.4947, 0.42173, -0.55702, -2.3288, 0.034873, 0.79488, 0.67863, -0.84325, -1.419, 0.65057, 0.90974, -1.9729, 0.52563, 2.0708, -0.41412, -2.7141, 1.6117, 0.30154, -0.54573, -0.48422,
        1.7781, 0.86661, -0.924, -1.0553, -0.92273, -0.11935, -2.3037, 0.76529, -0.5155, -2.9426, -1.5808, -2.4797, -1.0073, -1.0428, 0.9324, 0.52612, -1.9627, -0.3224, -0.43778, -1.5656, -1.1333, 1.0739, 0.89476, 1.4248, 0.14521,
        1.3618, 0.93335, -1.0928, -1.3903, -1.0418, -0.059475, 0.81363, -0.77174, -1.8105, 1.1163, -0.6631, -1.4609, 0.70347, 0.86079, 2.2879, 0.1549, -1.6596, 1.493, 1.8352, 1.312, -1.6161, 1.4562, 1.4878, 1.043, -0.79801,
        -1.5994, 1.1086, -1.3603, -0.15066, 1.6837, -1.1531, 0.47621, -1.285, 0.83967, -1.5122, -2.0612, -1.2007, -0.91162, -0.50992, -0.82553, 0.13641, -0.80155, -1.141, -0.41855, -0.03149, -1.4171, 0.22518, 1.1879, -1.7072, 1.5775,
        0.81389, -0.35583, -0.5826, -1.6586, -2.2, 1.3329, 0.5364, 0.69373, 1.1977, -2.3166, 0.023846, -0.75755, 0.16822, 1.055, 0.96868, 0.87663, -1.2089, 0.86896, -0.60898, -1.0191, 0.30327, 0.17205, 1.7963, 1.4609, -0.37735,
        -1.5283, 1.1276, 0.97037, 0.48029, -0.54984, -1.5364, 0.71616, -0.069784, -0.76377, 2.0853, 1.9444, 0.31107, -1.0412, 0.54231, 0.4995, 0.066157, 0.92321, -1.8846, -1.9232, 0.21663, 1.829, 0.88045, -0.56477, -0.58018, -0.70138,
        -0.41094, 0.13715, 0.74744, 1.7508, 1.7868, -0.96499, 0.72411, 0.3259, 0.83383, -0.47321, 1.3902, -0.3411, -1.1337, 0.14022, -0.6875, -0.56641, 0.71463, -2.182, 0.97206, 1.3799, 0.55703, 1.41, 1.0427, -0.7579, -1.1572,
        1.6309, -1.0275, -0.58505, -0.20485, -2.4631, -0.9918, -0.53683, -0.10941, -1.4311, -1.327, -1.4937, 0.55611, -0.25632, -1.6636, 0.73988, 1.898, -2.009, -0.8552, 0.28287, -1.7989, -1.3619, 0.12678, 1.3965, -2.0206, 0.52746,
        -2.3066, -1.6029, -0.61754, 1.7229, 0.67073, 1.6659, 2.6768, 1.2653, 0.67008, -1.1284, -1.0693, 1.164, 1.614, -2.7575, 0.47493, -0.57668, 1.3567, 0.073439, 0.49485, 0.41289, -0.24581, -1.462, 0.18591, -1.0024, -0.33939,
        -2.1308, 0.81552, -0.33116, -0.72757, -0.90473, -0.089867, -1.6486, -0.099509, -1.5741, -0.50866, -1.8929, 1.6468, 1.5413, -0.046811, -0.53459, 0.46658, 1.2359, -0.66536, -0.79578, -0.15953, -2.0791, -1.076, -0.1158, 2.172, -0.35911,
        -0.73684, -1.4825, 0.726, 1.2762, -1.1852, 0.54504, -1.4142, -2.0286, -2.8155, 1.6079, -0.84416, -1.3116, 0.59029, -0.54021, -0.005162, 0.0068913, -1.8482, 1.338, 0.70177, 0.81908, -0.1778, -0.8608, -0.53737, 1.4212, -1.7136,
        -0.4353, 1.1063, 0.18661, -1.592, 1.745, 0.7958, 1.0068, -1.0373, 1.3837, -2.1941, 1.6879, -1.6141, -0.90383, -1.3942, -0.20449, 1.4102, 0.92886, 1.225, -0.09438, -1.1484, 1.2998, -1.0661, -0.015538, -0.75842, -0.6645,
        -2.0208, 0.21313, 0.151, -0.92943, -0.39585, 2.3958, -0.68164, -1.4455, 2.4139, -0.57424, 0.54766, -0.57539, 1.3416, -1.2225, 1.2017, -0.99587, -1.6088, 1.5287, 1.108, -0.58478, -0.1169, -1.4056, -0.38645, 2.0179, -2.1973,
        -0.9154, -0.26935, -0.73901, -1.2895, 0.0081451, -1.014, -0.78892, -0.28777, 1.3885, 0.39527, -1.7319, 1.0688, -0.91022, -0.67894, 0.35809, 0.21719, -0.86934, -1.5294, 1.8819, -1.0481, -0.91898, -0.41366, -1.5676, 0.71734, 1.6641,
        1.643, -1.1069, 0.36342, 1.8086, 2.2139, 1.0981, -1.7961, -1.9001, -1.3816, -1.7724, 1.6339, -0.36094, -2.9218, 0.62633, -0.14622, -0.48764, -0.35708, 0.17152, 1.7226, 0.72209, -1.4603, 2.2786, -0.79736, 0.76079, -0.11209,
        -1.677, -0.74884, 1.0778, 1.4906, -1.2731, 0.27208, 0.3965, -1.0869, -0.0016805, -1.1832, 1.1619, 0.06244, 0.32653, 0.056084, 0.77334, 0.90436, 1.3887, 1.5527, 1.4131, 0.56247, -0.16603, 0.23401, 1.9612, 0.13587, 0.38894,
        -0.38761, -0.62298, 2.3505, -0.44988, 0.1562, 1.2363, -0.26328, -2.2154, 0.42905, -2.5947, -1.2681, -1.6574, -1.2825, -1.3252, -0.50331, -2.0672, -2.1395, 1.4461, 1.6265, 1.6285, -0.4695, -0.42894, -0.74093, -1.2538, 1.378,
        -1.2534, 0.66764, -0.79381, -0.26716, -1.2567, -0.89084, -2.2448, -0.73954, 0.60226, -0.58715, -0.73358, 1.7436, 0.96882, -1.4939, 1.1768, -0.94755, 1.9772, -1.6803, 1.1752, 0.79797, -1.1726, -0.40431, -0.43916, -2.306, -0.79548,
        -2.0178, -0.13385, -0.26662, -2.0181, 1.2811, -1.5233, 0.43445, -2.4113, -1.7072, -0.37648, -0.31322, -2.0364, 1.6382, 1.1339, 0.37056, 0.20253, -1.88, -2.2896, -0.62525, -1.3265, -1.5014, -1.0637, -2.2066, -1.9779, -0.59584,
        0.96404, -1.4826, 0.63258, 1.6272, 1.2706, 1.5981, 0.94417, 2.1495, 0.58891, 1.1256, 0.33691, -1.282, -0.2603, -1.546, 1.0184, 1.6493, -0.33561, 1.3058, 1.8086, -2.6916, 1.1736, -1.2875, -1.6246, 1.4438, -0.85716,
        -0.70715, 1.9292, 0.37484, -1.2289, 1.5134, -1.4596, -1.7292, 1.4486, 0.046179, 1.8254, 1.166, 1.7285, 0.73115, -1.1406, -0.5686, -1.3071, 1.6213, 1.5093, -0.22343, -1.9894, -1.9806, 1.3874, 0.86666, -1.3831, -1.0629,
        1.1841, 1.5379, -1.5616, 1.2053, -0.18342, 1.1576, -2.0506, 1.7991, -2.6182, 1.2152, -0.045138, 0.95669, 0.28819, 0.12568, 1.3748, -2.2356, 0.75467, 0.71959, 0.62663, -0.80267, -0.37728, -1.942, -0.73857, -1.1884, 1.0748,
        0.41919, 1.0249, -1.2949, -1.0514, -1.7297, 0.74433, 1.2688, 1.2449, -1.3775, -1.6366, 0.33797, 1.5519, 1.8289, -1.0988, -0.64954, -0.13752, 0.55469, 0.23549, -0.85569, -1.9817, -1.5828, -1.5425, -1.1467, 0.20893, 1.4064,
        -1.1759, -1.653, -1.1754, 0.5559, -0.77118, 1.271, -0.17442, 1.4928, -1.0774, -0.36255, -0.60864, -0.61592, 1.1308, -1.046, -1.4412, 0.022082, -0.97436, 0.64237, -0.2684, -0.76693, -0.85081, 1.6483, -1.021, 1.5158, 1.5691,
        0.98382, -0.898, 0.13423, 1.4323, 1.3537, 1.7217, 0.29167, -2.1585, 0.3592, 1.5833, -2.2, -0.98693, 1.0037, 0.52464, 0.40316, 1.6757, -0.37558, 1.1548, -0.42744, 0.69195, -1.1565, -1.3926, 1.3453, -1.147, 1.3701,
        0.90382, -1.4022, -1.1509, -1.6075, 1.239, 1.5432, 1.4312, 1.6283, 0.70538, 0.33445, 0.088438, -0.54454, 0.11774, 1.2623, -0.46034, -1.8917, 1.2111, -1.512, 1.7697, 0.47315, 0.14863, 1.6858, -0.72743, -0.043885, -0.94732,
        2.0056, -0.24537, 0.82044, -1.2037, -0.4718, -0.37565, -0.030299, -0.47466, -0.86933, -0.78674, 0.25849, -0.81593, -1.8786, 1.3031, 1.5108, 1.4878, -0.70962, -0.38787, 1.699, 1.0311, -1.1858, 0.36805, -0.87408, 1.5708, -0.82983,
        -1.983, 0.77242, -0.97969, -2.3111, 0.38835, -1.8109, 0.60488, 0.69348, 0.36995, 1.0386, -2.2049, 0.95979, 0.20576, 1.1618, -0.55542, 1.1998, 0.42037, -1.0964, 1.7869, -1.0127, 0.6222, 0.72263, -1.744, 1.8771, 1.6759,
        -1.3605, 1.672, -0.31034, -2.6089, 0.77767, -0.39396, -1.34, 0.86346, -0.36041, 1.2831, -0.71091, -0.23933, 0.78465, 0.37325, 1.2509, 1.8023, 1.4557, 0.75591, 0.38211, 0.12403, -1.8548, -0.10593, 0.0032975, 0.25611, 1.7284,
        -0.90049, 1.9134, 0.086436, 0.39638, -0.68123, -1.0176, 1.4042, 0.4983, 1.2566, -1.2485, 0.84132, 1.9302, 2.1128, 0.026247, 0.30405, -2.6525, -0.65398, 1.4854, -1.7066, -0.72853, -0.40017, 2.2487, -2.0201, -1.0841, -1.0311,
        -1.3019, -0.59866, 0.2214, 1.4038, 1.4963, -1.2251, 0.10948, 1.7812, 0.42427, 0.88751, 1.3123, 0.58527, 2.8656, 0.68736, -0.65149, -0.74822, -0.64692, 0.52339, -1.6149, -0.99051, -0.89724, 1.0848, 0.64248, -1.9942, -1.1015,
        -2.0131, -1.0419, -1.66, -1.1382, 2.1742, 0.34272, -1.476, 0.85003, -1.5299, -0.70159, -0.13137, 2.0908, 1.468, -0.40903, 0.56334, 1.9421, 0.84423, 0.077239, -1.8813, 1.5906, -0.19147, 0.034745, 0.49544, 0.22235, 1.067,
        1.2017, 0.61821, -0.91521, -0.18624, -0.43882, -1.4904, -1.8302, 0.63594, 0.50278, 1.2776, 2.1668, 0.86037, -1.4151, 1.0632, -0.5461, 0.83735, -1.5382, 1.8353, -0.90093, 0.79142, -0.44554, 0.6833, -0.98574, 0.28507, 0.92477,
        2.158, 1.3055, 1.337, 2.2471, 1.1361, 0.56746, 1.0288, 0.77982, -2.5355, -1.2517, 0.77454, -1.0992, -0.61335, -1.0794, 1.5766, 2.4984, 1.3977, -1.2459, 0.60642, 0.76426, -0.40528, -2.0331, -1.2791, 1.0518, 0.68472,
        -2.1776, 0.92011, 0.21138, 1.494, -0.11457, 0.62671, 0.54675, 0.94868, -0.81825, 2.0382, 1.4829, -1.5725, -0.47448, -1.5972, -2.0804, 0.55939, 1.0917, 1.235, 1.3499, 0.33113, -0.37475, 1.1478, 1.1112, 2.3251, -1.3667,
        1.1452, 0.24202, -0.92594, -0.85048, -0.74838, 1.3606, -0.34016, -1.882, 1.8941, -0.695, -1.8562, -1.1902, 1.5238, 1.1196, 0.95583, -0.88102, -0.61504, 1.1105, 1.6984, -0.53329, -1.0165, 1.2795, 0.90664, -0.27662, 0.7629,
        0.10629, -1.4756, -0.13994, 0.86441, 2.4952, -1.889, -0.81888, -0.039093, -1.7683, 0.094127, 0.047063, 1.2692, 0.70443, -3.0028, -1.4343, 0.26537, 0.080136, 3.2411, -0.4757, 1.7312, -1.4599, -1.2944, 0.18868, 0.62871, -1.0099,
        0.69609, -1.0519, -0.13392, -2.0799, 0.682, -0.75965, 0.64071, -1.8234, 2.1217, 1.1303, -1.0074, 2.2212, 1.4012, -0.28664, 1.7435, 0.90795, -1.4078, -0.53614, -0.88139, -1.2032, 0.76823, 0.57067, -0.69077, 1.2324, 0.62249,
        1.6283, -0.55167, 0.61999, -1.6657, 1.2996, 0.20409, 0.76205, 0.35753, -0.14927, -1.3045, 0.5237, 0.36488, 1.5762, 2.0981, -0.46896, -0.61556, 0.11687, 1.0727, 0.34468, 1.6225, -0.040605, -1.0862, -1.6138, 0.088861, 1.5432,
        1.4879, 0.23202, -0.081988, 1.4792, 2.2713, 0.086179, 1.4042, -0.019651, -2.4396, -0.86687, -0.52873, -0.53896, -0.54359, -0.91283, -0.8695, -1.2764, -0.98443, 1.3107, 1.1257, 1.3358, -1.0061, -1.459, -0.42906, 1.2343, -0.3074,
        1.3547, 1.3291, -0.55011, -2.2779, -0.24524, 1.6052, 0.54594, -1.3001, 1.1774, 0.47839, -0.66165, -1.6185, -2.1409, 1.254, -1.4238, 1.9348, -1.4657, -1.545, 2.4234, 0.12173, -0.48584, -1.5602, 0.69529, -2.5956, -0.94023,
        -1.5368, -1.0534, 2.8209, 1.5407, -1.1307, -1.3782, 1.2166, -0.98242, 1.0983, -2.0826, 0.50885, 0.88046, 0.67922, -1.0188, -1.5807, -1.0674, 1.0024, -0.97453, 1.3894, -0.24997, -1.3521, 1.8902, -1.2968, -1.4638, -0.76086,
        1.0109, -0.16286, 1.8, -1.6395, 2.992, 0.48939, 0.17778, -1.311, -0.45642, 0.75483, -1.6092, -1.2012, 0.73177, 0.89444, -0.48946, 0.76489, -1.1108, -2.0027, 1.0167, 0.082421, -1.5795, -0.77448, 1.5651, 1.3759, 0.85499,
        -1.1875, 0.42802, -1.6608, -0.57971, 1.0396, -0.99973, 1.4469, 0.69468, -0.01214, -1.1419, -0.64866, 1.0476, -0.012179, -0.016921, -0.52686, -0.69284, -1.5502, -0.42884, -1.4249, -1.5353, -0.36154, -1.7105, -0.90695, -0.84417, 2.1972,
        -0.13021, -1.2556, -1.3744, -0.53877, 1.5361, -1.299, -0.78544, 0.44716, 1.7742, 0.27242, 1.0373, -0.93174, 1.0991, 0.64757, 1.3236, 1.6865, -0.29721, -0.59633, 1.2686, 0.7936, -0.76763, 1.4338, 2.056, -1.5429, 1.9549,
        1.2948, 2.3494, -0.058804, -0.95722, -2.4478, -0.6507, -0.053714, -0.89145, 0.070057, 1.4694, -1.3703, 1.1252, 2.1913, -0.74377, -0.32019, 0.094334, -0.54601, -1.9697, -0.85397, 0.017912, -1.6663, 0.65342, 1.5149, 1.3136, -0.7879,
        0.72398, 1.295, 0.77934, 1.1631, 0.12397, -0.59474, -1.1392, 0.15082, -1.1119, -1.1154, 0.90477, -1.0109, 1.8388, -0.90694, 1.1557, 0.32458, -0.022763, -0.53386, -1.469, -0.14606, -1.3617, -1.3507, 1.1514, -0.93154, 1.1233,
        -2.1, -0.36152, 1.2239, 0.062524, -0.27975, -1.233, 1.2171, -0.9418, -1.1018, 0.36135, 1.5237, -0.96773, 0.74439, 1.5931, 0.15167, -0.27907, 1.2329, 1.2141, -0.88478, -1.0414, 0.25157, 0.86022, 1.497, 1.2072, 0.44703,
        -0.16596, 1.078, 0.71345, -1.0582, -0.20293, -1.2861, 0.48674, -1.6403, -0.93799, 0.65889, 0.42531, -2.0511, 1.5928, -1.2283, 0.86517, -0.70339, -0.45225, -1.8765, 1.0363, -0.76307, 0.092044, 0.56871, 0.48043, -2.083, -1.3986,
        0.58541, -0.89986, 0.84502, -0.93633, -1.0101, -0.71425, -1.3079, -0.40363, 0.37035, -0.15624, -1.282, 0.13986, 1.3435, 1.2902, 1.127, 2.1544, -0.68617, 1.0408, 1.8209, -1.0238, 1.3439, 0.81698, -1.1583, -2.0302, 1.2699,
        1.6523, 0.13691, -0.70384, -0.52752, -2.3332, 1.3515, -2.4205, -1.3325, -0.48334, -0.34794, -0.98522, -0.73594, 0.1264, -0.84707, -2.3315, -0.86653, 2.2786, -1.1156, -1.8171, 1.0539, 0.12091, -0.79314, -0.3567, -1.8433, -0.96438,
        1.9416, 2.5331, 1.1259, -0.60665, -1.5897, 1.5803, 1.3763, 1.4648, 2.012, -1.2695, 1.3857, 0.28786, -0.95027, 2.8706, 0.39378, -1.2648, 1.1827, -1.294, 1.564, -1.525, 1.2321, -1.2366, -0.70639, -0.1604, -0.010876,
        -1.5738, -1.5074, -0.41031, -0.85562, -0.079486, 1.2321, 2.2753, 0.31548, -0.20319, -1.4544, -2.0976, 1.0394, -0.12454, 0.60137, 0.76573, -2.0236, 0.34381, -0.21587, -0.72268, -0.09603, 1.8955, 0.030038, -0.73844, 1.3737, -1.1023,
        -1.7527, -0.6148, 0.93077, -0.25195, 1.5512, -0.66399, -1.4554, -0.27266, -0.90328, -0.83851, 0.71181, 1.1777, 0.85422, -0.58505, 1.0322, -1.5919, 0.020575, 1.764, 1.0011, 1.6609, -1.5146, -0.015621, 0.75959, -1.9345, 2.1619,
        1.0423, -0.99581, -0.78702, -0.81934, -0.7005, 0.6393, -1.0673, -2.0759, 1.1216, -1.2992, 1.3587, -1.6919, 1.3663, -0.56295, 1.6058, -1.5885, -0.64337, 1.6943, 1.1949, -1.2295, 1.0651, -1.4556, -0.80438, -0.63307, -0.78113,
        -1.7533, 1.6647, -1.0548, 0.079863, 0.82323, -0.72963, 1.3321, 1.8024, 2.2165, -0.013958, 1.1137, -1.0691, 0.17988, 0.52376, 1.3405, -1.5386, 1.3281, -0.71427, -1.0492, 1.2422, -2.6223, 0.96348, 1.3427, -2.4009, -2.0258,
        1.2068, 0.15716, -0.42453, 0.98144, -0.675, -1.1175, 0.91139, -1.0814, 0.10502, -1.118, 1.3444, 0.88985, -1.1601, 0.15809, -0.20946, 0.47716, -0.93312, -1.2703, -0.18391, -2.6321, 0.43958, 0.1724, 0.47839, -1.5368, -0.68127,
        0.1347, -0.626, -0.84738, -1.0669, 1.8897, -1.6883, 0.84114, -1.2966, 0.35698, 1.9354, -1.4469, -0.56528, -0.66407, -1.3689, 1.297, -0.83044, 0.16842, -0.11, 1.9152, 1.9173, -1.7738, 0.21943, 0.17472, -1.3923, -0.82026,
        1.2399, 1.7443, 1.6002, -1.753, -0.89907, -2.8281, 0.45484, -0.6823, -1.9546, -1.515, 0.72679, 0.36806, -1.7134, 0.40787, 1.8446, -1.1072, -0.39204, -2.0586, -0.36467, -1.6044, 1.6638, -1.441, -1.0347, 1.7276, -0.6446,
        -0.71759, 0.26942, 0.10157, 1.5675, 1.331, 1.1622, 0.19819, 1.4321, 1.7244, -0.97683, -0.26124, -1.2788, -2.5847, -1.1602, -0.64964, -1.5121, 0.0088704, -1.4738, 1.3691, -1.968, -0.18227, -0.062375, 0.82659, 1.5437, 0.34381,
        -1.335, 0.6819, 1.2044, -1.6981, -0.3933, -1.2922, 0.69871, -0.090377, -0.6244, -0.18589, 0.6457, 1.7508, -0.84414, -2.1784, 1.1443, 1.1362, 0.37886, 0.55637, -1.1578, 0.44354, 0.94287, -1.3746, -2.5781, 0.9565, -0.76835,
        1.2982, 0.77423, 1.1476, 1.2418, -1.8125, 0.79165, 2.2449, 1.4833, 1.903, 0.34525, -0.52372, 0.85656, 0.95395, -1.0637, -0.31399, 1.4573, 0.33903, 1.0187, -2.0011, -1.5864, 1.4495, 0.40966, 0.51156, -1.2104, -0.32609,
        -0.40898, -1.7215, -1.3131, 1.6734, -1.1616, 2.1488, 1.8176, 0.48915, -0.05998, -2.3662, 0.12149, 0.061543, -1.7209, -1.6824, 0.28037, -0.99461, -0.99327, 0.80434, 0.66074, -0.99246, 1.3253, 2.02, 0.60155, 1.1132, -1.211,
        2.0488, 1.9373, -0.93988, 0.77191, -1.1528, -0.32126, -2.1823, -1.5199, 0.68314, 2.3029, -0.71885, -1.2015, -1.5105, -2.348, -0.6343, 1.2213, -1.9685, -0.86706, -0.8389, 1.8036, -0.92105, -1.3005, -1.4773, -0.27976, -0.68366,
        -1.7463, 0.51576, -0.11573, -0.12605, 0.97803, -1.9744, -0.73354, -0.41985, 1.897, -1.3279, 0.97146, -1.0237, 1.2622, 1.0862, 1.0645, -0.59947, -0.62056, 1.622, 0.31436, 0.39151, 1.0941, -0.26805, -1.2212, -0.85847, 0.60176,
        1.0245, -0.48609, -2.0947, 1.5904, 1.2891, 0.61225, 0.67361, -0.038595, 0.63746, 1.8813, -1.7683, 0.82791, 0.2203, 1.9224, -0.29889, 1.3095, 1.2439, -1.1882, -1.835, 0.98794, 0.35365, -0.47423, -2.213, 2.2458, -1.2846,
        -0.81551, 0.88506, 1.7933, 1.0303, 1.8215, -0.43265, -1.8629, -1.9596, 0.76304, 0.32567, -0.54217, -2.1821, -1.3189, 0.68417, 1.8296, 1.3263, -2.9307, -1.6887, 0.78796, -1.3032, 1.4378, 1.1191, -1.6245, 0.10909, -0.53985,
        1.4511, 1.4078, -0.76287, -1.074, 1.1399, 2.0423, 0.83237, 0.45549, -0.71153, 0.54129, -1.4725, -1.0594, -2.388, -0.18281, -0.18578, -3.2302, -0.20973, 0.62999, 0.60839, -2.5858, -0.32441, 0.46994, -0.80692, -0.87098, -0.067356,
        -0.45542, 1.4774, 0.73062, -0.84123, -1.9225, 0.40445, 1.7729, -0.45036, -1.1049, -1.0025, -0.76032, -1.1782, 1.8081, -0.55338, -0.2012, 1.4623, -0.41712, -0.13683, -1.5615, 0.32699, 0.46574, 1.2007, 1.7079, -1.1167, -0.40777,
        -1.5718, -1.0634, 0.8519, 0.2908, -2.1435, -2.9042, 1.1707, 1.3913, 1.2708, -1.8529, -1.5108, 1.6406, -1.6705, -3.0886, -1.4178, 0.41375, 1.3953, -1.2176, -0.65128, 0.82067, 0.94495, -0.51093, 1.2575, 1.7089, 0.037235,
        1.1578, -0.019829, 0.42574, -1.0739, -0.69066, -0.54721, -0.60356, -0.098558, 0.44819, 0.58198, 1.7257, -1.5189, 1.7683, 1.8744, 1.5325, 1.0196, -1.0003, 0.36771, -0.63817, -1.6112, 1.4219, 0.95915, 0.80125, -1.3407, 0.79683,
        -1.8999, -2.2686, -0.58629, -0.79554, -0.1574, -1.7512, 1.5795, 0.67791, -1.349, -0.31076, 1.5872, -0.49162, -0.90663, 1.3546, -2.229, -0.17711, 1.4906, 0.88843, -0.64135, 0.43638, 1.827, 2.1391, 0.78867, -0.23258, 1.6105,
        -1.1002, 0.53774, 1.0324, 0.89174, 0.14227, -1.9826, -1.4335, 1.2953, 1.2995, 0.31277, 0.48668, 0.87234, 0.27531, -1.4812, 1.688, 1.8766, 0.10467, 1.5752, 1.7818, 1.5944, -1.6919, 0.027481, 1.5374, 0.34868, 2.2941,
        -0.021174, 1.4911, -1.3889, 0.93175, 1.7478, 0.86819, -1.2136, 2.2931, 1.4638, -2.3545, 0.15968, -1.8211, -1.2341, -0.65017, -0.36776, 1.6313, 1.0316, -0.6518, 0.2859, 1.1643, -1.4926, 0.92573, 0.63045, 1.0388, -1.0965,
        1.0026, -0.39297, -0.64331, -2.5834, 0.82936, 0.052389, 1.0625, -1.0945, -0.036159, -2.0623, 2.2799, -0.81314, 0.67256, 0.42272, -1.2701, 1.8813, 0.057388, 1.2188, 1.2901, 0.9928, -2.2119, 1.9466, 0.35238, -0.73426, -0.1728,
        2.2103, -0.59705, -1.1633, 1.2013, -0.74156, -0.97077, 0.20981, -1.0681, -1.8852, 1.6882, 1.6236, -1.0256, 1.194, 0.93079, 0.28782, 1.2173, -1.0871, 1.2936, -2.1692, -1.4519, 2.2967, 0.35105, -0.83696, 0.0015256, -0.015453,
        1.3446, 1.3683, 0.50759, -0.071679, 0.58733, -1.4175, -0.10163, -1.1856, 1.1356, 0.87484, 1.3476, 0.75746, 0.10273, -0.23705, -1.2789, 0.33475, -0.83348, 1.2483, -0.30024, 1.1203, -0.37882, 0.43659, -0.70267, 0.63714, 1.0631,
        -0.46314, -2.6251, 0.35172, -0.49331, -0.97743, 2.0997, -1.0131, 0.87166, -0.8946, -0.41752, 0.53152, -0.13464, -1.1995, -1.511, -0.62293, 1.4231, 1.8045, -1.0986, -0.89795, -1.7402, -1.3173, -2.4431, -0.0050147, -1.5177, 1.3907,
        -0.53202, -0.83034, -0.49181, -0.72889, -1.5338, -1.3683, 1.4885, 1.1619, 0.78998, 0.0061223, 0.40029, 1.8776, 0.29248, -1.1375, -0.34278, -1.6821, -0.3979, 0.227, -0.40363, -0.98332, -0.99614, -1.7731, 0.94749, 0.64174, 1.4872,
        0.57531, 1.074, -0.75425, 1.1827, 0.36616, -1.4536, -1.4074, 0.15034, -0.44969, -1.7066, -0.81647, -0.92069, 1.0658, -1.1124, 0.53735, 0.15271, -1.2218, 0.17933, 0.43094, -0.34016, -1.0211, 0.12517, 2.5688, 1.0574, -0.36424,
        1.0178, -0.53273, 1.5037, -0.44264, -0.22729, 0.48304, 1.3174, 1.088, 1.3802, -0.70811, -0.3122, -2.4372, -0.052384, -0.2319, -1.6541, 0.9832, -1.4155, 1.2914, 0.6508, 0.48781, -0.75449, -0.67263, -0.3615, -1.8428, -0.1233,
        -0.22643, 2.4423, 1.207, 0.57795, -1.4244, -0.65703, 1.0078, 0.7591, 0.70524, 1.7592, -0.78326, 1.2229, 2.8001, -0.25611, 0.8208, -0.25246, -0.48331, 1.2648, 2.9291, 0.22713, 1.1025, -1.5048, -0.67403, 2.0325, 0.5593,
        -0.7985, -0.061327, 1.5998, -1.1389, -0.060231, -2.4163, 1.9767, 0.51343, -0.239, -1.8593, -1.1174, 0.13551, 0.2234, -1.2223, -0.79551, 0.80122, 1.1452, 1.9185, -1.0146, 1.0364, -1.6004, -1.4935, 1.2017, -0.062004, 0.26483,
        -2.0011, 1.6685, 0.35439, -1.03, -0.87087, 0.95906, -0.48718, -0.40631, 0.43357, 0.80128, -1.6329, 0.55248, -2.2972, 1.2801, 0.71206, 0.67927, -1.0167, 1.7057, 1.2836, 0.6289, 0.84673, -2.0258, 0.2321, 0.52978, -2.3893,
        1.8387, -1.4532, -0.72099, 0.82183, 1.6615, 0.72055, 0.7855, -1.0061, 0.47279, -0.40423, 1.0558, 2.6881, 1.895, -1.1124, -1.7008, 0.22238, 1.0555, -0.50337, -0.32093, 0.61759, 1.0231, -0.3717, 1.5693, 1.6935, 0.073928,
        0.031951, 0.19013, 1.898, -0.0037941, -0.83559, 1.4633, 1.6593, 0.34688, 1.6202, 1.7028, 0.59965, 0.78925, 0.025806, -0.75884, -2.1799, 2.1225, 1.1013, -0.15445, -1.1042, -0.024777, -1.676, 0.079867, -0.23357, -1.7986, 0.47134,
        0.87371, 1.5466, 1.1291, -1.1001, -2.21, -0.56797, 0.78151, -1.0331, 0.1439, 1.1021, 1.6373, -0.55107, 2.428, 2.1642, -1.6428, -1.0537, -0.99148, 0.16389, 0.90608, 0.60168, 1.1786, -0.92816, -0.32974, 1.0837, -1.0759,
        0.82264, -0.95284, 1.3067, 1.0094, 0.21411, 0.84802, 0.69798, -2.2192, 1.6565, 0.90526, 1.189, 0.25043, 0.89866, -0.28302, 1.744, -0.20891, 1.6203, -0.3044, 1.1877, -1.3768, 0.33583, 1.9219, -0.36687, 0.062023, -0.72837,
        0.84529, 1.7487, 0.98664, 1.9238, 1.2787, -1.5034, -1.4737, 0.9419, -1.6365, 1.113, 0.71102, 0.62528, 1.0885, 1.2049, -0.59733, 0.19908, 2.5345, -1.2419, 1.8371, -1.7402, 2.4892, -0.063213, 1.0927, -1.227, 0.52577,
        0.86053, 0.057353, 1.3181, -2.1655, -0.8332, -0.2574, -1.4894, 0.19555, -1.8246, 0.90562, -0.58845, 0.17941, 0.84699, -1.8188, 1.7482, -2.514, -1.2297, 0.91867, 0.163, -0.26183, 0.99968, -0.32354, 2.292, -0.95335, -0.054991,
        1.9839, -1.9577, 1.2676, 1.0548, -0.93839, -1.3291, 0.83539, -1.9668, 2.5847, -1.6495, -0.45476, 1.507, 1.2762, 0.42205, 0.75187, -2.4012, 0.79198, -2.5041, -0.30132, 1.1239, 0.19352, 1.5255, -0.24774, 1.4229, 1.8464,
        0.76818, -1.2906, -1.392, 0.33856, -0.50054, 0.74569, 0.071514, 1.4621, 0.54791, -0.11702, 0.62669, 1.2564, 0.38652, 1.8136, -1.6091, -0.75157, 0.18521, -1.1707, -0.033955, 0.36524, 0.080529, 1.4375, 1.9849, 0.57858, -0.47249,
        1.2086, -1.7315, -0.62103, 1.5408, 0.66276, -1.239, 1.2088, -1.559, 0.82645, 0.87717, 2.7342, 1.0639, 1.0568, -0.70567, 0.13823, 1.877, 1.2842, -0.39832, -1.7539, -2.9514, -1.2447, 1.6263, -1.6891, -0.52616, -1.3333,
        0.6651, 1.2913, -0.82142, 0.86508, -0.61113, -0.1825, 1.4285, 2.5524, -1.2345, -0.61031, 0.48914, 1.6339, 0.17877, -0.34659, -1.8504, 0.64, -0.72967, 1.2647, -0.86252, -0.26715, 2.0261, 1.1636, 2.0758, 0.51509, 0.99389,
        -0.63749, -1.2663, 1.121, -1.3169, 1.6079, 2.9079, 0.5605, -0.98832, 1.1375, 1.5605, -0.75217, -0.72892, 0.62959, 1.095, 0.50391, 0.26976, 1.0707, 1.451, -0.68308, 0.72657, -0.37783, -0.026172, -1.2894, 1.1134, -0.70883,
        -0.65492, 0.099979, 1.1575, 0.82015, 0.56486, -1.2235, -1.1763, 1.0367, 1.1178, 2.0142, 0.32978, 1.3917, -0.25998, 0.89927, 0.4426, -0.70601, 0.58412, 0.2555, -1.3116, -0.86286, -1.9415, -1.0845, 1.7565, -1.6158, 1.4821,
        -0.61935, -1.4194, 0.30747, 0.59186, 0.75313, 1.847, 0.49539, 0.29074, 2.6249, -1.7775, 0.63803, -0.46106, -2.1546, 0.57115, 0.43329, 1.2479, 2.1076, -0.85909, 1.3347, -2.4282, -0.27762, -0.5372, -1.4716, 0.19892, 1.2849,
        -0.9765, -0.54968, -2.3086, 0.8082, -1.0405, 1.4294, -0.010546, -0.18885, 0.51016, 1.2446, 1.1329, 2.8944, 1.1093, -0.63214, -0.031151, -0.8871, 2.2016, -1.1155, 0.81448, 0.0063057, -0.58536, 1.2038, -0.65316, 0.90805, 0.070703,
        -0.90565, -0.022047, -0.45375, 0.82045, -0.43461, -0.31303, -0.422, 0.18428, 0.99746, 0.12757, -1.0444, 2.6336, 1.6986, 1.3646, 0.47147, 0.52492, 1.4106, -1.9484, -0.14971, -0.87735, -0.98694, 0.42633, -1.0622, 0.33507, -0.35523,
        1.166, -1.8474, 0.80597, 0.095022, -0.62085, -1.6737, -0.66222, 1.018, -0.014963, -1.0988, -0.58387, 0.24833, -2.4803, 0.43785, -0.1876, -0.3737, 0.53345, 1.0214, -1.8732, -1.3819, 1.6511, -1.3969, 1.6712, 1.1986, -1.6253,
        -1.1688, -0.83548, -1.555, 1.8955, 0.42589, -0.52831, -0.63588, 1.1711, -2.1372, -2.1199, 2.3177, -0.51655, 1.7812, -0.31993, 2.5201, -0.48124, -0.54356, 1.3044, -1.5337, 1.3154, -0.035221, 0.6452, 1.186, 0.79013, 2.0048,
        0.0067789, 1.0976, 0.41503, -1.8406, -1.0178, 1.2257, 1.2174, -0.65046, 0.87518, 0.18765, 0.62794, -2.0003, 1.06, 1.4004, 1.3075, -1.657, 0.81663, -0.28334, 1.3876, 1.3742, 0.80437, 0.84341, 0.88514, -2.6697, -1.1467,
        1.3602, 0.81282, 1.4445, -1.3526, -0.91497, 0.35602, -1.1781, -0.91441, 1.6475, 0.33749, 3.2173, -0.029311, -1.1612, -1.4109, -0.68219, 0.88518, 0.044192, 1.3546, -0.60044, -1.085, 0.93324, -0.62157, 0.4908, -0.84676, -2.4068,
        1.0628, 1.3053, -0.17756, -0.12382, -1.5937, -2.0473, 0.68293, -0.47175, -1.2095, 0.52623, -0.8581, -0.56503, 1.9054, 1.5036, 1.4077, -1.4053, -0.11422, 0.66016, -1.3939, -0.037931, -0.45504, 0.52816, -1.6787, 0.79148, 0.40999,
        -1.4386, -1.3696, 0.33002, 0.74752, -1.1301, 0.37957, 0.76615, 0.39866, -0.82564, 0.96917, -1.7811, -0.71749, 0.29757, 0.34806, 0.83436, 1.6564, -0.57051, 0.37367, 0.28641, 1.3083, -0.53316, 1.1007, -1.7745, -0.19247, 0.86476,
        -0.666, 1.0843, -1.5684, 1.7265, 0.95661, 0.99082, 0.42998, -0.33396, 1.1459, 0.8542, -0.056242, 0.88074, -1.7245, -1.5458, 3.3296, 1.7055, 0.040085, 0.84354, 1.2271, 1.0709, -1.8821, -1.4224, -0.393, -1.3539, 1.6146,
        1.4169, 0.93062, -1.3398, 0.00023705, 0.89133, 0.3959, 0.77807, -0.9053, 1.0719, -2.0822, 0.81441, 0.41755, -1.4459, -2.2167, -0.75222, 0.85123, 1.0994, 1.3047, 0.34426, -0.93953, 1.7486, -1.5266, -0.18478, 0.89203, 0.7071,
        -0.94122, -0.81635, -1.0068, -1.8339, 0.7854, 0.38458, -2.3641, -0.5197, 2.7506, -0.83911, 0.99478, -0.41771, 1.5603, -0.61198, 1.63, -2.4255, 0.66586, 1.793, -0.98997, 0.88066, 1.9318, 1.1175, 0.72318, -0.84157, 1.5259,
        0.35679, -1.4053, -0.033393, 1.2504, -1.7286, -1.3318, 1.2734, 0.7481, 1.0822, -0.37934, -1.4825, 1.6995, 1.4272, -1.0064, -1.5087, 1.3842, 0.36538, -0.99807, -1.7663, -0.98048, 0.68589, -1.8642, 0.79815, -1.8714, 1.6466,
        1.6847, -0.057698, 0.98001, 0.74709, -1.3664, -1.3911, 0.59774, 0.88645, -1.2543, 0.69789, 0.84323, -0.18234, 1.8714, -0.68634, 1.2379, 0.84899, 1.5546, -0.71583, -0.27019, -0.73525, 0.99105, 1.2574, 1.6563, -0.47984, 1.6296,
        -0.72729, -1.1426, 0.77313, 0.2081, 1.8204, 1.2391, 0.88036, 0.1743, -1.1546, 1.6773, 1.0621, 0.46604, -0.69601, 0.82071, -0.23364, 0.86036, -1.6871, 2.2845, -1.2093, -0.41438, -1.4298, 1.7502, -0.95226, 0.90185, -1.1916,
        1.2651, 1.2887, -0.46531, -0.13183, 0.30704, -0.37514, 0.37869, 1.7839, -2.5583, -1.1036, -1.263, 1.3022, 0.27345, 0.34723, -0.99798, -1.2285, -0.65874, 1.0319, 2.2964, 0.13447, -0.97866, 0.47805, -0.8533, -0.6439, 1.1406,
        -1.3955, 0.70747, -0.31279, -1.5519, 1.4284, 0.88127, -0.6749, -2.2057, -1.2047, -0.72597, -1.4265, -1.0797, 0.64889, 0.4281, 1.7088, 0.80146, -1.5723, 1.9777, -1.2419, 0.95168, -2.0742, -0.18604, 1.3516, -1.0999, 0.9522,
        -1.0339, -0.69608, 1.3531, -1.8811, -0.29968, -0.75104, 1.3028, 0.55657, 0.75191, 1.7593, -0.85451, 1.4877, 0.0080439, -0.74194, -0.058415, 1.1305, -1.0381, 1.0011, 2.4378, -0.45079, 1.0713, -0.77847, -1.2005, 2.6973, -0.77987,
        0.90704, -2.1492, 0.64937, 0.19894, 0.84719, -1.3665, 0.14755, -1.5441, -0.46695, -0.14756, 1.307, -0.97868, 1.2036, -1.3745, 1.6024, 1.2572, -0.36799, -0.36585, 0.3839, 0.68747, 1.8248, -0.39388, 0.95888, 0.69931, -0.19024,
        1.4236, 1.5635, -1.2069, 0.44454, 1.4646, -0.62575, 0.28046, -2.6689, -0.41839, 1.3029, -0.3526, -0.80615, -1.0475, 0.42877, 1.1034, 1.3002, 1.556, 0.13598, -2.1624, 0.99593, 0.38551, -1.793, -1.423, 1.6214, 0.48687,
        0.28353, 1.3136, -0.78841, 1.7965, 0.95949, -0.4944, 1.3928, -0.23867, -0.22404, 0.56506, 1.4712, -0.86275, 1.361, -2.4711, -1.1192, -0.0039001, -1.551, -1.705, 0.63758, 1.1655, 0.23717, 1.2953, 1.6683, -0.77242, -1.5422,
        -0.57195, 2.0568, -1.1854, 0.63865, -0.9485, -0.8968, -0.6414, 1.1059, -2.1621, 0.8723, -0.87777, 0.473, -0.57369, -1.4537, -2.056, -1.3937, 0.50609, 0.46072, -0.20336, 0.76274, -0.86816, -2.0265, 0.85825, 1.7251, 1.0682,
        -0.07078, -0.4387, 0.88383, 0.79177, 0.87971, 0.51828, 0.57853, 1.0952, 0.06216, 0.22606, 1.2337, -0.031875, 1.1086, -0.38016, 1.968, 0.60879, -2.1252, 1.8926, -2.2797, 1.337, 2.1737, -1.1203, 0.67588, -1.6738, -0.027132,
        -0.088807, 1.0611, -0.97211, 1.1581, 2.1962, 0.69717, 1.0339, 0.6139, -0.31074, 0.55515, 0.80491, 1.5412, 1.4937, 1.9932, -1.8594, -1.0054, -0.20458, 2.4431, -0.3197, 0.96459, -0.16689, 1.5535, -1.2815, 1.5367, 0.93958,
        0.67997, -0.95928, 1.5786, -0.73263, -1.1052, 1.3889, -1.0343, -0.45547, 1.596, -2.1848, 0.3428, 0.13346, -0.40272, -1.6282, 1.3103, -0.32503, -1.0533, -0.74952, -1.0257, 0.079971, -0.96074, 0.70211, -1.3501, -1.0413, 1.6638,
        -0.62252, 0.44594, 0.98497, 0.45569, 0.10599, 2.0039, -0.20059, -1.2122, -0.48717, 1.0419, 0.011711, 1.3214, 1.5754, -1.0371, 0.94809, -0.9897, -1.0945, -1.0115, -0.21741, 1.4627, 0.65818, 1.4556, 1.6042, 0.72549, 1.6763,
        -2.79, 0.97003, -1.2571, -1.9851, -0.48077, 0.96711, -0.064192, 1.4109, -0.18596, 1.3443, -0.011231, 1.4557, -0.5932, 2.0743, -1.6741, 0.35968, -2.2956, 0.48913, 0.88507, 1.4269, 1.8213, 2.2231, 1.2157, -0.6824, -2.6098,
        1.036, 1.4948, 0.19266, -0.043413, -0.32596, -0.52643, -1.6982, 1.6737, -0.84076, 1.7408, -0.483, -1.3258, 1.1591, -0.75583, 1.0768, 0.5574, 1.0018, -1.467, 2.0648, -1.2228, -1.3345, 1.0147, 1.0867, -0.28841, -0.263,
        1.5204, -0.05042, -0.10991, -1.6389, -0.49868, 1.5195, -0.9573, -0.70235, 0.43426, -1.104, -0.099996, 1.1081, -1.9619, 0.24924, -1.441, 1.307, 1.0191, 0.8993, -1.5991, -1.1122, 0.74166, -0.23114, 2.0715, 1.8688, 0.23584,
        0.7359, 1.991, 0.043521, -1.8412, -1.1484, 1.2257, -1.6548, -0.12367, -0.65889, -1.7477, -0.3395, 0.26266, -1.0392, -1.0872, 0.27466, 1.5922, 2.5378, 1.4941, -0.53849, -1.1546, -0.64566, -0.39569, 0.73223, 0.98594, -0.95062,
        -1.6915, 2.5591, 1.6981, 0.35872, 0.20481, -0.88219, -0.76171, -0.45979, -1.2286, -0.12865, 0.030269, 2.1279, 0.73856, 0.54779, 0.46614, 1.0132, -1.396, -0.78736, -0.20646, -0.096206, 0.90057, -0.76246, -0.86105, 0.8762, 2.5099,
        1.1033, -0.29368, -1.7934, 0.7441, -1.0957, -0.53623, 0.95385, 1.5245, 0.34843, 0.39501, -2.0055, 0.59982, 1.4758, -0.22093, 1.387, 0.3278, -0.97451, 1.6273, -0.80839, -0.7313, -1.3951, 1.2382, -1.5591, -0.73728, -0.45376,
        1.0098, -2.1748, 1.9511, 0.97422, 1.1021, 1.3462, -1.7274, -1.0995, 0.54882, 0.51799, -1.2831, -0.68113, -0.52273, -0.94588, -0.83025, 1.2286, 2.8605, -2.245, 0.2544, -0.52563, -0.089752, 0.80651, 0.96361, -1.7133, 0.63235,
        -0.78121, 0.68415, -0.69697, -0.56246, -1.5414, 2.1368, -0.68921, -0.29182, 0.71571, -1.8355, 1.0294, 1.8012, 0.30524, -0.40844, 0.2219, 0.70924, 1.0614, -2.1116, -0.88149, -0.12272, -0.68085, 0.31402, -2.0573, -0.57316, -1.5829,
        1.5195, -1.7422, -0.8848, 1.7396, -0.46866, 0.62438, -2.3012, -1.0909, -1.6884, 1.0122, 2.2001, 0.84943, -2.4568, 2.1063, 1.469, -1.3452, 2.3821, 1.0443, 1.1432, 0.11455, 0.0012331, -0.043266, 0.5654, 0.66638, -1.5631,
        -1.3265, -0.41828, -1.4782, 0.071851, 1.331, 0.1643, -0.1459, -1.7044, 0.74346, 0.19436, 0.73491, -2.3458, 0.51527, -1.4252, -0.376, 1.255, -1.6515, 0.76729, 1.4064, 0.32167, -0.52815, 0.89291, -0.27462, 1.2542, 0.99645,
        1.2852, -0.0392, -1.8903, 1.4171, 1.4532, 0.18469, -0.2243, 1.0437, 1.9346, -0.069462, -0.32299, 0.99971, -1.0007, -2.1147, -1.9549, 0.46426, 1.2512, 0.13289, -0.12611, -0.73408, 0.4083, 0.96736, -1.6522, 1.0688, -0.263,
        0.95741, 0.55709, -0.76379, 1.7083, -0.096521, -0.3056, -1.0525, -2.2577, 0.34279, -2.3781, -1.9743, -1.006, 1.1548, 2.1259, -1.0026, 1.5973, 0.63772, -1.1878, -1.2767, 1.4189, 1.543, -0.72566, 2.2823, 0.53476, -2.0599,
        -1.1512, -1.1879, -0.0095894, -1.3839, -1.1393, 0.25169, 0.5954, 1.9562, -0.26233, -0.00036735, -0.67002, 0.35101, 0.12401, 1.0464, -0.33837, 1.4671, -0.35378, -0.79392, -0.052392, 1.0642, -0.71431, 1.1882, 0.7256, 2.1106, -1.6379,
        -0.21996, 0.46623, -1.8911, -1.5592, -1.556, -1.2506, -1.4714, -0.35538, 0.68743, 0.22641, 1.1231, 1.2178, 0.1975, 1.2331, -2.1454, -2.0224, 1.4472, -0.67845, -2.1913, -1.3449, -0.50383, 1.3288, 2.0115, 1.022, 0.43756,
        1.3719, -1.2737, 1.3457, 1.5179, 2.0156, 1.258, 0.52803, 0.64825, 1.848, 1.0116, -0.62212, 0.2622, -0.46478, -0.64327, -1.1284, 1.1518, -1.3092, -1.743, 0.50181, -1.4404, -0.62974, -0.21844, -0.42853, 1.124, -0.50161,
        0.45691, 1.3904, 0.38257, 0.46877, 1.6228, 0.36834, -1.0014, -0.43474, -1.2788, -0.19574, -1.7701, 1.6855, -0.34099, -1.9116, -1.8768, 0.45752, -0.95638, 1.8502, -0.57384, 0.092488, 0.3003, 1.0746, 1.0039, 1.3194, -0.6267,
        -0.57884, -0.95098, -1.5867, -0.54917, -2.1203, -0.36914, -0.66651, -0.12678, -0.85812, 1.2695, -0.045949, -0.56621, -0.042648, 1.1569, 1.9928, 1.0589, -1.2167, 1.3859, -1.0384, 1.3348, -0.32163, -1.2398, -0.53333, -1.6235, 0.30179,
        -1.9045, 0.26117, -1.1545, 0.010285, 1.3771, -0.69726, -0.77051, 0.091873, -1.3907, -0.99633, -1.307, -0.15907, -0.94526, 1.4238, 0.59933, 1.1613, 1.3615, -0.85782, -0.30042, -1.1082, 0.68692, -0.53947, 0.16626, -0.07779, 1.6446,
        -1.1051, -0.46162, 0.43135, -2.6569, -0.64371, -0.46286, -1.2201, 1.3187, -0.95241, 1.6876, 0.82156, 0.62542, -0.58733, -1.9078, 1.2426, -0.33132, -0.4648, -1.7961, -0.7628, -1.1016, 0.049394, -1.6404, -0.70544, -1.7378, 0.12058,
        -0.99383, 2.0625, 0.29365, -0.69427, 1.5493, -0.32804, 0.05172, 0.61447, 1.0439, -0.19844, 0.92425, -2.2531, 0.80525, 0.57613, 1.601, 0.111, 0.5171, 0.80169, 0.55062, -0.9276, -2.0722, -1.1859, 1.4092, 1.5798, -0.51658,
        -1.8789, 0.92518, 0.30365, 0.22011, -2.8158, -1.9443, 1.5308, 0.45484, 0.11758, -1.392, -1.5385, -1.0402, -0.34358, 1.8375, -2.0644, 0.60279, 0.3085, -0.54444, 1.8191, -0.49526, -1.0985, -0.20654, -1.679, 0.73074, -0.4095,
        -0.9378, 1.1321, 0.71342, -2.2831, -0.28947, -1.7025, 0.14983, 0.66718, 1.5826, 0.17674, 1.6064, -0.23456, -3.8871, 0.22489, 1.4015, -1.2201, 0.41565, -0.25891, -0.77967, -0.95588, 1.4437, 1.3196, -1.4281, 1.0661, 0.1385,
        2.3901, -2.2447, -1.0856, 2.2885, 1.9451, 0.32777, 0.82898, -0.66363, 0.24194, -0.79834, 2.8447, 0.62148, -1.7368, -1.3595, -0.95549, 0.7803, -2.1354, -1.5006, -1.7205, -0.19485, 1.9675, -0.99182, -0.16492, 2.3097, -1.8169,
        0.17322, 1.6625, -0.98911, 1.4473, -2.1603, 0.66228, -0.5444, -1.2371, 0.031537, 1.67, -0.64197, 1.1443, -1.057, -0.84869, 1.6032, -1.3855, 1.4347, 0.86913, -0.8138, -0.094832, 0.74108, -0.76763, 1.5721, 0.91686, -1.5297,
        0.83676, -1.846, 1.3223, -0.047092, 1.3026, -0.87322, -0.8331, -1.1938, -1.4042, -2.7, 0.27995, 1.7244, 0.41902, 1.5271, -0.60714, 1.2959, 1.099, -2.4226, -1.3625, -0.8194, 2.2845, -0.1804, 0.34576, 0.87177, -0.38618,
        1.5536, 2.6162, -1.7346, -0.099596, -0.4645, 1.7908, 0.42981, 0.35687, 0.21463, 0.0073292, 1.5302, -1.0732, 1.8655, 0.71428, 1.8903, 0.59914, -1.581, 2.0776, 1.3907, 0.8684, -1.1047, 0.57143, 0.46684, 0.93988, -1.3063,
        -2.3155, -0.28486, 1.4753, 0.45551, -1.9592, 1.2857, 1.4617, 0.80196, 0.70181, -1.9255, 2.5615, 0.82677, 0.55925, -0.33101, -0.346, -0.59273, -1.4396, 0.072253, -1.1079, -0.37555, 1.0756, -1.2812, 2.6125, 1.0356, -1.8089,
        -1.083, -0.90607, -0.5315, 0.3322, 0.34726, -1.764, 1.6047, -2.0495, -0.023669, 1.8802, 1.6828, 1.0926, 0.63083, 2.0643, 0.98717, 0.321, -0.63552, 1.8202, -0.3163, 1.0272, 1.1419, 0.21872, -1.525, -2.4459, 2.5446,
        -1.1965, 1.7587, 0.090077, -1.2703, 2.0559, -1.0434, 1.4031, -0.11214, -0.22131, -1.6702, -1.5499, -0.85655, -0.22299, 0.30461, -1.2762, -1.0503, -2.1423, -1.1795, 0.76904, -0.81171, -1.1676, -2.6436, -1.4668, 0.44629, 1.2024,
        1.7564, -2.1271, -0.91167, -0.90331, 1.6429, 0.35485, -0.58015, -0.027949, 1.0141, 1.6257, -1.1494, 0.35123, 0.47626, -0.38113, 1.1874, -0.93345, -0.48249, -0.87362, 1.365, -1.8314, 0.87474, 0.68713, 0.90239, -0.15987, 0.68695,
        1.495, -1.5565, 1.0783, 0.60275, 1.559, -0.20039, -0.40441, -0.94795, 0.76599, 1.0016, 0.56796, -0.93504, 1.9274, -0.86916, 1.4718, 1.8706, -0.5437, 0.65868, -0.919, -1.5957, 0.1086, 1.482, -1.5511, -0.51008, -1.7475,
        0.22217, -0.69117, 0.54862, 0.025246, -0.41793, 0.90198, 0.37402, 0.41605, -0.21769, -1.9539, 1.2026, -0.75546, 1.5777, -0.50275, 0.5927, 1.977, -0.18413, -0.064041, 1.6212, 1.7141, 0.86359, -1.7753, 2.3014, -0.47165, -1.5046,
        -0.34219, -0.70917, -0.99293, -0.065868, 1.7819, 1.8744, -0.94927, 1.1003, -0.57672, -0.83384, -1.9028, 0.35993, 1.1851, -1.3636, 1.9359, 0.67768, 1.1969, -1.5872, 0.083883, -1.0789, 0.76159, 2.2303, 0.060239, 0.47365, -2.0044,
        1.8933, -1.0618, 1.6751, -0.59013, 0.036599, -0.88945, -0.20153, 1.0974, -1.1624, 1.5834, 2.0855, -1.2614, 2.2284, 1.5233, 1.4299, -1.6876, 0.8488, -0.86443, 1.0121, 0.6373, -1.0549, 0.818, -0.16345, -0.072791, 0.9525,
        0.75055, -1.2717, -0.19325, 0.18125, 0.77068, -1.3951, -0.41515, 1.9939, 1.3367, 0.68319, 0.9602, 0.0069978, 1.3663, 0.065695, 0.39332, -2.7159, -0.30302, -0.61467, -0.79632, -0.854, 0.87889, -1.2309, -1.9534, 0.81605, 1.3818,
        -1.3823, 0.96429, -1.2832, -0.5923, -0.61639, 2.031, 1.8594, 1.1948, -1.8683, -0.52496, 3.2233, -1.465, -1.0915, -1.1313, 1.6021, 1.0125, -1.0107, 0.47562, 0.10461, 1.0117, -1.4001, 0.69765, 2.0766, -1.9733, -0.60048,
        0.25894, 0.30414, -0.2141, -2.1988, -0.61265, 1.5708, -1.0579, -0.89002, -0.27357, -1.5719, -0.135, 1.9024, 0.025819, -0.69574, -0.62902, 1.6011, 0.1215, -1.5254, -0.31961, 0.7082, -3.0311, -0.86593, 1.1577, -1.3759, 0.91259,
        1.194, 0.47566, -0.39613, 0.48156, -1.2638, 0.63524, -1.5751, -0.3941, 0.56236, -0.32487, -1.6205, 0.86477, 0.32803, -0.63385, -1.4223, 1.2391, -1.0428, 1.2633, -0.50502, -2.6042, -1.7029, -0.93318, -0.1835, -1.1965, -1.5602,
        0.96007, 1.7295, -2.3458, -0.54893, 3.3596, 0.37314, -1.4674, 0.31414, -0.99843, -1.4559, -1.6392, -1.4799, -1.44, -1.2354, 0.82616, 0.4256, -1.7712, -0.26378, 1.0145, 1.4967, 1.2605, -0.45072, 1.484, 0.88447, 1.0499,
        0.92149, -0.3259, 0.40576, 1.5395, -0.63337, 0.54249, 0.15863, 0.71545, 1.2395, -0.40475, 0.61235, -0.8998, 0.40001, 0.94665, 0.93841, -0.18571, -0.83983, -1.3422, 0.55114, 0.72789, -0.83086, -1.8254, -0.56868, 1.2419, 1.4705,
        -1.845, -1.0234, 1.771, -1.2321, 0.49259, 1.3519, -2.1274, 1.2487, 1.4459, -0.051483, -1.2201, -1.3728, -1.3591, -1.0802, -1.1844, -0.21027, 0.91074, -1.3399, -1.6913, 1.5465, -0.027217, -0.69418, 1.7748, 1.1521, 0.4048,
        -0.9368, 1.2145, 0.70906, -0.64088, 0.88829, -1.6498, 1.9643, -0.07629, -1.603, 1.3602, -0.44794, 1.275, 0.64222, 0.11164, 0.4384, 0.17529, 0.84277, -0.77756, -1.1959, 0.6719, -0.81701, 0.24653, -0.12855, -1.0825, -2.2814,
        1.6356, 1.3272, -2.2456, -1.0945, 0.78253, 0.05269, -2.4606, 2.0959, 0.78303, -0.058691, -1.1069, 1.332, 1.5192, 1.4905, 0.31477, 1.2751, 0.86149, 1.0312, -1.2889, 0.79842, 1.5286, -1.8451, 0.78594, 0.83683, 0.64588,
        1.6435, -0.24004, -0.95259, 0.60825, 0.74003, -1.6908, -2.7057, -1.1588, 0.97889, -1.513, -0.0089181, 1.8831, 1.3235, -0.55445, 0.23014, 2.1304, 0.53089, -2.3351, 2.6851, 0.69617, 1.6443, -0.14626, 1.6631, -0.53402, 1.538,
        -2.113, -1.2498, -0.97073, -0.31884, -0.080025, -1.5186, 0.17403, 0.52514, 1.9959, -0.14697, -0.80516, 1.1009, -0.77398, -1.98, 0.86846, -1.2564, -0.86611, 1.4097, 1.2669, 1.8198, -0.52163, 0.77448, 0.73164, 1.2515, 1.7744,
        1.7876, 1.2359, -1.2107, -0.67375, -1.389, 1.3437, 0.98686, 1.6594, -0.73597, 1.8054, 1.9486, 1.3012, 1.7605, -1.0927, -1.4065, 0.23705, 1.424, 1.0454, 1.2687, 1.4819, 0.47965, 0.59222, -1.9918, -0.26178, 1.1057,
        -1.0934, -1.7322, -1.8458, -1.159, -1.0173, 0.37437, 1.815, -1.3163, -0.099431, 1.0366, -1.0794, 1.3275, -0.75632, -1.0447, 1.3574, -1.568, 1.6526, -0.35432, 0.41288, -0.9304, 0.98067, 1.1171, -0.64888, 0.35278, 1.1774,
        1.7213, -1.4085, 1.7612, 0.69835, -0.16311, 1.171, 0.91934, -0.4891, 1.4254, -1.6947, -1.7068, 0.76409, -1.1044, 0.79836, -0.84538, -1.5262, 0.70729, -0.82664, -1.414, 0.16462, -1.0514, -1.6923, 0.95076, 1.6187, -2.1122,
        0.041836, 0.65008, -1.8453, 1.4193, -0.42433, 1.7781, -1.1349, -1.2808, -0.43996, 1.776, -2.3962, -1.3076, -0.77175, -0.74284, 0.54909, -1.6478, -0.9192, -1.2539, -1.2505, -2.1154, -0.13362, -1.4387, 0.69617, -1.0372, -1.2238,
        0.13562, 1.9568, -0.88125, -0.53966, -0.053533, -1.7777, -0.88183, 0.74264, -2.3237, -1.3028, -0.19313, 0.4869, -1.683, -2.3389, -2.1237, 1.6053, 0.29568, 0.8404, -2.268, -1.0415, 0.86216, -0.51162, 0.98141, 1.1805, 1.3832,
        -0.19133, -1.8054, 1.513, -0.79353, -0.019613, -1.0548, -0.78823, 0.054214, -0.64289, 1.7356, 2.197, 1.2173, -0.91722, -0.82662, 2.5774, -0.08294, -0.28795, -0.48129, -0.59653, 0.019073, -2.0965, -0.61308, -1.0587, -1.1753, -0.50309,
        1.9301, 0.84283, -1.7599, -0.80474, -1.2122, 1.0752, -0.25057, 1.0441, -0.16727, 1.2078, 1.1236, 0.31284, -1.6818, 1.918, -0.49289, -1.2457, 0.70709, 0.43431, -2.3911, -0.14516, -0.13572, -1.3089, -0.4389, -1.1793, 1.3619,
        -0.65629, 1.4466, 1.5094, 1.0111, 2.1125, -1.0404, 0.91814, -0.51775, -2.6187, 1.1112, 1.3204, 0.88801, 1.9903, 1.0301, -0.47002, -0.185, 1.4872, -0.38902, -0.84736, 1.659, -0.91808, -2.9941, -1.6841, -1.0991, -1.5188,
        -1.4094, 0.44316, -1.7489, 0.82647, 1.7243, 1.2252, -0.53619, -0.66226, 0.85138, -0.55472, 1.0781, 1.4423, 1.7656, 1.7401, -1.9124, -0.80939, -2.144, -1.5435, -0.99163, -1.8184, -0.83708, 1.1486, 1.2346, -0.84218, -0.091452,
        -1.5239, -0.50142, 0.57472, -0.26363, 0.64315, 1.6194, 1.6794, 0.52183, 1.3201, -1.9603, -1.1758, -2.0551, -2.0273, -1.2342, -1.2967, 1.4268, -2.4919, -2.7364, -0.24333, -1.8117, 1.1326, 1.7083, 1.1277, 1.9378, 0.70936,
        0.88644, 0.63595, 0.76578, -1.411, -1.7155, 1.5396, -1.2236, 0.43599, 1.8322, -2.0518, 0.48268, -1.4275, -0.90212, 0.34445, 0.055887, -1.1234, 0.036954, -1.4922, -1.1331, 0.3607, -0.30691, -0.15031, -1.3464, 0.46013, -1.0366,
        -1.3949, -0.22307, 0.78832, 0.6195, -1.0309, -1.0229, 1.5101, 2.0927, -1.8672, 0.076982, -1.4467, -2.4598, -0.53238, 0.73727, -1.6422, 1.1751, -1.8264, 1.2321, -0.58747, 0.67848, -0.48272, -0.20042, 0.56969, 0.15956, 1.4286,
        1.5253, 0.68529, 2.002, -0.4722, 1.1922, 0.82596, 1.6722, 1.6502, -0.28116, 0.3811, 0.98913, 1.6799, 1.1046, 1.2768, 0.1446, -1.9797, -0.44348, 0.11725, 2.0055, 1.2421, 1.0532, -1.7213, -1.3245, 1.0443, 0.7579,
        1.4395, -1.067, -0.57312, -2.6553, 0.89343, 1.2901, 0.99203, 1.2742, -0.12045, 1.8017, -0.42139, 0.83732, -1.5264, -0.1191, -1.1626, -1.1545, -0.87054, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

char raw_4096_12[4096] = {
        1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
        0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0,
        0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0,
        1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1,
        0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
        1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
        1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1,
        1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
        0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0,
        1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1,
        0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
        0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1,
        0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
        0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0,
        0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,
        0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0,
        1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
        1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
        1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1,
        0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1,
        1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1,
        1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
        0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1,
        0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0,
        0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0,
        0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
        1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1,
        1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
        0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0,
        1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1,
        1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1,
        0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,
        1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
        1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0,
        1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,
        0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
        0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0,
        0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1,
        1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0,
        0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1,
        0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0,
        0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0,
        0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1,
        1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,
        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1,
        1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0,
        1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1,
        0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1,
        1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1,
        0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0,
        1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0,
        1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0,
        0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
        1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
        1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
        1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,
        0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1,
        1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
        0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0,
        1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0,
        1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0,
        1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0,
        0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1,
        1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1,
        0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1,
        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0,
        0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0,
        0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1,
        0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0,
        1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0,
        1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
        1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
        0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,
        0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,
        0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1,
        0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1,
        0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
        0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1,
        1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0,
        1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0,
        0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0,
        1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1,
        1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0,
        1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0,
        1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,
        0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1,
        0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1,
        1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1,
        0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,
        0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1,
        0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0,
        0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1,
        0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,
        1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0,
        1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0,
        0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0,
        0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1,
        1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,
        1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1,
        0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1,
        0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0,
        1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1,
        0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
        1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1,
        1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1,
        0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0,
        1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0,
        0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1,
        1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0,
        0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1,
        1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0,
        1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1,
        0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1,
        0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
        1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0,
        0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1,
        1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0,
        0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
        0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0
};
#41 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/txword.h" 1



char TXrawData[1280] = {
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30
};
#42 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/ldpc4096_45_data.h" 1

ldpc_dbl Rx_4096_45[] = {
          -2.844517, 1.621995, 1.659750, 1.742814, 0.859133, -3.260976, -1.112706, -2.118085, 1.583582, 1.744923,
           -1.463036, 3.178584, -1.389454, 2.144247, 4.463857, -2.537230, -2.130446, -2.140022, -2.114040, 0.703400,
           -1.833180, -1.874905, -2.420732, 1.391184, 2.776753, -0.752205, 3.172291, 0.700039, 2.663743, -1.659431,
           0.076042, -1.500063, 2.533946, -2.951464, 2.679410, -2.314821, 1.175052, 1.455982, -1.960991, 0.878735,
           1.679268, 3.614483, -2.898388, 2.061382, 1.881086, 1.646267, 3.198544, 2.441459, 2.284366, 1.145753,
           2.346571, -3.453130, -0.875085, -1.632000, 0.798725, -1.121907, -1.272615, -1.371405, 3.611718, 1.221490,
           0.509788, 2.082446, -1.605007, -2.107350, 1.687252, 0.498962, 1.469313, 1.785220, -2.590644, 0.568233,
           3.127717, -2.891351, 1.325978, 1.242628, -0.351337, -0.329233, 2.661536, -0.369981, 1.225693, -0.577347,
           -1.621852, -2.515577, 0.315149, 1.382327, 2.081600, 0.789107, 1.519717, -1.880086, -1.867212, 2.888117,
           3.406591, -1.810752, 1.618837, -1.731556, -1.104484, -2.780861, -1.387693, -1.162794, -2.020546, -0.113370,
           -1.742857, -2.578330, 2.607779, 0.594626, -2.517391, 0.105663, -2.411543, 1.942970, 0.463192, 2.335762,
           2.411663, 2.009397, 0.900350, 2.248038, 1.835880, -2.305293, -1.815525, 3.162552, 3.087026, -1.798207,
           0.931438, -2.273798, -0.774885, -2.202631, 2.647798, -1.617296, 1.496298, -1.449229, -1.563458, 0.707772,
           -1.379259, 0.754877, -3.193188, -2.453123, -2.650995, 3.210895, -0.474946, -2.344268, -2.039000, 1.946125,
           -3.068077, -2.344057, 1.319666, 2.377609, -1.411048, -2.035114, -2.334576, 0.774107, 4.074523, -2.530332,
           1.353489, -2.899505, -3.044278, -5.136357, -1.150860, 2.664805, 1.607578, -1.751119, 3.198184, 2.404702,
           2.012730, 3.170828, -3.354048, -1.481518, 3.430779, -0.533933, 1.758604, -2.616653, -1.175085, -1.871199,
           -1.699818, -1.297607, -1.329084, -1.147694, -2.784430, -1.731141, 2.156481, 0.632841, 2.095359, -1.844096,
           0.362398, -1.719308, -1.711091, 3.305891, -0.924484, 1.274535, 1.342157, 1.986708, -0.898249, 2.282681,
           2.386506, -1.465877, 2.067316, -2.995249, 1.625702, -2.717814, 2.140303, -1.169307, -2.530803, -0.933171,
           1.581360, 1.295838, -1.896073, -3.086485, 3.302231, 1.583374, 1.736277, -2.931628, 1.024521, -0.255540,
           1.959783, -3.128961, -0.725541, -2.874409, 2.771689, -0.459416, 2.876027, 1.089705, 2.106584, 2.875139,
           -1.699858, -2.726546, 2.983626, 0.999620, 2.895148, 2.722671, -3.321104, 1.028918, -1.676780, 1.226453,
           -2.302566, 1.626468, 2.987138, -1.154807, 2.649921, 1.018661, 0.735696, 1.779939, -1.658631, -1.652571,
           -2.317869, 1.310768, 0.862713, 3.050899, 2.810070, -1.748492, 1.681459, 3.705764, -3.061545, 1.617986,
           0.617451, 3.222176, 1.896622, -1.892407, -2.508519, 2.632617, -2.219386, -2.912599, 2.008805, -2.590978,
           -0.580749, -0.767737, 1.225663, -1.425956, -0.685547, -2.443324, 0.320244, -2.337510, -0.585434, -3.188276,
           2.757296, 1.060814, 2.039845, 2.233667, 2.497070, 2.083991, -2.381506, -0.524031, -1.890464, 2.523704,
           -2.849648, 3.087760, -2.591441, -2.610331, 1.646118, 0.563772, 2.072239, 2.631503, 2.815875, 1.054078,
           1.160531, -1.280769, 0.951321, -1.582498, 2.174516, -4.151091, -3.289351, 1.805444, -2.191967, 2.589688,
           -2.019853, 4.102862, 2.160788, -3.156924, -0.825951, 1.018678, -3.043270, 0.218588, -1.536260, 1.935435,
           2.676267, -1.788519, 0.646464, -1.952843, -3.212123, -0.967879, 2.404102, -2.233675, 3.334156, -0.379621,
           -2.237477, 2.401995, -1.050165, -1.067727, 1.348813, -1.069419, -1.675038, 1.673379, 1.816931, -1.518847,
           4.169680, 0.741824, -2.548414, -1.082343, -3.011409, 1.282544, -1.423927, 3.012189, 3.309080, 0.191942,
           1.740203, -0.280085, 1.907509, 3.249869, -3.567714, -2.304104, -1.038139, 4.066955, 2.255225, -2.996444,
           1.559150, 3.188761, -2.532961, 3.038869, -1.879436, -2.730633, -2.533895, -2.670583, 1.329617, -4.363559,
           -1.426481, 1.037997, 2.541309, 1.109191, -0.161790, 1.532329, -2.314254, 1.847113, -1.874958, 0.739857,
           1.451765, 2.115269, 2.895000, 1.635944, -2.379080, 2.702221, 1.508731, -1.663194, -0.367135, -2.450143,
           1.450211, -0.837864, -2.176269, 0.374334, -0.120486, 2.827705, -1.055514, 0.682010, -2.214790, -2.482864,
           1.789120, -1.306712, 2.987462, 1.555987, 1.149439, 2.300962, 1.769086, -1.388299, -2.675342, 2.773620,
           -0.861125, 2.372576, -1.707985, -2.055652, 1.712358, -0.617176, 0.923205, -2.911061, -3.200233, 2.232762,
           -1.932875, -1.475866, 3.805229, 1.495226, 1.801953, -1.706211, -3.323348, 1.339452, 1.215383, -3.094711,
           -2.323067, 2.183654, 2.035576, 1.321189, -0.320456, 2.303641, 1.611128, 0.965398, 3.183297, -1.195473,
           -2.024543, 3.436750, 4.108362, -1.771248, -0.577670, -1.927552, -1.717815, -1.394686, -0.923146, -1.458624,
           4.006946, 0.494138, 1.535066, -2.638099, -2.491455, -1.664022, 1.393951, 1.402529, -3.059206, 3.262458,
           3.097850, -3.695884, -0.661532, -3.076879, 1.542374, 1.084263, 0.312158, -1.451842, -1.956842, 2.137389,
           -2.773674, 2.473325, 1.493709, 1.235993, 2.359844, 2.772857, -1.300674, 0.909232, -1.449732, 2.769537,
           2.118412, 2.976057, -1.045936, 1.745660, 2.890255, -1.784322, 1.704652, 2.285605, 0.257415, 1.805372,
           -0.971790, 3.434788, -1.972392, 0.764550, 1.817106, -2.765403, 0.669672, 3.572477, 0.467906, 1.404831,
           -1.361582, -2.996546, 1.877858, 1.733572, -1.511122, -1.068876, -3.034333, -0.698536, -2.165095, 1.651589,
           2.134870, -2.757294, -2.301903, 2.007718, -0.220961, 1.552833, -3.098444, -2.393499, -1.305196, -1.790634,
           1.567033, -2.647165, -1.024726, -1.531146, -2.679194, -1.460490, 3.205953, -2.400660, -2.741321, 2.532813,
           -1.457845, 1.726983, 1.556061, -1.560286, 0.053416, 1.939280, -1.622655, 3.638639, 2.547596, -2.443272,
           2.319385, 1.691631, 4.043668, -3.827968, -0.862907, -1.987363, -3.223376, 1.753649, -0.629455, 1.307451,
           0.691181, 1.000786, -1.614688, 3.732569, 2.662927, -3.391878, 2.076180, 2.716672, 2.654293, -1.603066,
           1.667671, -1.896922, -2.543246, 2.545497, 0.827603, 2.349340, 4.028032, 0.801340, 0.457591, 2.670403,
           -0.718522, 1.815650, -0.224315, 2.647961, -2.809099, -3.016308, 1.907316, -2.312638, 0.594701, -1.788906,
           1.625233, -2.416525, -4.047913, -2.514592, -1.773753, 2.059558, 0.694337, 1.727964, 2.681397, -0.279382,
           -3.961142, 0.160053, -1.983779, 2.135220, 0.949456, 2.245597, -2.245066, 3.331114, -3.423995, 3.483471,
           -2.623881, -4.126113, 2.357765, 0.909710, 1.929343, -0.857658, -3.746495, 1.491775, 1.483295, -0.009248,
           1.582574, 1.875902, -1.512441, -0.582114, -2.707514, 1.392591, -2.924304, -3.974529, 1.765760, 2.873061,
           -1.931240, -1.944068, -2.596349, 1.654793, 2.162527, 2.731914, -1.051703, -1.045277, -1.728675, -2.138669,
           -1.834039, 0.725345, 1.426937, 2.744633, -1.385950, 2.744932, -4.230833, -1.168552, 1.823776, -1.662569,
           -2.316349, -2.046604, -1.534863, -2.342084, 0.853442, -1.893401, 1.593592, 1.489201, 1.548059, -1.425084,
           -1.107744, -1.124837, -1.955134, 2.380554, 1.141782, 1.864530, -3.068881, -3.519335, 2.458135, 3.216226,
           -2.302730, 3.035013, -1.113190, -0.753316, -2.188495, -3.124645, 1.881594, -2.388304, -1.893387, 3.070520,
           2.133106, 1.504155, 2.723029, -0.332652, 0.785105, -2.869877, 0.629346, -2.279396, 2.734616, 2.207439,
           -0.427518, 2.177107, 3.705919, -2.016399, 1.092341, -2.060237, 3.176157, -2.248297, 2.965882, 1.807628,
           -3.169259, 1.969838, 2.546597, 1.954030, -1.738210, -0.987343, -1.961122, 3.376846, 2.216458, 1.409691,
           0.966543, -1.534355, 2.497231, -2.109935, 2.045699, -2.422040, -0.753619, -2.080202, -2.763501, 2.058999,
           1.994106, 3.663137, -1.768978, 2.177641, -2.708780, -0.741204, 1.974828, 1.969003, 3.085777, -1.648056,
           0.610710, -1.655424, -1.141351, 2.258856, 1.290650, 3.008598, 3.019223, 3.819666, -2.322787, -2.609620,
           0.321435, -0.918380, -2.347995, -2.455427, -1.503510, -1.215945, -3.959055, 1.829088, -0.904290, -0.762865,
           3.338958, 1.262202, -2.911914, -3.752084, 0.430443, 2.246473, -0.322372, 3.134768, 2.373989, 1.939334,
           1.050815, 0.173903, -2.853919, 1.879996, 1.641268, -1.212038, 0.279565, 1.299405, 3.018472, -2.669884,
           1.384044, -2.001064, -1.357850, -4.050319, 2.464365, 1.386378, 0.823605, -1.406504, 3.177175, 2.755441,
           -3.581524, 2.793753, -1.368639, -1.888498, 1.935656, -1.968355, 1.541130, -2.597175, -2.620245, 2.440016,
           1.481963, -3.992060, -1.802605, -1.972072, -2.779775, -1.703778, 2.747319, 0.415754, 1.758214, 2.741521,
           -0.699633, -1.321153, -1.769323, -3.184958, -1.517764, -1.371969, -2.899041, 2.019893, -2.332489, 1.371323,
           2.301034, -2.824171, 0.198952, -3.070159, 2.215351, -1.077555, 2.369932, -2.504052, -1.294051, -2.481939,
           -2.127257, 1.694815, 0.153864, -1.044153, 0.314266, -2.445751, -0.772960, 0.970911, 1.508838, -0.175698,
           4.252287, 2.133605, 2.973913, -2.370329, -0.280074, -2.503667, 3.969378, -0.215295, -0.153515, 1.847237,
           3.978822, -2.421530, 3.543773, 1.218662, 2.568237, 1.620784, 1.092575, -2.472195, -1.790424, -2.939711,
           -2.248426, 1.939831, -2.058045, -2.672931, -1.573269, -0.902262, -1.615273, 0.605392, -3.060675, -2.213241,
           1.571598, -1.991460, -2.937880, -2.482597, -0.438575, -3.212446, -0.643360, 0.001503, -2.136909, -3.393879,
           -3.603873, -1.342414, -2.194565, 1.854123, -2.600381, -2.511713, 1.344555, 2.022576, 0.767969, 0.637985,
           -1.993672, 2.746618, -2.879814, 2.087990, -1.566808, 0.468239, 2.120242, -2.292626, -2.165968, 1.965981,
           2.789595, -1.723728, 3.181421, 1.416392, 3.454193, 2.045466, -3.265607, -1.432189, 1.206633, 2.434791,
           4.022320, -2.486941, -1.533606, -2.526080, 1.860183, -2.336287, -2.864238, 1.635502, -1.465670, 0.031486,
           2.267668, 3.413699, -2.796878, 2.227993, -0.431352, 1.088648, -1.700253, 2.972503, 0.179207, -1.652753,
           2.351168, 1.924711, 1.201696, -2.744979, 2.569906, 2.356449, -1.789256, 1.746990, 2.590709, -1.603895,
           -1.278723, -0.980027, -3.095185, 1.670346, -0.117055, 1.100994, -2.467660, -2.096190, 3.048128, 3.134059,
           -0.614880, 2.120832, -1.507400, -2.983080, 0.512658, -1.039898, 2.432659, -1.845598, 3.105580, 0.732943,
           1.787806, 1.036461, -1.736873, 1.855947, 2.526923, -2.353502, -0.657207, -3.386757, 2.559963, 1.596468,
           -2.712085, 2.302749, 2.404695, -1.517251, 3.167932, 1.681269, -2.751931, -3.437357, 2.316695, 1.986445,
           1.418912, -1.616630, 2.279573, 0.748500, 1.485806, 1.635590, -2.135938, -1.097734, -1.895108, 2.163875,
           2.454509, -2.469499, -3.591879, 1.934890, 0.986328, 0.010930, 3.405114, 1.358009, -1.706082, -3.274986,
           2.040795, -2.898454, -0.340506, -0.125814, -1.886821, -1.588063, 1.068957, -0.167573, 2.225557, 1.590823,
           2.946721, 1.185957, -2.221423, -1.648718, 2.182838, 1.960468, -0.956037, -2.219137, 1.744098, 1.571002,
           -0.819141, -1.269086, 2.246751, 2.099355, -2.414707, 0.444072, 2.528032, -1.532681, -1.251601, 1.922372,
           -2.363500, -1.467847, -1.110643, -3.067432, 2.606320, -1.637184, 2.905986, 0.292400, 3.392936, -0.668363,
           3.508482, 1.815668, 3.833511, -1.736748, 2.692082, 2.608403, -0.879345, -1.947478, -1.023857, -2.456721,
           0.948865, 2.392875, -1.742898, -1.396532, -2.248336, 2.027873, 1.927706, -1.182908, 1.596457, -1.151394,
           0.971563, -0.302798, 1.495312, -0.780250, -1.997116, 2.512294, -1.510619, 1.295284, 1.055675, 0.739626,
           4.159645, -2.178469, 2.369733, -1.573119, 3.584652, 1.175146, -1.062716, 0.794684, 1.667173, 2.141631,
           2.820168, -0.699252, 1.339667, -1.184503, 1.982773, -2.379415, -1.997186, -1.238963, -2.935287, 0.756487,
           -3.413792, -2.004313, -3.152405, 1.544657, 2.767095, -1.778348, 0.899852, 2.083687, -3.422637, -3.729347,
           1.098961, -1.813809, 0.572462, -2.715125, 0.669983, -3.479304, -1.294409, 3.052571, -3.446290, -1.581222,
           -0.951919, -1.533121, -1.826883, -0.720812, -1.125122, -2.643512, 1.688970, 1.610761, 3.272773, -2.045261,
           0.638486, -1.028973, 1.695795, 1.158980, 2.455580, 3.083890, -1.809924, -1.140176, -2.261667, -1.968350,
           2.273518, 2.152962, -1.563384, 1.922363, -1.644220, -1.115469, -1.079348, 2.413969, 2.532397, 2.722878,
           0.392236, 3.832954, 0.158605, -2.457254, -1.782581, 2.149433, 0.412630, 2.434675, -3.213104, 0.271902,
           -2.378990, 1.297771, -2.310673, 1.101411, -0.813973, -3.591818, 0.904927, -3.032650, 1.044685, -1.176358,
           1.989453, 3.452794, -1.373207, -0.967171, 1.905287, 1.824357, 0.885787, -2.225667, -0.679145, 0.484284,
           -1.874848, -1.332757, 2.977495, -2.721141, 1.390896, -3.106169, 1.389498, -1.178849, -1.174234, 2.837973,
           3.509810, -2.735294, -2.188155, -2.983262, 1.536895, -1.231621, -3.173312, 4.073821, 1.622529, -3.070284,
           -1.402616, -1.574758, -2.850087, 2.580378, 2.354220, -2.810710, -2.848180, 1.761272, 4.126808, 3.025606,
           1.683933, 1.602044, 1.872983, 2.408498, 2.134338, 3.456992, 1.407734, 0.929747, 3.075039, 2.596658,
           1.364592, 3.956936, -2.085414, -2.438838, -1.837139, 3.322189, 3.399336, -2.149060, 2.038451, -1.964911,
           -1.917519, -2.264582, -1.260193, 2.602703, -3.283653, 1.874603, -2.142691, -2.208855, -1.255743, 1.098808,
           -0.976885, 2.585564, 1.760248, 0.064912, 1.149745, 1.477288, -1.180725, 3.444930, -2.058690, 1.632852,
           1.696200, 1.034952, -1.417252, 1.019915, -3.153320, -2.657854, -1.555709, -1.162333, -1.865406, -2.990228,
           0.653066, -4.399469, -0.569550, -2.038805, -1.563490, -2.555108, 0.911399, -2.674033, 2.330853, 2.536132,
           -0.481529, 2.000064, 1.738591, 1.959289, 1.313143, 2.574365, 0.529570, 1.205834, -2.093470, 1.331733,
           -2.394406, -2.298583, 2.336524, -2.247269, -0.916602, -2.527383, -2.886544, -2.055013, -0.796048, -2.641032,
           2.022664, 2.747103, 0.740195, 1.408539, 1.993388, -1.700781, 1.942587, -2.651632, 3.445655, 2.630466,
           1.485362, 0.847940, 3.410630, 2.558794, -1.354634, 2.548392, 2.554890, -1.849113, -1.921098, -0.572083,
           -0.922288, -2.997679, -1.145238, -0.645817, -2.293729, 2.537746, 1.572936, 4.528485, -1.845180, 1.353232,
           0.366205, 2.049833, -2.630889, 2.339508, 2.408786, 1.405102, 1.415899, -1.801764, -1.359987, -1.388314,
           -1.863492, 0.810601, -0.091309, 2.562568, 3.076464, -1.941272, 0.376429, -2.497138, -2.618049, 2.185015,
           2.367457, 0.832755, 2.664979, 2.133983, 3.528265, -2.540491, -2.229090, 2.605575, 1.576488, -2.159066,
           1.621221, -2.777238, 1.221061, -2.770856, 2.072238, -1.786659, -0.515361, -0.431202, -2.968686, 2.004943,
           -2.751524, -0.687191, -2.328068, 1.901216, 3.586277, -2.301873, 1.383293, -1.187493, 2.305296, -1.153924,
           0.979126, -1.806668, 1.550737, -1.462571, 1.180861, 2.348902, -3.181417, -1.593386, 2.453366, -3.171589,
           -2.880548, -2.422604, -2.672904, 2.729709, 1.246394, 1.542774, 1.915227, 2.657278, 1.927516, -1.972776,
           -1.301068, 1.042273, -1.982039, -0.432851, -3.664898, 1.591193, -1.849625, 2.393135, 0.606811, 2.190509,
           2.890392, -2.494590, -2.587459, 1.133683, 1.963222, 0.955837, 0.736038, 0.782767, -1.612484, -2.135171,
           -1.099194, -1.054258, 3.147819, 1.184337, 2.892583, 0.760744, 1.916880, -0.962260, 1.186916, -1.956113,
           3.923907, -3.349600, -2.757169, 2.484335, 1.046571, 1.018878, 3.034265, -2.404895, -1.422141, -1.823880,
           -1.151755, 2.028759, -2.285493, 3.661723, 0.009155, 1.023577, 0.098352, 2.500748, -2.778301, -1.934091,
           2.334837, -1.037630, -1.411238, 1.760992, 3.212245, -1.977725, -2.837957, 3.909739, -2.232753, -2.280053,
           -0.110539, -2.029803, 1.594922, 1.861784, -4.099551, 3.068389, 0.831945, -1.980384, 3.334042, -2.089713,
           -3.438200, 3.530521, 2.405187, 1.278041, -2.152792, -1.030371, -1.652070, 1.689035, -2.295173, 2.244473,
           0.965427, -0.934862, 4.616259, 2.544882, -2.328783, 3.078641, 2.370188, 2.232355, 3.291349, -1.778376,
           -1.519946, 1.808343, 2.263888, -0.034576, 1.930485, -2.240818, -0.957666, 2.913638, 3.754410, 1.508184,
           1.227689, -3.015523, -0.777773, 1.275537, -2.812693, -2.096014, 1.915983, -1.419662, -2.711075, 1.542703,
           -0.931177, 2.903783, 2.213370, 0.362970, -1.242533, -0.720307, -2.117944, 1.606512, -3.841617, -1.347826,
           2.077068, -3.123571, -2.090501, -1.424849, -2.119025, 1.427947, -2.308434, -2.086056, 0.804314, 1.868844,
           -3.111836, -3.514641, -3.284391, -2.769855, 1.508792, -1.535284, -1.125343, 0.751643, 1.328758, -2.246393,
           -0.389010, -1.959371, -2.039990, -1.815636, 2.712869, -3.183810, -3.029924, 1.450177, -0.674756, 2.971268,
           -1.187153, 2.977126, 1.763136, -0.647493, -1.971575, -2.864440, -3.121643, 1.803090, 2.907477, -3.118389,
           -4.272969, 2.611723, 3.208053, -3.081379, -3.243523, 1.931493, 2.976098, 2.170267, 1.014194, 1.814232,
           -1.296657, 2.545480, 2.122502, 2.482327, -1.622405, -2.004180, -2.136612, -2.349767, -2.703840, -0.888682,
           2.260004, -2.987789, -1.552381, -1.105933, 1.684300, -2.567195, 1.643108, 1.097346, 0.468755, 2.776371,
           1.940306, 0.096744, 2.268128, -1.827507, -3.526187, 1.377579, -1.352738, 1.602221, -2.628014, -2.596003,
           0.838578, 0.207111, 1.428333, 2.180519, -0.784557, -3.798325, 0.401804, -2.143007, 3.025857, 1.073401,
           2.181294, -1.737464, 3.894109, 0.690113, 3.884829, -0.123447, 2.453925, 0.535864, 2.928713, -3.345451,
           -1.834569, -0.439696, -1.145058, -0.456333, -2.797257, -3.127314, 3.113892, 1.316711, 0.864113, -1.227625,
           1.216422, 1.141247, 0.453204, 2.877681, -2.734704, -2.725330, -1.433219, -0.685502, -1.461886, 2.700702,
           2.884324, -2.101944, -2.267090, 3.455338, -2.628245, -2.749254, 1.540973, -2.763411, -1.745354, -1.086183,
           0.999161, 1.129033, 1.577956, 1.060809, 1.746779, -1.972018, -0.537144, -1.438771, -2.844663, -2.580344,
           -1.583662, -0.778893, -2.300586, -2.462037, -4.694099, 2.384603, 0.401165, -3.610433, 1.433011, 1.754841,
           -0.762891, 1.632199, -3.312895, -2.118463, -3.276418, -2.084850, -0.526790, 2.118222, -3.313587, 3.505651,
           -1.515750, 1.279109, 1.825931, 1.539587, -3.010124, -1.460945, -1.470464, -0.169554, -2.034568, -2.850059,
           0.098209, 0.217211, 4.244061, 1.294111, 0.400372, 1.212015, -1.918260, 1.286145, -2.147651, 3.951781,
           1.317265, -5.195906, -1.250568, -1.419827, 2.101905, 1.440381, 2.012908, 2.125471, 1.549634, -3.248149,
           -0.797158, -2.457792, 2.372607, -2.045594, -0.566349, -1.182983, -1.556732, -2.039177, 3.378231, 0.935025,
           2.128879, -0.943175, 2.237843, 1.461184, 1.463518, 1.460235, 1.636823, -1.824397, -1.820996, -1.771207,
           -2.549670, -1.838825, 2.005818, -2.209852, -2.473210, -1.879205, 2.105347, 1.869562, -1.411561, 1.851452,
           -1.565152, 1.480652, -1.478699, 1.601358, 1.147006, 3.576186, -2.471089, 2.511270, -2.241219, 1.078808,
           -2.419558, -0.266993, -2.182200, -2.780995, 2.364984, -3.651861, 2.249603, -1.724817, 2.852099, 1.035981,
           0.038454, 1.596145, 2.623052, -2.573630, 0.387523, -2.372608, 0.100041, -1.747757, 1.555466, -1.726212,
           -3.337966, -3.941394, -1.811199, 1.788698, -1.299101, -2.457988, 1.785305, 2.070025, -1.403024, 1.336021,
           2.281102, -0.901626, 2.352267, 0.702570, 2.673587, 0.367353, 1.689689, -2.302092, 2.627466, 1.250915,
           0.708531, 2.771681, 1.159740, -3.116616, 1.003625, 3.493211, -0.763649, 2.509858, 0.761857, -1.760041,
           -1.077845, -3.631827, 2.467834, 1.894683, 2.978804, -2.028192, -0.956165, -2.211406, 0.391436, -2.470624,
           2.488279, 2.782870, -0.818837, 1.690921, 2.470774, 2.369434, 1.459113, -3.252187, -1.546816, 2.519758,
           1.704175, 1.532177, 3.400215, -0.781115, -2.111309, -0.938659, -4.220696, 1.461373, -2.045229, 0.977812,
           -2.402670, -1.588635, -1.790639, 2.079764, 0.566471, -2.824019, -1.117797, -1.830597, 1.187138, -1.871333,
           1.394733, -2.485252, -1.938643, -1.663479, 2.744345, -1.870756, 2.475112, 1.938022, 1.105356, -2.387347,
           -0.984343, -2.816379, -0.299671, 2.751318, 1.620389, 2.106934, -1.669956, 0.428597, 2.609883, -0.251500,
           -2.665329, 2.358148, -2.950951, 1.222531, 0.560957, -2.332803, -2.814921, -1.641061, 2.637984, 2.514704,
           -3.685081, -1.927681, 2.045772, 2.714195, -1.696136, -2.666165, 2.979516, 2.334281, -2.836926, 2.988513,
           -1.953951, 2.093410, 1.415567, -2.013279, 0.532244, -3.379877, -2.974914, -1.950439, 2.485473, 2.015859,
           -1.197719, 2.019732, 2.107374, 0.782906, 0.893835, -2.985177, -1.943059, 1.036216, 1.934113, -1.468430,
           2.461773, -2.572817, -1.530905, -4.209051, 1.971190, -0.595269, 2.023033, -4.001109, -2.019884, -1.045640,
           2.945567, 1.512144, -1.737815, -1.599553, 2.393931, 0.751638, -2.179545, -2.052302, -1.208668, -2.724238,
           3.114681, 3.677606, 1.852400, -2.550026, -0.044372, -2.855489, -2.907897, 0.334796, 1.215798, 0.698520,
           0.142005, -1.757135, -0.375007, 3.379710, 1.196519, -2.404770, 1.120311, -1.284076, 0.915709, -0.299013,
           2.414435, -1.964986, 0.253017, -3.556653, -3.608204, 0.981720, -0.862022, -2.691851, -3.721616, 1.961047,
           -1.924983, -0.106409, -1.938762, 2.032508, -3.438627, -1.921548, -2.145488, 1.555411, -1.808098, 2.286928,
           -1.580549, 2.115709, -1.724749, -3.683289, 3.227976, -3.578424, -2.497286, 0.328065, -1.712864, 3.885649,
           1.922603, -1.630162, 1.612582, -1.820656, -1.841436, -2.970680, -2.562185, 1.631582, -1.777311, 2.568396,
           -2.309182, -0.326848, -1.416911, -3.892669, 0.205587, -0.811331, -2.608384, 2.937201, -2.673665, -1.546088,
           -1.888092, 3.014624, -1.065807, -3.248472, -0.898055, -2.045383, 0.961533, 2.353366, -1.256467, -1.663213,
           1.309001, -2.215152, -0.202997, -2.190573, 1.657674, 2.069433, 0.675236, 0.596892, 2.579632, 0.559871,
           1.196676, -3.208520, -3.700000, 1.125701, -1.206606, -0.500352, -2.931265, -1.830980, -0.969323, 2.656446,
           -0.427825, 0.712517, 2.872762, -0.673054, 2.427362, 1.175906, -1.123598, -2.371742, -2.047139, -1.169043,
           -0.993633, -1.535706, 1.093073, 2.745285, -0.824518, 2.529907, 2.084279, 1.745486, 0.549323, 2.010336,
           -1.159561, 1.841006, 1.136754, 1.912300, -0.316607, 1.213985, -3.390230, -1.143470, 2.338729, 2.091048,
           2.709509, 3.235848, 2.543346, 1.567839, 0.151719, 3.016355, -1.093336, 1.027446, -3.373369, -1.238077,
           4.006086, 2.492156, 1.618394, -3.342499, -2.576632, 1.443016, -1.684508, -1.030617, -2.543498, 1.131901,
           -1.137388, -0.910296, -0.694494, -3.438736, 1.771640, 0.936967, -2.954637, 2.257546, -2.670626, -2.609120,
           2.992652, -1.273113, 3.167951, 2.439048, 2.738475, -1.727320, -1.212619, -1.319473, 1.014802, -2.149388,
           -1.249807, -1.966560, -3.019247, 1.716845, -0.119551, 1.811898, 2.198084, 1.732725, -1.919217, 2.395733,
           -1.962709, -2.840512, 3.439652, 2.939759, -1.993389, 2.775829, 1.930755, -3.067314, 1.924632, -2.807621,
           -1.811030, -2.175885, -1.690964, 2.216764, -1.385646, 0.916303, -1.346674, 2.980047, 1.351504, 1.253697,
           2.037057, 2.903961, 1.333976, -1.799138, 1.178365, 2.656385, 1.704878, 2.730105, 2.755659, 0.725257,
           1.464230, 2.598941, -1.488700, -0.178358, -1.693622, -2.151928, 1.979138, -2.549807, -2.697066, -2.222789,
           1.622185, -1.434624, 3.429188, 1.346981, 0.154647, 1.424386, -2.524156, -2.706081, -0.437020, 2.765026,
           -1.737333, 2.074863, -2.016283, 1.961690, -2.039228, -3.527077, -2.781302, 1.551201, 1.442320, -2.718359,
           -1.892219, -4.604781, 2.678648, -1.946958, -0.903070, -0.623071, -3.163403, -2.125885, 3.625442, 1.768339,
           0.750163, -0.880833, -2.048339, 1.169740, -2.523569, 4.391117, -2.590271, -3.289862, -0.526542, -0.673504,
           -2.395563, 1.137099, 3.759823, -1.862625, 1.553010, -2.065460, 3.181647, 2.050696, -2.212267, 1.208049,
           -1.230557, -2.993982, 2.115684, -2.757218, -3.768879, 0.920150, 2.657194, -3.701904, -1.921705, -1.968136,
           1.660340, -2.219545, -2.379848, 1.957248, -1.308960, -0.279396, -1.714793, 2.791535, -2.129968, 3.030505,
           -2.177090, 2.126436, -3.743583, 1.998065, 2.902513, -1.416521, 2.236414, -2.375322, -2.436336, 1.137026,
           1.638974, -3.210707, -2.104891, -1.992356, -2.808706, -0.563883, 3.068689, 1.879277, -2.074130, 2.194403,
           2.023224, 2.396913, 2.523097, 1.335568, 1.313209, 0.845924, 1.696905, 1.318064, 1.052478, -3.408216,
           3.118150, -1.163795, -2.889051, 2.249092, 0.294849, 3.655793, 0.925536, -2.967664, -1.705913, 1.732554,
           2.322291, -0.278657, 3.064002, -1.799049, -3.337801, 1.251230, -2.515579, 2.051571, -0.997364, 0.318546,
           -2.032722, 3.651726, 0.361896, 0.238604, 3.011131, -1.282233, 2.821458, 3.874228, -2.217540, 1.891392,
           -1.554259, -1.631713, 2.687672, 1.596898, -0.659523, 2.859143, -2.686655, -1.674946, -0.329634, -1.773033,
           2.136838, -2.698909, 2.260311, 1.739195, -1.587517, 0.345548, -1.583974, -1.542816, -1.633281, 1.693249,
           2.780087, 1.978240, -0.713072, -2.189539, 2.927863, -1.466473, -1.267532, -2.109182, -2.837370, -1.858986,
           2.558545, 1.488942, -1.954093, -2.454452, 1.166390, -2.341896, 0.322838, 0.102963, 0.435692, 3.982806,
           -2.138190, -3.763873, 1.227288, 0.802136, 0.926334, 3.353743, -2.035017, -3.274163, 0.566294, 2.284243,
           2.228284, -3.314855, -2.100168, 3.785893, 0.289104, 0.499871, 2.526139, -2.247485, 1.668891, -3.620636,
           2.973751, 1.947161, -2.255053, 2.647411, 0.500614, 0.647847, 1.341379, -2.714584, 1.825771, -1.898284,
           1.436859, -2.293520, 2.247866, -1.888938, -2.330624, 1.788154, 3.887519, -0.771523, 0.326579, -0.994383,
           -1.000337, 1.217354, -1.913686, 1.259879, -1.695897, 2.576619, 2.202827, -1.477161, 2.059853, 2.346784,
           -0.527393, 1.775793, -3.691268, -1.993294, 3.971674, 1.320574, 2.076107, -1.294588, -2.130865, 1.562956,
           -3.249568, 1.561322, -1.509010, 2.413250, -0.441548, -1.032321, -1.938864, 2.260816, -3.420839, -1.495440,
           -0.463616, -4.205644, 2.045324, -1.771426, 2.037637, 0.488846, 1.509093, -1.312971, 1.240552, -3.590313,
           -1.554974, -1.938207, 2.180681, -3.437434, -3.209068, 1.572652, -1.168408, 2.083062, 0.809290, 0.873132,
           2.629220, -2.786167, 2.190592, -1.168570, 0.879641, -3.529550, -1.354902, -1.284874, 2.443584, 1.231817,
           3.433633, 1.297293, 1.734852, -2.102068, 3.750256, 1.822703, 0.614949, 1.228919, 3.826173, -0.304468,
           3.616133, 1.567540, 1.885522, 1.991551, -1.491162, -1.017964, 1.387168, 1.333040, 1.983806, -1.450773,
           2.160301, 1.395660, -1.133343, -1.049711, -3.576458, 1.802871, -2.706897, 1.736987, -2.986393, 2.596627,
           -0.457662, -1.405598, -2.609726, -2.844076, 2.537262, -2.262242, 1.776627, -0.769816, 2.018983, 1.584097,
           -1.630178, 3.256327, 3.039009, -1.716089, -1.512641, 2.108362, -2.164956, 1.715805, 2.951901, 1.159642,
           -3.629280, -3.921850, 2.897188, 2.387469, -1.245172, -1.083430, -0.253942, -3.682236, -0.802573, 2.250896,
           2.329421, -1.585449, 2.022554, 2.705231, -0.736515, 2.685325, 0.953723, 0.394783, 3.216528, -0.775967,
           1.248028, -1.917557, 2.384917, 0.741654, -1.692415, 0.848517, 1.367999, -0.676074, -2.172111, -0.008869,
           -1.581638, -3.718307, 2.172939, -0.181485, 1.609018, -3.401120, -2.933984, -3.006123, 1.252554, 2.161085,
           2.614778, -1.484782, -1.503666, -1.185689, 0.935609, -2.056161, -1.919573, -2.487029, 2.964776, 0.249425,
           1.251569, 1.094348, 0.856980, -1.977847, 3.008285, -1.737003, -2.980704, -0.715960, -2.461595, 1.779815,
           4.134280, 2.706131, -1.338318, -0.432099, -2.853124, 0.990246, -1.812657, -2.277984, -1.155167, -1.630975,
           2.405331, -0.905251, -1.705984, 1.118709, 2.332212, -0.322323, 2.111061, 0.924350, 1.807723, 1.782156,
           2.097150, -1.401815, 1.649059, -0.301484, -3.395643, -1.126857, -1.749182, -3.191516, 1.399254, -2.718651,
           -1.976938, -0.154252, -2.476965, -1.352771, -2.113523, 3.139263, 1.220502, 1.562971, -1.505333, 0.998202,
           -2.289227, -1.372858, -2.569563, 3.254124, -2.134764, -3.532379, 2.133848, 1.096980, 2.507798, -2.289228,
           -2.529966, 2.350736, -3.350740, -1.540817, 1.952622, 3.353008, 2.391598, -1.847897, -3.205659, 1.684020,
           -1.917963, 1.949180, 1.190650, 2.596795, -1.381543, -0.836509, 1.532998, -3.776031, -3.001159, 2.038434,
           1.141484, 3.131266, 1.435497, 0.162082, 1.068593, -1.122526, -1.565337, 1.811370, 2.119988, 1.723274,
           -2.373246, -2.973898, -2.710018, 2.401619, 2.223893, 0.845863, 2.347631, 2.626905, 2.752699, -2.879140,
           1.939956, -1.871989, -0.963981, 1.828974, -1.701630, -3.927528, 3.157244, 2.398953, -0.512102, 1.831350,
           0.966245, 2.677784, -0.998244, 3.175508, -1.667179, 2.165015, -3.443386, -1.635231, 2.995350, -1.698175,
           -0.163573, -2.975801, -0.952842, 4.010486, 1.952297, -2.893210, 2.638523, -0.421429, 2.987013, -1.787936,
           -1.427789, -1.382611, -3.020997, -2.078245, 2.250915, 0.975814, 0.248238, -3.098237, -1.995317, -2.760924,
           2.489594, 3.565520, -2.031168, 0.699851, -1.278557, -1.328236, -0.289053, -2.365588, -2.637245, -1.730654,
           -1.213792, 2.878646, 2.331013, -0.618118, 1.665189, 2.496134, -2.381975, -0.949642, -1.162325, 1.603973,
           -0.728560, 2.281928, 1.698763, -1.865114, -2.108142, -2.815140, -2.377310, 1.542982, -1.803137, 2.997075,
           1.191616, 1.130646, 1.690175, -1.108119, 1.879322, 2.198314, -2.737358, 2.547330, -1.862138, -1.691293,
           -2.350294, -1.785790, 1.376874, 1.959182, -2.699259, -2.059905, 2.330741, 2.586121, -3.413583, -2.318798,
           -2.454866, 0.277362, -0.970112, 1.956014, 1.927643, 0.912687, 2.399947, 2.468127, 1.560644, 1.080519,
           2.890376, 1.599442, -1.819530, 2.158052, -2.779335, 3.075215, 0.983623, -3.436198, -1.804429, 2.829838,
           -2.435076, -1.385571, 2.120196, 2.792366, 1.871625, 3.314567, -1.869305, -2.567727, 0.815266, -3.285005,
           -1.898818, 1.031047, 2.203248, 2.344676, -1.351709, -2.374521, 1.791191, 1.516496, -0.531651, -3.067434,
           2.137155, -1.040198, 0.392057, 2.092071, -2.022408, -2.007402, 1.509290, 1.712496, 1.178548, 0.469994,
           -2.204194, -0.961055, -0.222179, -2.206478, -1.481474, -1.850572, 1.794854, 2.886259, 1.379456, -3.804127,
           -3.096193, 3.456534, -1.927894, -2.513700, 1.196514, 2.606620, -2.118744, -3.078306, -2.981606, 2.415650,
           1.394329, -1.061611, 1.948663, -1.444492, -2.143016, 2.472705, 2.762402, -4.497967, 0.862757, 2.750328,
           -3.455812, -1.759848, 3.865707, 1.928010, -1.398150, -0.770284, -0.274279, 2.105629, -1.750187, 0.370550,
           2.572680, -1.081966, 2.303212, 2.057507, 1.525827, -2.694056, -1.293310, -3.535183, 3.411810, 2.367683,
           -2.425457, -0.999829, 1.994525, -2.402049, -1.209520, -1.347322, -3.059319, 1.798648, -4.024512, -0.169843,
           -2.713407, 1.534420, 2.345495, -2.908561, -2.957025, -1.641321, 1.758200, -2.792412, 0.547168, -2.475175,
           -2.300261, -2.595881, 4.029003, -0.897460, 2.489068, 2.300443, 3.219696, -2.125160, -2.749258, 2.051713,
           -2.012973, 2.154564, 3.107079, -1.418743, 0.126239, -2.811284, 0.347783, 1.693398, 2.112788, -2.886435,
           1.316642, -2.298631, -1.414447, -1.864906, 1.655827, 0.811886, 2.745448, -1.451536, -2.154467, 1.598681,
           5.179055, -2.125220, 1.659016, 0.956633, -2.182496, 4.437236, 2.386904, -2.560331, -1.705978, -3.586961,
           2.004181, 0.710101, 1.782763, 2.513660, 1.969546, 3.606296, -3.240565, -1.256023, 1.585130, 1.810588,
           -0.947001, 1.716342, -2.683438, -4.170271, 3.243937, 3.220347, 1.471572, -1.927124, 2.137308, 2.293057,
           2.291894, 3.436010, -1.258838, 1.627866, -2.601877, 2.020297, -1.253355, -0.089452, -3.219982, -2.473770,
           1.405254, 2.679746, 0.417421, 3.286783, 2.395903, -1.336458, 2.499328, -1.664730, 2.348279, -1.766377,
           2.701457, 1.943113, -2.184495, 2.513326, -0.579270, 1.565135, -0.391481, -1.990386, 1.211457, -0.923008,
           -0.547349, 1.833745, -2.004700, -2.863551, 2.463789, 1.295133, 0.934775, 1.410513, 2.368483, 1.810477,
           -1.771578, -0.025112, -2.688878, -4.169091, 2.214697, -2.028005, 0.996339, 1.755830, 1.646575, -2.165655,
           -2.608638, 2.869931, -1.378627, 2.424640, 0.933947, -1.116233, 2.131687, -1.526998, 1.762714, -2.092376,
           1.897851, 0.670363, -3.701166, -1.061241, 1.007152, -1.338487, 1.352680, -2.563822, 1.370959, -0.957757,
           -1.922305, 2.951596, -2.145241, -1.694573, 1.250084, -3.365343, -0.484814, -1.230664, -2.786541, 2.676969,
           0.489359, 1.240482, 0.209530, 2.806406, -1.440215, -1.008201, -0.612001, 3.496645, 2.062283, 1.160045,
           1.992190, -1.699073, 2.613663, 0.540493, 2.025374, -2.410115, 1.826673, -1.052496, 1.210266, 0.425657,
           1.809349, 1.654719, -2.877684, 2.108771, 3.355122, 3.160342, -1.898747, -0.244535, -1.763271, -1.416224,
           -3.006185, -0.168680, -3.485857, -1.905880, 2.363273, -3.864209, -3.118874, 2.032089, 2.429936, 2.123390,
           -0.291681, 2.243315, -0.126321, 0.031496, 3.469426, 0.621708, 0.947920, 2.386318, -1.267568, 2.309646,
           -3.408159, 1.807928, 2.714928, 2.941035, 0.738163, -1.906077, 2.412901, 2.358022, -2.783943, 1.990973,
           2.231378, -3.109920, 1.747685, 2.740747, 0.575506, 2.160233, -0.696222, 2.419524, 1.229625, 2.286104,
           1.629257, 1.718113, -1.807329, -1.755828, 1.505020, -3.375437, -0.399118, 1.696793, -1.445210, -1.377547,
           -2.730241, 2.738000, -1.638090, -2.785458, 3.313466, 1.800957, -3.286892, -2.173976, -0.907496, 1.079140,
           2.106785, -2.776362, 3.222678, 2.206566, -2.495436, -2.316038, -0.835754, 1.850079, -2.703598, -1.465810,
           -0.551908, -2.577569, 1.241997, 3.335509, -2.051873, -2.398619, -1.142693, 3.250305, -2.687520, 2.431956,
           -2.066981, -2.080040, 3.353153, 3.272033, -2.040352, -1.993843, -3.145000, 1.415684, -3.147397, -0.230107,
           -1.340350, -2.916635, -2.822800, -2.121213, 2.412749, -0.231355, -3.254308, -1.236586, -2.008464, -2.120426,
           1.117521, 3.034005, 0.140220, 1.293889, -0.422039, 1.186213, 2.400057, -2.221666, 2.696292, 2.867465,
           -0.513200, 3.379428, -1.655248, 1.080275, -2.024300, -3.169865, -0.847526, -1.941285, 0.977820, -1.968179,
           3.210378, -2.494653, 2.453771, 2.408239, -1.921221, -1.564411, -1.076030, 2.457529, -2.653646, -2.072805,
           -2.421384, -2.367263, 1.685321, -1.913523, -3.532223, 1.243163, 1.017461, -3.644497, -0.194608, 1.664465,
           1.928945, -1.442277, 1.067420, 1.364728, -0.296851, -1.110999, 0.003574, -2.265090, 0.594635, -2.261872,
           -0.601808, 2.374080, 1.299111, 2.277339, -1.530931, -2.541982, 1.422568, -2.728847, 0.630050, -3.286775,
           -1.391456, -1.132497, -2.297422, -2.140066, 2.448564, 2.178067, -1.280501, -2.347420, 0.565198, -2.858812,
           -1.472326, 3.042797, -2.640338, -1.387209, -1.551469, 2.773274, -1.861113, -3.983639, 2.616708, 2.636466,
           2.234529, -2.328658, 1.195592, -1.761050, -0.732933, -2.003038, 2.048316, -2.839615, -2.329426, 3.086276,
           0.322121, -0.041711, 0.128965, 1.559911, 1.489461, -1.191550, 1.744088, -2.222591, 2.063723, 1.431158,
           1.122000, 0.690694, 0.247803, 2.161118, 0.014942, 1.787362, 0.136690, -3.161072, 0.906536, -1.678410,
           2.754778, 1.228049, 1.967015, 2.309807, -1.900345, 1.555614, -2.153513, -1.396375, 1.867755, -1.507000,
           3.349646, 1.635470, 2.678466, -1.587388, -2.568177, 1.204875, -1.969138, 2.616731, 1.150661, 0.831543,
           0.939658, -1.103172, 2.085108, -2.723526, -2.363170, -1.914499, -1.371171, 0.569194, -2.920908, -0.642634,
           -2.517238, -1.858639, 3.667902, -1.212913, 2.079348, -1.817595, -2.335175, 2.869942, -1.758563, -0.586715,
           -1.875789, -1.099995, -2.092506, -2.464585, 1.479126, -3.253337, -1.982519, 2.036943, 1.336785, 1.931111,
           -1.679277, -3.595478, 0.834471, -1.360075, -3.134079, 2.224037, -1.834933, -2.399111, 2.158307, -1.916432,
           0.874222, 0.803585, 0.978745, 2.121027, -0.807857, 1.149679, 1.682160, 3.705908, -2.475204, -1.383690,
           -1.844902, -3.359693, 2.338126, 1.948941, 2.207431, 1.407340, 2.748394, 2.648404, 0.807102, 1.132792,
           -1.139486, 1.367558, 0.894115, 2.980755, -3.084463, 1.220824, 0.563665, -2.629678, 1.928125, -1.891395,
           2.368590, 1.736983, -0.770141, 1.735833, 1.843564, 2.169108, -0.290918, 1.913542, -3.293254, 0.021682,
           2.011931, -2.422812, 1.832289, -1.889085, 1.648277, -0.858244, -2.465922, 2.368431, -1.187651, -2.491553,
           -1.814223, -0.809428, 2.923207, 1.749053, 2.318806, -3.216468, 0.141099, -1.580740, -0.887340, -1.480615,
           2.250607, -2.707949, 2.730649, 1.715077, -1.987968, -1.100988, -3.370416, -1.776426, -0.778710, -0.968139,
           -2.692037, 1.101418, -2.892483, -2.251848, -1.185660, -0.222882, -1.677180, 1.017958, -2.063475, -2.099941,
           1.767592, 1.307739, 1.508438, -3.695991, -0.443514, 1.886809, -1.245000, 0.962381, -1.718657, 1.519233,
           -0.960631, 3.190434, 1.871560, -1.772610, 1.085493, 1.256692, 1.815195, -1.575059, 0.802900, -2.036443,
           -2.289959, -0.615239, -2.665995, 2.142030, -1.920854, 1.868884, -0.806043, 2.068297, -2.156287, -3.521131,
           -0.269754, -0.772434, -2.252404, -3.000568, -1.264859, -1.184152, -3.911526, -2.771993, -1.704024, -1.283500,
           1.677319, 2.097994, 1.689933, 1.505089, 0.863970, 2.996578, 1.673058, -0.745583, 3.487109, -0.824458,
           1.381353, -3.465814, 2.651172, 2.624724, 1.840367, 1.040775, 2.876431, -2.394310, 1.983140, 3.183923,
           -2.101012, -2.627535, -3.254790, 3.766699, -0.949419, 1.958254, -1.060783, 1.237023, 1.274874, 0.407495,
           0.503372, 2.416847, 2.632397, -0.801946, 0.329869, -0.288032, 1.103806, -2.788615, -0.713854, -1.752096,
           2.983503, 3.555573, -2.456676, -1.899423, -0.708018, 1.273959, -1.583158, 3.361932, 2.117032, -1.990728,
           -1.733820, 1.038522, -1.745656, -0.218779, -1.739280, 1.833860, 2.118672, 2.061838, 0.019756, 1.584287,
           1.227965, -1.391854, -2.503486, 1.802931, 2.158777, -2.572438, -0.984730, 2.895946, -0.308754, 3.159313,
           -0.721446, 2.149923, -0.472762, 1.834751, 2.545459, 0.053324, 2.807220, 0.773513, -1.602337, 0.286774,
           -3.344333, -2.878847, -2.035091, 1.932945, -1.559926, 1.444525, 3.084513, -1.751229, 2.989344, 1.784287,
           2.789348, 3.160749, -2.704993, -1.632912, 2.643094, 0.504863, 2.692420, 2.774891, -3.834909, -0.571441,
           2.656081, 1.267203, -0.044471, 2.508458, -1.044857, 2.633808, -2.445012, -2.889431, -1.988728, -1.380662,
           -2.840809, 2.578969, -2.022190, 2.280931, 3.547560, -1.991216, 0.611862, -0.134411, 2.261291, -3.016682,
           -0.706773, -1.236459, -1.886653, -1.220431, 2.147475, 0.161180, 1.918132, -2.460029, -1.533349, -0.987542,
           1.676486, 2.669456, -2.135987, -2.746361, 0.899392, -3.592869, -1.308019, -2.240380, 0.588785, -1.871394,
           -3.295466, 2.012955, 3.082774, 2.053288, -2.574070, -1.496077, 1.433732, -3.017225, -2.215885, 0.843370,
           -3.016403, 1.621341, -1.365113, -1.900281, 0.323886, 2.746969, -2.974667, -3.346153, -2.089415, 2.930915,
           2.845285, -3.586033, 1.735161, -1.808566, 1.138027, -1.925050, -2.765596, 2.454029, -1.712716, 1.778169,
           0.290638, 1.973169, 3.053149, -2.238259, 3.061357, -4.248680, 1.631011, -3.018263, -0.555385, -0.462463,
           -1.587795, -2.006345, 4.227792, 2.735857, -1.682575, -3.761844, 1.996569, -1.174937, 3.119440, -3.130626,
           2.656590, -1.372897, 0.986578, 1.309878, 3.543229, -1.157690, -1.330046, 1.115436, -1.895683, 1.914011,
           0.653403, 2.513173, -2.451448, -2.215123, 1.203808, 1.638091, 0.982996, 1.117290, -3.877608, -0.838059,
           -1.926923, -2.162014, 1.681012, 2.538223, -1.815195, -2.620879, -2.890916, -0.247145, -2.528096, 2.678637,
           3.501194, -0.910126, -2.515218, 2.503411, 2.224211, 3.549967, 0.104368, 1.714371, 1.460410, 2.523000,
           -2.436436, -1.454491, 2.875255, 4.237248, -2.612677, 0.766314, -1.795850, 2.708739, -0.702435, 2.128824,
           3.110813, -2.317181, 1.121924, 1.383555, 2.475570, -0.779752, -0.178779, -1.262591, 1.602992, -2.783287,
           -2.231268, -2.752059, 2.204305, 3.066973, -3.167259, -2.770828, -1.500847, 1.066553, -4.084895, -2.215680,
           -0.799870, -1.030972, 1.676778, 2.236239, -2.008789, 1.642191, -1.282986, 1.160534, 3.202666, -2.240121,
           -1.756129, -1.679972, -3.486256, 2.498678, 0.523348, 1.289583, 2.579804, -1.954405, -2.568827, 2.044789,
           1.582406, 0.664792, -1.948099, -0.612021, -1.202401, -2.185299, -1.205108, 3.027776, 0.362953, 3.335011,
           -3.093792, -1.499573, -1.353485, -0.958062, 1.873346, 1.589520, -2.719866, 0.844298, 0.553346, -1.396893,
           -0.948406, -2.264660, -2.043051, 1.978461, 0.692640, 2.112411, 2.085303, -2.561557, 1.230615, 2.855199,
           0.041097, -1.054159, 2.931468, 1.536016, 0.846180, 3.120950, 2.600732, 1.610214, 2.103623, 1.938310,
           -1.011834, -4.003154, 1.937413, 2.188789, 1.429964, 2.188537, -1.387934, 1.561983, 2.250746, -2.498451,
           -2.276310, -1.875003, -1.255898, -2.496810, 1.678738, -3.718589, -1.942727, -2.651439, -1.292657, 3.061053,
           1.680197, 2.612378, -2.031059, -2.113599, -0.080841, -1.524951, 3.200605, 2.937764, -1.468946, 1.642629,
           -3.415868, -2.305864, -2.609077, 2.765638, 2.247648, -2.556504, -2.230460, -3.250807, 1.019340, -1.664907,
           -3.454238, 3.359924, 1.009868, 0.371949, 2.013641, 0.657430, 3.330519, -1.734371, 2.071526, -2.267924,
           2.522155, 1.524520, 0.700047, 1.617345, -1.153477, 2.003337, -1.880960, -1.009148, -1.340054, -1.178602,
           3.722066, -0.269597, 0.384001, -0.831415, -1.407908, 1.607404, 2.039268, 2.652527, 1.224878, -2.145503,
           -0.384722, -0.463555, -3.045283, -1.241569, -1.964671, 1.414532, 0.561492, 3.180245, -1.358150, -1.597117,
           1.965738, -2.966595, 1.274775, -1.101498, -2.837647, 2.332631, -1.026092, 1.255445, -2.476927, -2.818190,
           2.235439, -1.261035, 1.532716, 1.990000, 1.829452, 1.816145, 2.641496, -0.911943, 2.877437, -3.367937,
           -2.989032, 0.912668, 3.051917, -1.253819, 3.603187, 1.437392, 1.017239, 2.095202, -0.455775, -0.289840,
           -2.696251, -1.459932, -2.487491, 1.162565, -0.802040, 2.480393, 2.042427, -2.124126, 2.127006, -3.588102,
           -1.474272, 1.504706, 2.045997, 2.350724, -2.059993, -1.683259, 0.101557, 0.175242, 1.987049, -1.449340,
           -0.924529, -1.951911, 1.675900, -3.225854, 2.846902, -3.223362, -2.529847, 2.558161, 1.373392, -0.018173,
           1.707653, 2.031530, -2.122110, 1.977462, 1.358883, 2.401056, 1.712283, 1.728597, 1.733032, -2.524909,
           -3.145970, 2.943462, -4.427799, -1.088021, -2.475219, 2.086035, 1.918522, -1.163752, -0.222854, -2.013274,
           -2.150629, 2.386955, 2.856270, -1.386651, -3.095110, 3.973662, 2.610770, -1.787583, 2.547364, 1.212967,
           1.628352, -1.909523, 1.378706, 3.339602, 2.092524, -1.642686, -0.700787, -1.184865, -1.934946, 2.145848,
           1.509133, 0.474676, 1.210800, 1.489067, -2.533279, 1.630721, 3.932979, 2.355606, 1.321531, 0.792100,
           -1.905403, -0.925244, -1.019572, 0.733776, 2.503518, 1.311275, 2.233717, 1.966435, -3.618297, -1.754704,
           1.893749, 2.349999, 3.019776, -3.070058, -0.199342, 2.272960, -3.347963, -1.043580, -0.659945, 1.778838,
           2.904049, 1.071447, 1.196063, -2.022624, 2.815445, 1.880531, 1.656202, -2.196191, 1.788942, -2.532607,
           -2.380293, 1.481707, 1.020601, -0.478494, -1.423560, 1.204648, 0.820120, -0.599338, 2.577364, 1.521117,
           1.265886, -2.779096, 2.445361, 4.058877, -1.429926, -2.038250, 2.386954, -0.036540, 0.238897, 0.094489,
           3.456780, 0.581115, 1.659857, 0.752508, -0.622811, 1.267554, -2.874843, 0.962618, 3.251888, -1.588161,
           3.872537, 1.500786, 2.624611, -1.122033, 1.628492, 0.139582, 1.915869, -0.299646, 2.102168, -0.522416,
           2.085152, 1.076972, -1.722122, -0.956658, 1.855548, 3.179682, 1.094079, 0.879424, 2.323166, -2.907123,
           -0.772742, 1.697546, 1.973382, 1.970806, -0.656526, -0.395836, -2.029247, 2.082043, 1.626689, -1.912616,
           -3.057770, 1.583573, 2.646872, -0.790165, 1.699668, 3.138768, -1.840262, 1.606369, -0.732608, 1.724596,
           -2.247004, -1.909602, 2.698825, 1.727123, 1.081201, 4.152880, -1.362886, -1.487079, -1.978471, 1.412598,
           0.905220, -1.630111, 1.839285, -1.391340, 1.217752, -3.740949, 2.895154, 2.151017, 1.657728, 1.524535,
           2.427837, -2.299053, 1.612627, 3.452979, 0.449514, 1.731374, -0.197578, -0.104196, -3.636980, 2.822409,
           0.684268, 2.301590, 3.902038, -2.045352, -3.026093, 2.704098, 2.753957, -1.501098, -1.132262, -2.200256,
           -1.850113, -0.685051, 2.008857, -2.134747, -0.514172, -3.268467, 2.162663, -3.080551, 2.113761, -1.849215,
           -2.743979, -1.950658, -1.248656, -1.462107, -1.046541, 1.259339, -1.400852, 1.060126, 1.144824, -1.521169,
           -2.256542, 1.858830, -3.568131, -2.391653, -1.677451, 1.719615, -2.864586, 2.096830, -1.032802, 1.474053,
           1.561040, 1.805570, -3.090111, -1.828767, -3.029161, 3.041418, 2.390993, 0.975947, 2.809258, -2.723085,
           -2.597121, 2.614838, 2.262598, 3.622853, 2.329749, -1.659464, 1.301297, -2.014760, 1.045549, 1.255215,
           -1.541039, -1.971527, -2.189924, 2.729766, -2.182035, 3.320538, 3.104243, 1.103231, 2.065354, -1.320470,
           2.586435, 0.445749, 1.725336, -1.387393, -2.593109, 2.456733, 1.917309, 0.173241, 2.201764, -3.801591,
           -3.183938, 2.014181, -1.938043, 1.004074, -1.688781, 2.044506, -3.042680, -2.127858, 3.880427, -2.381766,
           -1.903289, -2.510927, 2.326919, -1.825587, -0.368494, -3.469325, -1.780372, -3.121017, 1.892748, 1.423022,
           -1.693006, -1.952158, -2.520380, 3.061820, -2.221389, -2.994998, 2.229918, 1.523661, -1.681898, -3.202030,
           0.364005, -2.330372, -2.365043, 1.398102, 1.660545, 1.716391, 1.471599, 0.268006, -2.898382, -1.354696,
           -1.050789, -1.807280, 2.343214, -1.356722, -2.270952, -2.066825, -2.227082, 2.553930, -1.799996, -2.169926,
           2.667824, -3.680713, -1.803600, -1.233569, -1.302097, -2.148825, -2.440952, 1.966171, -3.814328, -0.544073,
           -2.929843, -2.721617, 2.047698, -2.260715, 2.686240, 2.905366, -1.040912, 1.180207, -2.440471, -2.637381,
           -2.175975, -2.439167, -1.910896, -2.206967, -1.394156, -1.995448, 2.177515, 1.377205, -3.034531, -1.949782,
           0.991425, 0.207002, -0.813762, -3.745589, 0.916656, 2.965690, 1.228977, 3.587679, -2.353768, -3.022773,
           -1.422563, -2.581959, -2.547372, -2.587778, 4.248673, 1.028092, 1.129023, 1.782501, -2.489793, 0.497075,
           -2.554139, 1.900634, 0.243464, 2.912564, -2.644313, 2.039456, -2.878912, -3.323982, 2.812002, -3.257304,
           -3.069956, 3.280178, -0.623885, 1.731053, 1.925094, 1.650640, 2.873155, -1.664808, 2.409148, 1.169650,
           1.595256, 2.770785, -1.590129, -2.927469, 2.805683, -3.875011, -1.607116, -1.381215, 2.276720, -2.756542,
           -2.449870, 1.890895, -1.019133, 1.635178, 1.742706, -1.899650, 3.113678, 1.465075, 2.636538, 0.323433,
           1.812423, 1.082747, 2.321518, -3.116372, 2.252292, -0.106839, 2.935617, 1.507940, 3.880798, -1.906517,
           -2.667791, 2.035872, -2.072327, -1.036897, 2.099103, 2.530505, 0.064622, 2.101565, 3.119755, 3.730990,
           2.507281, 0.726461, 1.404367, 1.760949, -2.340885, -1.122224, 1.357721, -0.188408, -3.375624, 2.467815,
           -0.821259, -1.185684, 2.617281, 2.533635, -2.173641, 1.811575, -2.573689, 2.879128, 2.747769, -1.920675,
           -1.841745, -1.225295, 1.958239, -2.730254, 1.114713, -2.555092, -2.083167, -2.426680, 1.010485, 2.799348,
           2.566095, 2.890475, 0.147347, -0.760236, -1.489421, -1.314814, -2.980150, 1.534085, -2.276407, 3.590581,
           3.601202, -0.789668, 2.171573, -2.750087, -3.224131, 1.478317, -1.959709, -2.507650, -2.326131, -2.248574,
           1.652298, -3.183402, -2.090833, -0.830816, -2.084865, -2.212865, -1.939956, 2.819871, 0.775969, 2.742243,
           -2.476381, -0.427272, -2.404830, 1.372455, 3.074879, 1.460120, 2.045815, 1.710358, 1.072805, 2.354649,
           -1.366847, -2.653828, 2.634523, 2.391697, -1.304283, 3.126756, 0.938851, -1.133889, -3.172457, 2.011568,
           1.789624, -2.596860, -3.251137, 1.232674, 3.807226, -0.142759, -2.793087, 3.026400, 1.425079, -3.056020,
           3.024061, -0.012702, -1.426440, -2.299399, 2.679586, -2.645583, 2.640927, -0.854329, -0.423547, 1.249414,
           3.217966, -2.233380, 1.230428, 1.018724, -2.613440, -1.376087, -2.364708, 1.179569, -1.507734, -1.578202,
           -1.906343, 2.529748, 1.946216, -2.057787, 2.160633, 2.393678, 0.941085, 3.447524, -2.223019, -1.926390,
           2.789044, 2.090527, -1.750833, -0.916612, -2.167511, -2.197608, 3.518711, 0.117941, 3.314738, -0.261300,
           2.772515, -1.902595, 1.011472, -1.510592, 4.102248, 1.858102, -3.013837, 2.777628, 0.802631, -1.133497,
           -2.030380, 2.414044, 2.961292, -1.122745, 2.858882, 2.013592, -4.086101, -3.348834, 2.067935, -1.722473,
           -2.429203, -0.539715, -2.260758, -2.283805, 2.343634, 1.442928, -1.549490, 2.107345, 1.683909, 1.311207,
           1.244736, 1.590974, -2.302538, -0.504690, 0.131088, -2.807014, -0.050955, -1.505996, -2.772693, 0.051824,
           2.571100, -2.482574, -1.774004, -3.068449, 1.748555, 1.385518, 2.234368, 2.478405, -1.478227, -2.713689,
           2.826515, 1.357376, -1.926322, -2.999397, 1.644603, -0.940620, 1.764513, -2.183435, 0.310276, -2.807745,
           -0.667474, -3.890212, 1.323989, -2.073735, 2.999115, 1.155217, 1.088126, 2.793925, -1.878232, 2.417621,
           -1.695638, 1.982638, 2.289784, -2.343246, 2.529349, -1.976534, 0.828253, 2.251504, -0.288592, 1.771200,
           -1.339145, 3.333491, -1.769076, 1.295877, -1.578990, 2.405816, -3.089753, -0.229945, -0.709227, 1.342979,
           0.533641, -3.717159, -1.408698, 1.809533, 1.736134, -1.367732, 0.851139, -1.884806, 2.222303, -1.963390,
           4.072129, 2.023987, -2.659343, 2.696947, -1.915247, 1.607457, 2.645820, -2.373246, -0.862001, -2.095094,
           2.178853, 3.161566, -0.959629, -1.619108, -1.935222, 0.985282, -2.359032, -1.070976, -1.956629, -2.269207,
           -1.760378, -0.172075, -0.640588, -1.837571, 0.907896, -1.427950, -2.169390, -1.580227, 1.640804, -2.309553,
           3.282720, 0.857451, 1.938621, -0.569998, 2.409535, 2.720355, 2.679846, -3.421999, -1.791438, 2.517671,
           2.515707, -2.905518, -2.550169, -2.631073, -1.820999, -3.538378, -1.698675, 3.287504, -3.254845, -1.388773,
           2.445014, 2.415839, -3.902222, 2.317639, -0.708103, -3.027259, 2.693275, 1.406264, 2.478577, -1.944904,
           -1.404859, 1.460645, -1.252558, -1.400710, 1.339673, 1.867337, -2.692440, 2.110911, 2.943665, -3.013961,
           1.991599, -2.353540, -3.493532, -2.492345, -1.329133, -2.905004, 1.992421, 2.874483, -0.060609, 3.210583,
           0.804042, 2.773052, 2.511267, -2.808511, -1.629223, 1.473077, -2.198113, 1.631278, 0.332629, 1.793892,
           1.541526, 0.850940, -3.538892, -2.115560, 3.206196, -2.906124, 2.784336, 2.701899, -1.963687, 3.181177,
           1.628625, -3.097112, -2.125948, 1.749168, -0.626160, 1.051468, 1.542275, -1.622128, 3.529848, -0.542989,
           1.539585, -2.135660, -2.254658, -2.756848, 2.033935, -2.690026, 2.076719, 1.930215, -1.432759, -2.331392,
           -2.836105, 1.822159, 2.714254, -2.551400, 1.267137, 2.887934, -0.607433, 0.433174, 2.768927, -1.176761,
           2.670307, 1.210578, -2.521508, 1.959440, 1.357243, -1.553964, 1.661684, -3.230291, 2.222438, -2.094429,
           -3.342181, 3.773840, 1.483385, -2.917944, -1.080674, -3.476276, 2.458532, -3.012860, -1.029954, -3.466995,
           3.066798, 3.180544, -1.260074, 2.052476, 2.058693, 1.412535, 2.042566, -1.417055, 2.071752, -3.275851,
           3.371260, 1.472370, -2.481537, 1.132915, -0.882766, -1.018633, -0.122498, -1.870009, -3.878094, 3.060409,
           3.167488, -1.287372, 3.485487, 2.005032, -1.727518, -2.596102, -0.906370, -1.924628, 2.210301, 2.206924,
           2.011876, -1.810023, -3.647074, 0.226653, -0.666710, 2.182381, -1.830187, -1.294933, -3.449082, -3.459905,
           0.787611, -1.373900, 2.279245, -2.341393, 2.105182, -1.035946, -1.696141, -2.343510, 0.594909, -4.078457,
           -1.007432, -1.760127, -1.352451, 1.635741, 1.660901, -5.253726, -4.339556, 1.648772, 2.514305, -4.270340,
           -0.477382, -1.341217, 2.095105, -2.202767, 2.492185, -0.605620, 2.253492, -2.708673, -1.210859, -1.264336,
           -2.739044, -2.514983, -2.063197, -2.725306, 1.313195, -2.492294, -2.590273, 3.162512, 0.720821, -1.917548,
           -0.069829, -2.449901, 0.922905, -2.579913, -2.229475, 2.081909, 1.685102, 2.032945, 2.411472, 1.110803,
           1.287032, -1.800894, -0.162759, 1.636579, 0.961328, 1.092075, 2.969327, -1.351013, 2.589923, -1.377353,
           0.996508, 2.709122, -0.168473, 1.654067, 1.460741, 1.829650, -0.354376, 1.402976, -1.449987, -1.818763,
           1.875077, -0.647253, 3.109682, 1.523329, 2.727475, 2.324979, 2.657378, -1.320847, -1.022317, -1.876032,
           2.268239, 3.215977, -3.002481, -3.098300, 2.752852, 1.493405, 0.732178, 2.422790, 1.398197, -2.980549,
           -1.162086, -1.114714, -2.402670, -0.642334, 3.019263, 2.898386, -2.497334, 2.675141, 3.834480, 0.283309,
           -2.799669, -1.880166, 1.782868, -2.348387, -1.081786, 1.626396, 1.863375, 1.409884, 2.863981, -2.982238,
           3.322926, 1.751966, -3.586918, -1.715961, 2.597501, -0.813666, 3.724152, -1.769607, 1.577445, 1.734972,
           3.234480, 1.341735, 2.359509, -0.759517, 1.821554, -1.795442, 1.785697, -1.284736, 0.843976, 3.438354,
           -1.508449, 2.298157, 1.448348, 2.534223, 0.857379, 3.014215, 1.109839, 1.427908, 1.677091, -1.791251,
           2.761982, 3.276131, -1.421947, 1.973993, -2.073256, 0.081727, 1.726163, -1.735859, 1.128659, -2.478742,
           -1.950826, -2.357996, -0.778870, -1.437241, -2.071543, -2.531892, 1.148446, 1.905936, -1.255900, -1.675239,
           1.880016, 2.021873, -0.892122, 2.208059, 2.460006, 1.004999, 0.367888, 1.187854, 2.039372, 1.910197,
           2.158995, 3.518512, -1.724643, 1.638412, -2.005299, -2.212373, 2.447844, 0.397378, 2.050473, -2.642862,
           2.607569, -2.184885, -1.670279, 1.496614, 2.285225, -2.622711, 2.042947, -2.957988, -2.341210, -1.735574,
           -1.773357, -1.566432, 3.915270, -1.255051, 1.353227, 3.724154, 1.172459, -2.403379, -2.200926, 0.363677,
           -2.309512, -1.395103, -1.502208, 2.518210, -1.283686, 2.708022, -1.740296, 0.923997, 0.773422, -0.131620,
           1.773980, -0.269811, 0.183897, 1.915525, -1.229345, -3.087660, 0.792691, 2.481514, -2.189286, -3.712890,
           2.940000, 2.903189, -3.079679, -3.025028, -1.736119, 1.786585, 2.668249, -0.614969, 3.552960, -2.101464,
           2.936386, -1.296545, -3.023390, -1.753901, -3.391382, 0.600559, -0.745961, 2.480260, 2.479988, -3.435855,
           1.281786, 2.270524, -1.584174, -3.443121, 1.302365, 2.241525, -1.660808, 2.644724, 1.314256, 3.983894,
           -0.426199, -1.772490, 0.591734, -1.622003, 2.468610, 2.465739, 0.602845, 0.940881, 2.967753, -3.822462,
           -1.386093, -1.969588, -1.705097, -2.946286, -0.492366, -4.659410, 0.294724, 2.098265, 1.067939, 4.700223,
           -0.920805, 2.683874, 1.181029, 1.973992, 2.382326, 3.549289, -1.746198, -0.821768, 1.814538, -2.891805,
           -0.177579, -1.793678, -4.024991, 0.313701, -1.574453, 3.861285, 1.898078, 0.843075, -2.798650, -1.785200,
           1.854138, -1.482099, 3.495950, 3.016920, 2.224436, 1.064672, 1.818012, -2.870300, -1.707929, -2.077286,
           -1.356386, 2.198681, 2.882847, 2.707654, -1.963048, -0.887081, 0.807061, -2.064263, 2.536914, -2.913502,
           -2.490679, -1.446021, -3.552437, 1.162490, 0.322815, 1.543255, 1.505770, 3.848902, -1.045443, -2.894843,
           2.095024, -2.690402, 3.221644, -0.845952, -2.433279, 2.771628, 2.085947, -1.090277, 0.027413, -1.868122,
           -2.375392, -0.729320, 2.401793, -4.433709, 1.869039, -1.262787, 1.561552, 2.021197, -1.674812, 0.029895,
           -1.508830, 0.839817, -2.626237, 1.924164, -3.811078, -1.043805, 2.322544, -1.602230, -0.445822, -2.480247,
           1.030805, -1.210103, 2.153720, -4.088655, -2.489001, 0.879104, -1.629537, 2.642581, -1.851964, 3.494615,
           1.518972, 2.296899, 4.080022, 1.252642, 1.744437, 2.025400, 1.862935, 0.580678, 3.963881, -0.733546,
           -2.748560, 1.994599, 3.080398, 2.375790, 2.532246, 2.810232, 2.508183, 2.313961, -2.099401, -3.091916,
           2.019967, 1.819783, -2.753518, -1.914094, 1.682119, 3.030009, -1.661555, 2.438501, 2.519207, 2.217719,
           0.993304, 3.483106, -0.928109, 1.495504, -1.372621, 2.613511, -2.348241, -1.023438, 2.757980, -2.676336,
           -2.896115, -0.911836, -2.215689, 1.488054, -1.664849, 2.239791, 1.783322, 1.032046, 1.025715, 3.006090,
           -2.014592, 3.271292, 1.391766, -1.374388, 2.854857, 2.503932, -2.657061, -1.078707, -3.142032, -1.878267,
           1.740853, -0.610554, 2.265561, -2.716567, -0.869853, -0.406491, -1.065406, -3.027299, -0.713546, -1.810725,
           0.310655, -2.518922, 2.547758, 1.593309, 0.843366, 2.141151, 2.797825, -1.478423, 1.373347, 2.873124,
           -2.304357, -3.114002, 3.435001, 2.892095, -1.599732, 1.911249, 1.821042, -2.152136, 2.823815, 2.994064,
           3.117734, -2.070862, -1.377995, -1.641925, -1.262327, -2.439582, -2.453823, 1.570119, 3.278329, -3.224550,
           -1.888793, 1.723205, -0.622067, 3.061603, 1.852544, 2.136032, -2.062354, -0.786058, 0.718736, 2.756834,
           -2.581109, -3.036709, 2.214369, 2.247189, -2.623133, 0.589757, -3.383614, 0.544413, -2.101992, -1.995428,
           -1.619745, 2.533802, -2.056041, 2.241325, -0.995659, 2.320552, -1.140710, 1.148324, 1.250768, -1.575281,
           -1.575281, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0 };
#43 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/ldpc4096_45_info.h" 1

char Info_4096_45[] = {
          0, 1, 1, 1, 1, 0, 0, 0, 1, 1,
           0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
           1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           0, 0, 1, 1, 1, 0, 1, 0, 0, 1,
           1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 0, 1, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 0, 1, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 1, 1, 1, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 1, 1, 0, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 1, 1,
           0, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 1, 1, 1, 0, 0,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           1, 1, 1, 0, 0, 1, 0, 0, 1, 0,
           0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
           0, 1, 0, 0, 1, 1, 1, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 0, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 1, 0, 0, 1, 0, 0, 1, 1, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 1, 0, 0, 0, 1, 1, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 1, 0, 1, 1, 0, 0, 0,
           1, 0, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 1, 1, 1, 0, 0, 1, 1, 0,
           0, 1, 1, 1, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 0, 0, 0, 1, 1, 0, 1,
           1, 0, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 0, 0, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
           0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           1, 1, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 0, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 1,
           0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
           1, 1, 0, 0, 0, 1, 0, 0, 1, 1,
           0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
           0, 1, 1, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 0, 0, 1, 0, 0, 1,
           1, 1, 1, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 1, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 1, 0, 0, 1, 1, 0, 1, 1, 1,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 0, 0, 1, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
           1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
           0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 0,
           0, 1, 1, 0, 0, 0, 0, 1, 1, 0,
           1, 1, 1, 0, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 1, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 1, 1, 0, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           1, 1, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 0, 0, 0, 1, 1,
           0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
           1, 0, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 1, 0, 0,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 0,
           1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
           0, 1, 1, 0, 0, 1, 1, 1, 0, 1,
           0, 1, 0, 0, 0, 0, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 0, 1, 0, 1, 0, 1, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 0, 0, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
           0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 1, 1,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 1,
           0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 1, 1, 0, 1, 1, 0, 0, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
           1, 1, 0, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 1, 1, 1, 0, 1, 0, 0, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 0, 1, 0, 1, 1, 0, 0, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 0,
           1, 0, 0, 1, 1, 0, 0, 1, 0, 0,
           1, 0, 1, 1, 0, 1, 1, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 0, 1, 0, 0, 1, 1, 1,
           1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
           0, 1, 1, 1, 0, 0, 0, 1, 0, 0,
           1, 0, 0, 0, 0, 1, 0, 0, 1, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 0, 0, 0, 1, 1, 0,
           0, 1, 1, 0, 0, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 0, 1,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 0, 0, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 1, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
           0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 0, 0, 0, 1, 1, 1, 1, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 0, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 0, 1, 1,
           1, 1, 1, 0, 1, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 1,
           1, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 1, 0, 0, 1,
           1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           0, 0, 0, 1, 1, 0, 0, 0, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 0, 1, 1, 0,
           0, 1, 0, 1, 1, 0, 0, 0, 1, 1,
           0, 0, 1, 1, 0, 0, 1, 1, 0, 1,
           0, 1, 1, 0, 1, 0, 0, 0, 1, 1,
           0, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 0, 0, 0, 0, 1, 0, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 0, 1,
           0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
           1, 0, 1, 0, 0, 0, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           0, 1, 0, 0, 0, 0, 1, 1, 0, 0,
           1, 0, 0, 0, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 0, 0, 0, 0, 1,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 0,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 1, 0, 0, 1, 1,
           1, 1, 1, 1, 1, 1, 0, 1, 0, 0,
           1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 1, 1, 0, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           1, 0, 0, 1, 0, 1, 0, 0, 0, 0,
           0, 1, 1, 0, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
           1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
           0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
           1, 0, 0, 0, 0, 0, 1, 1, 0, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 1,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
           1, 0, 1, 1, 0, 1, 0, 0, 0, 1,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 1, 1,
           1, 0, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 1, 0, 0, 1, 1, 0, 1, 0,
           0, 1, 0, 1, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 0, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 0, 0, 1, 1, 1, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 0, 0, 1, 0, 1, 1, 1,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
           1, 0, 1, 1, 0, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 1, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 1, 0, 0, 1, 0, 0, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 1,
           0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 0, 1, 1, 0, 1,
           1, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
           0, 1, 1, 0, 1, 1, 0, 0, 0, 1,
           0, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           1, 1, 1, 0, 1, 1, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
           0, 1, 0, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 1, 0, 1, 1, 0, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
           1, 0, 1, 1, 0, 0, 1, 1, 1, 1,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 0, 1, 1, 0, 1, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 1,
           0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
           0, 1, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 1, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 0, 1, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 1, 1, 1, 0, 1, 1,
           1, 1, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 0, 0, 1, 0,
           0, 1, 0, 0, 1, 1, 1, 1, 1, 1,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 1, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 0, 1, 0, 1, 0,
           0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 0, 1, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 1, 0, 0, 0, 0,
           0, 1, 0, 0, 1, 0, 0, 1, 1, 1,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 1,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
           1, 1, 0, 0, 1, 0, 0, 1, 0, 0,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 1, 1, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 1, 0, 0, 0, 0, 1, 0,
           1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 1, 0, 0, 0,
           0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
           1, 0, 1, 0, 0, 0, 1, 0, 0, 1,
           1, 0, 0, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 1, 0,
           1, 1, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 1, 0, 0, 1, 1, 1,
           0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 0, 1, 0, 0,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 1, 0, 1, 0, 0, 0,
           1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 1, 1, 0, 0, 1, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 1,
           0, 0, 0, 1, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 1, 1, 0, 1,
           1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
           0, 1, 0, 1, 1, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 1, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 0, 0,
           0, 1, 0, 1, 1, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 0, 0, 1,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 0, 1, 0, 1, 0,
           0, 0, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 0, 1, 1, 1, 0, 0, 1, 0, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
           0, 0, 1, 1, 0, 1, 0, 1, 0, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 0, 0, 1,
           1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
           0, 0, 0, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
           0, 0, 1, 1, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 0, 1, 0, 1, 1, 0, 1,
           0, 0, 0, 1, 1, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 0, 0,
           1, 1, 1, 0, 0, 1, 1, 1, 1, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 1, 1, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
           0, 0, 1, 0, 1, 0, 0, 1, 1, 1,
           1, 1, 0, 1, 1, 1, 1, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 1, 0, 0, 0,
           0, 1, 1, 0, 0, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
           1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
           0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
           1, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 1, 1, 0, 0, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 1, 1, 0,
           1, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
           0, 1, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 0, 0, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 1, 0, 1,
           1, 1, 0, 0, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 1, 1, 0, 1, 0, 1, 1,
           0, 0, 0, 1, 0, 1, 1, 1, 1, 0,
           1, 1, 1, 0, 0, 1, 1, 1, 1, 0,
           0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 0, 0, 0, 0};
#44 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/ldpc4096_45_code.h" 1

char Code_4096_45[] = {
          0, 1, 1, 1, 1, 0, 0, 0, 1, 1,
           0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 1, 0, 1, 0, 1, 1, 0, 1,
           1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           0, 0, 1, 1, 1, 0, 1, 0, 0, 1,
           1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 0, 0, 0, 1, 0, 0, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 0, 1, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 0, 1, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 1, 1, 1, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 1, 1, 0, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 1, 1,
           0, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 1, 1, 1, 0, 0,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           1, 1, 1, 0, 0, 1, 0, 0, 1, 0,
           0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
           0, 1, 0, 0, 1, 1, 1, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 0, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 1, 0, 0, 1, 0, 0, 1, 1, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 1, 0, 0, 0, 1, 1, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 1, 0, 1, 1, 0, 0, 0,
           1, 0, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 1, 1, 1, 0, 0, 1, 1, 0,
           0, 1, 1, 1, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 0, 0, 0, 1, 1, 0, 1,
           1, 0, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 0, 0, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
           0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           1, 1, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 0, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 1,
           0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
           1, 1, 0, 0, 0, 1, 0, 0, 1, 1,
           0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
           0, 1, 1, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 0, 0, 1, 0, 0, 1,
           1, 1, 1, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 1, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 1, 0, 0, 1, 1, 0, 1, 1, 1,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           1, 0, 0, 0, 1, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 0, 1,
           1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
           0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 0,
           0, 1, 1, 0, 0, 0, 0, 1, 1, 0,
           1, 1, 1, 0, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 1, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 1, 1, 0, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           1, 1, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 0, 0, 0, 1, 1,
           0, 1, 1, 0, 1, 1, 0, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
           1, 0, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 1, 0, 0,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 0,
           1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
           0, 1, 1, 0, 0, 1, 1, 1, 0, 1,
           0, 1, 0, 0, 0, 0, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 0, 1, 0, 1, 0, 1, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 0, 0, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
           0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 0, 0, 0, 0, 1, 0, 1, 1,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 1,
           0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 1, 1, 0, 1, 1, 0, 0, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
           1, 1, 0, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 1, 1, 1, 0, 1, 0, 0, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 1, 0, 1, 0, 1, 0, 0, 1,
           0, 0, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 0, 1, 0, 1, 1, 0, 0, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 0,
           1, 0, 0, 1, 1, 0, 0, 1, 0, 0,
           1, 0, 1, 1, 0, 1, 1, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 0, 1, 0, 0, 1, 1, 1,
           1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
           0, 1, 1, 1, 0, 0, 0, 1, 0, 0,
           1, 0, 0, 0, 0, 1, 0, 0, 1, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 0, 0, 0, 1, 1, 0,
           0, 1, 1, 0, 0, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 0, 1,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 0, 0, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           1, 1, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
           0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 0, 0, 0, 1, 1, 1, 1, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 0, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 1, 1, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 0, 1, 1,
           1, 1, 1, 0, 1, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 0, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 1,
           1, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 1, 0, 0, 1,
           1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           0, 0, 0, 1, 1, 0, 0, 0, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 0, 1, 1, 0,
           0, 1, 0, 1, 1, 0, 0, 0, 1, 1,
           0, 0, 1, 1, 0, 0, 1, 1, 0, 1,
           0, 1, 1, 0, 1, 0, 0, 0, 1, 1,
           0, 1, 1, 1, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 1, 0, 1, 0, 0, 1, 1, 0,
           1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 0, 0, 0, 0, 1, 0, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 0, 1,
           0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
           1, 0, 1, 0, 0, 0, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           0, 1, 0, 0, 0, 0, 1, 1, 0, 0,
           1, 0, 0, 0, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 0, 0, 0, 0, 1,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 0,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 1, 0, 0, 1, 1,
           1, 1, 1, 1, 1, 1, 0, 1, 0, 0,
           1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
           0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 1, 1, 0, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           1, 0, 0, 1, 0, 1, 0, 0, 0, 0,
           0, 1, 1, 0, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 0, 0, 1, 1, 0, 0, 0,
           1, 0, 0, 1, 0, 1, 0, 1, 0, 1,
           0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
           1, 0, 0, 0, 0, 0, 1, 1, 0, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 1,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
           1, 0, 1, 1, 0, 1, 0, 0, 0, 1,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 0,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 1, 1,
           1, 0, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 1, 0, 0, 1, 1, 0, 1, 0,
           0, 1, 0, 1, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 0, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 0, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 0, 0, 1, 1, 1, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
           0, 0, 0, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 0, 0, 1, 0, 1, 1, 1,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 1, 1, 0,
           1, 0, 1, 1, 0, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
           1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 1, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 1, 0, 0, 1, 0, 0, 1,
           1, 1, 1, 1, 1, 0, 0, 1, 1, 1,
           0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
           1, 0, 0, 1, 0, 0, 1, 1, 0, 1,
           1, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           1, 0, 0, 1, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
           0, 1, 1, 0, 1, 1, 0, 0, 0, 1,
           0, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           1, 1, 1, 0, 1, 1, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 1, 1, 0, 0,
           0, 1, 0, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 1, 0, 1, 1, 0, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
           1, 0, 1, 1, 0, 0, 1, 1, 1, 1,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 0, 1, 1, 0, 1, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 1,
           0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
           0, 1, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 1, 0, 1, 1, 1, 0, 0, 1,
           0, 1, 1, 0, 0, 0, 1, 1, 1, 0,
           1, 0, 0, 0, 1, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 0, 1, 1, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
           0, 1, 0, 0, 1, 1, 1, 0, 1, 1,
           1, 1, 0, 1, 0, 1, 0, 1, 0, 0,
           1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 0, 0, 1, 0,
           0, 1, 0, 0, 1, 1, 1, 1, 1, 1,
           0, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 1, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 0, 1, 0, 1, 0,
           0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
           1, 0, 1, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 1, 0, 0, 0, 0,
           0, 1, 0, 0, 1, 0, 0, 1, 1, 1,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 1,
           0, 1, 1, 1, 1, 0, 1, 1, 0, 1,
           1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
           1, 1, 0, 0, 1, 0, 0, 1, 0, 0,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 1,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
           1, 1, 1, 1, 0, 1, 1, 0, 1, 1,
           0, 1, 0, 1, 0, 0, 0, 0, 1, 0,
           1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 0, 1, 1, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 1, 0, 0, 0,
           0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 0, 1, 1,
           1, 0, 1, 0, 0, 0, 1, 0, 0, 1,
           1, 0, 0, 1, 1, 0, 1, 0, 1, 1,
           1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 1, 0,
           1, 1, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 0, 0, 1, 0, 0, 1, 1, 1,
           0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
           0, 1, 1, 1, 0, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 0, 1, 0, 0,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 1, 0, 1, 0, 0, 0,
           1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
           0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 1, 1, 0, 0, 1, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 0, 1, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           1, 1, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 1,
           0, 0, 0, 1, 0, 1, 0, 1, 1, 1,
           1, 1, 1, 0, 1, 0, 1, 0, 0, 0,
           1, 1, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 1, 1, 0, 1,
           1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
           0, 1, 0, 1, 1, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 1, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 0, 0,
           0, 1, 0, 1, 1, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 0, 0, 1,
           0, 1, 0, 0, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 1, 0, 0, 1, 0, 1,
           0, 1, 1, 0, 1, 0, 1, 0, 1, 0,
           0, 0, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 0, 1, 1, 1, 0, 0, 1, 0, 1,
           1, 1, 0, 0, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
           0, 0, 1, 1, 0, 1, 0, 1, 0, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
           0, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 0, 0, 1,
           1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
           0, 0, 0, 0, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
           0, 0, 1, 1, 1, 1, 0, 1, 1, 0,
           0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
           1, 1, 0, 0, 1, 0, 1, 1, 0, 1,
           0, 0, 0, 1, 1, 0, 0, 0, 1, 0,
           0, 1, 1, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 0, 0, 0,
           1, 1, 1, 0, 0, 1, 1, 1, 1, 0,
           0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 0,
           0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
           0, 0, 0, 1, 0, 1, 1, 0, 1, 0,
           0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
           0, 0, 1, 0, 1, 0, 0, 1, 1, 1,
           1, 1, 0, 1, 1, 1, 1, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 1, 0, 0, 0,
           0, 1, 1, 0, 0, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
           1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
           0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
           1, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           0, 1, 1, 0, 0, 1, 1, 0, 1, 1,
           1, 0, 1, 1, 0, 0, 1, 0, 1, 0,
           1, 1, 1, 1, 0, 1, 0, 1, 1, 0,
           1, 1, 1, 0, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
           0, 1, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 1, 1, 0, 1, 1, 0, 1, 0, 1,
           0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
           1, 0, 1, 0, 1, 0, 1, 1, 1, 1,
           1, 0, 1, 1, 1, 1, 0, 1, 0, 1,
           1, 1, 1, 0, 0, 1, 1, 0, 0, 0,
           0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 0, 0, 1, 0, 1, 1, 0,
           0, 1, 0, 0, 0, 1, 0, 1, 0, 1,
           1, 1, 0, 0, 0, 1, 1, 1, 1, 0,
           0, 1, 1, 1, 1, 0, 1, 0, 1, 1,
           0, 0, 0, 1, 0, 1, 1, 1, 1, 0,
           1, 1, 1, 0, 0, 1, 1, 1, 1, 0,
           0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
           0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
           1, 0, 0, 1, 1, 1, 1, 1, 0, 0,
           0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
           0, 0, 1, 0, 1, 1, 0, 1, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
           1, 0, 0, 0, 1, 1, 1, 1, 0, 0,
           0, 0, 0, 0, 1, 1, 1, 1, 0, 1,
           0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           0, 1, 0, 1, 1, 1, 1, 0, 1, 1,
           1, 1, 0, 0, 1, 0, 0, 0, 1, 0,
           0, 1, 0, 1, 1, 0, 1, 1, 1, 1,
           1, 1, 1, 0, 1, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 0, 1, 1, 1,
           1, 1, 1, 1, 0, 0, 1, 1, 0, 1,
           0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
           0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
           1, 1, 1, 0, 0, 0, 0, 1, 0, 1,
           1, 0, 1, 0, 0, 1, 0, 0, 0, 0,
           1, 0, 0, 0, 0, 0, 0, 1, 1, 1,
           0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
           1, 0, 0, 1, 1, 0, 0, 1, 1, 0,
           1, 1, 0, 0, 1, 0, 1, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
           0, 1, 1, 0, 1, 1, 1, 1, 0, 0,
           1, 1, 0, 0, 0, 0, 1, 0, 1, 1,
           1, 0, 1, 0, 1, 1, 0, 1, 1, 0,
           0, 1, 1, 0, 1, 1, 0, 0, 1, 0,
           0, 0, 0, 0, 1, 1, 0, 1, 1, 1,
           1, 1, 0, 0, 1, 0, 0, 0, 0, 1,
           1, 0, 0, 0, 1, 1, 1, 1, 0, 0,
           1, 1, 0, 0, 1, 0, 1, 0, 1, 0,
           0, 0, 1, 0, 1, 1, 1, 1, 0, 1,
           0, 1, 1, 0, 1, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 0, 1, 0, 0, 0, 1,
           1, 0, 0, 1, 1, 0, 1, 0, 1, 0,
           1, 1, 0, 1, 0, 1, 1, 0, 0, 0,
           1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
           0, 1, 0, 0, 1, 0, 0, 0, 1, 0,
           1, 1, 1, 0, 1, 1, 1, 0, 0, 1,
           1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
           1, 1, 0, 1, 0, 0, 1, 1, 1, 0,
           0, 1, 0, 0, 1, 1, 0, 1, 1, 0,
           1, 0, 0, 0, 0, 0, 1, 1, 0, 1,
           1, 1, 1, 0, 0, 1, 0, 1, 1, 1,
           1, 1, 0, 0, 1, 0, 1, 1, 0, 1,
           1, 0, 0, 1, 0, 1, 1, 0, 1, 0,
           1, 0, 0, 0, 1, 0, 1, 1, 0, 0,
           0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
           1, 1, 0, 1, 1, 0, 1, 0, 1, 0,
           0, 1, 1, 0, 0, 0, 1, 0, 0, 0,
           1, 1, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 0, 0, 0, 0, 0, 1,
           1, 0, 1, 1, 0, 0, 0, 0, 1, 1,
           1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
           1, 0, 1, 0, 1, 0, 0, 0, 1, 0,
           0, 0, 0, 1, 1, 0, 0, 1, 1, 0,
           0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
           0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
           0, 0, 1, 0, 0, 1, 1, 1, 1, 1,
           1, 0, 0, 1, 1, 1, 1, 0, 1, 0,
           1, 1, 0, 1, 1, 1, 0, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
           0, 0, 0, 0, 1, 1, 0, 1, 1, 1,
           0, 0, 1, 0, 0, 1, 1, 1, 1, 0,
           1, 1, 0, 0, 1, 0, 1, 0, 1, 1,
           1, 1, 1, 0, 1, 0, 1, 0, 1, 1,
           0, 1, 1, 1, 1, 1, 1, 1, 1, 0,
           1, 1, 0, 1, 0, 1, 1, 0, 1, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
           1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 0, 1, 0, 0, 1, 0, 1, 0,
           1, 0, 0, 1, 1, 0, 1, 0, 0, 0,
           0, 0, 1, 0, 1, 1, 1, 0, 0, 1,
           0, 0, 0, 1, 0, 1, 0, 1, 1, 1,
           1, 0, 1, 1, 0, 0, 1, 1, 0, 0,
           1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
           1, 0, 0, 0, 0, 1, 0, 1, 1, 0,
           1, 1, 0, 0, 1, 1, 0, 1, 1, 1,
           0, 0, 1, 0, 1, 1, 1, 1, 1, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
           0, 1, 1, 1, 1, 1, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 1, 1, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 0, 0,
           0, 1, 1, 1, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 1, 1, 0, 0,
           1, 0, 1, 0, 0, 1, 1, 0, 1, 0,
           0, 0, 1, 0, 1, 0, 1, 1, 0, 1,
           0, 1, 0, 1, 0, 0, 1, 0, 0, 0,
           1, 0, 1, 0, 0, 1, 0, 1, 0, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
           0, 1, 1, 1, 1, 1, 1, 1, 0, 0,
           1, 1, 0, 0, 1, 1, 0, 1, 1, 1,
           1, 1, 0, 1, 0, 1, 0, 0, 1, 0,
           0, 0, 0, 1, 0, 1, 1, 1, 1, 1,
           0, 1, 1, 0, 1, 1, 0, 0, 0, 0,
           1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
           1, 0, 1, 1, 1, 1, 1, 0, 1, 1,
           0, 0, 1, 1, 0, 1, 1, 0, 1, 1,
           1, 0, 0, 0, 0, 0, 0, 1, 1, 0,
           0, 1, 0, 1, 1, 1, 0, 0, 1, 1,
           0, 0, 1, 1, 0, 1, 0, 1, 0, 0,
           0, 1, 0, 1, 0, 1, 0, 1, 1, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0};
#45 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/ldpc1024_23.h" 1

ldpc_dbl code_1024_23[] = {
          -1.687400, 2.266100, -1.054700, -3.366100, 0.549110, 0.182910, -1.658000, 2.225800, 0.697540, 3.011100,
           -2.569600, -3.299000, -4.222900, 1.652700, 3.062100, -2.334200, 4.148900, -3.447500, -2.048400, -1.109200,
           1.275500, -1.198600, 2.178600, 2.612100, 0.945110, -2.439800, 1.350800, -0.334720, 1.263700, 3.321900,
           -4.341500, -1.484300, -1.359000, -2.713300, -4.719400, 1.336100, 3.027000, 0.170390, -0.423600, 2.710300,
           0.635570, -0.981350, 3.476400, 1.894400, -1.591400, 2.356500, 0.090437, 1.699900, 2.299500, -3.183600,
           -0.490930, -1.592300, -1.855300, 1.289700, 2.045700, -0.501230, -2.566600, 2.836100, -1.748700, -3.658900,
           -2.170000, -0.364460, -3.251300, -3.107300, 2.263000, -1.428600, 3.561300, 1.140700, -0.812270, 0.765510,
           2.176900, -1.886200, 2.762900, 0.667430, 1.689800, 3.564000, 4.099700, -1.785500, 2.472800, -0.353210,
           0.330370, -3.020200, -3.607500, 2.163900, -3.004300, -2.680700, -1.118200, -1.449600, -1.860400, 0.647660,
           1.429500, -4.293700, -0.565140, -0.611270, 1.432800, -1.997600, -4.075000, 2.388500, -1.755500, 1.445200,
           -1.975100, -1.197100, 1.666400, 1.057200, -0.690550, 2.230900, 3.157300, -2.602600, -3.666500, 1.166300,
           -0.507290, -1.862800, -1.947500, -1.027400, 1.228100, 1.494900, 2.043800, -2.951500, -2.052400, 2.192800,
           1.179600, 1.577900, -1.749800, -2.791600, -2.192800, -2.217500, 0.643690, -2.939900, -2.859900, -2.871000,
           1.490700, -0.397030, 2.255200, -2.695100, 3.200700, 0.627250, 2.228200, 3.691600, 1.671100, 2.285900,
           -1.742900, 3.440000, 3.347900, 0.853010, 0.173160, -2.815100, -1.347400, -1.238100, -3.422200, 1.784400,
           2.864900, -0.383910, -0.837430, 1.230100, 2.034400, -0.012486, 1.763000, 1.197600, 0.646890, -2.364200,
           3.202900, 0.773640, 1.076500, 2.361300, -1.721800, -2.562400, 0.975390, -1.114200, 1.751200, 1.755700,
           2.910000, 0.005522, 3.362600, 0.387310, -2.101500, 1.302500, 0.272850, 1.546500, -3.350600, -2.684900,
           -3.692600, 0.991700, -3.704300, -2.818600, -1.608500, -3.585800, 3.007500, 1.089500, 1.616900, 1.422700,
           -0.799300, 2.645300, 1.941200, -2.191400, -2.735000, -2.196400, 2.581400, -4.459100, -1.209700, -0.815060,
           -2.408700, 1.014300, 2.556000, -2.415800, -0.797160, -0.960260, 2.096400, -2.227900, 1.221000, -1.456500,
           2.822000, -2.307300, -1.888800, -2.685100, 3.871500, -4.313300, -1.322600, 0.708420, -3.603800, -2.855400,
           -3.183200, 2.811000, 3.484000, -3.086400, 2.988200, 1.431000, -1.959800, 1.725300, 0.662540, -1.434500,
           1.485000, -3.904400, -2.135800, 0.228230, -4.196400, 1.205700, 2.512700, -2.499800, -3.000900, 1.281800,
           1.845900, -2.908100, 3.262700, 2.888200, 1.353900, 2.921800, 0.586890, -1.595600, 1.761100, -2.711100,
           1.184600, -0.052448, 2.567400, -0.632000, 2.432000, -0.671340, 3.724500, 0.311660, 1.434100, 1.035000,
           0.708990, -0.457780, -2.828400, 2.308300, 1.184200, 1.642900, 3.838400, 3.692400, -2.390700, -4.183800,
           -1.064000, -4.615400, 2.583500, -2.364700, 1.501300, -2.764000, -1.078900, 1.892900, 2.404900, -0.635050,
           0.551390, -0.670930, 2.344800, -0.394960, 2.296200, -0.176330, 3.413400, 2.110500, 1.768500, 2.705200,
           1.656100, 3.532000, -0.039982, 1.506700, -0.575960, 1.345100, -2.012000, -3.211500, -1.601100, 2.299500,
           2.292200, -1.669500, 2.666100, 2.310900, 0.165670, 3.684200, -2.030600, -0.254570, -1.850300, -0.956970,
           0.714480, -1.801700, -2.534800, 2.225400, -1.835400, 1.974000, -3.657100, 4.104100, 2.703700, -0.122020,
           1.808700, 2.488800, 0.504430, 2.103600, 0.325140, -2.216200, -0.785160, -2.653900, -0.626990, -0.755440,
           -1.813700, -1.336300, 2.408400, 2.051100, -2.010300, 3.366000, 1.885200, 1.428000, -2.708800, -2.338900,
           2.756900, 3.797400, -2.375200, 2.842000, 1.434300, -1.556000, 1.254500, -3.149100, 2.518900, 1.535400,
           -2.252400, -2.331600, -1.973400, -2.188000, -3.787700, 2.543500, 3.084900, -3.087400, -1.481900, 2.026900,
           1.406500, -2.440000, -2.501100, 2.817900, 1.532300, -1.265400, 1.841100, -2.281500, 1.987700, 2.325200,
           -1.864200, -2.646100, 3.308300, 1.414800, 0.003164, 3.635900, -1.605100, 2.461600, 1.224700, 0.416820,
           1.840800, 1.459900, 1.418200, 2.683800, 1.726600, -1.321500, -0.742030, -3.183900, 1.924300, 3.227300,
           -3.796700, -2.564800, -2.055800, 1.759900, -1.462300, 2.972300, 2.222900, -3.453000, -2.904400, -3.135300,
           1.172900, 1.582900, 0.612900, -0.015952, -0.517340, -1.867800, -1.550100, -3.872400, 1.199000, -1.956800,
           -2.586000, 2.102600, 0.747060, 2.443500, -1.845500, 0.991950, 3.426500, 0.906470, -2.802300, 1.405100,
           -1.151300, 3.108800, 1.199600, 1.506900, -0.258180, 2.423300, 1.313100, 2.229300, -2.724000, 1.816100,
           1.273600, -0.996640, -2.420100, 1.785000, -5.073000, 0.191630, 2.468000, -2.261000, -2.446900, 1.285000,
           1.024400, -1.198900, -3.144400, -1.607900, -0.181840, -3.635700, 0.943020, 2.598600, 1.401400, 0.368090,
           -2.091500, -0.102480, 0.744770, -2.854900, -0.167430, -1.501500, 2.046100, -3.630000, -1.816600, 4.664000,
           -3.065400, -1.841400, 1.544400, 3.271400, 1.891700, -0.636940, 2.749300, 3.487800, 2.385700, -0.840680,
           -0.852910, 0.326070, 4.657300, 1.244900, 2.617400, 1.439400, -1.852000, 1.695900, -1.352300, 0.278920,
           -2.286100, 3.027200, -3.068600, -3.665000, 2.746400, -1.631600, -3.402400, -4.062100, 1.691300, -1.512900,
           2.131800, -2.675400, -2.927900, 2.882500, 2.685900, 1.759200, 0.613260, 4.891700, -3.695500, -0.831040,
           -2.316900, -1.605000, 2.570200, -2.049300, -2.125500, 4.075800, 0.997370, 0.689280, 3.741200, -2.597100,
           3.351900, 1.249700, 1.271000, 3.165200, 1.472000, -2.791200, -2.663300, 2.435000, -1.517300, 2.254000,
           2.716300, -1.618500, 0.455120, -3.105000, -3.066200, -0.622720, -1.276000, -1.288900, -1.070900, -1.194100,
           -2.900600, -2.419100, -1.544500, 1.236000, -0.637980, -3.621800, -2.440800, -2.028400, -1.667500, -3.896100,
           -2.306200, -0.251030, -2.256300, 0.184430, -1.457800, -0.397810, 3.043700, -2.604000, -0.431150, -1.912100,
           -1.487000, 3.514800, -2.155500, -2.768900, 0.131010, 1.842700, -2.876600, -2.805000, -1.474500, -0.803930,
           -2.434500, 2.886500, 2.760500, -2.236600, -1.382400, 1.497700, 1.804500, -1.149100, 3.170200, -2.065000,
           -2.315800, 1.094100, 2.400400, -2.833800, 2.994800, 2.436200, -2.384100, 0.962230, -1.697600, 3.021000,
           2.290300, -1.367400, 2.129000, -3.462000, -2.294700, -1.362000, -2.257200, 2.061100, -0.377560, 2.680600,
           2.660000, 1.848300, -2.461500, 0.453820, -3.588800, -2.585800, -1.415500, 4.014200, 1.743100, 2.030000,
           -2.675000, -1.982900, -1.971800, -1.342200, -3.066000, 0.465280, -0.243070, 4.341400, -2.385100, 2.782800,
           -2.755500, -2.635700, -2.716200, 2.661200, 2.410800, 2.386800, 2.514900, -1.312000, 1.889900, 2.503900,
           -1.514000, -0.059727, -0.555540, -3.505100, 0.880290, 1.947800, 2.625500, 1.756200, 1.254000, 2.764600,
           2.609100, -3.732900, -2.058900, -1.777600, -2.652200, 2.576100, 2.181600, -1.833800, -1.611100, 0.005414,
           -3.608800, -2.816300, 1.831400, -2.025600, -1.015700, -1.155700, 1.922800, 1.858800, -2.586400, -0.402970,
           -1.980000, 0.474960, -1.168000, 2.515500, -1.793600, 3.530900, -2.598000, 2.342800, 1.569100, -2.983000,
           -2.213400, -2.194100, -2.331200, 0.801300, 0.911450, -1.657600, 1.131300, -3.092300, 2.671800, 3.411100,
           -3.452300, -1.667800, 1.579600, -0.672820, 1.219300, -1.666700, -1.558100, -2.446900, -0.004204, -0.614000,
           -1.098200, -2.739900, 2.342400, -1.663400, 0.340390, 2.293000, -3.665400, -2.144400, -2.059200, -1.993600,
           -3.593000, 1.888500, 3.427300, -1.955100, -2.284300, -3.232000, 2.225100, 1.835900, 2.318600, -0.350970,
           2.148100, 0.848420, 1.516600, -1.764500, -2.681400, -2.107000, 1.807400, -1.227700, -0.276720, -3.673900,
           1.298400, 3.765800, 2.575100, -3.003800, 1.917500, -2.167900, -4.830000, 0.395200, 0.520580, 1.696500,
           1.933400, 1.711700, -1.974800, -1.780800, -1.943200, -0.789270, -1.911500, -1.763800, 1.710300, -3.716200,
           -1.283200, -3.340600, 1.840000, 2.181300, 2.561000, -3.932700, -1.686000, 0.435160, -1.668000, 0.959800,
           -4.642500, 0.804520, -1.449900, 3.223200, 2.658700, 2.798600, -1.853400, -1.883100, -2.694300, 1.829600,
           -1.702100, -1.857400, 1.958200, -1.544800, 3.814700, -0.896450, 1.786500, -3.346300, -0.169520, 0.827640,
           -3.484600, -0.901710, -1.150900, -1.226100, -1.791800, 1.244900, -2.500300, 2.985900, -2.704700, -2.091200,
           -2.051200, 1.952200, 4.117500, -1.945000, 0.384150, 1.184100, 2.704600, 0.747180, 0.757230, 3.425500,
           1.051400, -2.225900, 5.793900, 3.053500, -3.227700, -0.934790, -3.574800, -2.115300, 0.894810, -1.209000,
           -3.693800, 1.943900, 0.396140, -3.194100, 2.530900, 2.216200, 2.655300, -1.680700, 0.726320, -2.387600,
           -1.583400, 2.065700, -0.698120, -1.826400, 1.804000, -1.759600, -1.727000, 0.945310, -1.506700, 3.251900,
           -1.340000, -2.261600, 2.240300, -3.209200, -1.990100, 0.331050, -2.117000, 2.033800, -2.191500, -1.140300,
           -2.525600, 1.474300, -2.759100, -0.827800, -1.065900, -3.053800, 1.430400, -2.380600, 3.434100, 2.701500,
           -1.409200, 3.528000, -1.412600, 0.459670, 1.027700, 0.263650, 2.448100, -3.277300, -1.472300, -1.226200,
           1.086000, -1.375000, 0.890450, -1.864500, -0.799190, -1.843700, -1.701000, 2.320400, -1.075500, -0.305350,
           -2.342900, 3.445400, 1.977500, -0.572800, 2.376700, -0.369260, 1.428800, -2.397600, -3.805900, 0.764160,
           -3.611800, -1.225800, -2.143500, -4.185000, 3.087100, -2.608300, -1.771100, 2.475800, -1.889600, -2.379800,
           -1.035500, -2.966800, -1.063000, -0.249190, -2.018200, -2.381700, 2.781400, -1.509300, -1.833600, 3.313800,
           2.177900, 1.328800, 0.221040, 2.429500, -1.035700, 2.828400, 1.572600, 3.608900, -2.907600, -0.926520,
           -0.486890, -1.899700, -1.624700, 1.357700, -1.434700, -1.351500, 2.511900, 2.328700, 2.744200, -2.680200,
           -3.207800, 0.999800, -1.947600, 2.633000, -1.344000, -0.457580, -1.536900, -3.126400, -2.853800, 1.226200,
           -3.920800, -0.661530, -2.832500, 3.569800, 2.959600, -1.868900, -1.928300, -1.154900, -2.352600, -1.915900,
           3.184000, 0.908000, 1.057800, -2.624100, -1.091400, -2.865800, -0.803880, 1.307000, -1.601700, -2.832600,
           0.932280, 1.694800, -2.102500, -1.096100, -0.356590, -2.379200, 1.201500, -2.619900, -0.401180, -3.343400,
           2.160700, -0.983790, 2.055100, 4.046100, -1.387600, 1.642500, -2.841100, 0.133230, 0.241600, -1.058100,
           1.078600, 3.681200, -2.771500, -1.686800, 1.472600, -1.120500, -1.687300, -0.056494, 2.503900, -2.617600,
           -2.818700, 1.651000, 1.710300, 0.665430, 0.267000, -1.438800, -2.630800, 1.829100, 1.265200, 1.661100,
           2.089600, -1.591100, -2.571200, -0.373730, 3.743800, -2.240300, 2.471100, -4.159200, -2.747300, 2.768900,
           -2.996500, 1.081500, -1.994600, -1.628500, 2.102600, 0.376790, -1.985100, -1.875000, 4.973800, 2.333900,
           3.038400, -3.393700, -2.959700, 3.183400, 3.030400, -1.317200, -1.054300, -1.653800, -0.858840, 0.194140,
           -2.706100, -1.282200, -3.140600, 1.292700, 2.586500, -1.031600, 2.050700, 2.637800, -1.159600, 4.221400,
           1.801800, -1.594600, -2.555800, 3.090400, -1.628800, -1.460400, -0.736760, 3.205600, 1.254600, 2.039300,
           2.299300, -2.233000, 0.660130, 2.311500, -0.941670, 2.125800, 0.981120, 2.201100, -1.540600, -0.200730,
           -3.217100, 2.189200, 3.784500, 1.888400, 1.144200, 1.422900, 2.782300, -1.926400, 1.785000, -1.625300,
           -2.670100, 2.798600, -2.954400, -1.149300, -1.742100, 1.155700, 1.098900, 1.064000, 1.875500, 1.100100,
           1.734700, -1.243400, 1.284800, 1.766600, 1.808100, 3.841200, 2.466400, 1.327100, 2.488400, -0.423890,
           0.211100, 1.062300, 0.944610, 1.711200, -2.114500, -2.551900, -3.302000, 3.132700, 3.157800, -2.260700,
           -2.739800, -1.917200, 2.371600, 0.686770, -2.839900, 1.279300, 1.486600, 3.880100, -2.678100, -2.621900,
           1.101800, 3.188000, 1.893400, -2.392800, -0.903310, -1.589200, -0.920680, 2.260300, 1.932500, -4.355700,
           -3.409300, 3.675100, 1.127000, 0.286550, 2.662700, -1.946000, -0.985750, -0.278520, 0.386770, 2.022400,
           2.479000, -0.681760, -1.711500, 2.330900, 1.871700, -1.410600, -3.288100, 2.139700, -3.008800, -1.569000,
           1.760300, -3.349600, 2.093100, 1.726200, 2.353100, -2.056600, -1.515200, -0.980260, -0.097489, 2.151300,
           -1.884400, 2.638800, -1.430600, 0.761390, -2.437500, 2.480300, 1.586600, 2.971200, -2.335700, 1.904700,
           0.782450, -1.545200, 2.289500, -3.385000, -0.891840, -2.783300, 0.261670, -1.931000, -2.357500, 2.266800,
           0.774930, 1.701900, -1.267900, 2.270400, 2.974400, -3.995900, -2.057800, -1.887300, -1.610400, 0.957580,
           3.606300, -2.039200, -3.286500, 2.505800, 1.125600, 0.796920, -2.880600, 3.880400, 2.864400, -0.114980,
           0.249160, -3.204900, -2.355200, 1.410000, -2.237400, -1.598900, -1.127900, -1.906600, 3.126400, 1.041400,
           1.642800, 1.991700, -1.564800, 1.032900, -1.893500, 3.135600, 3.144200, -2.603300, 2.852600, 0.494930,
           -1.353100, 0.897650, -0.504850, -0.948260, -0.881220, -3.008600, 2.536500, -2.051100, 1.025400, -2.372800,
           -2.655900, 2.121500, -3.120300, -2.468500, 2.176300, -1.250600, -1.953500, -1.968700, -2.974200, -1.057500,
           2.500800, -1.131500, 1.958700, 2.282900, -2.821300, -2.434700, -2.543800, -0.203670, -2.529200, 3.603600,
           1.765500, -1.464000, 1.755700, 1.443300, -2.108500, -1.257300, -1.813100, 0.749220, -1.472300, 2.341400,
           4.054600, -1.416300, -2.581900, 0.685830, -1.624900, -1.391900, 0.710950, -2.935000, -0.304050, -1.867500,
           -2.199600, -3.050600, -3.402800, 1.926700, -0.794610, -1.721600, 3.331600, 1.262700, 2.814100, -1.268000,
           -2.289200, 2.747600, 2.791700, -1.091500, 2.589200, -0.346630, -2.641600, 3.078800, -3.830300, 2.486100,
           4.161700, 1.843200, -2.460500, 0.835470, -2.077700, 2.679600, 2.858300, -3.223800, -3.220600, 3.061300,
           3.935500, -2.508900, 1.431700, -2.156000, -1.286900, -2.505900, -2.423000, -1.366700, -1.682300, 0.565470,
           -2.276900, -0.719090, -1.462000, 3.520900, 0.912720, -4.138000, 3.354400, 3.118300, -0.925780, 3.003500,
           2.467100, -4.297100, -2.246400, 0.666610, -2.616500, -2.503000, 1.617700, 1.574500, 2.017600, 0.636670,
           1.543100, -0.138620, 5.043200, 0.808420, 2.262100, -1.814500, -3.070300, -1.685400, -3.192100, 3.342800,
           1.732600, 2.556300, 3.028700, 0.118800, 0.321510, -2.158100, -3.502300, -1.820900, -0.570900, -2.163900,
           -2.059000, 3.624900, 0.750460, -1.455700, -0.368250, -1.745600, 0.804140, -1.261200, -0.507710, 2.199500,
           -2.354200, -1.401900, 0.300460, 0.821510, 3.157200, 1.837900, -1.780000, 2.197100, 1.825200, 3.124300,
           1.637400, -3.230600, 0.644110, 1.698700, 3.307500, 2.650100, -1.783400, -1.833500, -1.978000, -1.454000,
           -3.652100, -0.593070, -0.961620, -2.054000, 0.701580, -1.382700, -3.160900, 2.217500, -0.481480, -1.100200,
           2.645600, 1.592600, 3.160000, 1.795500, -2.201400, 1.633900, -3.456000, -1.271200, -2.544700, -1.638400,
           -1.982000, -1.311000, -2.827300, -1.252200, -2.825000, 2.622800, -0.922840, -1.226600, 1.489300, -1.458000,
           -0.084465, -2.324500, -2.465600, 0.981390, 2.759900, -1.558400, -1.928000, -1.963500, -1.090400, -1.919400,
           1.105700, 3.081600, 2.782800, -1.253000, -2.988700, 1.952700, 1.745300, -2.215200, -3.518100, -2.940900,
           -2.500800, 0.888670, -1.107300, 2.412800, -1.535300, 1.872000, 0.455010, 0.222330, -3.180000, -1.075700,
           -1.265200, -1.652900, -1.870000, 1.613100, 2.256500, 2.910700, 0.468290, 1.683600, 2.412300, -2.572600,
           -1.074600, 1.754600, -3.471600, -1.998000, 1.161200, -0.417290, 1.351700, -1.182000, 1.960200, 0.443640,
           -2.846600, -2.232600, -1.228500, 2.602100, -2.107700, 3.505100, 1.857600, -2.060700, 0.375860, -3.586600,
           2.608200, -0.736110, 3.976300, 1.630200, 1.391500, -1.351500, -1.152900, 0.139050, -3.722300, 1.650800,
           -3.233500, -0.354100, -1.515800, -1.769400, -2.377200, -0.478840, 1.457300, -1.325300, 1.591300, -1.451900,
           -3.137600, -2.779300, -2.049600, 3.630600, -0.208270, -2.087100, -1.611500, -0.785270, -1.157800, -2.383000,
           1.458500, -4.071200, -1.315300, -0.912710, -3.393500, 2.190100, -1.803200, -0.376540, -2.158000, 1.953100,
           -2.163600, -3.364800, 0.838120, -2.096400, -3.383100, 1.484900, 2.084600, -1.451100, 3.465300, -2.399800,
           2.889800, 0.015878, 2.017000, -1.616500, 0.919550, 3.564700, 2.404800, -2.524200, -2.117000, -2.451900,
           -0.282300, -3.397700, -2.180000, -2.349000, 0.446630, 2.192800, 3.078800, -1.166300, 0.812940, -2.368600,
           -2.120800, 1.460800, 1.707000, -1.685700, -3.008100, 2.339500, 3.307500, -1.651100, -1.866700, -2.971800,
           0.519210, 3.151300, 1.405400, 0.074655, 2.048300, 1.131600, 1.351700, -2.547300, 0.643630, -2.129700,
           -0.020609, -2.326100, -3.334600, 2.167700, 0.176020, -0.444520, 3.684000, -0.569160, -3.885100, -0.040545,
           -1.451500, 2.127900, -3.192200, -0.055275, -1.298400, -1.834800, -1.834800};


unsigned char rawData_1024_23[1536] = {
   0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30,
   0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
   0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31,
   0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
   0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
   0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
   0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
   0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31,
   0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
   0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
   0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,
   0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
   0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
   0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
   0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
   0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31,
   0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
   0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
   0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
   0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
   0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
   0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31,
   0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
   0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
   0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
   0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
   0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
   0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
   0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30
  };
#46 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2
#1 "C:/Users/dougo/LDPC_Decoder3U/Txcode_1024_23.h" 1



unsigned char TxData1024_23[1536] = {
 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30,
 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30,
 0x31, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x30,
 0x30, 0x31, 0x30, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x31, 0x30,
 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30,
 0x30, 0x31, 0x31, 0x30, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x31, 0x31,
 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x31,
 0x31, 0x30, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30
};
#47 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp" 2






static tab_int nR_M, etaIndexM_M, etaIndexN_M, numbits;
static tab_int pCodeM;
static tab_int pMaxIterations;

bool run1024_45=false;
bool run1024_23=false;
bool run1024_12=false;
bool run4096_45=false;
bool run4096_23=false;
bool run4096_12=true;


short r_int[10240];
int8_t p_int[2048], p_int1[2048], p_int2[2048], p_int3[2048], p_int4[1024], p_int5[1024], p_int6[1024], p_int7[1024], p_int8[1024];
int8_t p_int9[1024], p_int10[1024];

void HLSLdpcLogDecScaledMin(int8_t pR[2048], int8_t pR1[2048], int8_t pR2[2048], int8_t pR3[2048], int8_t pR4[1024], int8_t pR5[1024],
             int8_t pR6[1024], int8_t pR7[1024], int8_t pR8[1024], int8_t pR9[1024], int8_t pR10[1024],
            bool pbhat0[2048], bool pbhat1[2048], bool pbhat2[1024], bool pbhat3[1024],
         bool pbhat4[1024], bool pbhat5[1024], bool pbhat6[1024], bool pbhat7[1024], int *cnt, tab_int nR_M,
            tab_int etaIndexM_M, tab_int pCodeM, tab_int pMaxIterations, int8_t *itt_num,
         tab_int numbits, volatile bool *mux);

int new_setupLDPC(int size, int rate);

int main();


void split_mem()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<1280; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 128)
  {
   pos = 0;
   mem++;
  }
 }
}

void split_mem_4096_45()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<5120; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 512)
  {
   pos = 0;
   mem++;
  }
 }
}

void split_mem_1024_23()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<1536; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 256)
  {
   pos = 0;
   mem++;
  }
 }
}

void split_mem_4096_23()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<6144; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 1024)
  {
   pos = 0;
   mem++;
  }
 }
}

void split_mem_1024_12()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<2048; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 512)
  {
   pos = 0;
   mem++;
  }
 }
}

void split_mem_4096_12()
{
 int mem=0;
 int pos =0;


 for (int i=0;i<8192; i++)
 {
  switch (mem)
  {
  case 0:
   p_int[pos] = r_int[i];
   break;
  case 1:
   p_int1[pos] = r_int[i];
   break;
  case 2:
   p_int2[pos] = r_int[i];
   break;
  case 3:
   p_int3[pos] = r_int[i];
   break;
  case 4:
   p_int4[pos] = r_int[i];
   break;
  case 5:
   p_int5[pos] = r_int[i];
   break;
  case 6:
   p_int6[pos] = r_int[i];
   break;
  case 7:
   p_int7[pos] = r_int[i];
   break;
  case 8:
   p_int8[pos] = r_int[i];
   break;
  case 9:
   p_int9[pos] = r_int[i];
   break;
  case 10:
   p_int10[pos] = r_int[i];
   break;

  }

  pos++;

  if (pos == 2048)
  {
   pos = 0;
   mem++;
  }
 }
}


#ifndef HLS_FASTSIM
#417 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#include "apatb_HLSLdpcLogDecScaledMin.h"
#endif

#417 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
int main()
{
 unsigned char cHat[20480];
 bool bHat0[2048], bHat1[2048], bHat2[1024], bHat3[1024], bHat4[1024], bHat5[1024], bHat6[1024], bHat7[1024];
 ldpc_dbl codem = 384, NumItt = 1, r_prime[20480];
 double r_dub, r_prime_dub;
 bool codepass = true;
 bool pass_tot = true;
 bool mux1 = true;
 bool *ptr_mux ;

 ptr_mux = &mux1;
 int result=1, cnt = 0, size, rate;

 char test;
 int8_t itt_num, itt_step;
 short spot;



 for(int inx=0; inx<10240; inx++)
  r_prime[inx]=0;


 if (run4096_23)
 {
  codepass = true;

  for(int inx=0; inx<10240; inx++)
   r_prime[inx]=0;

  for(int inx=0; inx<7168; inx++)
  {
   r_prime[inx]=r_4096_23[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 128)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = 128;
   }
   if (r_int[inx] < -128)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = -128;
   }
  }
  size =2;
  rate = 2;

  new_setupLDPC(size, rate);
  split_mem_4096_23();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#471 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#471 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#471 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#471 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<1024; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+1024]= (unsigned char) bHat1[k];
   cHat[k+2048]= (unsigned char) bHat2[k];
   cHat[k+3072]= (unsigned char) bHat3[k];
   cHat[k+4096]= (unsigned char) bHat4[k];
   cHat[k+5120]= (unsigned char) bHat5[k];
   cHat[k+6144]= (unsigned char) bHat6[k];

  }


  for (int i = 0; i < 4096; i++)
  {

   if (raw_4096_23[i] != (cHat[i]))
   {



    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 4096 2/3 ************ \n");
  else
   printf("************** You Loser it Failed 4096 2/3 !!!!     ************ \n");

  printf(" 4096 2/3 *****  Iterations = %i \n", cnt);
 }



 if (run1024_45)
 {

  codepass = true;

  for(int inx=0; inx<1408; inx++)
  {
   r_prime_dub= trunc(60 * ( (double)r[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);
   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }


   if (inx < 1280)
   {
    if (TXrawData[inx] == 0x30)
     r_int[inx] = -32;
    else
     r_int[inx] = 31;
   }
   else
    r_int[inx] =0;


  }


  size =1;
  rate = 3;


  new_setupLDPC(size, rate);




  split_mem();

  codepass = true;




  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#562 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#562 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#562 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#562 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<128; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+128]= (unsigned char) bHat1[k];
   cHat[k+256]= (unsigned char) bHat2[k];
   cHat[k+384]= (unsigned char) bHat3[k];
   cHat[k+512]= (unsigned char) bHat4[k];
   cHat[k+640]= (unsigned char) bHat5[k];
   cHat[k+768]= (unsigned char) bHat6[k];
   cHat[k+896]= (unsigned char) bHat7[k];
  }



  for (int i = 0; i < 1024; i++)
  {
   if (TXrawData[i] != (cHat[i] | 0x30))
   {


    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 4/5 ************ \n");
  else
   printf("************** You Loser it Failed 1024 4/5 !!!!     ************ \n");

  printf(" 1024 4/5 *****  Iterations = %i \n", cnt);

  codepass = true;

  for(int inx=0; inx<1408; inx++)
  {
   r_prime_dub= trunc(60 * ( (double)r[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);
   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }


  }


  size =1;
  rate = 3;


  new_setupLDPC(size, rate);
  split_mem();





  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#630 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#630 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#630 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#630 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<128; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+128]= (unsigned char) bHat1[k];
   cHat[k+256]= (unsigned char) bHat2[k];
   cHat[k+384]= (unsigned char) bHat3[k];
   cHat[k+512]= (unsigned char) bHat4[k];
   cHat[k+640]= (unsigned char) bHat5[k];
   cHat[k+768]= (unsigned char) bHat6[k];
   cHat[k+896]= (unsigned char) bHat7[k];
  }

  for (int i = 0; i < 1024; i++)
  {
   if (rawData[i] != (cHat[i] | 0x30))
   {


    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 4/5 ************ \n");
  else
   printf("************** You Loser it Failed 1024 4/5 !!!!     ************ \n");

  printf(" 1024 4/5 *****  Iterations = %i \n", cnt);

  for(int inx=0; inx<1408; inx++)
  {
   r_prime_dub= trunc(60 * ( (double)r[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);
   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }


   if (inx < 1280)
   {
    if (TXrawData[inx] == 0x30)
     r_int[inx] = -32;
    else
     r_int[inx] = 31;
   }
   else
    r_int[inx] =0;


  }

  codepass = true;
  size =1;
  rate = 3;


  new_setupLDPC(size, rate);
  split_mem();




  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#704 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#704 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#704 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#704 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<128; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+128]= (unsigned char) bHat1[k];
   cHat[k+256]= (unsigned char) bHat2[k];
   cHat[k+384]= (unsigned char) bHat3[k];
   cHat[k+512]= (unsigned char) bHat4[k];
   cHat[k+640]= (unsigned char) bHat5[k];
   cHat[k+768]= (unsigned char) bHat6[k];
   cHat[k+896]= (unsigned char) bHat7[k];
  }

  for (int i = 0; i < 1024; i++)
  {
   if (TXrawData[i] != (cHat[i] | 0x30))
   {


    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 4/5 ************ \n");
  else
   printf("************** You Loser it Failed 1024 4/5 !!!!     ************ \n");

  printf(" 1024 4/5 *****  Iterations = %i \n", cnt);

  for(int inx=0; inx<1408; inx++)
  {
   r_prime_dub= trunc(60 * ( (double)r[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);
   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }

  }

  codepass = true;
  size =1;
  rate = 3;


  new_setupLDPC(size, rate);
  split_mem();




  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#766 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#766 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#766 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#766 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<128; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+128]= (unsigned char) bHat1[k];
   cHat[k+256]= (unsigned char) bHat2[k];
   cHat[k+384]= (unsigned char) bHat3[k];
   cHat[k+512]= (unsigned char) bHat4[k];
   cHat[k+640]= (unsigned char) bHat5[k];
   cHat[k+768]= (unsigned char) bHat6[k];
   cHat[k+896]= (unsigned char) bHat7[k];
  }

  for (int i = 0; i < 1024; i++)
  {
   if (rawData[i] != (cHat[i] | 0x30))
   {


    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 4/5 ************ \n");
  else
   printf("************** You Loser it Failed 1024 4/5 !!!!     ************ \n");

  printf(" 1024 4/5 *****  Iterations = %i \n", cnt);
 }


 if (run4096_45)
 {
  codepass = true;

  for(int inx=0; inx<10240; inx++)
   r_prime[inx]=0;

  for(int inx=0; inx<5120; inx++)
  {
   r_prime[inx]=Rx_4096_45[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }
  }



  size =2;
  rate = 3;

  new_setupLDPC(size, rate);
  split_mem_4096_45();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#835 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#835 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#835 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#835 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<512; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+512]= (unsigned char) bHat1[k];
   cHat[k+1024]= (unsigned char) bHat2[k];
   cHat[k+1536]= (unsigned char) bHat3[k];
   cHat[k+2048]= (unsigned char) bHat4[k];
   cHat[k+2560]= (unsigned char) bHat5[k];
   cHat[k+3072]= (unsigned char) bHat6[k];
   cHat[k+3584]= (unsigned char) bHat7[k];
  }

  for (int i = 0; i < 4096; i++)
  {

   if (Info_4096_45[i] != (cHat[i]))
   {

    printf("loop i= %i: expected = %c calculated = %c \n", i, (raw_4096_45[i] | 0x30), (cHat[i] | 0x30));

    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 4096 4/5 ************ \n");
  else
   printf("************** You Loser it Failed 4096  4/5 !!!!     ************ \n");

  printf(" 4096 4/5 *****  Iterations = %i \n", cnt);
 }


 if (run1024_23)
 {
  codepass = true;
#1013 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
  codepass = true;

  for(int inx=0; inx<10240; inx++)
  {
   r_prime[inx]=0;
   r_int[inx] =0;
  }

  for(int inx=0; inx<1536; inx++)
  {
   r_prime[inx]=code_1024_23[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }

   if (inx < 1536)
   {
    if (TxData1024_23[inx] == 0x30)
     r_int[inx] = -32;
    else
     r_int[inx] = 31;
   }
   else
    r_int[inx] =0;

  }
  size =1;
  rate = 2;

  new_setupLDPC(size, rate);
  split_mem_1024_23();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1055 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1055 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#1055 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#1055 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<256; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+256]= (unsigned char) bHat1[k];
   cHat[k+512]= (unsigned char) bHat2[k];
   cHat[k+768]= (unsigned char) bHat3[k];
   cHat[k+1024]= (unsigned char) bHat4[k];
   cHat[k+1280]= (unsigned char) bHat5[k];
   cHat[k+1536]= (unsigned char) bHat6[k];
   cHat[k+1792]= (unsigned char) bHat7[k];
  }



  for (int i = 0; i < 1024; i++)
  {

   if (rawData_1024_23[i] != (cHat[i]|0x30))
   {

    printf("loop i= %i: expected = %c calculated = %c \n", i, test, cHat[i]);

    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 2/3 ************ \n");
  else
   printf("************** You Loser it Failed 1024 2/3 !!!!     ************ \n");

  printf(" 1024 2/3 *****  Iterations = %i \n", cnt);
 }



 if (run1024_12)
 {
  codepass = true;

  for(int inx=0; inx<10240; inx++)
   r_prime[inx]=0;

  for(int inx=0; inx<2560; inx++)
  {
   r_prime[inx]=r_1024_12[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 127)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = -127;
   }
  }
  size =1;
  rate = 1;

  new_setupLDPC(size, rate);

  split_mem_1024_12();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1127 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1127 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#1127 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#1127 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<512; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+512]= (unsigned char) bHat1[k];
   cHat[k+1024]= (unsigned char) bHat3[k];
   cHat[k+1536]= (unsigned char) bHat4[k];
   cHat[k+2048]= (unsigned char) bHat5[k];
   cHat[k+2560]= (unsigned char) bHat6[k];

  }


  for (int i = 0; i < 1024; i++)
  {

   if (raw_1024_12[i] != cHat[i])
   {

    printf("loop i= %i: expected = %c calculated = %c \n", i, test, cHat[i]);

    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 1024 1/2 ************ \n");
  else
   printf("************** You Loser it Failed 1024 1/2 !!!!     ************ \n");

  printf(" 1024 1/2 *****  Iterations = %i \n", cnt);
 }



 if (run4096_23)
 {
  codepass = true;

  for(int inx=0; inx<10240; inx++)
   r_prime[inx]=0;

  for(int inx=0; inx<7168; inx++)
  {
   r_prime[inx]=r_4096_23[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 128)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = 128;
   }
   if (r_int[inx] < -128)
   {
    printf("overflow at %i %i %d \n", inx, r_int[inx], (double) r_prime[inx]);
    r_int[inx] = -128;
   }
  }
  size =2;
  rate = 2;

  new_setupLDPC(size, rate);
  split_mem_4096_23();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1196 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1196 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#1196 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#1196 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<1024; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+1024]= (unsigned char) bHat1[k];
   cHat[k+2048]= (unsigned char) bHat2[k];
   cHat[k+3072]= (unsigned char) bHat3[k];
   cHat[k+4096]= (unsigned char) bHat4[k];
   cHat[k+5120]= (unsigned char) bHat5[k];
   cHat[k+6144]= (unsigned char) bHat6[k];

  }


  for (int i = 0; i < 4096; i++)
  {

   if (raw_4096_23[i] != cHat[i])
   {

    printf("loop i= %i: expected = %c calculated = %c \n", i, (raw_4096_23[i] | 0x30), (cHat[i] | 0x30) );

    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 4096 2/3 ************ \n");
  else
   printf("************** You Loser it Failed 4096 2/3 !!!!     ************ \n");

  printf(" 4096 2/3 *****  Iterations = %i \n", cnt);
 }

 if (run4096_12)
 {

  codepass = true;

  for(int inx=0; inx<10240; inx++)
   r_prime[inx]=0;

  for(int inx=0; inx<10240; inx++)
  {
   r_prime[inx]=r_4096_12[inx];
   r_prime_dub= trunc(60 * ( (double)r_prime[inx] / 3));
   r_int[inx] = (short) ((r_prime_dub * 2) + 1);

   if (r_int[inx] > 127)
   {

    r_int[inx] = 127;
   }
   if (r_int[inx] < -127)
   {

    r_int[inx] = -127;
   }

  }
  size =2;
  rate = 1;

  new_setupLDPC(size, rate);

  split_mem_4096_12();

  
#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1267 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#ifndef HLS_FASTSIM
#define HLSLdpcLogDecScaledMin AESL_WRAP_HLSLdpcLogDecScaledMin
#endif

#1267 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
HLSLdpcLogDecScaledMin
#undef HLSLdpcLogDecScaledMin
#1267 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"

#undef HLSLdpcLogDecScaledMin
#1267 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"
(p_int, p_int1, p_int2, p_int3, p_int4, p_int5, p_int6, p_int7, p_int8, p_int9, p_int10,
    bHat0, bHat1, bHat2, bHat3, bHat4, bHat5, bHat6, bHat7, &cnt, nR_M, etaIndexM_M,
    pCodeM, pMaxIterations, &itt_num, numbits, ptr_mux);

  for (int k=0; k<2048; k++)
  {
   cHat[k]= (unsigned char) bHat0[k];
   cHat[k+2048]= (unsigned char) bHat1[k];





  }

  for (int i = 0; i < 4096; i++)
  {

   if (raw_4096_12[i] != cHat[i])
   {

    printf("loop i= %i: expected = %c calculated = %c \n", i, (raw_4096_12[i] | 0x30), (cHat[i] | 0x30));

    codepass = false;
    pass_tot = false;
   }
  }

  if (codepass)
   printf("**************  You Lucky Biscuit it passed 4096 1/2 ************ \n");
  else
   printf("************** You Loser it Failed 4096 1/2  !!!!     ************ \n");

  printf(" 4096 1/2  *****  Iterations = %i \n", cnt);
 }



 if (pass_tot)
 {
  printf("\n **** All Tests Passed ********* \n");
  result = 0;
 }
 else
 {
  printf("\n **** Test(s) Failed ********* \n");
  result = 1;
 }



 return(result);

}
#endif
#1320 "C:/Users/dougo/LDPC_Decoder3U/LDPC_Decoder_check.cpp"


int new_setupLDPC(int size, int rate)
{



 int sucess = 0;
 int etaindexM_max = 0;
 int etaindexN_max = 0;
 int lambdaindexM_max = 0;

 int num_read;
 int value;
 int delta[25];
 int last_val[25];
 int cur_val[25];
 int line_val[25];
 int line_num = 0;
 int first_num = 0;
 int diff = 0;
 int test_diff;
 int num_entries = 0;
 int chk_indx_m[41000];
 int chk_pos = 0;




 for (int dx = 0; dx < 25; dx++)
 {
  delta[dx] = 0;
  last_val[dx] = 0;
  cur_val[dx] = 0;
  line_val[dx] = 0;
 }



 if (size == 1 && rate == 3)
 {
  nR_M = 1408;
  etaIndexM_M = 5376;
  etaIndexN_M = 6400;
  pCodeM = 384;
  pMaxIterations = 50;
  sucess = 1;
  numbits= 1280;
 }

 if (size == 1 && rate == 2)
 {

  nR_M = 1792;
  etaIndexM_M = 6656;
  etaIndexN_M = 7680;
  pCodeM = 768;
  pMaxIterations = 50;
  sucess = 1;
  numbits = 1536;
 }

 if (size == 1 && rate == 1)
 {

  nR_M = 2560;
  etaIndexM_M = 9216;
  etaIndexN_M = 10240;
  pCodeM = 1536;
  pMaxIterations = 50;
  sucess = 1;
  numbits = 2048;
 }

 if (size == 2 && rate == 3)
 {
  nR_M = 5632;
  etaIndexM_M = 21504;
  etaIndexN_M = 25600;
  pCodeM = 1536;
  pMaxIterations = 100;
  sucess = 1;
  numbits = 5120;
 }

 if (size == 2 && rate == 2)
 {

  nR_M = 7168;
  etaIndexM_M = 26624;
  etaIndexN_M = 30720;
  pCodeM = 3072;
  pMaxIterations = 50;
  sucess = 1;
  numbits = 6144;
 }

 if (size == 2 && rate == 1)
 {

  nR_M = 10240;
  etaIndexM_M = 36864;
  etaIndexN_M = 40960;
  pCodeM = 6144;
  pMaxIterations = 50;
  sucess = 1;
  numbits = 8192;
 }


 return(sucess);
}
