/*
 *	Trellis_detector.c
 *
 *	This file contains the functions for the STC trellis detector (for Tier 1 modulations).
 *	Trellis_detector() is the function that performs the detection using a trellis based
 *	on the Tier 1 modulation memory and on the Alamouti space time code.
 *	Trellis_setup() fills the lookup tables that are a function of the complex channel
 *	gains and the differential delay.
 *
 *	Copyright (c) 2005 Tom Nelson, Brigham Young University
 *
 */


////////////////////////////////
// includes
#include "lu_table.h"		// contains the theoretical waveforms for building the trellis lookup tables
#include <stdio.h>
#include <stdlib.h>

////////////////////////////////
// defines


////////////////////////////////
// global variables

extern openError;

// arrays for accumulating the path costs
float path_cost16[16];
float path_cost32[32];
float path_cost64[64];
float path_cost128[128];
float path_cost128_tmp[128];

// look up tables for the viterbi detector (based on the current estimates
// of h0, h1, and tau)
float	table_0_r[16];
float	table_0_i[16];
float	table_1_r[16];
float	table_1_i[16];
float	table_2_r[32];
float	table_2_i[32];
float	table_3_r[64];
float	table_3_i[64];
float	table_4_r[128];
float	table_4_i[128];
float	table_5_r[128];
float	table_5_i[128];
float	table_6_r[64];
float	table_6_i[64];
float	table_7_r[32];
float	table_7_i[32];

// tables of trellis transitions at various stages in the trellis
int		trans_4_3[128];
int		trans_5_4[128][2];
int		trans_6_5[64][2];
int		trans_7_6[32][2];
int		trans_8_7[16][2];

float	test_min;
/*float	min_tot[1000];
float	min0[1000];
float	min1[1000];
float	min2[1000];
float	min3[1000];
float	min4[1000];
float	min5[1000];
float	min6[1000];
float	min7[1000];
int		min_ndx;
int		best_state[36000];
int		state_ndx;
float	temp_array[36000];*/

////////////////////////////////
// function definitions
int Trellis_setup_0(int tau_ndx, float h0_r, float h0_i, float h1_r, float h1_i);
int Trellis_setup_1(int tau_ndx, float h0_r, float h0_i, float h1_r, float h1_i);
int Detect_block(float *s_in0_r, float *s_in0_i, float *s_in1_r, float *s_in1_i, int *DemodBits, int Count);


/*
 *	Function
 *
 *		Trellis_detector()
 *
 *	Description
 *
 *		Trellis_detector() is the wrapper for the detector.  It calls the appropriate setup routine (depending
 *		on whether delta_tau is positive or negative) and then loops over blocks of 4 samples, calling
 *		Detect_block() to detect each block of 4 bits.
 *
 *
 *	Inputs
 *
 *		float *s_in0_r			- pointer to input signal for channel 0
 *		float *s_in0_i			  (there must be num_in_samps samples in this array)
 *		float *s_in1_r			- pointer to input signal for channel 1
 *		float *s_in1_i			  (there must be num_in_samps samples in this array)
 *		int *BitsOut			- array for the output bits
 *		int num_out_bits		- number of bits to be detected
 *		float delta_tau			- differential delay which equals tau_1 - tau_0, should be between -1.0 and +1.0,
 *								  positive means channel 1 delayed more than channel 0)
 *								  NOTE: currently delta_tau gets quantized to the nearest quarter of a bit time
 *		float h0_r				- complex channel gain on channel 0
 *		float h0_i
 *		float h1_r				- complex chanenl gain on channel 1
 *		float h1_i
 *
 *	Outputs
 *
 *		The function returns 0 on success
 *
 *	Side Effects
 *
 *
 */
int Trellis_detector(float *s_in0_r, float *s_in0_i, float *s_in1_r, float *s_in1_i, int *BitsOut,
					 int num_out_bits, float delta_tau, float h0_r, float h0_i, float h1_r, float h1_i)
{
	int i,j;
	int tau_ndx;
	int	*bit_ptr;
	float *sig_a_r;
	float *sig_a_i;
	float *sig_b_r;
	float *sig_b_i;

	bit_ptr = BitsOut;

//	min_ndx = 0;			// reset the index for the debugging arrays
//	state_ndx = 0;

	// use delta_tau to determine which setup routine to call and to calculate tau_ndx
	// (the index into the lookup tables)

	if(delta_tau >= 0.0f)
	{
		// currently the delay is quantized to 0.0, 0.25, 0.5, or 0.75 Tb
		// we will probably want to make that quantization finer in the future
		// (have to change lu_table.h which is generated by gen_stc_soqpsk_headers.m in
		// the "Tier 1 STC" directory)
		tau_ndx = (int)(delta_tau*NB_LUT + 0.5);				// round to nearest quarter of a bit time
		Trellis_setup_0(tau_ndx, h0_r, h0_i, h1_r, h1_i);	// setup the lookup tables for this block of data

		sig_a_r = s_in1_r;			// sig_a points to the signal with the longest delay
		sig_a_i = s_in1_i;
		sig_b_r = s_in0_r+1;		// sig_b points to the signal with the shortest delay
		sig_b_i = s_in0_i+1;
	}
	else
	{
		tau_ndx = (int)(-delta_tau*NB_LUT + 0.5);				// round to nearest quarter of a bit time
		Trellis_setup_1(tau_ndx, h0_r, h0_i, h1_r, h1_i);	// setup the lookup tables for this block of data

		sig_a_r = s_in0_r;			// sig_a points to the signal with the longest delay
		sig_a_i = s_in0_i;
		sig_b_r = s_in1_r+1;			// sig_b points to the signal with the shortest delay
		sig_b_i = s_in1_i+1;
	}

	// need to call Detect_block() once to initialize the path costs in the trellis--won't keep the bits that
	// are produced, but this step will mean that the first block of four data bits won't be from the startup
	// step.
	Detect_block(sig_a_r,sig_a_i,sig_b_r,sig_b_i,bit_ptr, 100);	// detect a block of 4 bits

	/*|TESTING|*/
	for(i = 0; i < 16; i++)
	{
		path_cost16[i] -= test_min;	// subtract the minimum cost from all the path costs here
	}	/**/							// (this makes debugging easier)
	/*|TESTING|*/

	// increment the signal pointers but not the bit pointer (throw away the bits that were just detected)
	sig_a_r += 4;
	sig_a_i += 4;

	sig_b_r += 4;
	sig_b_i += 4;

	// now loop over the data bits detecting them four at a time
	for(i = 0; i < num_out_bits; i += 4)
	{
		Detect_block(sig_a_r,sig_a_i,sig_b_r,sig_b_i,bit_ptr, i);	// detect a block of 4 bits


		/*|TESTING|*/
		for(j = 0; j < 16; j++)
		{
		  path_cost16[j] -= test_min;	// subtract the minimum cost from all the path costs here
		}	/**/			// (this makes debugging easier)
		/*|TESTING|*/



		// increment the pointers for the next block of 4 bits
		sig_a_r += 4;
		sig_a_i += 4;

		sig_b_r += 4;
		sig_b_i += 4;

		bit_ptr += 4;
	}
	printf("\n");

	// done
	return(0);
}


/*
 *	Function
 *
 *		Detect_block()
 *
 *	Description
 *
 *		Detect_block() is the core of the trellis detector.  It performs the actual bit detection
 *		on a single block of 4 bits.
 *
 *
 *	Inputs
 *
 *		float *s_in0_r			- pointer to input signal for channel 0
 *		float *s_in0_i			  (there must be num_in_samps samples in this array)
 *		float *s_in1_r			- pointer to input signal for channel 1
 *		float *s_in1_i			  (there must be num_in_samps samples in this array)
 *		int *BitsOut			- array for the output bits
 *
 *	Outputs
 *
 *		The function returns 0 on success
 *
 *	Side Effects
 *
 *		The detected bits are stored in the DemodBits[] array (the output bits are bipolar)
 *
 */

int Detect_block(float *s_in0_r, float *s_in0_i, float *s_in1_r, float *s_in1_i, int *DemodBits, int Count)
{
	int i,ndx;
	float temp_r;
	float temp_i;
	float	min;
	int		winner4[128];
	int		winner5[128];
	int		winner6[64];
	int		winner7[32];
	int		state;
	float	tmp_cost16[16];
	float	tmp_cost32[32];
	float	tmp_cost64[64];
	float	tmp_cost128[128];

	static float	last_min = 0;

    // stage 0
    for(i = 0; i < 16; i++)
	{
		temp_r = table_0_r[i] - s_in0_r[0];
		temp_i = table_0_i[i] - s_in0_i[0];
		tmp_cost16[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost16[i] += tmp_cost16[i];
    }
/*	min0[min_ndx] = tmp_cost16[0];
    for(i = 1; i < 16; i++)
	{
		if(min0[min_ndx] > tmp_cost16[i])
			min0[min_ndx] = tmp_cost16[i];
	}
	min = path_cost16[0];
	ndx = 0;
    for(i = 1; i < 16; i++)
	{
		if(min > path_cost16[i])
		{
			min = path_cost16[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

    // stage 1 (there are no branches or merges through these stages)
    for (i = 0; i < 16; i++)
	{
		temp_r = table_1_r[i] - s_in1_r[0];
		temp_i = table_1_i[i] - s_in1_i[0];

		tmp_cost16[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost16[i] += tmp_cost16[i];
    }
/*	min1[min_ndx] = tmp_cost16[0];
    for(i = 1; i < 16; i++)
	{
		if(min1[min_ndx] > tmp_cost16[i])
			min1[min_ndx] = tmp_cost16[i];
	}

	min = path_cost16[0];
	ndx = 0;
    for(i = 1; i < 16; i++)
	{
		if(min > path_cost16[i])
		{
			min = path_cost16[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	// stage 2
    for (i = 0; i < 32; i++)
	{
		temp_r = table_2_r[i] - s_in0_r[1];
		temp_i = table_2_i[i] - s_in0_i[1];

		tmp_cost32[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost32[i] = path_cost16[i>>1] + tmp_cost32[i];
    }
/*	min2[min_ndx] = tmp_cost32[0];
    for(i = 1; i < 32; i++)
	{
		if(min2[min_ndx] > tmp_cost32[i])
			min2[min_ndx] = tmp_cost32[i];
	}
	min = path_cost32[0];
	ndx = 0;
    for(i = 1; i < 32; i++)
	{
		if(min > path_cost32[i])
		{
			min = path_cost32[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	// stage 3
    for (i = 0; i < 64; i++)
	{
		temp_r = table_3_r[i] - s_in1_r[1];
		temp_i = table_3_i[i] - s_in1_i[1];

		tmp_cost64[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost64[i] = path_cost32[i>>1] + tmp_cost64[i];
    }
/*	min3[min_ndx] = tmp_cost64[0];
    for(i = 1; i < 64; i++)
	{
		if(min3[min_ndx] > tmp_cost64[i])
			min3[min_ndx] = tmp_cost64[i];
	}
	min = path_cost64[0];
	ndx = 0;
    for(i = 1; i < 64; i++)
	{
		if(min > path_cost64[i])
		{
			min = path_cost64[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	// stage 4
   for (i = 0; i < 128; i++)
	{
		temp_r = table_4_r[i] - s_in0_r[2];
		temp_i = table_4_i[i] - s_in0_i[2];

		tmp_cost128[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost128[i] = path_cost64[trans_4_3[i]] + tmp_cost128[i];
    }
/*	min4[min_ndx] = tmp_cost128[0];
    for(i = 1; i < 128; i++)
	{
		if(min4[min_ndx] > tmp_cost128[i])
			min4[min_ndx] = tmp_cost128[i];
	}
	min = path_cost128[0];
	ndx = 0;
    for(i = 1; i < 128; i++)
	{
		if(min > path_cost128[i])
		{
			min = path_cost128[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

   // pick the winners among the current 128 states for the next stage of 128 states
   // (and keep track of winning paths)
	for(i = 0; i < 128; i++)
	{
		if(path_cost128[trans_5_4[i][0]] < path_cost128[trans_5_4[i][1]])
		{
			winner4[i] = trans_5_4[i][0];
			path_cost128_tmp[i] = path_cost128[trans_5_4[i][0]];
		}
		else
		{
			winner4[i] = trans_5_4[i][1];
			path_cost128_tmp[i] = path_cost128[trans_5_4[i][1]];
		}
	}

    // stage 5
    for (i = 0; i < 128; i++)
	{
		temp_r = table_5_r[i] - s_in1_r[2];
		temp_i = table_5_i[i] - s_in1_i[2];

		tmp_cost128[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost128[i] = path_cost128_tmp[i] + tmp_cost128[i];
    }
/*	min5[min_ndx] = tmp_cost128[0];
    for(i = 1; i < 128; i++)
	{
		if(min5[min_ndx] > tmp_cost128[i])
			min5[min_ndx] = tmp_cost128[i];
	}
	min = path_cost128[0];
	ndx = 0;
    for(i = 1; i < 128; i++)
	{
		if(min > path_cost128[i])
		{
			min = path_cost128[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	for(i = 0; i < 64; i++)
	{
		if(path_cost128[trans_6_5[i][0]] < path_cost128[trans_6_5[i][1]])
		{
			winner5[i] = trans_6_5[i][0];
			path_cost64[i] = path_cost128[trans_6_5[i][0]];
		}
		else
		{
			winner5[i] = trans_6_5[i][1];
			path_cost64[i] = path_cost128[trans_6_5[i][1]];
		}
	}

    // stage 6
    for (i = 0; i < 64; i++)
	{
		temp_r = table_6_r[i] - s_in0_r[3];
		temp_i = table_6_i[i] - s_in0_i[3];

		tmp_cost64[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost64[i] += tmp_cost64[i];
    }
/*	min6[min_ndx] = tmp_cost64[0];
    for(i = 1; i < 64; i++)
	{
		if(min6[min_ndx] > tmp_cost64[i])
			min6[min_ndx] = tmp_cost64[i];
	}
	min = path_cost64[0];
	ndx = 0;
    for(i = 1; i < 64; i++)
	{
		if(min > path_cost64[i])
		{
			min = path_cost64[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	for(i = 0; i < 32; i++)
	{
		if(path_cost64[trans_7_6[i][0]] < path_cost64[trans_7_6[i][1]])
		{
			winner6[i] = trans_7_6[i][0];
			path_cost32[i] = path_cost64[trans_7_6[i][0]];
		}
		else
		{
			winner6[i] = trans_7_6[i][1];
			path_cost32[i] = path_cost64[trans_7_6[i][1]];
		}
	}

    // stage 7
    for (i = 0; i < 32; i++)
	{
		temp_r = table_7_r[i] - s_in1_r[3];
		temp_i = table_7_i[i] - s_in1_i[3];

		tmp_cost32[i] = temp_r*temp_r + temp_i*temp_i;
		path_cost32[i] += tmp_cost32[i];
    }
/*	min7[min_ndx] = tmp_cost32[0];
    for(i = 1; i < 32; i++)
	{
		if(min7[min_ndx] > tmp_cost32[i])
			min7[min_ndx] = tmp_cost32[i];
	}
	min = path_cost32[0];
	ndx = 0;
    for(i = 1; i < 32; i++)
	{
		if(min > path_cost32[i])
		{
			min = path_cost32[i];
			ndx = i;
		}
	}
	best_state[state_ndx] = ndx;
	temp_array[state_ndx] = min;
	state_ndx++;*/

	for(i = 0; i < 16; i++)
	{
		if(path_cost32[trans_8_7[i][0]] < path_cost32[trans_8_7[i][1]])
		{
			winner7[i] = trans_8_7[i][0];
			path_cost16[i] = path_cost32[trans_8_7[i][0]];
		}
		else
		{
			winner7[i] = trans_8_7[i][1];
			path_cost16[i] = path_cost32[trans_8_7[i][1]];
		}
	}

	// now find the winning path among the 16 survivors that lead into the next group of 8 stages
	min = path_cost16[0];
	ndx = 0;
	for(i = 1; i < 16; i++)
	{
		if(path_cost16[i] < min)
		{
			min = path_cost16[i];
			ndx = i;
		}
	}

/*	min_tot[min_ndx] = min0[min_ndx] + min1[min_ndx] + min2[min_ndx] + min3[min_ndx] + min4[min_ndx] + min5[min_ndx] + min6[min_ndx] + min7[min_ndx];
	min_ndx++;*/

	// get the winnning state
	state = winner4[winner5[winner6[winner7[ndx]]]];

	// remove the 3 LSBs because they are for the next pair of symbols
	state = state >> 3;

	last_min = min;
	test_min = min;

	// break out the bits
	DemodBits[0] = ((state>>3) & 0x1);
	DemodBits[1] = ((state>>2) & 0x1);
	DemodBits[2] = ((state>>1) & 0x1);
	DemodBits[3] = ((state>>0) & 0x1);

/*	FILE *HexPtr;
	openError = fopen_s(&HexPtr, "HexOutLive.txt", "a");
	fclose(HexPtr);
*/
	if (Count < 16)
		printf("%x ", state);

	// done
	return(0);
}


/*
 *	Function
 *
 *		Trellis_setup_0() and Trellis_setup_1()
 *
 *	Description
 *
 *		The trellis setup functions prepare the trellis for detection based on the values of the
 *		complex channel gains h0 and h1 as well as the differential delay.  Trellis_setup_0() is
 *		called when delta_tau is positive (which means that the delay on channel 0 is less than
 *		the delay on channel 1).  Otherwise Trellis_setup_1() is called.
 *
 *
 *	Inputs
 *
 *		float *s_in0_r			- pointer to input signal for channel 0
 *		float *s_in0_i			  (there must be num_in_samps samples in this array)
 *		float *s_in1_r			- pointer to input signal for channel 1
 *		float *s_in1_i			  (there must be num_in_samps samples in this array)
 *		int *BitsOut			- array for the output bits
 *		int num_out_bits		- number of bits to be detected
 *		float delta_tau			- differential delay which equals tau_1 - tau_0, should be between -1.0 and +1.0,
 *								  positive means channel 1 delayed more than channel 0)
 *		float h0_r				- complex channel gain on channel 0
 *		float h0_i
 *		float h1_r				- complex chanenl gain on channel 1
 *		float h1_i
 *
 *	Outputs
 *
 *		The function returns 0 on success
 *
 *	Side Effects
 *
 *
 */
int Trellis_setup_0(int tau_ndx, float h0_r, float h0_i, float h1_r, float h1_i)
{
	float	temp1_r;
	float	temp1_i;
	float	temp2_r;
	float	temp2_i;
	float	samp_0_r;
	float	samp_0_i;
	float	samp_1_r;
	float	samp_1_i;
	int i;
	int ndx;
	int	trans;
	int tmp;
	int	In;
	int	Qn;
	int	In1;
	int	Qn1;
	int	In2;
	int	Qn2;
	int	In3;
	int	Qn3;

	// initialize the path costs
	for(i = 0; i < 16; i++)
		path_cost16[i] = 0.0;
	for(i = 0; i < 32; i++)
		path_cost32[i] = 0.0;
	for(i = 0; i < 64; i++)
		path_cost64[i] = 0.0;
	for(i = 0; i < 128; i++)
		path_cost128[i] = 0.0;

	for(i = 0; i < 16; i++)
	{
		In = (i>>3)&0x1;
		Qn = (i>>2)&0x1;
		In1 = (i>>1)&0x1;
		Qn1 = (i>>0)&0x1;

		ndx = (In<<3) + (Qn<<2) + (((~In1)&0x1)<<1) + (Qn1<<0);
		samp_0_r = lu_tableQ_r[ndx][tau_ndx];		// the second of the index is a Q bit so use lu_tableQ
		samp_0_i = lu_tableQ_i[ndx][tau_ndx];

		ndx = (In1<<3) + (Qn1<<2) + (In<<1) + (((~Qn)&0x1)<<0);
		samp_1_r = lu_tableQ_r[ndx][0];				// the second bit of the index is a Q bit so use lu_tableQ
		samp_1_i = lu_tableQ_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_0_r[i] = temp1_r + temp2_r;
		table_0_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 16; i++)
	{
		In = (i>>3)&0x1;
		Qn = (i>>2)&0x1;
		In1 = (i>>1)&0x1;
		Qn1 = (i>>0)&0x1;

		ndx = (Qn<<3) + (((~In1)&0x1)<<2) + (Qn1<<1) + 0;		// In2
		samp_0_r = lu_tableI_r[ndx][0];			// the second bit of the index is an I bit so use lu_tableI
		samp_0_i = lu_tableI_i[ndx][0];

		ndx = (In1<<3) + (Qn1<<2) + (In<<1) + (((~Qn)&0x1)<<0);
		samp_1_r = lu_tableQ_r[ndx][NB_LUT-tau_ndx];		//
		samp_1_i = lu_tableQ_i[ndx][NB_LUT-tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_1_r[i] = temp1_r + temp2_r;
		table_1_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 32; i++)
	{
		In = (i>>4)&0x1;
		Qn = (i>>3)&0x1;
		In1 = (i>>2)&0x1;
		Qn1 = (i>>1)&0x1;
		In2 = (i>>0)&0x1;

		ndx = (Qn<<3) + (((~In1)&0x1)<<2) + (Qn1<<1) + (In2<<0);
		samp_0_r = lu_tableI_r[ndx][tau_ndx];		//
		samp_0_i = lu_tableI_i[ndx][tau_ndx];

		ndx = (Qn1<<3) + (In<<2) + (((~Qn)&0x1)<<1) + 0;		// In3
		samp_1_r = lu_tableI_r[ndx][0];		//
		samp_1_i = lu_tableI_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_2_r[i] = temp1_r + temp2_r;
		table_2_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 64; i++)
	{
		In = (i>>5)&0x1;
		Qn = (i>>4)&0x1;
		In1 = (i>>3)&0x1;
		Qn1 = (i>>2)&0x1;
		In2 = (i>>1)&0x1;
		In3 = (i>>0)&0x1;

		ndx = (((~In1)&0x1)<<3) + (Qn1<<2) + (In2<<1) + 0;		// Qn2
		samp_0_r = lu_tableQ_r[ndx][0];		//
		samp_0_i = lu_tableQ_i[ndx][0];

		ndx = (Qn1<<3) + (In<<2) + (((~Qn)&0x1)<<1) + (In3<<0);
		samp_1_r = lu_tableI_r[ndx][NB_LUT-tau_ndx];		//
		samp_1_i = lu_tableI_i[ndx][NB_LUT-tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_3_r[i] = temp1_r + temp2_r;
		table_3_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 128; i++)
	{
		In = (i>>6)&0x1;
		Qn = (i>>5)&0x1;
		In1 = (i>>4)&0x1;
		Qn1 = (i>>3)&0x1;
		In2 = (i>>2)&0x1;
		Qn2 = (i>>1)&0x1;
		In3 = (i>>0)&0x1;

		ndx = (((~In1)&0x1)<<3) + (Qn1<<2) + (In2<<1) + (Qn2<<0);
		samp_0_r = lu_tableQ_r[ndx][tau_ndx]; 		//
		samp_0_i = lu_tableQ_i[ndx][tau_ndx];

		ndx = (In<<3) + (((~Qn)&0x1)<<2) + (In3<<1) + 0;		// Qn3
		samp_1_r = lu_tableQ_r[ndx][0];		//
		samp_1_i = lu_tableQ_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_4_r[i] = temp1_r + temp2_r;
		table_4_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 128; i++)
	{
		In = (i>>6)&0x1;
		Qn = (i>>5)&0x1;
		Qn1 = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (Qn1<<3) + (In2<<2) + (Qn2<<1) + (((~In3)&0x1)<<0);	// In3
		samp_0_r = lu_tableI_r[ndx][0];		//
		samp_0_i = lu_tableI_i[ndx][0];

		ndx = (In<<3) + (((~Qn)&0x1)<<2) + (In3<<1) + (Qn3<<0);
		samp_1_r = lu_tableQ_r[ndx][NB_LUT-tau_ndx];		//
		samp_1_i = lu_tableQ_i[ndx][NB_LUT-tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_5_r[i] = temp1_r + temp2_r;
		table_5_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 64; i++)
	{
		Qn = (i>>5)&0x1;
		Qn1 = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (Qn1<<3) + (In2<<2) + (Qn2<<1) + (((~In3)&0x1)<<0);
		samp_0_r = lu_tableI_r[ndx][tau_ndx];		//
		samp_0_i = lu_tableI_i[ndx][tau_ndx];

		ndx = (((~Qn)&0x1)<<3) + (In3<<2) + (Qn3<<1) + (In2<<0);	// In2
		samp_1_r = lu_tableI_r[ndx][0];		//
		samp_1_i = lu_tableI_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_6_r[i] = temp1_r + temp2_r;
		table_6_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 32; i++)
	{
		Qn = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (In2<<3) + (Qn2<<2) + (((~In3)&0x1)<<1) + (Qn3<<0);	//
		samp_0_r = lu_tableQ_r[ndx][0];		//
		samp_0_i = lu_tableQ_i[ndx][0];

		ndx = (((~Qn)&0x1)<<3) + (In3<<2) + (Qn3<<1) + (In2<<0);
		samp_1_r = lu_tableI_r[ndx][NB_LUT-tau_ndx];		//
		samp_1_i = lu_tableI_i[ndx][NB_LUT-tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_7_r[i] = temp1_r + temp2_r;
		table_7_i[i] = temp1_i + temp2_i;
	}

	// now fill out the transition matrices
	// this is for the backward transitions (not for moving forwards through the trellis)
	for(i = 0; i < 128; i++)
	{
		tmp = (i & 0x1);
		trans = ((i & 0x7c)>>1) | tmp;
		trans_4_3[i] = trans;
	}

	for(i = 0; i < 128; i++)
	{
		tmp = (i & 0x60);
		trans = (i & 0x1e)>>1 | tmp;
		trans_5_4[i][0] = trans;
		trans_5_4[i][1] = trans | (1<<4);
	}

	for(i = 0; i < 64; i++)
	{
		trans = i;
		trans_6_5[i][0] = trans;
		trans_6_5[i][1] = trans | (1<<6);
	}

	for(i = 0; i < 32; i++)
	{
		tmp = (i & 0x10) << 1;
		trans = (i & 0xf) | tmp;
		trans_7_6[i][0] = trans;
		trans_7_6[i][1] = trans | (1<<4);
	}

	for(i = 0; i < 16; i++)
	{
		trans = i;
		trans_8_7[i][0] = trans;
		trans_8_7[i][1] = trans | (1<<4);
	}

	// done
	return(0);
}


int Trellis_setup_1(int tau_ndx, float h0_r, float h0_i, float h1_r, float h1_i)
{
	float	temp1_r;
	float	temp1_i;
	float	temp2_r;
	float	temp2_i;
	float	samp_0_r;
	float	samp_0_i;
	float	samp_1_r;
	float	samp_1_i;
	int i;
	int ndx;
	int	trans;
	int tmp;
	int	In;
	int	Qn;
	int	In1;
	int	Qn1;
	int	In2;
	int	Qn2;
	int	In3;
	int	Qn3;

	// initialize the path costs
	for(i = 0; i < 16; i++)
		path_cost16[i] = 0.0;
	for(i = 0; i < 32; i++)
		path_cost32[i] = 0.0;
	for(i = 0; i < 64; i++)
		path_cost64[i] = 0.0;
	for(i = 0; i < 128; i++)
		path_cost128[i] = 0.0;

	for(i = 0; i < 16; i++)
	{
		In = (i>>3)&0x1;
		Qn = (i>>2)&0x1;
		In1 = (i>>1)&0x1;
		Qn1 = (i>>0)&0x1;

		ndx = (In<<3) + (Qn<<2) + (((~In1)&0x1)<<1) + (Qn1<<0);		// Qn1
		samp_0_r = lu_tableQ_r[ndx][0];		// the second of the index is a Q bit so use lu_tableQ
		samp_0_i = lu_tableQ_i[ndx][0];

		ndx = (In1<<3) + (Qn1<<2) + (In<<1) + (((~Qn)&0x1)<<0);
		samp_1_r = lu_tableQ_r[ndx][tau_ndx];				// the second bit of the index is a Q bit so use lu_tableQ
		samp_1_i = lu_tableQ_i[ndx][tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_0_r[i] = temp1_r + temp2_r;
		table_0_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 16; i++)
	{
		In = (i>>3)&0x1;
		Qn = (i>>2)&0x1;
		In1 = (i>>1)&0x1;
		Qn1 = (i>>0)&0x1;

		ndx = (In<<3) + (Qn<<2) + (((~In1)&0x1)<<1) + (Qn1<<0);
		samp_0_r = lu_tableQ_r[ndx][NB_LUT-tau_ndx];
		samp_0_i = lu_tableQ_i[ndx][NB_LUT-tau_ndx];

		ndx = (Qn1<<3) + (In<<2) + (((~Qn)&0x1)<<1) + 0;	// In3
		samp_1_r = lu_tableI_r[ndx][0];		// the second of the index is an I bit so use lu_tableI
		samp_1_i = lu_tableI_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_1_r[i] = temp1_r + temp2_r;
		table_1_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 32; i++)
	{
		In = (i>>4)&0x1;
		Qn = (i>>3)&0x1;
		In1 = (i>>2)&0x1;
		Qn1 = (i>>1)&0x1;
		In3 = (i>>0)&0x1;

		ndx = (Qn<<3) + (((~In1)&0x1)<<2) + (Qn1<<1) + 0;		// In2
		samp_0_r = lu_tableI_r[ndx][0];		//
		samp_0_i = lu_tableI_i[ndx][0];

		ndx = (Qn1<<3) + (In<<2) + (((~Qn)&0x1)<<1) + In3;
		samp_1_r = lu_tableI_r[ndx][tau_ndx];		//
		samp_1_i = lu_tableI_i[ndx][tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_2_r[i] = temp1_r + temp2_r;
		table_2_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 64; i++)
	{
		In = (i>>5)&0x1;
		Qn = (i>>4)&0x1;
		In1 = (i>>3)&0x1;
		Qn1 = (i>>2)&0x1;
		In2 = (i>>1)&0x1;
		In3 = (i>>0)&0x1;

		ndx = (Qn<<3) + (((~In1)&0x1)<<2) + (Qn1<<1) + (In2<<0);
		samp_0_r = lu_tableI_r[ndx][NB_LUT-tau_ndx];		//
		samp_0_i = lu_tableI_i[ndx][NB_LUT-tau_ndx];

		ndx = (In<<3) + (((~Qn)&0x1)<<2) + (In3<<1) + 0;		// Qn3
		samp_1_r = lu_tableQ_r[ndx][0];		//
		samp_1_i = lu_tableQ_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_3_r[i] = temp1_r + temp2_r;
		table_3_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 128; i++)
	{
		In = (i>>6)&0x1;
		Qn = (i>>5)&0x1;
		In1 = (i>>4)&0x1;
		Qn1 = (i>>3)&0x1;
		In2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (((~In1)&0x1)<<3) + (Qn1<<2) + (In2<<1) + 0;		// Qn2
		samp_0_r = lu_tableQ_r[ndx][0]; 		//
		samp_0_i = lu_tableQ_i[ndx][0];

		ndx = (In<<3) + (((~Qn)&0x1)<<2) + (In3<<1) + Qn3;
		samp_1_r = lu_tableQ_r[ndx][tau_ndx];		//
		samp_1_i = lu_tableQ_i[ndx][tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_4_r[i] = temp1_r + temp2_r;
		table_4_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 128; i++)
	{
		Qn = (i>>6)&0x1;
		In1 = (i>>5)&0x1;
		Qn1 = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (((~In1)&0x1)<<3) + (Qn1<<2) + (In2<<1) + (Qn2<<0);
		samp_0_r = lu_tableQ_r[ndx][NB_LUT-tau_ndx];		//
		samp_0_i = lu_tableQ_i[ndx][NB_LUT-tau_ndx];

		ndx = (((~Qn)&0x1)<<3) + (In3<<2) + (Qn3<<1) + (In2<<0);	// In2
		samp_1_r = lu_tableI_r[ndx][0];		//
		samp_1_i = lu_tableI_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_5_r[i] = temp1_r + temp2_r;
		table_5_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 64; i++)
	{
		Qn = (i>>5)&0x1;
		Qn1 = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (Qn1<<3) + (In2<<2) + (Qn2<<1) + (((~In3)&0x1)<<0);	// In3
		samp_0_r = lu_tableI_r[ndx][0];		//
		samp_0_i = lu_tableI_i[ndx][0];

		ndx = (((~Qn)&0x1)<<3) + (In3<<2) + (Qn3<<1) + (In2<<0);
		samp_1_r = lu_tableI_r[ndx][tau_ndx];		//
		samp_1_i = lu_tableI_i[ndx][tau_ndx];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_6_r[i] = temp1_r + temp2_r;
		table_6_i[i] = temp1_i + temp2_i;
	}

	for(i = 0; i < 32; i++)
	{
		Qn1 = (i>>4)&0x1;
		In2 = (i>>3)&0x1;
		Qn2 = (i>>2)&0x1;
		In3 = (i>>1)&0x1;
		Qn3 = (i>>0)&0x1;

		ndx = (Qn1<<3) + (In2<<2) + (Qn2<<1) + (((~In3)&0x1)<<0);
		samp_0_r = lu_tableI_r[ndx][NB_LUT-tau_ndx];		//
		samp_0_i = lu_tableI_i[ndx][NB_LUT-tau_ndx];

		ndx = (In3<<3) + (Qn3<<2) + (In2<<1) + (Qn2<<0);
		samp_1_r = lu_tableQ_r[ndx][0];		//
		samp_1_i = lu_tableQ_i[ndx][0];

		temp1_r = h0_r*samp_0_r - h0_i*samp_0_i;	// h0 * samp_0
		temp1_i = h0_r*samp_0_i + h0_i*samp_0_r;

		temp2_r = h1_r*samp_1_r - h1_i*samp_1_i;	// h1 * samp_1
		temp2_i = h1_r*samp_1_i + h1_i*samp_1_r;

		table_7_r[i] = temp1_r + temp2_r;
		table_7_i[i] = temp1_i + temp2_i;
	}

	// now fill out the transition matrices
	// this is for the backward transitions (not for moving forwards through the trellis)
	for(i = 0; i < 128; i++)
	{
		trans = ((i & 0x7e)>>1);
		trans_4_3[i] = trans;
	}

	for(i = 0; i < 128; i++)
	{
		tmp = (i & 0x3);
		trans = (i & 0x78)>>1 | tmp;
		trans_5_4[i][0] = trans;
		trans_5_4[i][1] = trans | (1<<6);
	}

	for(i = 0; i < 64; i++)
	{
		tmp = (i & 0x20) << 1;
		trans = (i & 0x1f) | tmp;
		trans_6_5[i][0] = trans;
		trans_6_5[i][1] = trans | (1<<5);
	}

	for(i = 0; i < 32; i++)
	{
		trans = i;
		trans_7_6[i][0] = trans;
		trans_7_6[i][1] = trans | (1<<5);
	}

	for(i = 0; i < 16; i++)
	{
		trans = i;
		trans_8_7[i][0] = trans;
		trans_8_7[i][1] = trans | (1<<4);
	}

	// done
	return(0);
}

